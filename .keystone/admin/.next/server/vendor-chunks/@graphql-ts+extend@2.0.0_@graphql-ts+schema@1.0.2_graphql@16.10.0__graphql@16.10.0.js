"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0";
exports.ids = ["vendor-chunks/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0/node_modules/@graphql-ts/extend/dist/graphql-ts-extend.esm.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0/node_modules/@graphql-ts/extend/dist/graphql-ts-extend.esm.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extend: () => (/* binding */ extend)\n/* harmony export */ });\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphql */ \"(pages-dir-node)/../../../../node_modules/.pnpm/graphql@16.10.0/node_modules/graphql/index.js\");\n/* harmony import */ var _graphql_ts_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @graphql-ts/schema */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@graphql-ts+schema@1.0.2_graphql@16.10.0/node_modules/@graphql-ts/schema/dist/graphql-ts-schema.esm.js\");\n\n\n\n/**\n * An API to extend an arbitrary {@link GraphQLSchema} with `@graphql-ts/schema`.\n * Note if you're building a schema entirely with `@graphql-ts/schema`, you\n * shouldn't use this package. This is useful when you have a\n * {@link GraphQLSchema} from somewhere else and you want to some fields to\n * various places in it.\n *\n * See {@link extend} for more details.\n *\n * @module\n */\nconst builtinScalars = new Set(graphql__WEBPACK_IMPORTED_MODULE_1__.specifiedScalarTypes.map(x => x.name));\n\n/**\n * `extend` allows you to extend a {@link GraphQLSchema} with\n * `@graphql-ts/schema`.\n *\n * ```ts\n * const originalSchema = new GraphQLSchema({ ...etc });\n *\n * const extendedSchema = extend({\n *   query: {\n *     hello: g.field({\n *       type: g.String,\n *       resolve() {\n *         return \"Hello!\";\n *       },\n *     }),\n *   },\n * })(originalSchema);\n * ```\n *\n * To use existing types from the schema you're extending, you can provide a\n * function and use the {@link BaseSchemaMeta} passed into the function to use\n * existing types in the schema.\n *\n * ```ts\n * const originalSchema = new GraphQLSchema({ ...etc });\n *\n * const extendedSchema = extend((base) => ({\n *   query: {\n *     something: g.field({\n *       type: base.object(\"Something\"),\n *       resolve() {\n *         return { something: true };\n *       },\n *     }),\n *   },\n * }))(originalSchema);\n * ```\n *\n * See {@link BaseSchemaMeta} for how to get other types from the schema\n *\n * `extend` will currently throw an error if the query or mutation types are\n * used in other types like this. This will be allowed in a future version.\n *\n * ```graphql\n * type Query {\n *   thing: Query\n * }\n * ```\n */\nfunction extend(extension) {\n  return schema => {\n    const getType = name => {\n      const graphQLType = schema.getType(name);\n      if (graphQLType == null) {\n        throw new Error(`No type named ${JSON.stringify(name)} exists in the schema that is being extended`);\n      }\n      return graphQLType;\n    };\n    const resolvedExtension = flattenExtensions(typeof extension === \"function\" ? extension({\n      schema,\n      object(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isObjectType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an object type`);\n        }\n        return graphQLType;\n      },\n      inputObject(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isInputObjectType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an input object type`);\n        }\n        return graphQLType;\n      },\n      enum(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isEnumType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an enum type`);\n        }\n        return graphQLType;\n      },\n      interface(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isInterfaceType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an interface type`);\n        }\n        return graphQLType;\n      },\n      scalar(name) {\n        if (builtinScalars.has(name)) {\n          throw new Error(`The names of built-in scalars cannot be passed to BaseSchemaInfo.scalar but ${name} was passed`);\n        }\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isScalarType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not a scalar type`);\n        }\n        return graphQLType;\n      },\n      union(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isUnionType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not a union type`);\n        }\n        return graphQLType;\n      }\n    }) : extension);\n    const queryType = schema.getQueryType();\n    const mutationType = schema.getMutationType();\n    const typesToFind = new Set();\n    if (queryType) {\n      typesToFind.add(queryType);\n    }\n    if (mutationType) {\n      typesToFind.add(mutationType);\n    }\n    const usages = findObjectTypeUsages(schema, typesToFind);\n    if (usages.size) {\n      throw new Error(`@graphql-ts/extend doesn't yet support using the query and mutation types in other types but\\n${[...usages].map(([type, usages]) => {\n        return `- ${JSON.stringify(type)} is used at ${usages.map(x => JSON.stringify(x)).join(\", \")}`;\n      }).join(\"\\n\")}`);\n    }\n    if (!resolvedExtension.mutation && !resolvedExtension.query) {\n      return schema;\n    }\n    const newQueryType = extendObjectType(queryType, resolvedExtension.query || {}, \"Query\");\n    const newMutationType = extendObjectType(mutationType, resolvedExtension.mutation || {}, \"Mutation\");\n    const schemaConfig = schema.toConfig();\n    let types = [...(queryType || !newQueryType ? [] : [newQueryType]), ...(mutationType || !newMutationType ? [] : [newMutationType]), ...schemaConfig.types.map(type => {\n      if (newQueryType && type.name === (queryType === null || queryType === void 0 ? void 0 : queryType.name)) {\n        return newQueryType;\n      }\n      if (newMutationType && type.name === (mutationType === null || mutationType === void 0 ? void 0 : mutationType.name)) {\n        return newMutationType;\n      }\n      return type;\n    })];\n    const updatedSchema = new graphql__WEBPACK_IMPORTED_MODULE_1__.GraphQLSchema({\n      ...schemaConfig,\n      query: newQueryType,\n      mutation: newMutationType,\n      types\n    });\n    return updatedSchema;\n  };\n}\nfunction printFieldOnType(type, fieldName) {\n  const printed = (0,graphql__WEBPACK_IMPORTED_MODULE_1__.printType)(type);\n  const document = (0,graphql__WEBPACK_IMPORTED_MODULE_1__.parse)(printed);\n  const parsed = document.definitions[0];\n  const parsedField = parsed.fields.find(x => x.name.value === fieldName);\n  return (0,graphql__WEBPACK_IMPORTED_MODULE_1__.print)(parsedField);\n}\nfunction extendObjectType(existingType, fieldsToAdd, defaultName) {\n  const hasNewFields = Object.entries(fieldsToAdd).length;\n  if (!hasNewFields) {\n    return existingType;\n  }\n  const existingTypeConfig = existingType === null || existingType === void 0 ? void 0 : existingType.toConfig();\n  const newFields = {\n    ...(existingTypeConfig === null || existingTypeConfig === void 0 ? void 0 : existingTypeConfig.fields)\n  };\n  for (const [key, val] of Object.entries(fieldsToAdd)) {\n    if (newFields[key]) {\n      var _name;\n      throw new Error(`The schema extension defines a field ${JSON.stringify(key)} on the ${JSON.stringify((_name = existingType.name) !== null && _name !== void 0 ? _name : defaultName)} type but that type already defines a field with that name.\\nThe original field:\\n${printFieldOnType(existingType, key)}\\nThe field added by the extension:\\n${printFieldOnType(new graphql__WEBPACK_IMPORTED_MODULE_1__.GraphQLObjectType({\n        name: \"ForError\",\n        fields: {\n          [key]: val\n        }\n      }), key)}`);\n    }\n    newFields[key] = val;\n  }\n  return new graphql__WEBPACK_IMPORTED_MODULE_1__.GraphQLObjectType({\n    name: defaultName,\n    ...existingTypeConfig,\n    fields: newFields\n  });\n}\n\n// https://github.com/microsoft/TypeScript/issues/17002\nconst isReadonlyArray = Array.isArray;\nconst operations = [\"query\", \"mutation\"];\nfunction flattenExtensions(extensions) {\n  if (isReadonlyArray(extensions)) {\n    const resolvedExtension = {\n      mutation: {},\n      query: {}\n    };\n    for (const extension of extensions) {\n      for (const operation of operations) {\n        const fields = extension[operation];\n        if (fields) {\n          for (const [key, val] of Object.entries(fields)) {\n            if (resolvedExtension[operation][key]) {\n              throw new Error(`More than one extension defines a field named ${JSON.stringify(key)} on the ${operation} type.\\nThe first field:\\n${printFieldOnType(new _graphql_ts_schema__WEBPACK_IMPORTED_MODULE_0__.GObjectType({\n                name: \"ForError\",\n                fields: {\n                  [key]: val\n                }\n              }), key)}\\nThe second field:\\n${printFieldOnType(new _graphql_ts_schema__WEBPACK_IMPORTED_MODULE_0__.GObjectType({\n                name: \"ForError\",\n                fields: {\n                  [key]: resolvedExtension[operation][key]\n                }\n              }), key)}`);\n            }\n            resolvedExtension[operation][key] = val;\n          }\n        }\n      }\n    }\n    return resolvedExtension;\n  }\n  return extensions;\n}\n\n/**\n * Any\n *\n * Note the distinct usages of `any` vs `unknown` is intentional.\n *\n * - The `unknown` used for the source type is because the source isn't known and\n *   it shouldn't generally be used here because these fields are on the query\n *   and mutation types\n * - The first `any` used for the `Args` type parameter is used because `Args` is\n *   invariant so only `Record<string, Arg<InputType, boolean>>` would work with\n *   it. The arguable unsafety here doesn't really matter because people will\n *   always use `g.field`\n * - The `any` in `OutputType` and the last type argument mean that a field that\n *   requires any context can be provided. This is unsafe, the only way this\n *   could arguably be made more \"safe\" is by making this unknown which would\n *   requiring casting or make `extend` and etc. generic over a `Context` but\n *   given this is immediately used on an arbitrary {@link GraphQLSchema} so the\n *   type would immediately be thrown away, it would be pretty much pointless.\n */\n\n/**\n * An extension to a GraphQL schema. This currently only supports adding fields\n * to the query and mutation types. Extending other types will be supported in\n * the future.\n */\n\n/**\n * This object contains the schema being extended and functions to get GraphQL\n * types from the schema.\n */\n\nfunction findObjectTypeUsages(schema, types) {\n  const usages = new Map();\n  for (const [name, type] of Object.entries(schema.getTypeMap())) {\n    if ((0,graphql__WEBPACK_IMPORTED_MODULE_1__.isInterfaceType)(type) || (0,graphql__WEBPACK_IMPORTED_MODULE_1__.isObjectType)(type)) {\n      for (const [fieldName, field] of Object.entries(type.getFields())) {\n        const namedType = (0,graphql__WEBPACK_IMPORTED_MODULE_1__.getNamedType)(field.type);\n        if ((0,graphql__WEBPACK_IMPORTED_MODULE_1__.isObjectType)(namedType) && types.has(namedType)) {\n          getOrDefault(usages, namedType, []).push(`${name}.${fieldName}`);\n        }\n      }\n    }\n    if ((0,graphql__WEBPACK_IMPORTED_MODULE_1__.isUnionType)(type)) {\n      for (const member of type.getTypes()) {\n        if (types.has(member)) {\n          getOrDefault(usages, member, []).push(name);\n        }\n      }\n    }\n  }\n  return usages;\n}\nfunction getOrDefault(input, key, defaultValue) {\n  if (!input.has(key)) {\n    input.set(key, defaultValue);\n    return defaultValue;\n  }\n  return input.get(key);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGdyYXBocWwtdHMrZXh0ZW5kQDIuMC4wX0BncmFwaHFsLXRzK3NjaGVtYUAxLjAuMl9ncmFwaHFsQDE2LjEwLjBfX2dyYXBocWxAMTYuMTAuMC9ub2RlX21vZHVsZXMvQGdyYXBocWwtdHMvZXh0ZW5kL2Rpc3QvZ3JhcGhxbC10cy1leHRlbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpTjtBQUNoSzs7QUFFakQ7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBb0I7O0FBRW5EO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1IsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixVQUFVO0FBQ1YsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFZO0FBQ3pCLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYSwwREFBaUI7QUFDOUIsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYSx3REFBZTtBQUM1QixtREFBbUQsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlHQUF5RyxNQUFNO0FBQy9HO0FBQ0E7QUFDQSxhQUFhLHFEQUFZO0FBQ3pCLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYSxvREFBVztBQUN4QixtREFBbUQsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIO0FBQ3ZILG9CQUFvQixzQkFBc0IsYUFBYSw4Q0FBOEM7QUFDckcsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLGtEQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFTO0FBQzNCLG1CQUFtQiw4Q0FBSztBQUN4QjtBQUNBO0FBQ0EsU0FBUyw4Q0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFCQUFxQixTQUFTLGdHQUFnRyxtRkFBbUYsb0NBQW9DLHVDQUF1QyxxQkFBcUIsc0RBQWlCO0FBQ2hZO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxRQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHFCQUFxQixTQUFTLFdBQVcsMkJBQTJCLHFCQUFxQiwyREFBVztBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSx1QkFBdUIscUJBQXFCLDJEQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQjtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBZSxVQUFVLHFEQUFZO0FBQzdDO0FBQ0EsMEJBQTBCLHFEQUFZO0FBQ3RDLFlBQVkscURBQVk7QUFDeEIsc0RBQXNELEtBQUssR0FBRyxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtCIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9AZ3JhcGhxbC10cytleHRlbmRAMi4wLjBfQGdyYXBocWwtdHMrc2NoZW1hQDEuMC4yX2dyYXBocWxAMTYuMTAuMF9fZ3JhcGhxbEAxNi4xMC4wL25vZGVfbW9kdWxlcy9AZ3JhcGhxbC10cy9leHRlbmQvZGlzdC9ncmFwaHFsLXRzLWV4dGVuZC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3BlY2lmaWVkU2NhbGFyVHlwZXMsIGlzT2JqZWN0VHlwZSwgaXNJbnB1dE9iamVjdFR5cGUsIGlzRW51bVR5cGUsIGlzSW50ZXJmYWNlVHlwZSwgaXNTY2FsYXJUeXBlLCBpc1VuaW9uVHlwZSwgR3JhcGhRTFNjaGVtYSwgR3JhcGhRTE9iamVjdFR5cGUsIGdldE5hbWVkVHlwZSwgcHJpbnRUeXBlLCBwYXJzZSwgcHJpbnQgfSBmcm9tICdncmFwaHFsJztcbmltcG9ydCB7IEdPYmplY3RUeXBlIH0gZnJvbSAnQGdyYXBocWwtdHMvc2NoZW1hJztcblxuLyoqXG4gKiBBbiBBUEkgdG8gZXh0ZW5kIGFuIGFyYml0cmFyeSB7QGxpbmsgR3JhcGhRTFNjaGVtYX0gd2l0aCBgQGdyYXBocWwtdHMvc2NoZW1hYC5cbiAqIE5vdGUgaWYgeW91J3JlIGJ1aWxkaW5nIGEgc2NoZW1hIGVudGlyZWx5IHdpdGggYEBncmFwaHFsLXRzL3NjaGVtYWAsIHlvdVxuICogc2hvdWxkbid0IHVzZSB0aGlzIHBhY2thZ2UuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IGhhdmUgYVxuICoge0BsaW5rIEdyYXBoUUxTY2hlbWF9IGZyb20gc29tZXdoZXJlIGVsc2UgYW5kIHlvdSB3YW50IHRvIHNvbWUgZmllbGRzIHRvXG4gKiB2YXJpb3VzIHBsYWNlcyBpbiBpdC5cbiAqXG4gKiBTZWUge0BsaW5rIGV4dGVuZH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IGJ1aWx0aW5TY2FsYXJzID0gbmV3IFNldChzcGVjaWZpZWRTY2FsYXJUeXBlcy5tYXAoeCA9PiB4Lm5hbWUpKTtcblxuLyoqXG4gKiBgZXh0ZW5kYCBhbGxvd3MgeW91IHRvIGV4dGVuZCBhIHtAbGluayBHcmFwaFFMU2NoZW1hfSB3aXRoXG4gKiBgQGdyYXBocWwtdHMvc2NoZW1hYC5cbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgb3JpZ2luYWxTY2hlbWEgPSBuZXcgR3JhcGhRTFNjaGVtYSh7IC4uLmV0YyB9KTtcbiAqXG4gKiBjb25zdCBleHRlbmRlZFNjaGVtYSA9IGV4dGVuZCh7XG4gKiAgIHF1ZXJ5OiB7XG4gKiAgICAgaGVsbG86IGcuZmllbGQoe1xuICogICAgICAgdHlwZTogZy5TdHJpbmcsXG4gKiAgICAgICByZXNvbHZlKCkge1xuICogICAgICAgICByZXR1cm4gXCJIZWxsbyFcIjtcbiAqICAgICAgIH0sXG4gKiAgICAgfSksXG4gKiAgIH0sXG4gKiB9KShvcmlnaW5hbFNjaGVtYSk7XG4gKiBgYGBcbiAqXG4gKiBUbyB1c2UgZXhpc3RpbmcgdHlwZXMgZnJvbSB0aGUgc2NoZW1hIHlvdSdyZSBleHRlbmRpbmcsIHlvdSBjYW4gcHJvdmlkZSBhXG4gKiBmdW5jdGlvbiBhbmQgdXNlIHRoZSB7QGxpbmsgQmFzZVNjaGVtYU1ldGF9IHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvbiB0byB1c2VcbiAqIGV4aXN0aW5nIHR5cGVzIGluIHRoZSBzY2hlbWEuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IG9yaWdpbmFsU2NoZW1hID0gbmV3IEdyYXBoUUxTY2hlbWEoeyAuLi5ldGMgfSk7XG4gKlxuICogY29uc3QgZXh0ZW5kZWRTY2hlbWEgPSBleHRlbmQoKGJhc2UpID0+ICh7XG4gKiAgIHF1ZXJ5OiB7XG4gKiAgICAgc29tZXRoaW5nOiBnLmZpZWxkKHtcbiAqICAgICAgIHR5cGU6IGJhc2Uub2JqZWN0KFwiU29tZXRoaW5nXCIpLFxuICogICAgICAgcmVzb2x2ZSgpIHtcbiAqICAgICAgICAgcmV0dXJuIHsgc29tZXRoaW5nOiB0cnVlIH07XG4gKiAgICAgICB9LFxuICogICAgIH0pLFxuICogICB9LFxuICogfSkpKG9yaWdpbmFsU2NoZW1hKTtcbiAqIGBgYFxuICpcbiAqIFNlZSB7QGxpbmsgQmFzZVNjaGVtYU1ldGF9IGZvciBob3cgdG8gZ2V0IG90aGVyIHR5cGVzIGZyb20gdGhlIHNjaGVtYVxuICpcbiAqIGBleHRlbmRgIHdpbGwgY3VycmVudGx5IHRocm93IGFuIGVycm9yIGlmIHRoZSBxdWVyeSBvciBtdXRhdGlvbiB0eXBlcyBhcmVcbiAqIHVzZWQgaW4gb3RoZXIgdHlwZXMgbGlrZSB0aGlzLiBUaGlzIHdpbGwgYmUgYWxsb3dlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICpcbiAqIGBgYGdyYXBocWxcbiAqIHR5cGUgUXVlcnkge1xuICogICB0aGluZzogUXVlcnlcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBleHRlbmQoZXh0ZW5zaW9uKSB7XG4gIHJldHVybiBzY2hlbWEgPT4ge1xuICAgIGNvbnN0IGdldFR5cGUgPSBuYW1lID0+IHtcbiAgICAgIGNvbnN0IGdyYXBoUUxUeXBlID0gc2NoZW1hLmdldFR5cGUobmFtZSk7XG4gICAgICBpZiAoZ3JhcGhRTFR5cGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHR5cGUgbmFtZWQgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gZXhpc3RzIGluIHRoZSBzY2hlbWEgdGhhdCBpcyBiZWluZyBleHRlbmRlZGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoUUxUeXBlO1xuICAgIH07XG4gICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb24gPSBmbGF0dGVuRXh0ZW5zaW9ucyh0eXBlb2YgZXh0ZW5zaW9uID09PSBcImZ1bmN0aW9uXCIgPyBleHRlbnNpb24oe1xuICAgICAgc2NoZW1hLFxuICAgICAgb2JqZWN0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JhcGhRTFR5cGUgPSBnZXRUeXBlKG5hbWUpO1xuICAgICAgICBpZiAoIWlzT2JqZWN0VHlwZShncmFwaFFMVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGEgdHlwZSBuYW1lZCAke0pTT04uc3RyaW5naWZ5KG5hbWUpfSBpbiB0aGUgc2NoZW1hIGJlaW5nIGV4dGVuZGVkIGJ1dCBpdCBpcyBub3QgYW4gb2JqZWN0IHR5cGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhcGhRTFR5cGU7XG4gICAgICB9LFxuICAgICAgaW5wdXRPYmplY3QobmFtZSkge1xuICAgICAgICBjb25zdCBncmFwaFFMVHlwZSA9IGdldFR5cGUobmFtZSk7XG4gICAgICAgIGlmICghaXNJbnB1dE9iamVjdFR5cGUoZ3JhcGhRTFR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhIHR5cGUgbmFtZWQgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gaW4gdGhlIHNjaGVtYSBiZWluZyBleHRlbmRlZCBidXQgaXQgaXMgbm90IGFuIGlucHV0IG9iamVjdCB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoUUxUeXBlO1xuICAgICAgfSxcbiAgICAgIGVudW0obmFtZSkge1xuICAgICAgICBjb25zdCBncmFwaFFMVHlwZSA9IGdldFR5cGUobmFtZSk7XG4gICAgICAgIGlmICghaXNFbnVtVHlwZShncmFwaFFMVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGEgdHlwZSBuYW1lZCAke0pTT04uc3RyaW5naWZ5KG5hbWUpfSBpbiB0aGUgc2NoZW1hIGJlaW5nIGV4dGVuZGVkIGJ1dCBpdCBpcyBub3QgYW4gZW51bSB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoUUxUeXBlO1xuICAgICAgfSxcbiAgICAgIGludGVyZmFjZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoUUxUeXBlID0gZ2V0VHlwZShuYW1lKTtcbiAgICAgICAgaWYgKCFpc0ludGVyZmFjZVR5cGUoZ3JhcGhRTFR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhIHR5cGUgbmFtZWQgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gaW4gdGhlIHNjaGVtYSBiZWluZyBleHRlbmRlZCBidXQgaXQgaXMgbm90IGFuIGludGVyZmFjZSB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoUUxUeXBlO1xuICAgICAgfSxcbiAgICAgIHNjYWxhcihuYW1lKSB7XG4gICAgICAgIGlmIChidWlsdGluU2NhbGFycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBuYW1lcyBvZiBidWlsdC1pbiBzY2FsYXJzIGNhbm5vdCBiZSBwYXNzZWQgdG8gQmFzZVNjaGVtYUluZm8uc2NhbGFyIGJ1dCAke25hbWV9IHdhcyBwYXNzZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncmFwaFFMVHlwZSA9IGdldFR5cGUobmFtZSk7XG4gICAgICAgIGlmICghaXNTY2FsYXJUeXBlKGdyYXBoUUxUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYSB0eXBlIG5hbWVkICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGluIHRoZSBzY2hlbWEgYmVpbmcgZXh0ZW5kZWQgYnV0IGl0IGlzIG5vdCBhIHNjYWxhciB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoUUxUeXBlO1xuICAgICAgfSxcbiAgICAgIHVuaW9uKG5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JhcGhRTFR5cGUgPSBnZXRUeXBlKG5hbWUpO1xuICAgICAgICBpZiAoIWlzVW5pb25UeXBlKGdyYXBoUUxUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYSB0eXBlIG5hbWVkICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGluIHRoZSBzY2hlbWEgYmVpbmcgZXh0ZW5kZWQgYnV0IGl0IGlzIG5vdCBhIHVuaW9uIHR5cGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhcGhRTFR5cGU7XG4gICAgICB9XG4gICAgfSkgOiBleHRlbnNpb24pO1xuICAgIGNvbnN0IHF1ZXJ5VHlwZSA9IHNjaGVtYS5nZXRRdWVyeVR5cGUoKTtcbiAgICBjb25zdCBtdXRhdGlvblR5cGUgPSBzY2hlbWEuZ2V0TXV0YXRpb25UeXBlKCk7XG4gICAgY29uc3QgdHlwZXNUb0ZpbmQgPSBuZXcgU2V0KCk7XG4gICAgaWYgKHF1ZXJ5VHlwZSkge1xuICAgICAgdHlwZXNUb0ZpbmQuYWRkKHF1ZXJ5VHlwZSk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvblR5cGUpIHtcbiAgICAgIHR5cGVzVG9GaW5kLmFkZChtdXRhdGlvblR5cGUpO1xuICAgIH1cbiAgICBjb25zdCB1c2FnZXMgPSBmaW5kT2JqZWN0VHlwZVVzYWdlcyhzY2hlbWEsIHR5cGVzVG9GaW5kKTtcbiAgICBpZiAodXNhZ2VzLnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQGdyYXBocWwtdHMvZXh0ZW5kIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdXNpbmcgdGhlIHF1ZXJ5IGFuZCBtdXRhdGlvbiB0eXBlcyBpbiBvdGhlciB0eXBlcyBidXRcXG4ke1suLi51c2FnZXNdLm1hcCgoW3R5cGUsIHVzYWdlc10pID0+IHtcbiAgICAgICAgcmV0dXJuIGAtICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9IGlzIHVzZWQgYXQgJHt1c2FnZXMubWFwKHggPT4gSlNPTi5zdHJpbmdpZnkoeCkpLmpvaW4oXCIsIFwiKX1gO1xuICAgICAgfSkuam9pbihcIlxcblwiKX1gKTtcbiAgICB9XG4gICAgaWYgKCFyZXNvbHZlZEV4dGVuc2lvbi5tdXRhdGlvbiAmJiAhcmVzb2x2ZWRFeHRlbnNpb24ucXVlcnkpIHtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGNvbnN0IG5ld1F1ZXJ5VHlwZSA9IGV4dGVuZE9iamVjdFR5cGUocXVlcnlUeXBlLCByZXNvbHZlZEV4dGVuc2lvbi5xdWVyeSB8fCB7fSwgXCJRdWVyeVwiKTtcbiAgICBjb25zdCBuZXdNdXRhdGlvblR5cGUgPSBleHRlbmRPYmplY3RUeXBlKG11dGF0aW9uVHlwZSwgcmVzb2x2ZWRFeHRlbnNpb24ubXV0YXRpb24gfHwge30sIFwiTXV0YXRpb25cIik7XG4gICAgY29uc3Qgc2NoZW1hQ29uZmlnID0gc2NoZW1hLnRvQ29uZmlnKCk7XG4gICAgbGV0IHR5cGVzID0gWy4uLihxdWVyeVR5cGUgfHwgIW5ld1F1ZXJ5VHlwZSA/IFtdIDogW25ld1F1ZXJ5VHlwZV0pLCAuLi4obXV0YXRpb25UeXBlIHx8ICFuZXdNdXRhdGlvblR5cGUgPyBbXSA6IFtuZXdNdXRhdGlvblR5cGVdKSwgLi4uc2NoZW1hQ29uZmlnLnR5cGVzLm1hcCh0eXBlID0+IHtcbiAgICAgIGlmIChuZXdRdWVyeVR5cGUgJiYgdHlwZS5uYW1lID09PSAocXVlcnlUeXBlID09PSBudWxsIHx8IHF1ZXJ5VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcXVlcnlUeXBlLm5hbWUpKSB7XG4gICAgICAgIHJldHVybiBuZXdRdWVyeVR5cGU7XG4gICAgICB9XG4gICAgICBpZiAobmV3TXV0YXRpb25UeXBlICYmIHR5cGUubmFtZSA9PT0gKG11dGF0aW9uVHlwZSA9PT0gbnVsbCB8fCBtdXRhdGlvblR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11dGF0aW9uVHlwZS5uYW1lKSkge1xuICAgICAgICByZXR1cm4gbmV3TXV0YXRpb25UeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSldO1xuICAgIGNvbnN0IHVwZGF0ZWRTY2hlbWEgPSBuZXcgR3JhcGhRTFNjaGVtYSh7XG4gICAgICAuLi5zY2hlbWFDb25maWcsXG4gICAgICBxdWVyeTogbmV3UXVlcnlUeXBlLFxuICAgICAgbXV0YXRpb246IG5ld011dGF0aW9uVHlwZSxcbiAgICAgIHR5cGVzXG4gICAgfSk7XG4gICAgcmV0dXJuIHVwZGF0ZWRTY2hlbWE7XG4gIH07XG59XG5mdW5jdGlvbiBwcmludEZpZWxkT25UeXBlKHR5cGUsIGZpZWxkTmFtZSkge1xuICBjb25zdCBwcmludGVkID0gcHJpbnRUeXBlKHR5cGUpO1xuICBjb25zdCBkb2N1bWVudCA9IHBhcnNlKHByaW50ZWQpO1xuICBjb25zdCBwYXJzZWQgPSBkb2N1bWVudC5kZWZpbml0aW9uc1swXTtcbiAgY29uc3QgcGFyc2VkRmllbGQgPSBwYXJzZWQuZmllbGRzLmZpbmQoeCA9PiB4Lm5hbWUudmFsdWUgPT09IGZpZWxkTmFtZSk7XG4gIHJldHVybiBwcmludChwYXJzZWRGaWVsZCk7XG59XG5mdW5jdGlvbiBleHRlbmRPYmplY3RUeXBlKGV4aXN0aW5nVHlwZSwgZmllbGRzVG9BZGQsIGRlZmF1bHROYW1lKSB7XG4gIGNvbnN0IGhhc05ld0ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkc1RvQWRkKS5sZW5ndGg7XG4gIGlmICghaGFzTmV3RmllbGRzKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nVHlwZTtcbiAgfVxuICBjb25zdCBleGlzdGluZ1R5cGVDb25maWcgPSBleGlzdGluZ1R5cGUgPT09IG51bGwgfHwgZXhpc3RpbmdUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGlzdGluZ1R5cGUudG9Db25maWcoKTtcbiAgY29uc3QgbmV3RmllbGRzID0ge1xuICAgIC4uLihleGlzdGluZ1R5cGVDb25maWcgPT09IG51bGwgfHwgZXhpc3RpbmdUeXBlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGlzdGluZ1R5cGVDb25maWcuZmllbGRzKVxuICB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzVG9BZGQpKSB7XG4gICAgaWYgKG5ld0ZpZWxkc1trZXldKSB7XG4gICAgICB2YXIgX25hbWU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzY2hlbWEgZXh0ZW5zaW9uIGRlZmluZXMgYSBmaWVsZCAke0pTT04uc3RyaW5naWZ5KGtleSl9IG9uIHRoZSAke0pTT04uc3RyaW5naWZ5KChfbmFtZSA9IGV4aXN0aW5nVHlwZS5uYW1lKSAhPT0gbnVsbCAmJiBfbmFtZSAhPT0gdm9pZCAwID8gX25hbWUgOiBkZWZhdWx0TmFtZSl9IHR5cGUgYnV0IHRoYXQgdHlwZSBhbHJlYWR5IGRlZmluZXMgYSBmaWVsZCB3aXRoIHRoYXQgbmFtZS5cXG5UaGUgb3JpZ2luYWwgZmllbGQ6XFxuJHtwcmludEZpZWxkT25UeXBlKGV4aXN0aW5nVHlwZSwga2V5KX1cXG5UaGUgZmllbGQgYWRkZWQgYnkgdGhlIGV4dGVuc2lvbjpcXG4ke3ByaW50RmllbGRPblR5cGUobmV3IEdyYXBoUUxPYmplY3RUeXBlKHtcbiAgICAgICAgbmFtZTogXCJGb3JFcnJvclwiLFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICBba2V5XTogdmFsXG4gICAgICAgIH1cbiAgICAgIH0pLCBrZXkpfWApO1xuICAgIH1cbiAgICBuZXdGaWVsZHNba2V5XSA9IHZhbDtcbiAgfVxuICByZXR1cm4gbmV3IEdyYXBoUUxPYmplY3RUeXBlKHtcbiAgICBuYW1lOiBkZWZhdWx0TmFtZSxcbiAgICAuLi5leGlzdGluZ1R5cGVDb25maWcsXG4gICAgZmllbGRzOiBuZXdGaWVsZHNcbiAgfSk7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTcwMDJcbmNvbnN0IGlzUmVhZG9ubHlBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBvcGVyYXRpb25zID0gW1wicXVlcnlcIiwgXCJtdXRhdGlvblwiXTtcbmZ1bmN0aW9uIGZsYXR0ZW5FeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgaWYgKGlzUmVhZG9ubHlBcnJheShleHRlbnNpb25zKSkge1xuICAgIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9uID0ge1xuICAgICAgbXV0YXRpb246IHt9LFxuICAgICAgcXVlcnk6IHt9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiBleHRlbnNpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IGV4dGVuc2lvbltvcGVyYXRpb25dO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkcykpIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZEV4dGVuc2lvbltvcGVyYXRpb25dW2tleV0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb3JlIHRoYW4gb25lIGV4dGVuc2lvbiBkZWZpbmVzIGEgZmllbGQgbmFtZWQgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBvbiB0aGUgJHtvcGVyYXRpb259IHR5cGUuXFxuVGhlIGZpcnN0IGZpZWxkOlxcbiR7cHJpbnRGaWVsZE9uVHlwZShuZXcgR09iamVjdFR5cGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRm9yRXJyb3JcIixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgIFtrZXldOiB2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBrZXkpfVxcblRoZSBzZWNvbmQgZmllbGQ6XFxuJHtwcmludEZpZWxkT25UeXBlKG5ldyBHT2JqZWN0VHlwZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJGb3JFcnJvclwiLFxuICAgICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgW2tleV06IHJlc29sdmVkRXh0ZW5zaW9uW29wZXJhdGlvbl1ba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGtleSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlZEV4dGVuc2lvbltvcGVyYXRpb25dW2tleV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbjtcbiAgfVxuICByZXR1cm4gZXh0ZW5zaW9ucztcbn1cblxuLyoqXG4gKiBBbnlcbiAqXG4gKiBOb3RlIHRoZSBkaXN0aW5jdCB1c2FnZXMgb2YgYGFueWAgdnMgYHVua25vd25gIGlzIGludGVudGlvbmFsLlxuICpcbiAqIC0gVGhlIGB1bmtub3duYCB1c2VkIGZvciB0aGUgc291cmNlIHR5cGUgaXMgYmVjYXVzZSB0aGUgc291cmNlIGlzbid0IGtub3duIGFuZFxuICogICBpdCBzaG91bGRuJ3QgZ2VuZXJhbGx5IGJlIHVzZWQgaGVyZSBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgb24gdGhlIHF1ZXJ5XG4gKiAgIGFuZCBtdXRhdGlvbiB0eXBlc1xuICogLSBUaGUgZmlyc3QgYGFueWAgdXNlZCBmb3IgdGhlIGBBcmdzYCB0eXBlIHBhcmFtZXRlciBpcyB1c2VkIGJlY2F1c2UgYEFyZ3NgIGlzXG4gKiAgIGludmFyaWFudCBzbyBvbmx5IGBSZWNvcmQ8c3RyaW5nLCBBcmc8SW5wdXRUeXBlLCBib29sZWFuPj5gIHdvdWxkIHdvcmsgd2l0aFxuICogICBpdC4gVGhlIGFyZ3VhYmxlIHVuc2FmZXR5IGhlcmUgZG9lc24ndCByZWFsbHkgbWF0dGVyIGJlY2F1c2UgcGVvcGxlIHdpbGxcbiAqICAgYWx3YXlzIHVzZSBgZy5maWVsZGBcbiAqIC0gVGhlIGBhbnlgIGluIGBPdXRwdXRUeXBlYCBhbmQgdGhlIGxhc3QgdHlwZSBhcmd1bWVudCBtZWFuIHRoYXQgYSBmaWVsZCB0aGF0XG4gKiAgIHJlcXVpcmVzIGFueSBjb250ZXh0IGNhbiBiZSBwcm92aWRlZC4gVGhpcyBpcyB1bnNhZmUsIHRoZSBvbmx5IHdheSB0aGlzXG4gKiAgIGNvdWxkIGFyZ3VhYmx5IGJlIG1hZGUgbW9yZSBcInNhZmVcIiBpcyBieSBtYWtpbmcgdGhpcyB1bmtub3duIHdoaWNoIHdvdWxkXG4gKiAgIHJlcXVpcmluZyBjYXN0aW5nIG9yIG1ha2UgYGV4dGVuZGAgYW5kIGV0Yy4gZ2VuZXJpYyBvdmVyIGEgYENvbnRleHRgIGJ1dFxuICogICBnaXZlbiB0aGlzIGlzIGltbWVkaWF0ZWx5IHVzZWQgb24gYW4gYXJiaXRyYXJ5IHtAbGluayBHcmFwaFFMU2NoZW1hfSBzbyB0aGVcbiAqICAgdHlwZSB3b3VsZCBpbW1lZGlhdGVseSBiZSB0aHJvd24gYXdheSwgaXQgd291bGQgYmUgcHJldHR5IG11Y2ggcG9pbnRsZXNzLlxuICovXG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIHRvIGEgR3JhcGhRTCBzY2hlbWEuIFRoaXMgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgYWRkaW5nIGZpZWxkc1xuICogdG8gdGhlIHF1ZXJ5IGFuZCBtdXRhdGlvbiB0eXBlcy4gRXh0ZW5kaW5nIG90aGVyIHR5cGVzIHdpbGwgYmUgc3VwcG9ydGVkIGluXG4gKiB0aGUgZnV0dXJlLlxuICovXG5cbi8qKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgdGhlIHNjaGVtYSBiZWluZyBleHRlbmRlZCBhbmQgZnVuY3Rpb25zIHRvIGdldCBHcmFwaFFMXG4gKiB0eXBlcyBmcm9tIHRoZSBzY2hlbWEuXG4gKi9cblxuZnVuY3Rpb24gZmluZE9iamVjdFR5cGVVc2FnZXMoc2NoZW1hLCB0eXBlcykge1xuICBjb25zdCB1c2FnZXMgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgW25hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5nZXRUeXBlTWFwKCkpKSB7XG4gICAgaWYgKGlzSW50ZXJmYWNlVHlwZSh0eXBlKSB8fCBpc09iamVjdFR5cGUodHlwZSkpIHtcbiAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRdIG9mIE9iamVjdC5lbnRyaWVzKHR5cGUuZ2V0RmllbGRzKCkpKSB7XG4gICAgICAgIGNvbnN0IG5hbWVkVHlwZSA9IGdldE5hbWVkVHlwZShmaWVsZC50eXBlKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0VHlwZShuYW1lZFR5cGUpICYmIHR5cGVzLmhhcyhuYW1lZFR5cGUpKSB7XG4gICAgICAgICAgZ2V0T3JEZWZhdWx0KHVzYWdlcywgbmFtZWRUeXBlLCBbXSkucHVzaChgJHtuYW1lfS4ke2ZpZWxkTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNVbmlvblR5cGUodHlwZSkpIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZ2V0VHlwZXMoKSkge1xuICAgICAgICBpZiAodHlwZXMuaGFzKG1lbWJlcikpIHtcbiAgICAgICAgICBnZXRPckRlZmF1bHQodXNhZ2VzLCBtZW1iZXIsIFtdKS5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1c2FnZXM7XG59XG5mdW5jdGlvbiBnZXRPckRlZmF1bHQoaW5wdXQsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghaW5wdXQuaGFzKGtleSkpIHtcbiAgICBpbnB1dC5zZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlucHV0LmdldChrZXkpO1xufVxuXG5leHBvcnQgeyBleHRlbmQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0/node_modules/@graphql-ts/extend/dist/graphql-ts-extend.esm.js\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0/node_modules/@graphql-ts/extend/dist/graphql-ts-extend.esm.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0/node_modules/@graphql-ts/extend/dist/graphql-ts-extend.esm.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extend: () => (/* binding */ extend)\n/* harmony export */ });\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphql */ \"../../../../node_modules/.pnpm/graphql@16.10.0/node_modules/graphql/index.js\");\n/* harmony import */ var _graphql_ts_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @graphql-ts/schema */ \"../../../../node_modules/.pnpm/@graphql-ts+schema@1.0.2_graphql@16.10.0/node_modules/@graphql-ts/schema/dist/graphql-ts-schema.esm.js\");\n\n\n\n/**\n * An API to extend an arbitrary {@link GraphQLSchema} with `@graphql-ts/schema`.\n * Note if you're building a schema entirely with `@graphql-ts/schema`, you\n * shouldn't use this package. This is useful when you have a\n * {@link GraphQLSchema} from somewhere else and you want to some fields to\n * various places in it.\n *\n * See {@link extend} for more details.\n *\n * @module\n */\nconst builtinScalars = new Set(graphql__WEBPACK_IMPORTED_MODULE_1__.specifiedScalarTypes.map(x => x.name));\n\n/**\n * `extend` allows you to extend a {@link GraphQLSchema} with\n * `@graphql-ts/schema`.\n *\n * ```ts\n * const originalSchema = new GraphQLSchema({ ...etc });\n *\n * const extendedSchema = extend({\n *   query: {\n *     hello: g.field({\n *       type: g.String,\n *       resolve() {\n *         return \"Hello!\";\n *       },\n *     }),\n *   },\n * })(originalSchema);\n * ```\n *\n * To use existing types from the schema you're extending, you can provide a\n * function and use the {@link BaseSchemaMeta} passed into the function to use\n * existing types in the schema.\n *\n * ```ts\n * const originalSchema = new GraphQLSchema({ ...etc });\n *\n * const extendedSchema = extend((base) => ({\n *   query: {\n *     something: g.field({\n *       type: base.object(\"Something\"),\n *       resolve() {\n *         return { something: true };\n *       },\n *     }),\n *   },\n * }))(originalSchema);\n * ```\n *\n * See {@link BaseSchemaMeta} for how to get other types from the schema\n *\n * `extend` will currently throw an error if the query or mutation types are\n * used in other types like this. This will be allowed in a future version.\n *\n * ```graphql\n * type Query {\n *   thing: Query\n * }\n * ```\n */\nfunction extend(extension) {\n  return schema => {\n    const getType = name => {\n      const graphQLType = schema.getType(name);\n      if (graphQLType == null) {\n        throw new Error(`No type named ${JSON.stringify(name)} exists in the schema that is being extended`);\n      }\n      return graphQLType;\n    };\n    const resolvedExtension = flattenExtensions(typeof extension === \"function\" ? extension({\n      schema,\n      object(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isObjectType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an object type`);\n        }\n        return graphQLType;\n      },\n      inputObject(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isInputObjectType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an input object type`);\n        }\n        return graphQLType;\n      },\n      enum(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isEnumType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an enum type`);\n        }\n        return graphQLType;\n      },\n      interface(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isInterfaceType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an interface type`);\n        }\n        return graphQLType;\n      },\n      scalar(name) {\n        if (builtinScalars.has(name)) {\n          throw new Error(`The names of built-in scalars cannot be passed to BaseSchemaInfo.scalar but ${name} was passed`);\n        }\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isScalarType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not a scalar type`);\n        }\n        return graphQLType;\n      },\n      union(name) {\n        const graphQLType = getType(name);\n        if (!(0,graphql__WEBPACK_IMPORTED_MODULE_1__.isUnionType)(graphQLType)) {\n          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not a union type`);\n        }\n        return graphQLType;\n      }\n    }) : extension);\n    const queryType = schema.getQueryType();\n    const mutationType = schema.getMutationType();\n    const typesToFind = new Set();\n    if (queryType) {\n      typesToFind.add(queryType);\n    }\n    if (mutationType) {\n      typesToFind.add(mutationType);\n    }\n    const usages = findObjectTypeUsages(schema, typesToFind);\n    if (usages.size) {\n      throw new Error(`@graphql-ts/extend doesn't yet support using the query and mutation types in other types but\\n${[...usages].map(([type, usages]) => {\n        return `- ${JSON.stringify(type)} is used at ${usages.map(x => JSON.stringify(x)).join(\", \")}`;\n      }).join(\"\\n\")}`);\n    }\n    if (!resolvedExtension.mutation && !resolvedExtension.query) {\n      return schema;\n    }\n    const newQueryType = extendObjectType(queryType, resolvedExtension.query || {}, \"Query\");\n    const newMutationType = extendObjectType(mutationType, resolvedExtension.mutation || {}, \"Mutation\");\n    const schemaConfig = schema.toConfig();\n    let types = [...(queryType || !newQueryType ? [] : [newQueryType]), ...(mutationType || !newMutationType ? [] : [newMutationType]), ...schemaConfig.types.map(type => {\n      if (newQueryType && type.name === (queryType === null || queryType === void 0 ? void 0 : queryType.name)) {\n        return newQueryType;\n      }\n      if (newMutationType && type.name === (mutationType === null || mutationType === void 0 ? void 0 : mutationType.name)) {\n        return newMutationType;\n      }\n      return type;\n    })];\n    const updatedSchema = new graphql__WEBPACK_IMPORTED_MODULE_1__.GraphQLSchema({\n      ...schemaConfig,\n      query: newQueryType,\n      mutation: newMutationType,\n      types\n    });\n    return updatedSchema;\n  };\n}\nfunction printFieldOnType(type, fieldName) {\n  const printed = (0,graphql__WEBPACK_IMPORTED_MODULE_1__.printType)(type);\n  const document = (0,graphql__WEBPACK_IMPORTED_MODULE_1__.parse)(printed);\n  const parsed = document.definitions[0];\n  const parsedField = parsed.fields.find(x => x.name.value === fieldName);\n  return (0,graphql__WEBPACK_IMPORTED_MODULE_1__.print)(parsedField);\n}\nfunction extendObjectType(existingType, fieldsToAdd, defaultName) {\n  const hasNewFields = Object.entries(fieldsToAdd).length;\n  if (!hasNewFields) {\n    return existingType;\n  }\n  const existingTypeConfig = existingType === null || existingType === void 0 ? void 0 : existingType.toConfig();\n  const newFields = {\n    ...(existingTypeConfig === null || existingTypeConfig === void 0 ? void 0 : existingTypeConfig.fields)\n  };\n  for (const [key, val] of Object.entries(fieldsToAdd)) {\n    if (newFields[key]) {\n      var _name;\n      throw new Error(`The schema extension defines a field ${JSON.stringify(key)} on the ${JSON.stringify((_name = existingType.name) !== null && _name !== void 0 ? _name : defaultName)} type but that type already defines a field with that name.\\nThe original field:\\n${printFieldOnType(existingType, key)}\\nThe field added by the extension:\\n${printFieldOnType(new graphql__WEBPACK_IMPORTED_MODULE_1__.GraphQLObjectType({\n        name: \"ForError\",\n        fields: {\n          [key]: val\n        }\n      }), key)}`);\n    }\n    newFields[key] = val;\n  }\n  return new graphql__WEBPACK_IMPORTED_MODULE_1__.GraphQLObjectType({\n    name: defaultName,\n    ...existingTypeConfig,\n    fields: newFields\n  });\n}\n\n// https://github.com/microsoft/TypeScript/issues/17002\nconst isReadonlyArray = Array.isArray;\nconst operations = [\"query\", \"mutation\"];\nfunction flattenExtensions(extensions) {\n  if (isReadonlyArray(extensions)) {\n    const resolvedExtension = {\n      mutation: {},\n      query: {}\n    };\n    for (const extension of extensions) {\n      for (const operation of operations) {\n        const fields = extension[operation];\n        if (fields) {\n          for (const [key, val] of Object.entries(fields)) {\n            if (resolvedExtension[operation][key]) {\n              throw new Error(`More than one extension defines a field named ${JSON.stringify(key)} on the ${operation} type.\\nThe first field:\\n${printFieldOnType(new _graphql_ts_schema__WEBPACK_IMPORTED_MODULE_0__.GObjectType({\n                name: \"ForError\",\n                fields: {\n                  [key]: val\n                }\n              }), key)}\\nThe second field:\\n${printFieldOnType(new _graphql_ts_schema__WEBPACK_IMPORTED_MODULE_0__.GObjectType({\n                name: \"ForError\",\n                fields: {\n                  [key]: resolvedExtension[operation][key]\n                }\n              }), key)}`);\n            }\n            resolvedExtension[operation][key] = val;\n          }\n        }\n      }\n    }\n    return resolvedExtension;\n  }\n  return extensions;\n}\n\n/**\n * Any\n *\n * Note the distinct usages of `any` vs `unknown` is intentional.\n *\n * - The `unknown` used for the source type is because the source isn't known and\n *   it shouldn't generally be used here because these fields are on the query\n *   and mutation types\n * - The first `any` used for the `Args` type parameter is used because `Args` is\n *   invariant so only `Record<string, Arg<InputType, boolean>>` would work with\n *   it. The arguable unsafety here doesn't really matter because people will\n *   always use `g.field`\n * - The `any` in `OutputType` and the last type argument mean that a field that\n *   requires any context can be provided. This is unsafe, the only way this\n *   could arguably be made more \"safe\" is by making this unknown which would\n *   requiring casting or make `extend` and etc. generic over a `Context` but\n *   given this is immediately used on an arbitrary {@link GraphQLSchema} so the\n *   type would immediately be thrown away, it would be pretty much pointless.\n */\n\n/**\n * An extension to a GraphQL schema. This currently only supports adding fields\n * to the query and mutation types. Extending other types will be supported in\n * the future.\n */\n\n/**\n * This object contains the schema being extended and functions to get GraphQL\n * types from the schema.\n */\n\nfunction findObjectTypeUsages(schema, types) {\n  const usages = new Map();\n  for (const [name, type] of Object.entries(schema.getTypeMap())) {\n    if ((0,graphql__WEBPACK_IMPORTED_MODULE_1__.isInterfaceType)(type) || (0,graphql__WEBPACK_IMPORTED_MODULE_1__.isObjectType)(type)) {\n      for (const [fieldName, field] of Object.entries(type.getFields())) {\n        const namedType = (0,graphql__WEBPACK_IMPORTED_MODULE_1__.getNamedType)(field.type);\n        if ((0,graphql__WEBPACK_IMPORTED_MODULE_1__.isObjectType)(namedType) && types.has(namedType)) {\n          getOrDefault(usages, namedType, []).push(`${name}.${fieldName}`);\n        }\n      }\n    }\n    if ((0,graphql__WEBPACK_IMPORTED_MODULE_1__.isUnionType)(type)) {\n      for (const member of type.getTypes()) {\n        if (types.has(member)) {\n          getOrDefault(usages, member, []).push(name);\n        }\n      }\n    }\n  }\n  return usages;\n}\nfunction getOrDefault(input, key, defaultValue) {\n  if (!input.has(key)) {\n    input.set(key, defaultValue);\n    return defaultValue;\n  }\n  return input.get(key);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BncmFwaHFsLXRzK2V4dGVuZEAyLjAuMF9AZ3JhcGhxbC10cytzY2hlbWFAMS4wLjJfZ3JhcGhxbEAxNi4xMC4wX19ncmFwaHFsQDE2LjEwLjAvbm9kZV9tb2R1bGVzL0BncmFwaHFsLXRzL2V4dGVuZC9kaXN0L2dyYXBocWwtdHMtZXh0ZW5kLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaU47QUFDaEs7O0FBRWpEO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQW9COztBQUVuRDtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBWTtBQUN6QixtREFBbUQsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsMERBQWlCO0FBQzlCLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QixtREFBbUQsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsd0RBQWU7QUFDNUIsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx5R0FBeUcsTUFBTTtBQUMvRztBQUNBO0FBQ0EsYUFBYSxxREFBWTtBQUN6QixtREFBbUQsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsb0RBQVc7QUFDeEIsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDtBQUN2SCxvQkFBb0Isc0JBQXNCLGFBQWEsOENBQThDO0FBQ3JHLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRiwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixrREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrREFBUztBQUMzQixtQkFBbUIsOENBQUs7QUFDeEI7QUFDQTtBQUNBLFNBQVMsOENBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxxQkFBcUIsU0FBUyxnR0FBZ0csbUZBQW1GLG9DQUFvQyx1Q0FBdUMscUJBQXFCLHNEQUFpQjtBQUNoWTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sUUFBUTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxQkFBcUIsU0FBUyxXQUFXLDJCQUEyQixxQkFBcUIsMkRBQVc7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsdUJBQXVCLHFCQUFxQiwyREFBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQWUsVUFBVSxxREFBWTtBQUM3QztBQUNBLDBCQUEwQixxREFBWTtBQUN0QyxZQUFZLHFEQUFZO0FBQ3hCLHNEQUFzRCxLQUFLLEdBQUcsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQiIsInNvdXJjZXMiOlsiL1VzZXJzL2phaW1laXNyYWVsY2FtcGVhcy9rZXlzdG9uZS9ub2RlX21vZHVsZXMvLnBucG0vQGdyYXBocWwtdHMrZXh0ZW5kQDIuMC4wX0BncmFwaHFsLXRzK3NjaGVtYUAxLjAuMl9ncmFwaHFsQDE2LjEwLjBfX2dyYXBocWxAMTYuMTAuMC9ub2RlX21vZHVsZXMvQGdyYXBocWwtdHMvZXh0ZW5kL2Rpc3QvZ3JhcGhxbC10cy1leHRlbmQuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwZWNpZmllZFNjYWxhclR5cGVzLCBpc09iamVjdFR5cGUsIGlzSW5wdXRPYmplY3RUeXBlLCBpc0VudW1UeXBlLCBpc0ludGVyZmFjZVR5cGUsIGlzU2NhbGFyVHlwZSwgaXNVbmlvblR5cGUsIEdyYXBoUUxTY2hlbWEsIEdyYXBoUUxPYmplY3RUeXBlLCBnZXROYW1lZFR5cGUsIHByaW50VHlwZSwgcGFyc2UsIHByaW50IH0gZnJvbSAnZ3JhcGhxbCc7XG5pbXBvcnQgeyBHT2JqZWN0VHlwZSB9IGZyb20gJ0BncmFwaHFsLXRzL3NjaGVtYSc7XG5cbi8qKlxuICogQW4gQVBJIHRvIGV4dGVuZCBhbiBhcmJpdHJhcnkge0BsaW5rIEdyYXBoUUxTY2hlbWF9IHdpdGggYEBncmFwaHFsLXRzL3NjaGVtYWAuXG4gKiBOb3RlIGlmIHlvdSdyZSBidWlsZGluZyBhIHNjaGVtYSBlbnRpcmVseSB3aXRoIGBAZ3JhcGhxbC10cy9zY2hlbWFgLCB5b3VcbiAqIHNob3VsZG4ndCB1c2UgdGhpcyBwYWNrYWdlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGFcbiAqIHtAbGluayBHcmFwaFFMU2NoZW1hfSBmcm9tIHNvbWV3aGVyZSBlbHNlIGFuZCB5b3Ugd2FudCB0byBzb21lIGZpZWxkcyB0b1xuICogdmFyaW91cyBwbGFjZXMgaW4gaXQuXG4gKlxuICogU2VlIHtAbGluayBleHRlbmR9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQG1vZHVsZVxuICovXG5jb25zdCBidWlsdGluU2NhbGFycyA9IG5ldyBTZXQoc3BlY2lmaWVkU2NhbGFyVHlwZXMubWFwKHggPT4geC5uYW1lKSk7XG5cbi8qKlxuICogYGV4dGVuZGAgYWxsb3dzIHlvdSB0byBleHRlbmQgYSB7QGxpbmsgR3JhcGhRTFNjaGVtYX0gd2l0aFxuICogYEBncmFwaHFsLXRzL3NjaGVtYWAuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IG9yaWdpbmFsU2NoZW1hID0gbmV3IEdyYXBoUUxTY2hlbWEoeyAuLi5ldGMgfSk7XG4gKlxuICogY29uc3QgZXh0ZW5kZWRTY2hlbWEgPSBleHRlbmQoe1xuICogICBxdWVyeToge1xuICogICAgIGhlbGxvOiBnLmZpZWxkKHtcbiAqICAgICAgIHR5cGU6IGcuU3RyaW5nLFxuICogICAgICAgcmVzb2x2ZSgpIHtcbiAqICAgICAgICAgcmV0dXJuIFwiSGVsbG8hXCI7XG4gKiAgICAgICB9LFxuICogICAgIH0pLFxuICogICB9LFxuICogfSkob3JpZ2luYWxTY2hlbWEpO1xuICogYGBgXG4gKlxuICogVG8gdXNlIGV4aXN0aW5nIHR5cGVzIGZyb20gdGhlIHNjaGVtYSB5b3UncmUgZXh0ZW5kaW5nLCB5b3UgY2FuIHByb3ZpZGUgYVxuICogZnVuY3Rpb24gYW5kIHVzZSB0aGUge0BsaW5rIEJhc2VTY2hlbWFNZXRhfSBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb24gdG8gdXNlXG4gKiBleGlzdGluZyB0eXBlcyBpbiB0aGUgc2NoZW1hLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBvcmlnaW5hbFNjaGVtYSA9IG5ldyBHcmFwaFFMU2NoZW1hKHsgLi4uZXRjIH0pO1xuICpcbiAqIGNvbnN0IGV4dGVuZGVkU2NoZW1hID0gZXh0ZW5kKChiYXNlKSA9PiAoe1xuICogICBxdWVyeToge1xuICogICAgIHNvbWV0aGluZzogZy5maWVsZCh7XG4gKiAgICAgICB0eXBlOiBiYXNlLm9iamVjdChcIlNvbWV0aGluZ1wiKSxcbiAqICAgICAgIHJlc29sdmUoKSB7XG4gKiAgICAgICAgIHJldHVybiB7IHNvbWV0aGluZzogdHJ1ZSB9O1xuICogICAgICAgfSxcbiAqICAgICB9KSxcbiAqICAgfSxcbiAqIH0pKShvcmlnaW5hbFNjaGVtYSk7XG4gKiBgYGBcbiAqXG4gKiBTZWUge0BsaW5rIEJhc2VTY2hlbWFNZXRhfSBmb3IgaG93IHRvIGdldCBvdGhlciB0eXBlcyBmcm9tIHRoZSBzY2hlbWFcbiAqXG4gKiBgZXh0ZW5kYCB3aWxsIGN1cnJlbnRseSB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcXVlcnkgb3IgbXV0YXRpb24gdHlwZXMgYXJlXG4gKiB1c2VkIGluIG90aGVyIHR5cGVzIGxpa2UgdGhpcy4gVGhpcyB3aWxsIGJlIGFsbG93ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAqXG4gKiBgYGBncmFwaHFsXG4gKiB0eXBlIFF1ZXJ5IHtcbiAqICAgdGhpbmc6IFF1ZXJ5XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGV4dGVuc2lvbikge1xuICByZXR1cm4gc2NoZW1hID0+IHtcbiAgICBjb25zdCBnZXRUeXBlID0gbmFtZSA9PiB7XG4gICAgICBjb25zdCBncmFwaFFMVHlwZSA9IHNjaGVtYS5nZXRUeXBlKG5hbWUpO1xuICAgICAgaWYgKGdyYXBoUUxUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIG5hbWVkICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGV4aXN0cyBpbiB0aGUgc2NoZW1hIHRoYXQgaXMgYmVpbmcgZXh0ZW5kZWRgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFwaFFMVHlwZTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9uID0gZmxhdHRlbkV4dGVuc2lvbnModHlwZW9mIGV4dGVuc2lvbiA9PT0gXCJmdW5jdGlvblwiID8gZXh0ZW5zaW9uKHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIG9iamVjdChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoUUxUeXBlID0gZ2V0VHlwZShuYW1lKTtcbiAgICAgICAgaWYgKCFpc09iamVjdFR5cGUoZ3JhcGhRTFR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhIHR5cGUgbmFtZWQgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gaW4gdGhlIHNjaGVtYSBiZWluZyBleHRlbmRlZCBidXQgaXQgaXMgbm90IGFuIG9iamVjdCB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoUUxUeXBlO1xuICAgICAgfSxcbiAgICAgIGlucHV0T2JqZWN0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JhcGhRTFR5cGUgPSBnZXRUeXBlKG5hbWUpO1xuICAgICAgICBpZiAoIWlzSW5wdXRPYmplY3RUeXBlKGdyYXBoUUxUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYSB0eXBlIG5hbWVkICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGluIHRoZSBzY2hlbWEgYmVpbmcgZXh0ZW5kZWQgYnV0IGl0IGlzIG5vdCBhbiBpbnB1dCBvYmplY3QgdHlwZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaFFMVHlwZTtcbiAgICAgIH0sXG4gICAgICBlbnVtKG5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JhcGhRTFR5cGUgPSBnZXRUeXBlKG5hbWUpO1xuICAgICAgICBpZiAoIWlzRW51bVR5cGUoZ3JhcGhRTFR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhIHR5cGUgbmFtZWQgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gaW4gdGhlIHNjaGVtYSBiZWluZyBleHRlbmRlZCBidXQgaXQgaXMgbm90IGFuIGVudW0gdHlwZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaFFMVHlwZTtcbiAgICAgIH0sXG4gICAgICBpbnRlcmZhY2UobmFtZSkge1xuICAgICAgICBjb25zdCBncmFwaFFMVHlwZSA9IGdldFR5cGUobmFtZSk7XG4gICAgICAgIGlmICghaXNJbnRlcmZhY2VUeXBlKGdyYXBoUUxUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYSB0eXBlIG5hbWVkICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IGluIHRoZSBzY2hlbWEgYmVpbmcgZXh0ZW5kZWQgYnV0IGl0IGlzIG5vdCBhbiBpbnRlcmZhY2UgdHlwZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaFFMVHlwZTtcbiAgICAgIH0sXG4gICAgICBzY2FsYXIobmFtZSkge1xuICAgICAgICBpZiAoYnVpbHRpblNjYWxhcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbmFtZXMgb2YgYnVpbHQtaW4gc2NhbGFycyBjYW5ub3QgYmUgcGFzc2VkIHRvIEJhc2VTY2hlbWFJbmZvLnNjYWxhciBidXQgJHtuYW1lfSB3YXMgcGFzc2VkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JhcGhRTFR5cGUgPSBnZXRUeXBlKG5hbWUpO1xuICAgICAgICBpZiAoIWlzU2NhbGFyVHlwZShncmFwaFFMVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGEgdHlwZSBuYW1lZCAke0pTT04uc3RyaW5naWZ5KG5hbWUpfSBpbiB0aGUgc2NoZW1hIGJlaW5nIGV4dGVuZGVkIGJ1dCBpdCBpcyBub3QgYSBzY2FsYXIgdHlwZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaFFMVHlwZTtcbiAgICAgIH0sXG4gICAgICB1bmlvbihuYW1lKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoUUxUeXBlID0gZ2V0VHlwZShuYW1lKTtcbiAgICAgICAgaWYgKCFpc1VuaW9uVHlwZShncmFwaFFMVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGEgdHlwZSBuYW1lZCAke0pTT04uc3RyaW5naWZ5KG5hbWUpfSBpbiB0aGUgc2NoZW1hIGJlaW5nIGV4dGVuZGVkIGJ1dCBpdCBpcyBub3QgYSB1bmlvbiB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoUUxUeXBlO1xuICAgICAgfVxuICAgIH0pIDogZXh0ZW5zaW9uKTtcbiAgICBjb25zdCBxdWVyeVR5cGUgPSBzY2hlbWEuZ2V0UXVlcnlUeXBlKCk7XG4gICAgY29uc3QgbXV0YXRpb25UeXBlID0gc2NoZW1hLmdldE11dGF0aW9uVHlwZSgpO1xuICAgIGNvbnN0IHR5cGVzVG9GaW5kID0gbmV3IFNldCgpO1xuICAgIGlmIChxdWVyeVR5cGUpIHtcbiAgICAgIHR5cGVzVG9GaW5kLmFkZChxdWVyeVR5cGUpO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb25UeXBlKSB7XG4gICAgICB0eXBlc1RvRmluZC5hZGQobXV0YXRpb25UeXBlKTtcbiAgICB9XG4gICAgY29uc3QgdXNhZ2VzID0gZmluZE9iamVjdFR5cGVVc2FnZXMoc2NoZW1hLCB0eXBlc1RvRmluZCk7XG4gICAgaWYgKHVzYWdlcy5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEBncmFwaHFsLXRzL2V4dGVuZCBkb2Vzbid0IHlldCBzdXBwb3J0IHVzaW5nIHRoZSBxdWVyeSBhbmQgbXV0YXRpb24gdHlwZXMgaW4gb3RoZXIgdHlwZXMgYnV0XFxuJHtbLi4udXNhZ2VzXS5tYXAoKFt0eXBlLCB1c2FnZXNdKSA9PiB7XG4gICAgICAgIHJldHVybiBgLSAke0pTT04uc3RyaW5naWZ5KHR5cGUpfSBpcyB1c2VkIGF0ICR7dXNhZ2VzLm1hcCh4ID0+IEpTT04uc3RyaW5naWZ5KHgpKS5qb2luKFwiLCBcIil9YDtcbiAgICAgIH0pLmpvaW4oXCJcXG5cIil9YCk7XG4gICAgfVxuICAgIGlmICghcmVzb2x2ZWRFeHRlbnNpb24ubXV0YXRpb24gJiYgIXJlc29sdmVkRXh0ZW5zaW9uLnF1ZXJ5KSB7XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBjb25zdCBuZXdRdWVyeVR5cGUgPSBleHRlbmRPYmplY3RUeXBlKHF1ZXJ5VHlwZSwgcmVzb2x2ZWRFeHRlbnNpb24ucXVlcnkgfHwge30sIFwiUXVlcnlcIik7XG4gICAgY29uc3QgbmV3TXV0YXRpb25UeXBlID0gZXh0ZW5kT2JqZWN0VHlwZShtdXRhdGlvblR5cGUsIHJlc29sdmVkRXh0ZW5zaW9uLm11dGF0aW9uIHx8IHt9LCBcIk11dGF0aW9uXCIpO1xuICAgIGNvbnN0IHNjaGVtYUNvbmZpZyA9IHNjaGVtYS50b0NvbmZpZygpO1xuICAgIGxldCB0eXBlcyA9IFsuLi4ocXVlcnlUeXBlIHx8ICFuZXdRdWVyeVR5cGUgPyBbXSA6IFtuZXdRdWVyeVR5cGVdKSwgLi4uKG11dGF0aW9uVHlwZSB8fCAhbmV3TXV0YXRpb25UeXBlID8gW10gOiBbbmV3TXV0YXRpb25UeXBlXSksIC4uLnNjaGVtYUNvbmZpZy50eXBlcy5tYXAodHlwZSA9PiB7XG4gICAgICBpZiAobmV3UXVlcnlUeXBlICYmIHR5cGUubmFtZSA9PT0gKHF1ZXJ5VHlwZSA9PT0gbnVsbCB8fCBxdWVyeVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHF1ZXJ5VHlwZS5uYW1lKSkge1xuICAgICAgICByZXR1cm4gbmV3UXVlcnlUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKG5ld011dGF0aW9uVHlwZSAmJiB0eXBlLm5hbWUgPT09IChtdXRhdGlvblR5cGUgPT09IG51bGwgfHwgbXV0YXRpb25UeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtdXRhdGlvblR5cGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ld011dGF0aW9uVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0pXTtcbiAgICBjb25zdCB1cGRhdGVkU2NoZW1hID0gbmV3IEdyYXBoUUxTY2hlbWEoe1xuICAgICAgLi4uc2NoZW1hQ29uZmlnLFxuICAgICAgcXVlcnk6IG5ld1F1ZXJ5VHlwZSxcbiAgICAgIG11dGF0aW9uOiBuZXdNdXRhdGlvblR5cGUsXG4gICAgICB0eXBlc1xuICAgIH0pO1xuICAgIHJldHVybiB1cGRhdGVkU2NoZW1hO1xuICB9O1xufVxuZnVuY3Rpb24gcHJpbnRGaWVsZE9uVHlwZSh0eXBlLCBmaWVsZE5hbWUpIHtcbiAgY29uc3QgcHJpbnRlZCA9IHByaW50VHlwZSh0eXBlKTtcbiAgY29uc3QgZG9jdW1lbnQgPSBwYXJzZShwcmludGVkKTtcbiAgY29uc3QgcGFyc2VkID0gZG9jdW1lbnQuZGVmaW5pdGlvbnNbMF07XG4gIGNvbnN0IHBhcnNlZEZpZWxkID0gcGFyc2VkLmZpZWxkcy5maW5kKHggPT4geC5uYW1lLnZhbHVlID09PSBmaWVsZE5hbWUpO1xuICByZXR1cm4gcHJpbnQocGFyc2VkRmllbGQpO1xufVxuZnVuY3Rpb24gZXh0ZW5kT2JqZWN0VHlwZShleGlzdGluZ1R5cGUsIGZpZWxkc1RvQWRkLCBkZWZhdWx0TmFtZSkge1xuICBjb25zdCBoYXNOZXdGaWVsZHMgPSBPYmplY3QuZW50cmllcyhmaWVsZHNUb0FkZCkubGVuZ3RoO1xuICBpZiAoIWhhc05ld0ZpZWxkcykge1xuICAgIHJldHVybiBleGlzdGluZ1R5cGU7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdUeXBlQ29uZmlnID0gZXhpc3RpbmdUeXBlID09PSBudWxsIHx8IGV4aXN0aW5nVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmdUeXBlLnRvQ29uZmlnKCk7XG4gIGNvbnN0IG5ld0ZpZWxkcyA9IHtcbiAgICAuLi4oZXhpc3RpbmdUeXBlQ29uZmlnID09PSBudWxsIHx8IGV4aXN0aW5nVHlwZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmdUeXBlQ29uZmlnLmZpZWxkcylcbiAgfTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkc1RvQWRkKSkge1xuICAgIGlmIChuZXdGaWVsZHNba2V5XSkge1xuICAgICAgdmFyIF9uYW1lO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2NoZW1hIGV4dGVuc2lvbiBkZWZpbmVzIGEgZmllbGQgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBvbiB0aGUgJHtKU09OLnN0cmluZ2lmeSgoX25hbWUgPSBleGlzdGluZ1R5cGUubmFtZSkgIT09IG51bGwgJiYgX25hbWUgIT09IHZvaWQgMCA/IF9uYW1lIDogZGVmYXVsdE5hbWUpfSB0eXBlIGJ1dCB0aGF0IHR5cGUgYWxyZWFkeSBkZWZpbmVzIGEgZmllbGQgd2l0aCB0aGF0IG5hbWUuXFxuVGhlIG9yaWdpbmFsIGZpZWxkOlxcbiR7cHJpbnRGaWVsZE9uVHlwZShleGlzdGluZ1R5cGUsIGtleSl9XFxuVGhlIGZpZWxkIGFkZGVkIGJ5IHRoZSBleHRlbnNpb246XFxuJHtwcmludEZpZWxkT25UeXBlKG5ldyBHcmFwaFFMT2JqZWN0VHlwZSh7XG4gICAgICAgIG5hbWU6IFwiRm9yRXJyb3JcIixcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgW2tleV06IHZhbFxuICAgICAgICB9XG4gICAgICB9KSwga2V5KX1gKTtcbiAgICB9XG4gICAgbmV3RmllbGRzW2tleV0gPSB2YWw7XG4gIH1cbiAgcmV0dXJuIG5ldyBHcmFwaFFMT2JqZWN0VHlwZSh7XG4gICAgbmFtZTogZGVmYXVsdE5hbWUsXG4gICAgLi4uZXhpc3RpbmdUeXBlQ29uZmlnLFxuICAgIGZpZWxkczogbmV3RmllbGRzXG4gIH0pO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXG5jb25zdCBpc1JlYWRvbmx5QXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3Qgb3BlcmF0aW9ucyA9IFtcInF1ZXJ5XCIsIFwibXV0YXRpb25cIl07XG5mdW5jdGlvbiBmbGF0dGVuRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGlmIChpc1JlYWRvbmx5QXJyYXkoZXh0ZW5zaW9ucykpIHtcbiAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbiA9IHtcbiAgICAgIG11dGF0aW9uOiB7fSxcbiAgICAgIHF1ZXJ5OiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBleHRlbnNpb25bb3BlcmF0aW9uXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZHMpKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRFeHRlbnNpb25bb3BlcmF0aW9uXVtrZXldKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9yZSB0aGFuIG9uZSBleHRlbnNpb24gZGVmaW5lcyBhIGZpZWxkIG5hbWVkICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gb24gdGhlICR7b3BlcmF0aW9ufSB0eXBlLlxcblRoZSBmaXJzdCBmaWVsZDpcXG4ke3ByaW50RmllbGRPblR5cGUobmV3IEdPYmplY3RUeXBlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkZvckVycm9yXCIsXG4gICAgICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAgICBba2V5XTogdmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwga2V5KX1cXG5UaGUgc2Vjb25kIGZpZWxkOlxcbiR7cHJpbnRGaWVsZE9uVHlwZShuZXcgR09iamVjdFR5cGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRm9yRXJyb3JcIixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgIFtrZXldOiByZXNvbHZlZEV4dGVuc2lvbltvcGVyYXRpb25dW2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCBrZXkpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZWRFeHRlbnNpb25bb3BlcmF0aW9uXVtrZXldID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRFeHRlbnNpb247XG4gIH1cbiAgcmV0dXJuIGV4dGVuc2lvbnM7XG59XG5cbi8qKlxuICogQW55XG4gKlxuICogTm90ZSB0aGUgZGlzdGluY3QgdXNhZ2VzIG9mIGBhbnlgIHZzIGB1bmtub3duYCBpcyBpbnRlbnRpb25hbC5cbiAqXG4gKiAtIFRoZSBgdW5rbm93bmAgdXNlZCBmb3IgdGhlIHNvdXJjZSB0eXBlIGlzIGJlY2F1c2UgdGhlIHNvdXJjZSBpc24ndCBrbm93biBhbmRcbiAqICAgaXQgc2hvdWxkbid0IGdlbmVyYWxseSBiZSB1c2VkIGhlcmUgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIG9uIHRoZSBxdWVyeVxuICogICBhbmQgbXV0YXRpb24gdHlwZXNcbiAqIC0gVGhlIGZpcnN0IGBhbnlgIHVzZWQgZm9yIHRoZSBgQXJnc2AgdHlwZSBwYXJhbWV0ZXIgaXMgdXNlZCBiZWNhdXNlIGBBcmdzYCBpc1xuICogICBpbnZhcmlhbnQgc28gb25seSBgUmVjb3JkPHN0cmluZywgQXJnPElucHV0VHlwZSwgYm9vbGVhbj4+YCB3b3VsZCB3b3JrIHdpdGhcbiAqICAgaXQuIFRoZSBhcmd1YWJsZSB1bnNhZmV0eSBoZXJlIGRvZXNuJ3QgcmVhbGx5IG1hdHRlciBiZWNhdXNlIHBlb3BsZSB3aWxsXG4gKiAgIGFsd2F5cyB1c2UgYGcuZmllbGRgXG4gKiAtIFRoZSBgYW55YCBpbiBgT3V0cHV0VHlwZWAgYW5kIHRoZSBsYXN0IHR5cGUgYXJndW1lbnQgbWVhbiB0aGF0IGEgZmllbGQgdGhhdFxuICogICByZXF1aXJlcyBhbnkgY29udGV4dCBjYW4gYmUgcHJvdmlkZWQuIFRoaXMgaXMgdW5zYWZlLCB0aGUgb25seSB3YXkgdGhpc1xuICogICBjb3VsZCBhcmd1YWJseSBiZSBtYWRlIG1vcmUgXCJzYWZlXCIgaXMgYnkgbWFraW5nIHRoaXMgdW5rbm93biB3aGljaCB3b3VsZFxuICogICByZXF1aXJpbmcgY2FzdGluZyBvciBtYWtlIGBleHRlbmRgIGFuZCBldGMuIGdlbmVyaWMgb3ZlciBhIGBDb250ZXh0YCBidXRcbiAqICAgZ2l2ZW4gdGhpcyBpcyBpbW1lZGlhdGVseSB1c2VkIG9uIGFuIGFyYml0cmFyeSB7QGxpbmsgR3JhcGhRTFNjaGVtYX0gc28gdGhlXG4gKiAgIHR5cGUgd291bGQgaW1tZWRpYXRlbHkgYmUgdGhyb3duIGF3YXksIGl0IHdvdWxkIGJlIHByZXR0eSBtdWNoIHBvaW50bGVzcy5cbiAqL1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byBhIEdyYXBoUUwgc2NoZW1hLiBUaGlzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGFkZGluZyBmaWVsZHNcbiAqIHRvIHRoZSBxdWVyeSBhbmQgbXV0YXRpb24gdHlwZXMuIEV4dGVuZGluZyBvdGhlciB0eXBlcyB3aWxsIGJlIHN1cHBvcnRlZCBpblxuICogdGhlIGZ1dHVyZS5cbiAqL1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIHRoZSBzY2hlbWEgYmVpbmcgZXh0ZW5kZWQgYW5kIGZ1bmN0aW9ucyB0byBnZXQgR3JhcGhRTFxuICogdHlwZXMgZnJvbSB0aGUgc2NoZW1hLlxuICovXG5cbmZ1bmN0aW9uIGZpbmRPYmplY3RUeXBlVXNhZ2VzKHNjaGVtYSwgdHlwZXMpIHtcbiAgY29uc3QgdXNhZ2VzID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IFtuYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEuZ2V0VHlwZU1hcCgpKSkge1xuICAgIGlmIChpc0ludGVyZmFjZVR5cGUodHlwZSkgfHwgaXNPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkXSBvZiBPYmplY3QuZW50cmllcyh0eXBlLmdldEZpZWxkcygpKSkge1xuICAgICAgICBjb25zdCBuYW1lZFR5cGUgPSBnZXROYW1lZFR5cGUoZmllbGQudHlwZSk7XG4gICAgICAgIGlmIChpc09iamVjdFR5cGUobmFtZWRUeXBlKSAmJiB0eXBlcy5oYXMobmFtZWRUeXBlKSkge1xuICAgICAgICAgIGdldE9yRGVmYXVsdCh1c2FnZXMsIG5hbWVkVHlwZSwgW10pLnB1c2goYCR7bmFtZX0uJHtmaWVsZE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzVW5pb25UeXBlKHR5cGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmdldFR5cGVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVzLmhhcyhtZW1iZXIpKSB7XG4gICAgICAgICAgZ2V0T3JEZWZhdWx0KHVzYWdlcywgbWVtYmVyLCBbXSkucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXNhZ2VzO1xufVxuZnVuY3Rpb24gZ2V0T3JEZWZhdWx0KGlucHV0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoIWlucHV0LmhhcyhrZXkpKSB7XG4gICAgaW5wdXQuc2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiBpbnB1dC5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IHsgZXh0ZW5kIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/@graphql-ts+extend@2.0.0_@graphql-ts+schema@1.0.2_graphql@16.10.0__graphql@16.10.0/node_modules/@graphql-ts/extend/dist/graphql-ts-extend.esm.js\n");

/***/ })

};
;