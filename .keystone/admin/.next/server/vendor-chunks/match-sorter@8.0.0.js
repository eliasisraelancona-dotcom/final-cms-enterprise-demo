"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/match-sorter@8.0.0";
exports.ids = ["vendor-chunks/match-sorter@8.0.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/match-sorter@8.0.0/node_modules/match-sorter/dist/match-sorter.cjs.js":
/*!************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/match-sorter@8.0.0/node_modules/match-sorter/dist/match-sorter.cjs.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar removeAccents = __webpack_require__(/*! remove-accents */ \"(pages-dir-node)/../../../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js\");\n\n/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2020 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */\nconst rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nconst defaultBaseSortFn = (a, b) => String(a.rankedValue).localeCompare(String(b.rankedValue));\n\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    keys,\n    threshold = rankings.MATCHES,\n    baseSort = defaultBaseSortFn,\n    sorter = matchedItems => matchedItems.sort((a, b) => sortRankedValues(a, b, baseSort))\n  } = options;\n  const matchedItems = items.reduce(reduceItemsToRanked, []);\n  return sorter(matchedItems).map(_ref => {\n    let {\n      item\n    } = _ref;\n    return item;\n  });\n  function reduceItemsToRanked(matches, item, index) {\n    const rankingInfo = getHighestRanking(item, keys, value, options);\n    const {\n      rank,\n      keyThreshold = threshold\n    } = rankingInfo;\n    if (rank >= keyThreshold) {\n      matches.push({\n        ...rankingInfo,\n        item,\n        index\n      });\n    }\n    return matches;\n  }\n}\nmatchSorter.rankings = rankings;\n\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    const stringItem = item;\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: stringItem,\n      rank: getMatchRanking(stringItem, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n  const valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce((_ref2, _ref3, i) => {\n    let {\n      rank,\n      rankedValue,\n      keyIndex,\n      keyThreshold\n    } = _ref2;\n    let {\n      itemValue,\n      attributes\n    } = _ref3;\n    let newRank = getMatchRanking(itemValue, value, options);\n    let newRankedValue = rankedValue;\n    const {\n      minRanking,\n      maxRanking,\n      threshold\n    } = attributes;\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedValue = itemValue;\n    }\n    return {\n      rankedValue: newRankedValue,\n      rank,\n      keyIndex,\n      keyThreshold\n    };\n  }, {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options);\n\n  // too long\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  }\n\n  // case sensitive equals\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n\n  // Lower casing before further comparison\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase();\n\n  // case insensitive equals\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  }\n\n  // starts with\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  }\n\n  // word starts with\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH;\n  }\n\n  // contains\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  }\n\n  // acronym\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  }\n\n  // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n  return getClosenessRanking(testString, stringToRank);\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\nfunction getAcronym(string) {\n  let acronym = '';\n  const wordsInString = string.split(' ');\n  wordsInString.forEach(wordInString => {\n    const splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(splitByHyphenWord => {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\nfunction getClosenessRanking(testString, stringToRank) {\n  let matchingInOrderCharCount = 0;\n  let charNumber = 0;\n  function findMatchingCharacter(matchChar, string, index) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j];\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n    return -1;\n  }\n  function getRanking(spread) {\n    const spreadPercentage = 1 / spread;\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n    return ranking;\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n  charNumber = firstIndex;\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    const found = charNumber > -1;\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n  const spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\nfunction sortRankedValues(a, b, baseSort) {\n  const aFirst = -1;\n  const bFirst = 1;\n  const {\n    rank: aRank,\n    keyIndex: aKeyIndex\n  } = a;\n  const {\n    rank: bRank,\n    keyIndex: bKeyIndex\n  } = b;\n  const same = aRank === bRank;\n  if (same) {\n    if (aKeyIndex === bKeyIndex) {\n      // use the base sort function as a tie-breaker\n      return baseSort(a, b);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\nfunction prepareValueForComparison(value, _ref4) {\n  let {\n    keepDiacritics\n  } = _ref4;\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = `${value}`; // toString\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n  return value;\n}\n\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n  let value;\n  if (typeof key === 'function') {\n    value = key(item);\n  } else if (item == null) {\n    value = null;\n  } else if (Object.hasOwnProperty.call(item, key)) {\n    value = item[key];\n  } else if (key.includes('.')) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    return getNestedValues(key, item);\n  } else {\n    value = null;\n  }\n\n  // because `value` can also be undefined\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [String(value)];\n}\n\n/**\n * Given path: \"foo.bar.baz\"\n * And item: {foo: {bar: {baz: 'buzz'}}}\n *   -> 'buzz'\n * @param path a dot-separated set of keys\n * @param item the item to get the value from\n */\nfunction getNestedValues(path, item) {\n  const keys = path.split('.');\n  let values = [item];\n  for (let i = 0, I = keys.length; i < I; i++) {\n    const nestedKey = keys[i];\n    let nestedValues = [];\n    for (let j = 0, J = values.length; j < J; j++) {\n      const nestedItem = values[j];\n      if (nestedItem == null) continue;\n      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {\n        const nestedValue = nestedItem[nestedKey];\n        if (nestedValue != null) {\n          nestedValues.push(nestedValue);\n        }\n      } else if (nestedKey === '*') {\n        // ensure that values is an array\n        nestedValues = nestedValues.concat(nestedItem);\n      }\n    }\n    values = nestedValues;\n  }\n  if (Array.isArray(values[0])) {\n    // keep allowing the implicit wildcard for an array of strings at the end of\n    // the path; don't use `.flat()` because that's not available in node.js v10\n    const result = [];\n    return result.concat(...values);\n  }\n  // Based on our logic it should be an array of strings by now...\n  // assuming the user's path terminated in strings\n  return values;\n}\n\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\nfunction getAllValuesToRank(item, keys) {\n  const allValues = [];\n  for (let j = 0, J = keys.length; j < J; j++) {\n    const key = keys[j];\n    const attributes = getKeyAttributes(key);\n    const itemValues = getItemValues(item, key);\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes\n      });\n    }\n  }\n  return allValues;\n}\nconst defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given key\n * @param key - the key from which the attributes will be retrieved\n * @return object containing the key's attributes\n */\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    return defaultKeyAttributes;\n  }\n  return {\n    ...defaultKeyAttributes,\n    ...key\n  };\n}\n\n/*\neslint\n  no-continue: \"off\",\n*/\n\nexports.defaultBaseSortFn = defaultBaseSortFn;\nexports.matchSorter = matchSorter;\nexports.rankings = rankings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWF0Y2gtc29ydGVyQDguMC4wL25vZGVfbW9kdWxlcy9tYXRjaC1zb3J0ZXIvZGlzdC9tYXRjaC1zb3J0ZXIuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLGlJQUFnQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLHVEQUF1RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQixnQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL21hdGNoLXNvcnRlckA4LjAuMC9ub2RlX21vZHVsZXMvbWF0Y2gtc29ydGVyL2Rpc3QvbWF0Y2gtc29ydGVyLmNqcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZW1vdmVBY2NlbnRzID0gcmVxdWlyZSgncmVtb3ZlLWFjY2VudHMnKTtcblxuLyoqXG4gKiBAbmFtZSBtYXRjaC1zb3J0ZXJcbiAqIEBsaWNlbnNlIE1JVCBsaWNlbnNlLlxuICogQGNvcHlyaWdodCAoYykgMjAyMCBLZW50IEMuIERvZGRzXG4gKiBAYXV0aG9yIEtlbnQgQy4gRG9kZHMgPG1lQGtlbnRjZG9kZHMuY29tPiAoaHR0cHM6Ly9rZW50Y2RvZGRzLmNvbSlcbiAqL1xuY29uc3QgcmFua2luZ3MgPSB7XG4gIENBU0VfU0VOU0lUSVZFX0VRVUFMOiA3LFxuICBFUVVBTDogNixcbiAgU1RBUlRTX1dJVEg6IDUsXG4gIFdPUkRfU1RBUlRTX1dJVEg6IDQsXG4gIENPTlRBSU5TOiAzLFxuICBBQ1JPTllNOiAyLFxuICBNQVRDSEVTOiAxLFxuICBOT19NQVRDSDogMFxufTtcbmNvbnN0IGRlZmF1bHRCYXNlU29ydEZuID0gKGEsIGIpID0+IFN0cmluZyhhLnJhbmtlZFZhbHVlKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiLnJhbmtlZFZhbHVlKSk7XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgaXRlbXMgYW5kIGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgaXRlbXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gdGhlIGl0ZW1zIHRvIHNvcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byB1c2UgZm9yIHJhbmtpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU29tZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgc29ydGVyXG4gKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgbmV3IHNvcnRlZCBhcnJheVxuICovXG5mdW5jdGlvbiBtYXRjaFNvcnRlcihpdGVtcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAga2V5cyxcbiAgICB0aHJlc2hvbGQgPSByYW5raW5ncy5NQVRDSEVTLFxuICAgIGJhc2VTb3J0ID0gZGVmYXVsdEJhc2VTb3J0Rm4sXG4gICAgc29ydGVyID0gbWF0Y2hlZEl0ZW1zID0+IG1hdGNoZWRJdGVtcy5zb3J0KChhLCBiKSA9PiBzb3J0UmFua2VkVmFsdWVzKGEsIGIsIGJhc2VTb3J0KSlcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1hdGNoZWRJdGVtcyA9IGl0ZW1zLnJlZHVjZShyZWR1Y2VJdGVtc1RvUmFua2VkLCBbXSk7XG4gIHJldHVybiBzb3J0ZXIobWF0Y2hlZEl0ZW1zKS5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGl0ZW1cbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHJlZHVjZUl0ZW1zVG9SYW5rZWQobWF0Y2hlcywgaXRlbSwgaW5kZXgpIHtcbiAgICBjb25zdCByYW5raW5nSW5mbyA9IGdldEhpZ2hlc3RSYW5raW5nKGl0ZW0sIGtleXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICByYW5rLFxuICAgICAga2V5VGhyZXNob2xkID0gdGhyZXNob2xkXG4gICAgfSA9IHJhbmtpbmdJbmZvO1xuICAgIGlmIChyYW5rID49IGtleVRocmVzaG9sZCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgLi4ucmFua2luZ0luZm8sXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbn1cbm1hdGNoU29ydGVyLnJhbmtpbmdzID0gcmFua2luZ3M7XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaGVzdCByYW5raW5nIGZvciB2YWx1ZSBmb3IgdGhlIGdpdmVuIGl0ZW0gYmFzZWQgb24gaXRzIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXNcbiAqIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIHJhbmtcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSB0aGUga2V5cyB0byBnZXQgdmFsdWVzIGZyb20gdGhlIGl0ZW0gZm9yIHRoZSByYW5raW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcmFuayBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgcmFua2luZ1xuICogQHJldHVybiB7e3Jhbms6IE51bWJlciwga2V5SW5kZXg6IE51bWJlciwga2V5VGhyZXNob2xkOiBOdW1iZXJ9fSAtIHRoZSBoaWdoZXN0IHJhbmtpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0SGlnaGVzdFJhbmtpbmcoaXRlbSwga2V5cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFrZXlzKSB7XG4gICAgLy8gaWYga2V5cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHdlIGFzc3VtZSB0aGUgaXRlbSBnaXZlbiBpcyByZWFkeSB0byBiZSBtYXRjaGVkXG4gICAgY29uc3Qgc3RyaW5nSXRlbSA9IGl0ZW07XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGVuZHMgdXAgYmVpbmcgZHVwbGljYXRlIG9mICdpdGVtJyBpbiBtYXRjaGVzIGJ1dCBjb25zaXN0ZW50XG4gICAgICByYW5rZWRWYWx1ZTogc3RyaW5nSXRlbSxcbiAgICAgIHJhbms6IGdldE1hdGNoUmFua2luZyhzdHJpbmdJdGVtLCB2YWx1ZSwgb3B0aW9ucyksXG4gICAgICBrZXlJbmRleDogLTEsXG4gICAgICBrZXlUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkXG4gICAgfTtcbiAgfVxuICBjb25zdCB2YWx1ZXNUb1JhbmsgPSBnZXRBbGxWYWx1ZXNUb1JhbmsoaXRlbSwga2V5cyk7XG4gIHJldHVybiB2YWx1ZXNUb1JhbmsucmVkdWNlKChfcmVmMiwgX3JlZjMsIGkpID0+IHtcbiAgICBsZXQge1xuICAgICAgcmFuayxcbiAgICAgIHJhbmtlZFZhbHVlLFxuICAgICAga2V5SW5kZXgsXG4gICAgICBrZXlUaHJlc2hvbGRcbiAgICB9ID0gX3JlZjI7XG4gICAgbGV0IHtcbiAgICAgIGl0ZW1WYWx1ZSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gX3JlZjM7XG4gICAgbGV0IG5ld1JhbmsgPSBnZXRNYXRjaFJhbmtpbmcoaXRlbVZhbHVlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgbGV0IG5ld1JhbmtlZFZhbHVlID0gcmFua2VkVmFsdWU7XG4gICAgY29uc3Qge1xuICAgICAgbWluUmFua2luZyxcbiAgICAgIG1heFJhbmtpbmcsXG4gICAgICB0aHJlc2hvbGRcbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICBpZiAobmV3UmFuayA8IG1pblJhbmtpbmcgJiYgbmV3UmFuayA+PSByYW5raW5ncy5NQVRDSEVTKSB7XG4gICAgICBuZXdSYW5rID0gbWluUmFua2luZztcbiAgICB9IGVsc2UgaWYgKG5ld1JhbmsgPiBtYXhSYW5raW5nKSB7XG4gICAgICBuZXdSYW5rID0gbWF4UmFua2luZztcbiAgICB9XG4gICAgaWYgKG5ld1JhbmsgPiByYW5rKSB7XG4gICAgICByYW5rID0gbmV3UmFuaztcbiAgICAgIGtleUluZGV4ID0gaTtcbiAgICAgIGtleVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICAgIG5ld1JhbmtlZFZhbHVlID0gaXRlbVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmFua2VkVmFsdWU6IG5ld1JhbmtlZFZhbHVlLFxuICAgICAgcmFuayxcbiAgICAgIGtleUluZGV4LFxuICAgICAga2V5VGhyZXNob2xkXG4gICAgfTtcbiAgfSwge1xuICAgIHJhbmtlZFZhbHVlOiBpdGVtLFxuICAgIHJhbms6IHJhbmtpbmdzLk5PX01BVENILFxuICAgIGtleUluZGV4OiAtMSxcbiAgICBrZXlUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkXG4gIH0pO1xufVxuXG4vKipcbiAqIEdpdmVzIGEgcmFua2luZ3Mgc2NvcmUgYmFzZWQgb24gaG93IHdlbGwgdGhlIHR3byBzdHJpbmdzIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd9IHRlc3RTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmFuayAtIHRoZSBzdHJpbmcgdG8gcmFua1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgbWF0Y2ggKGxpa2Uga2VlcERpYWNyaXRpY3MgZm9yIGNvbXBhcmlzb24pXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgcmFua2luZyBmb3IgaG93IHdlbGwgc3RyaW5nVG9SYW5rIG1hdGNoZXMgdGVzdFN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRNYXRjaFJhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rLCBvcHRpb25zKSB7XG4gIHRlc3RTdHJpbmcgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHRlc3RTdHJpbmcsIG9wdGlvbnMpO1xuICBzdHJpbmdUb1JhbmsgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHN0cmluZ1RvUmFuaywgb3B0aW9ucyk7XG5cbiAgLy8gdG9vIGxvbmdcbiAgaWYgKHN0cmluZ1RvUmFuay5sZW5ndGggPiB0ZXN0U3RyaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgfVxuXG4gIC8vIGNhc2Ugc2Vuc2l0aXZlIGVxdWFsc1xuICBpZiAodGVzdFN0cmluZyA9PT0gc3RyaW5nVG9SYW5rKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkNBU0VfU0VOU0lUSVZFX0VRVUFMO1xuICB9XG5cbiAgLy8gTG93ZXIgY2FzaW5nIGJlZm9yZSBmdXJ0aGVyIGNvbXBhcmlzb25cbiAgdGVzdFN0cmluZyA9IHRlc3RTdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgc3RyaW5nVG9SYW5rID0gc3RyaW5nVG9SYW5rLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gY2FzZSBpbnNlbnNpdGl2ZSBlcXVhbHNcbiAgaWYgKHRlc3RTdHJpbmcgPT09IHN0cmluZ1RvUmFuaykge1xuICAgIHJldHVybiByYW5raW5ncy5FUVVBTDtcbiAgfVxuXG4gIC8vIHN0YXJ0cyB3aXRoXG4gIGlmICh0ZXN0U3RyaW5nLnN0YXJ0c1dpdGgoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5TVEFSVFNfV0lUSDtcbiAgfVxuXG4gIC8vIHdvcmQgc3RhcnRzIHdpdGhcbiAgaWYgKHRlc3RTdHJpbmcuaW5jbHVkZXMoYCAke3N0cmluZ1RvUmFua31gKSkge1xuICAgIHJldHVybiByYW5raW5ncy5XT1JEX1NUQVJUU19XSVRIO1xuICB9XG5cbiAgLy8gY29udGFpbnNcbiAgaWYgKHRlc3RTdHJpbmcuaW5jbHVkZXMoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5DT05UQUlOUztcbiAgfSBlbHNlIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gSWYgdGhlIG9ubHkgY2hhcmFjdGVyIGluIHRoZSBnaXZlbiBzdHJpbmdUb1JhbmtcbiAgICAvLyAgIGlzbid0IGV2ZW4gY29udGFpbmVkIGluIHRoZSB0ZXN0U3RyaW5nLCB0aGVuXG4gICAgLy8gICBpdCdzIGRlZmluaXRlbHkgbm90IGEgbWF0Y2guXG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9XG5cbiAgLy8gYWNyb255bVxuICBpZiAoZ2V0QWNyb255bSh0ZXN0U3RyaW5nKS5pbmNsdWRlcyhzdHJpbmdUb1JhbmspKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkFDUk9OWU07XG4gIH1cblxuICAvLyB3aWxsIHJldHVybiBhIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXG4gIC8vIHJhbmtpbmdzLk1BVENIRVMgKyAxIGRlcGVuZGluZyAgb24gaG93IGNsb3NlIG9mIGEgbWF0Y2ggaXQgaXMuXG4gIHJldHVybiBnZXRDbG9zZW5lc3NSYW5raW5nKHRlc3RTdHJpbmcsIHN0cmluZ1RvUmFuayk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFjcm9ueW0gZm9yIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdGhlIHN0cmluZyBmb3Igd2hpY2ggdG8gcHJvZHVjZSB0aGUgYWNyb255bVxuICogQHJldHVybnMge1N0cmluZ30gdGhlIGFjcm9ueW1cbiAqL1xuZnVuY3Rpb24gZ2V0QWNyb255bShzdHJpbmcpIHtcbiAgbGV0IGFjcm9ueW0gPSAnJztcbiAgY29uc3Qgd29yZHNJblN0cmluZyA9IHN0cmluZy5zcGxpdCgnICcpO1xuICB3b3Jkc0luU3RyaW5nLmZvckVhY2god29yZEluU3RyaW5nID0+IHtcbiAgICBjb25zdCBzcGxpdEJ5SHlwaGVuV29yZHMgPSB3b3JkSW5TdHJpbmcuc3BsaXQoJy0nKTtcbiAgICBzcGxpdEJ5SHlwaGVuV29yZHMuZm9yRWFjaChzcGxpdEJ5SHlwaGVuV29yZCA9PiB7XG4gICAgICBhY3JvbnltICs9IHNwbGl0QnlIeXBoZW5Xb3JkLnN1YnN0cigwLCAxKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBhY3JvbnltO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzY29yZSBiYXNlZCBvbiBob3cgc3ByZWFkIGFwYXJ0IHRoZVxuICogY2hhcmFjdGVycyBmcm9tIHRoZSBzdHJpbmdUb1JhbmsgYXJlIHdpdGhpbiB0aGUgdGVzdFN0cmluZy5cbiAqIEEgbnVtYmVyIGNsb3NlIHRvIHJhbmtpbmdzLk1BVENIRVMgcmVwcmVzZW50cyBhIGxvb3NlIG1hdGNoLiBBIG51bWJlciBjbG9zZVxuICogdG8gcmFua2luZ3MuTUFUQ0hFUyArIDEgcmVwcmVzZW50cyBhIHRpZ2h0ZXIgbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVzdFN0cmluZyAtIHRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nVG9SYW5rIC0gdGhlIHN0cmluZyB0byByYW5rXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIGJldHdlZW4gcmFua2luZ3MuTUFUQ0hFUyBhbmRcbiAqIHJhbmtpbmdzLk1BVENIRVMgKyAxIGZvciBob3cgd2VsbCBzdHJpbmdUb1JhbmsgbWF0Y2hlcyB0ZXN0U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldENsb3NlbmVzc1JhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rKSB7XG4gIGxldCBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgPSAwO1xuICBsZXQgY2hhck51bWJlciA9IDA7XG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ0NoYXJhY3RlcihtYXRjaENoYXIsIHN0cmluZywgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBqID0gaW5kZXgsIEogPSBzdHJpbmcubGVuZ3RoOyBqIDwgSjsgaisrKSB7XG4gICAgICBjb25zdCBzdHJpbmdDaGFyID0gc3RyaW5nW2pdO1xuICAgICAgaWYgKHN0cmluZ0NoYXIgPT09IG1hdGNoQ2hhcikge1xuICAgICAgICBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGogKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmFua2luZyhzcHJlYWQpIHtcbiAgICBjb25zdCBzcHJlYWRQZXJjZW50YWdlID0gMSAvIHNwcmVhZDtcbiAgICBjb25zdCBpbk9yZGVyUGVyY2VudGFnZSA9IG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCAvIHN0cmluZ1RvUmFuay5sZW5ndGg7XG4gICAgY29uc3QgcmFua2luZyA9IHJhbmtpbmdzLk1BVENIRVMgKyBpbk9yZGVyUGVyY2VudGFnZSAqIHNwcmVhZFBlcmNlbnRhZ2U7XG4gICAgcmV0dXJuIHJhbmtpbmc7XG4gIH1cbiAgY29uc3QgZmlyc3RJbmRleCA9IGZpbmRNYXRjaGluZ0NoYXJhY3RlcihzdHJpbmdUb1JhbmtbMF0sIHRlc3RTdHJpbmcsIDApO1xuICBpZiAoZmlyc3RJbmRleCA8IDApIHtcbiAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XG4gIH1cbiAgY2hhck51bWJlciA9IGZpcnN0SW5kZXg7XG4gIGZvciAobGV0IGkgPSAxLCBJID0gc3RyaW5nVG9SYW5rLmxlbmd0aDsgaSA8IEk7IGkrKykge1xuICAgIGNvbnN0IG1hdGNoQ2hhciA9IHN0cmluZ1RvUmFua1tpXTtcbiAgICBjaGFyTnVtYmVyID0gZmluZE1hdGNoaW5nQ2hhcmFjdGVyKG1hdGNoQ2hhciwgdGVzdFN0cmluZywgY2hhck51bWJlcik7XG4gICAgY29uc3QgZm91bmQgPSBjaGFyTnVtYmVyID4gLTE7XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICAgIH1cbiAgfVxuICBjb25zdCBzcHJlYWQgPSBjaGFyTnVtYmVyIC0gZmlyc3RJbmRleDtcbiAgcmV0dXJuIGdldFJhbmtpbmcoc3ByZWFkKTtcbn1cblxuLyoqXG4gKiBTb3J0cyBpdGVtcyB0aGF0IGhhdmUgYSByYW5rLCBpbmRleCwgYW5kIGtleUluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gYSAtIHRoZSBmaXJzdCBpdGVtIHRvIHNvcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIC0gdGhlIHNlY29uZCBpdGVtIHRvIHNvcnRcbiAqIEByZXR1cm4ge051bWJlcn0gLTEgaWYgYSBzaG91bGQgY29tZSBmaXJzdCwgMSBpZiBiIHNob3VsZCBjb21lIGZpcnN0LCAwIGlmIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIHNvcnRSYW5rZWRWYWx1ZXMoYSwgYiwgYmFzZVNvcnQpIHtcbiAgY29uc3QgYUZpcnN0ID0gLTE7XG4gIGNvbnN0IGJGaXJzdCA9IDE7XG4gIGNvbnN0IHtcbiAgICByYW5rOiBhUmFuayxcbiAgICBrZXlJbmRleDogYUtleUluZGV4XG4gIH0gPSBhO1xuICBjb25zdCB7XG4gICAgcmFuazogYlJhbmssXG4gICAga2V5SW5kZXg6IGJLZXlJbmRleFxuICB9ID0gYjtcbiAgY29uc3Qgc2FtZSA9IGFSYW5rID09PSBiUmFuaztcbiAgaWYgKHNhbWUpIHtcbiAgICBpZiAoYUtleUluZGV4ID09PSBiS2V5SW5kZXgpIHtcbiAgICAgIC8vIHVzZSB0aGUgYmFzZSBzb3J0IGZ1bmN0aW9uIGFzIGEgdGllLWJyZWFrZXJcbiAgICAgIHJldHVybiBiYXNlU29ydChhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFLZXlJbmRleCA8IGJLZXlJbmRleCA/IGFGaXJzdCA6IGJGaXJzdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFSYW5rID4gYlJhbmsgPyBhRmlyc3QgOiBiRmlyc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB2YWx1ZSBmb3IgY29tcGFyaXNvbiBieSBzdHJpbmdpZnlpbmcgaXQsIHJlbW92aW5nIGRpYWNyaXRpY3MgKGlmIHNwZWNpZmllZClcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBjbGVhblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB7a2VlcERpYWNyaXRpY3M6IHdoZXRoZXIgdG8gcmVtb3ZlIGRpYWNyaXRpY3N9XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwcmVwYXJlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHZhbHVlLCBfcmVmNCkge1xuICBsZXQge1xuICAgIGtlZXBEaWFjcml0aWNzXG4gIH0gPSBfcmVmNDtcbiAgLy8gdmFsdWUgbWlnaHQgbm90IGFjdHVhbGx5IGJlIGEgc3RyaW5nIGF0IHRoaXMgcG9pbnQgKHdlIGRvbid0IGdldCB0byBjaG9vc2UpXG4gIC8vIHNvIHBhcnQgb2YgcHJlcGFyaW5nIHRoZSB2YWx1ZSBmb3IgY29tcGFyaXNvbiBpcyBlbnN1cmUgdGhhdCBpdCBpcyBhIHN0cmluZ1xuICB2YWx1ZSA9IGAke3ZhbHVlfWA7IC8vIHRvU3RyaW5nXG4gIGlmICgha2VlcERpYWNyaXRpY3MpIHtcbiAgICB2YWx1ZSA9IHJlbW92ZUFjY2VudHModmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHZhbHVlIGZvciBrZXkgaW4gaXRlbSBhdCBhcmJpdHJhcmlseSBuZXN0ZWQga2V5cGF0aFxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSB0aGUgaXRlbVxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGtleSAtIHRoZSBwb3RlbnRpYWxseSBuZXN0ZWQga2V5cGF0aCBvciBwcm9wZXJ0eSBjYWxsYmFja1xuICogQHJldHVybiB7QXJyYXl9IC0gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUocykgYXQgdGhlIG5lc3RlZCBrZXlwYXRoXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZW1WYWx1ZXMoaXRlbSwga2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgIGtleSA9IGtleS5rZXk7XG4gIH1cbiAgbGV0IHZhbHVlO1xuICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0ga2V5KGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgIHZhbHVlID0gbnVsbDtcbiAgfSBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChpdGVtLCBrZXkpKSB7XG4gICAgdmFsdWUgPSBpdGVtW2tleV07XG4gIH0gZWxzZSBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgcmV0dXJuIGdldE5lc3RlZFZhbHVlcyhrZXksIGl0ZW0pO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbnVsbDtcbiAgfVxuXG4gIC8vIGJlY2F1c2UgYHZhbHVlYCBjYW4gYWxzbyBiZSB1bmRlZmluZWRcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBbU3RyaW5nKHZhbHVlKV07XG59XG5cbi8qKlxuICogR2l2ZW4gcGF0aDogXCJmb28uYmFyLmJhelwiXG4gKiBBbmQgaXRlbToge2Zvbzoge2Jhcjoge2JhejogJ2J1enonfX19XG4gKiAgIC0+ICdidXp6J1xuICogQHBhcmFtIHBhdGggYSBkb3Qtc2VwYXJhdGVkIHNldCBvZiBrZXlzXG4gKiBAcGFyYW0gaXRlbSB0aGUgaXRlbSB0byBnZXQgdGhlIHZhbHVlIGZyb21cbiAqL1xuZnVuY3Rpb24gZ2V0TmVzdGVkVmFsdWVzKHBhdGgsIGl0ZW0pIHtcbiAgY29uc3Qga2V5cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IHZhbHVlcyA9IFtpdGVtXTtcbiAgZm9yIChsZXQgaSA9IDAsIEkgPSBrZXlzLmxlbmd0aDsgaSA8IEk7IGkrKykge1xuICAgIGNvbnN0IG5lc3RlZEtleSA9IGtleXNbaV07XG4gICAgbGV0IG5lc3RlZFZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwLCBKID0gdmFsdWVzLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgICAgY29uc3QgbmVzdGVkSXRlbSA9IHZhbHVlc1tqXTtcbiAgICAgIGlmIChuZXN0ZWRJdGVtID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5lc3RlZEl0ZW0sIG5lc3RlZEtleSkpIHtcbiAgICAgICAgY29uc3QgbmVzdGVkVmFsdWUgPSBuZXN0ZWRJdGVtW25lc3RlZEtleV07XG4gICAgICAgIGlmIChuZXN0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmVzdGVkVmFsdWVzLnB1c2gobmVzdGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5lc3RlZEtleSA9PT0gJyonKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHZhbHVlcyBpcyBhbiBhcnJheVxuICAgICAgICBuZXN0ZWRWYWx1ZXMgPSBuZXN0ZWRWYWx1ZXMuY29uY2F0KG5lc3RlZEl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMgPSBuZXN0ZWRWYWx1ZXM7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzWzBdKSkge1xuICAgIC8vIGtlZXAgYWxsb3dpbmcgdGhlIGltcGxpY2l0IHdpbGRjYXJkIGZvciBhbiBhcnJheSBvZiBzdHJpbmdzIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgcGF0aDsgZG9uJ3QgdXNlIGAuZmxhdCgpYCBiZWNhdXNlIHRoYXQncyBub3QgYXZhaWxhYmxlIGluIG5vZGUuanMgdjEwXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoLi4udmFsdWVzKTtcbiAgfVxuICAvLyBCYXNlZCBvbiBvdXIgbG9naWMgaXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgYnkgbm93Li4uXG4gIC8vIGFzc3VtaW5nIHRoZSB1c2VyJ3MgcGF0aCB0ZXJtaW5hdGVkIGluIHN0cmluZ3NcbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCB0aGUgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5cyBpbiB0aGUgZ2l2ZW4gaXRlbSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZSB2YWx1ZXNcbiAqIEBwYXJhbSBpdGVtIC0gdGhlIGl0ZW0gZnJvbSB3aGljaCB0aGUgdmFsdWVzIHdpbGwgYmUgcmV0cmlldmVkXG4gKiBAcGFyYW0ga2V5cyAtIHRoZSBrZXlzIHRvIHVzZSB0byByZXRyaWV2ZSB0aGUgdmFsdWVzXG4gKiBAcmV0dXJuIG9iamVjdHMgd2l0aCB7aXRlbVZhbHVlLCBhdHRyaWJ1dGVzfVxuICovXG5mdW5jdGlvbiBnZXRBbGxWYWx1ZXNUb1JhbmsoaXRlbSwga2V5cykge1xuICBjb25zdCBhbGxWYWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDAsIEogPSBrZXlzLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbal07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdldEtleUF0dHJpYnV0ZXMoa2V5KTtcbiAgICBjb25zdCBpdGVtVmFsdWVzID0gZ2V0SXRlbVZhbHVlcyhpdGVtLCBrZXkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBJID0gaXRlbVZhbHVlcy5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICAgIGFsbFZhbHVlcy5wdXNoKHtcbiAgICAgICAgaXRlbVZhbHVlOiBpdGVtVmFsdWVzW2ldLFxuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbFZhbHVlcztcbn1cbmNvbnN0IGRlZmF1bHRLZXlBdHRyaWJ1dGVzID0ge1xuICBtYXhSYW5raW5nOiBJbmZpbml0eSxcbiAgbWluUmFua2luZzogLUluZmluaXR5XG59O1xuLyoqXG4gKiBHZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIGtleVxuICogQHBhcmFtIGtleSAtIHRoZSBrZXkgZnJvbSB3aGljaCB0aGUgYXR0cmlidXRlcyB3aWxsIGJlIHJldHJpZXZlZFxuICogQHJldHVybiBvYmplY3QgY29udGFpbmluZyB0aGUga2V5J3MgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBnZXRLZXlBdHRyaWJ1dGVzKGtleSkge1xuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVmYXVsdEtleUF0dHJpYnV0ZXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0S2V5QXR0cmlidXRlcyxcbiAgICAuLi5rZXlcbiAgfTtcbn1cblxuLypcbmVzbGludFxuICBuby1jb250aW51ZTogXCJvZmZcIixcbiovXG5cbmV4cG9ydHMuZGVmYXVsdEJhc2VTb3J0Rm4gPSBkZWZhdWx0QmFzZVNvcnRGbjtcbmV4cG9ydHMubWF0Y2hTb3J0ZXIgPSBtYXRjaFNvcnRlcjtcbmV4cG9ydHMucmFua2luZ3MgPSByYW5raW5ncztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/match-sorter@8.0.0/node_modules/match-sorter/dist/match-sorter.cjs.js\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/match-sorter@8.0.0/node_modules/match-sorter/dist/match-sorter.cjs.js":
/*!************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/match-sorter@8.0.0/node_modules/match-sorter/dist/match-sorter.cjs.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar removeAccents = __webpack_require__(/*! remove-accents */ \"../../../../node_modules/.pnpm/remove-accents@0.5.0/node_modules/remove-accents/index.js\");\n\n/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2020 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */\nconst rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nconst defaultBaseSortFn = (a, b) => String(a.rankedValue).localeCompare(String(b.rankedValue));\n\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    keys,\n    threshold = rankings.MATCHES,\n    baseSort = defaultBaseSortFn,\n    sorter = matchedItems => matchedItems.sort((a, b) => sortRankedValues(a, b, baseSort))\n  } = options;\n  const matchedItems = items.reduce(reduceItemsToRanked, []);\n  return sorter(matchedItems).map(_ref => {\n    let {\n      item\n    } = _ref;\n    return item;\n  });\n  function reduceItemsToRanked(matches, item, index) {\n    const rankingInfo = getHighestRanking(item, keys, value, options);\n    const {\n      rank,\n      keyThreshold = threshold\n    } = rankingInfo;\n    if (rank >= keyThreshold) {\n      matches.push({\n        ...rankingInfo,\n        item,\n        index\n      });\n    }\n    return matches;\n  }\n}\nmatchSorter.rankings = rankings;\n\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    const stringItem = item;\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: stringItem,\n      rank: getMatchRanking(stringItem, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n  const valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce((_ref2, _ref3, i) => {\n    let {\n      rank,\n      rankedValue,\n      keyIndex,\n      keyThreshold\n    } = _ref2;\n    let {\n      itemValue,\n      attributes\n    } = _ref3;\n    let newRank = getMatchRanking(itemValue, value, options);\n    let newRankedValue = rankedValue;\n    const {\n      minRanking,\n      maxRanking,\n      threshold\n    } = attributes;\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedValue = itemValue;\n    }\n    return {\n      rankedValue: newRankedValue,\n      rank,\n      keyIndex,\n      keyThreshold\n    };\n  }, {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options);\n\n  // too long\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  }\n\n  // case sensitive equals\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n\n  // Lower casing before further comparison\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase();\n\n  // case insensitive equals\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  }\n\n  // starts with\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  }\n\n  // word starts with\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH;\n  }\n\n  // contains\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  }\n\n  // acronym\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  }\n\n  // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n  return getClosenessRanking(testString, stringToRank);\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\nfunction getAcronym(string) {\n  let acronym = '';\n  const wordsInString = string.split(' ');\n  wordsInString.forEach(wordInString => {\n    const splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(splitByHyphenWord => {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\nfunction getClosenessRanking(testString, stringToRank) {\n  let matchingInOrderCharCount = 0;\n  let charNumber = 0;\n  function findMatchingCharacter(matchChar, string, index) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j];\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n    return -1;\n  }\n  function getRanking(spread) {\n    const spreadPercentage = 1 / spread;\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n    return ranking;\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n  charNumber = firstIndex;\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    const found = charNumber > -1;\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n  const spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\nfunction sortRankedValues(a, b, baseSort) {\n  const aFirst = -1;\n  const bFirst = 1;\n  const {\n    rank: aRank,\n    keyIndex: aKeyIndex\n  } = a;\n  const {\n    rank: bRank,\n    keyIndex: bKeyIndex\n  } = b;\n  const same = aRank === bRank;\n  if (same) {\n    if (aKeyIndex === bKeyIndex) {\n      // use the base sort function as a tie-breaker\n      return baseSort(a, b);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\nfunction prepareValueForComparison(value, _ref4) {\n  let {\n    keepDiacritics\n  } = _ref4;\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = `${value}`; // toString\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n  return value;\n}\n\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n  let value;\n  if (typeof key === 'function') {\n    value = key(item);\n  } else if (item == null) {\n    value = null;\n  } else if (Object.hasOwnProperty.call(item, key)) {\n    value = item[key];\n  } else if (key.includes('.')) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    return getNestedValues(key, item);\n  } else {\n    value = null;\n  }\n\n  // because `value` can also be undefined\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [String(value)];\n}\n\n/**\n * Given path: \"foo.bar.baz\"\n * And item: {foo: {bar: {baz: 'buzz'}}}\n *   -> 'buzz'\n * @param path a dot-separated set of keys\n * @param item the item to get the value from\n */\nfunction getNestedValues(path, item) {\n  const keys = path.split('.');\n  let values = [item];\n  for (let i = 0, I = keys.length; i < I; i++) {\n    const nestedKey = keys[i];\n    let nestedValues = [];\n    for (let j = 0, J = values.length; j < J; j++) {\n      const nestedItem = values[j];\n      if (nestedItem == null) continue;\n      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {\n        const nestedValue = nestedItem[nestedKey];\n        if (nestedValue != null) {\n          nestedValues.push(nestedValue);\n        }\n      } else if (nestedKey === '*') {\n        // ensure that values is an array\n        nestedValues = nestedValues.concat(nestedItem);\n      }\n    }\n    values = nestedValues;\n  }\n  if (Array.isArray(values[0])) {\n    // keep allowing the implicit wildcard for an array of strings at the end of\n    // the path; don't use `.flat()` because that's not available in node.js v10\n    const result = [];\n    return result.concat(...values);\n  }\n  // Based on our logic it should be an array of strings by now...\n  // assuming the user's path terminated in strings\n  return values;\n}\n\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\nfunction getAllValuesToRank(item, keys) {\n  const allValues = [];\n  for (let j = 0, J = keys.length; j < J; j++) {\n    const key = keys[j];\n    const attributes = getKeyAttributes(key);\n    const itemValues = getItemValues(item, key);\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes\n      });\n    }\n  }\n  return allValues;\n}\nconst defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given key\n * @param key - the key from which the attributes will be retrieved\n * @return object containing the key's attributes\n */\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    return defaultKeyAttributes;\n  }\n  return {\n    ...defaultKeyAttributes,\n    ...key\n  };\n}\n\n/*\neslint\n  no-continue: \"off\",\n*/\n\nexports.defaultBaseSortFn = defaultBaseSortFn;\nexports.matchSorter = matchSorter;\nexports.rankings = rankings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21hdGNoLXNvcnRlckA4LjAuMC9ub2RlX21vZHVsZXMvbWF0Y2gtc29ydGVyL2Rpc3QvbWF0Y2gtc29ydGVyLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyxnSEFBZ0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSx1REFBdUQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9tYXRjaC1zb3J0ZXJAOC4wLjAvbm9kZV9tb2R1bGVzL21hdGNoLXNvcnRlci9kaXN0L21hdGNoLXNvcnRlci5janMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVtb3ZlQWNjZW50cyA9IHJlcXVpcmUoJ3JlbW92ZS1hY2NlbnRzJyk7XG5cbi8qKlxuICogQG5hbWUgbWF0Y2gtc29ydGVyXG4gKiBAbGljZW5zZSBNSVQgbGljZW5zZS5cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMjAgS2VudCBDLiBEb2Rkc1xuICogQGF1dGhvciBLZW50IEMuIERvZGRzIDxtZUBrZW50Y2RvZGRzLmNvbT4gKGh0dHBzOi8va2VudGNkb2Rkcy5jb20pXG4gKi9cbmNvbnN0IHJhbmtpbmdzID0ge1xuICBDQVNFX1NFTlNJVElWRV9FUVVBTDogNyxcbiAgRVFVQUw6IDYsXG4gIFNUQVJUU19XSVRIOiA1LFxuICBXT1JEX1NUQVJUU19XSVRIOiA0LFxuICBDT05UQUlOUzogMyxcbiAgQUNST05ZTTogMixcbiAgTUFUQ0hFUzogMSxcbiAgTk9fTUFUQ0g6IDBcbn07XG5jb25zdCBkZWZhdWx0QmFzZVNvcnRGbiA9IChhLCBiKSA9PiBTdHJpbmcoYS5yYW5rZWRWYWx1ZSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYi5yYW5rZWRWYWx1ZSkpO1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGl0ZW1zIGFuZCBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIHRoZSBpdGVtcyB0byBzb3J0XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gdXNlIGZvciByYW5raW5nXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFNvbWUgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHNvcnRlclxuICogQHJldHVybiB7QXJyYXl9IC0gdGhlIG5ldyBzb3J0ZWQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gbWF0Y2hTb3J0ZXIoaXRlbXMsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGtleXMsXG4gICAgdGhyZXNob2xkID0gcmFua2luZ3MuTUFUQ0hFUyxcbiAgICBiYXNlU29ydCA9IGRlZmF1bHRCYXNlU29ydEZuLFxuICAgIHNvcnRlciA9IG1hdGNoZWRJdGVtcyA9PiBtYXRjaGVkSXRlbXMuc29ydCgoYSwgYikgPT4gc29ydFJhbmtlZFZhbHVlcyhhLCBiLCBiYXNlU29ydCkpXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBtYXRjaGVkSXRlbXMgPSBpdGVtcy5yZWR1Y2UocmVkdWNlSXRlbXNUb1JhbmtlZCwgW10pO1xuICByZXR1cm4gc29ydGVyKG1hdGNoZWRJdGVtcykubWFwKF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICBpdGVtXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pO1xuICBmdW5jdGlvbiByZWR1Y2VJdGVtc1RvUmFua2VkKG1hdGNoZXMsIGl0ZW0sIGluZGV4KSB7XG4gICAgY29uc3QgcmFua2luZ0luZm8gPSBnZXRIaWdoZXN0UmFua2luZyhpdGVtLCBrZXlzLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgcmFuayxcbiAgICAgIGtleVRocmVzaG9sZCA9IHRocmVzaG9sZFxuICAgIH0gPSByYW5raW5nSW5mbztcbiAgICBpZiAocmFuayA+PSBrZXlUaHJlc2hvbGQpIHtcbiAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgIC4uLnJhbmtpbmdJbmZvLFxuICAgICAgICBpdGVtLFxuICAgICAgICBpbmRleFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG59XG5tYXRjaFNvcnRlci5yYW5raW5ncyA9IHJhbmtpbmdzO1xuXG4vKipcbiAqIEdldHMgdGhlIGhpZ2hlc3QgcmFua2luZyBmb3IgdmFsdWUgZm9yIHRoZSBnaXZlbiBpdGVtIGJhc2VkIG9uIGl0cyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBrZXlzXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byByYW5rXG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gdGhlIGtleXMgdG8gZ2V0IHZhbHVlcyBmcm9tIHRoZSBpdGVtIGZvciB0aGUgcmFua2luZ1xuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHJhbmsgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRvIGNvbnRyb2wgdGhlIHJhbmtpbmdcbiAqIEByZXR1cm4ge3tyYW5rOiBOdW1iZXIsIGtleUluZGV4OiBOdW1iZXIsIGtleVRocmVzaG9sZDogTnVtYmVyfX0gLSB0aGUgaGlnaGVzdCByYW5raW5nXG4gKi9cbmZ1bmN0aW9uIGdldEhpZ2hlc3RSYW5raW5nKGl0ZW0sIGtleXMsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICgha2V5cykge1xuICAgIC8vIGlmIGtleXMgaXMgbm90IHNwZWNpZmllZCwgdGhlbiB3ZSBhc3N1bWUgdGhlIGl0ZW0gZ2l2ZW4gaXMgcmVhZHkgdG8gYmUgbWF0Y2hlZFxuICAgIGNvbnN0IHN0cmluZ0l0ZW0gPSBpdGVtO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBlbmRzIHVwIGJlaW5nIGR1cGxpY2F0ZSBvZiAnaXRlbScgaW4gbWF0Y2hlcyBidXQgY29uc2lzdGVudFxuICAgICAgcmFua2VkVmFsdWU6IHN0cmluZ0l0ZW0sXG4gICAgICByYW5rOiBnZXRNYXRjaFJhbmtpbmcoc3RyaW5nSXRlbSwgdmFsdWUsIG9wdGlvbnMpLFxuICAgICAga2V5SW5kZXg6IC0xLFxuICAgICAga2V5VGhyZXNob2xkOiBvcHRpb25zLnRocmVzaG9sZFxuICAgIH07XG4gIH1cbiAgY29uc3QgdmFsdWVzVG9SYW5rID0gZ2V0QWxsVmFsdWVzVG9SYW5rKGl0ZW0sIGtleXMpO1xuICByZXR1cm4gdmFsdWVzVG9SYW5rLnJlZHVjZSgoX3JlZjIsIF9yZWYzLCBpKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHJhbmssXG4gICAgICByYW5rZWRWYWx1ZSxcbiAgICAgIGtleUluZGV4LFxuICAgICAga2V5VGhyZXNob2xkXG4gICAgfSA9IF9yZWYyO1xuICAgIGxldCB7XG4gICAgICBpdGVtVmFsdWUsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IF9yZWYzO1xuICAgIGxldCBuZXdSYW5rID0gZ2V0TWF0Y2hSYW5raW5nKGl0ZW1WYWx1ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIGxldCBuZXdSYW5rZWRWYWx1ZSA9IHJhbmtlZFZhbHVlO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pblJhbmtpbmcsXG4gICAgICBtYXhSYW5raW5nLFxuICAgICAgdGhyZXNob2xkXG4gICAgfSA9IGF0dHJpYnV0ZXM7XG4gICAgaWYgKG5ld1JhbmsgPCBtaW5SYW5raW5nICYmIG5ld1JhbmsgPj0gcmFua2luZ3MuTUFUQ0hFUykge1xuICAgICAgbmV3UmFuayA9IG1pblJhbmtpbmc7XG4gICAgfSBlbHNlIGlmIChuZXdSYW5rID4gbWF4UmFua2luZykge1xuICAgICAgbmV3UmFuayA9IG1heFJhbmtpbmc7XG4gICAgfVxuICAgIGlmIChuZXdSYW5rID4gcmFuaykge1xuICAgICAgcmFuayA9IG5ld1Jhbms7XG4gICAgICBrZXlJbmRleCA9IGk7XG4gICAgICBrZXlUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICBuZXdSYW5rZWRWYWx1ZSA9IGl0ZW1WYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmtlZFZhbHVlOiBuZXdSYW5rZWRWYWx1ZSxcbiAgICAgIHJhbmssXG4gICAgICBrZXlJbmRleCxcbiAgICAgIGtleVRocmVzaG9sZFxuICAgIH07XG4gIH0sIHtcbiAgICByYW5rZWRWYWx1ZTogaXRlbSxcbiAgICByYW5rOiByYW5raW5ncy5OT19NQVRDSCxcbiAgICBrZXlJbmRleDogLTEsXG4gICAga2V5VGhyZXNob2xkOiBvcHRpb25zLnRocmVzaG9sZFxuICB9KTtcbn1cblxuLyoqXG4gKiBHaXZlcyBhIHJhbmtpbmdzIHNjb3JlIGJhc2VkIG9uIGhvdyB3ZWxsIHRoZSB0d28gc3RyaW5ncyBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXN0U3RyaW5nIC0gdGhlIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdUb1JhbmsgLSB0aGUgc3RyaW5nIHRvIHJhbmtcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIG1hdGNoIChsaWtlIGtlZXBEaWFjcml0aWNzIGZvciBjb21wYXJpc29uKVxuICogQHJldHVybnMge051bWJlcn0gdGhlIHJhbmtpbmcgZm9yIGhvdyB3ZWxsIHN0cmluZ1RvUmFuayBtYXRjaGVzIHRlc3RTdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hSYW5raW5nKHRlc3RTdHJpbmcsIHN0cmluZ1RvUmFuaywgb3B0aW9ucykge1xuICB0ZXN0U3RyaW5nID0gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbih0ZXN0U3RyaW5nLCBvcHRpb25zKTtcbiAgc3RyaW5nVG9SYW5rID0gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbihzdHJpbmdUb1JhbmssIG9wdGlvbnMpO1xuXG4gIC8vIHRvbyBsb25nXG4gIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID4gdGVzdFN0cmluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XG4gIH1cblxuICAvLyBjYXNlIHNlbnNpdGl2ZSBlcXVhbHNcbiAgaWYgKHRlc3RTdHJpbmcgPT09IHN0cmluZ1RvUmFuaykge1xuICAgIHJldHVybiByYW5raW5ncy5DQVNFX1NFTlNJVElWRV9FUVVBTDtcbiAgfVxuXG4gIC8vIExvd2VyIGNhc2luZyBiZWZvcmUgZnVydGhlciBjb21wYXJpc29uXG4gIHRlc3RTdHJpbmcgPSB0ZXN0U3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHN0cmluZ1RvUmFuayA9IHN0cmluZ1RvUmFuay50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIGNhc2UgaW5zZW5zaXRpdmUgZXF1YWxzXG4gIGlmICh0ZXN0U3RyaW5nID09PSBzdHJpbmdUb1JhbmspIHtcbiAgICByZXR1cm4gcmFua2luZ3MuRVFVQUw7XG4gIH1cblxuICAvLyBzdGFydHMgd2l0aFxuICBpZiAodGVzdFN0cmluZy5zdGFydHNXaXRoKHN0cmluZ1RvUmFuaykpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuU1RBUlRTX1dJVEg7XG4gIH1cblxuICAvLyB3b3JkIHN0YXJ0cyB3aXRoXG4gIGlmICh0ZXN0U3RyaW5nLmluY2x1ZGVzKGAgJHtzdHJpbmdUb1Jhbmt9YCkpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuV09SRF9TVEFSVFNfV0lUSDtcbiAgfVxuXG4gIC8vIGNvbnRhaW5zXG4gIGlmICh0ZXN0U3RyaW5nLmluY2x1ZGVzKHN0cmluZ1RvUmFuaykpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuQ09OVEFJTlM7XG4gIH0gZWxzZSBpZiAoc3RyaW5nVG9SYW5rLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIElmIHRoZSBvbmx5IGNoYXJhY3RlciBpbiB0aGUgZ2l2ZW4gc3RyaW5nVG9SYW5rXG4gICAgLy8gICBpc24ndCBldmVuIGNvbnRhaW5lZCBpbiB0aGUgdGVzdFN0cmluZywgdGhlblxuICAgIC8vICAgaXQncyBkZWZpbml0ZWx5IG5vdCBhIG1hdGNoLlxuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgfVxuXG4gIC8vIGFjcm9ueW1cbiAgaWYgKGdldEFjcm9ueW0odGVzdFN0cmluZykuaW5jbHVkZXMoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5BQ1JPTllNO1xuICB9XG5cbiAgLy8gd2lsbCByZXR1cm4gYSBudW1iZXIgYmV0d2VlbiByYW5raW5ncy5NQVRDSEVTIGFuZFxuICAvLyByYW5raW5ncy5NQVRDSEVTICsgMSBkZXBlbmRpbmcgIG9uIGhvdyBjbG9zZSBvZiBhIG1hdGNoIGl0IGlzLlxuICByZXR1cm4gZ2V0Q2xvc2VuZXNzUmFua2luZyh0ZXN0U3RyaW5nLCBzdHJpbmdUb1JhbmspO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhY3JvbnltIGZvciBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgZm9yIHdoaWNoIHRvIHByb2R1Y2UgdGhlIGFjcm9ueW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBhY3JvbnltXG4gKi9cbmZ1bmN0aW9uIGdldEFjcm9ueW0oc3RyaW5nKSB7XG4gIGxldCBhY3JvbnltID0gJyc7XG4gIGNvbnN0IHdvcmRzSW5TdHJpbmcgPSBzdHJpbmcuc3BsaXQoJyAnKTtcbiAgd29yZHNJblN0cmluZy5mb3JFYWNoKHdvcmRJblN0cmluZyA9PiB7XG4gICAgY29uc3Qgc3BsaXRCeUh5cGhlbldvcmRzID0gd29yZEluU3RyaW5nLnNwbGl0KCctJyk7XG4gICAgc3BsaXRCeUh5cGhlbldvcmRzLmZvckVhY2goc3BsaXRCeUh5cGhlbldvcmQgPT4ge1xuICAgICAgYWNyb255bSArPSBzcGxpdEJ5SHlwaGVuV29yZC5zdWJzdHIoMCwgMSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYWNyb255bTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2NvcmUgYmFzZWQgb24gaG93IHNwcmVhZCBhcGFydCB0aGVcbiAqIGNoYXJhY3RlcnMgZnJvbSB0aGUgc3RyaW5nVG9SYW5rIGFyZSB3aXRoaW4gdGhlIHRlc3RTdHJpbmcuXG4gKiBBIG51bWJlciBjbG9zZSB0byByYW5raW5ncy5NQVRDSEVTIHJlcHJlc2VudHMgYSBsb29zZSBtYXRjaC4gQSBudW1iZXIgY2xvc2VcbiAqIHRvIHJhbmtpbmdzLk1BVENIRVMgKyAxIHJlcHJlc2VudHMgYSB0aWdodGVyIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd9IHRlc3RTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmFuayAtIHRoZSBzdHJpbmcgdG8gcmFua1xuICogQHJldHVybnMge051bWJlcn0gdGhlIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXG4gKiByYW5raW5ncy5NQVRDSEVTICsgMSBmb3IgaG93IHdlbGwgc3RyaW5nVG9SYW5rIG1hdGNoZXMgdGVzdFN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRDbG9zZW5lc3NSYW5raW5nKHRlc3RTdHJpbmcsIHN0cmluZ1RvUmFuaykge1xuICBsZXQgbWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50ID0gMDtcbiAgbGV0IGNoYXJOdW1iZXIgPSAwO1xuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIobWF0Y2hDaGFyLCBzdHJpbmcsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaiA9IGluZGV4LCBKID0gc3RyaW5nLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgICAgY29uc3Qgc3RyaW5nQ2hhciA9IHN0cmluZ1tqXTtcbiAgICAgIGlmIChzdHJpbmdDaGFyID09PSBtYXRjaENoYXIpIHtcbiAgICAgICAgbWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBqICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJhbmtpbmcoc3ByZWFkKSB7XG4gICAgY29uc3Qgc3ByZWFkUGVyY2VudGFnZSA9IDEgLyBzcHJlYWQ7XG4gICAgY29uc3QgaW5PcmRlclBlcmNlbnRhZ2UgPSBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgLyBzdHJpbmdUb1JhbmsubGVuZ3RoO1xuICAgIGNvbnN0IHJhbmtpbmcgPSByYW5raW5ncy5NQVRDSEVTICsgaW5PcmRlclBlcmNlbnRhZ2UgKiBzcHJlYWRQZXJjZW50YWdlO1xuICAgIHJldHVybiByYW5raW5nO1xuICB9XG4gIGNvbnN0IGZpcnN0SW5kZXggPSBmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIoc3RyaW5nVG9SYW5rWzBdLCB0ZXN0U3RyaW5nLCAwKTtcbiAgaWYgKGZpcnN0SW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9XG4gIGNoYXJOdW1iZXIgPSBmaXJzdEluZGV4O1xuICBmb3IgKGxldCBpID0gMSwgSSA9IHN0cmluZ1RvUmFuay5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICBjb25zdCBtYXRjaENoYXIgPSBzdHJpbmdUb1JhbmtbaV07XG4gICAgY2hhck51bWJlciA9IGZpbmRNYXRjaGluZ0NoYXJhY3RlcihtYXRjaENoYXIsIHRlc3RTdHJpbmcsIGNoYXJOdW1iZXIpO1xuICAgIGNvbnN0IGZvdW5kID0gY2hhck51bWJlciA+IC0xO1xuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3ByZWFkID0gY2hhck51bWJlciAtIGZpcnN0SW5kZXg7XG4gIHJldHVybiBnZXRSYW5raW5nKHNwcmVhZCk7XG59XG5cbi8qKlxuICogU29ydHMgaXRlbXMgdGhhdCBoYXZlIGEgcmFuaywgaW5kZXgsIGFuZCBrZXlJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IGEgLSB0aGUgZmlyc3QgaXRlbSB0byBzb3J0XG4gKiBAcGFyYW0ge09iamVjdH0gYiAtIHRoZSBzZWNvbmQgaXRlbSB0byBzb3J0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0xIGlmIGEgc2hvdWxkIGNvbWUgZmlyc3QsIDEgaWYgYiBzaG91bGQgY29tZSBmaXJzdCwgMCBpZiBlcXVhbFxuICovXG5mdW5jdGlvbiBzb3J0UmFua2VkVmFsdWVzKGEsIGIsIGJhc2VTb3J0KSB7XG4gIGNvbnN0IGFGaXJzdCA9IC0xO1xuICBjb25zdCBiRmlyc3QgPSAxO1xuICBjb25zdCB7XG4gICAgcmFuazogYVJhbmssXG4gICAga2V5SW5kZXg6IGFLZXlJbmRleFxuICB9ID0gYTtcbiAgY29uc3Qge1xuICAgIHJhbms6IGJSYW5rLFxuICAgIGtleUluZGV4OiBiS2V5SW5kZXhcbiAgfSA9IGI7XG4gIGNvbnN0IHNhbWUgPSBhUmFuayA9PT0gYlJhbms7XG4gIGlmIChzYW1lKSB7XG4gICAgaWYgKGFLZXlJbmRleCA9PT0gYktleUluZGV4KSB7XG4gICAgICAvLyB1c2UgdGhlIGJhc2Ugc29ydCBmdW5jdGlvbiBhcyBhIHRpZS1icmVha2VyXG4gICAgICByZXR1cm4gYmFzZVNvcnQoYSwgYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhS2V5SW5kZXggPCBiS2V5SW5kZXggPyBhRmlyc3QgOiBiRmlyc3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBhUmFuayA+IGJSYW5rID8gYUZpcnN0IDogYkZpcnN0O1xuICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdmFsdWUgZm9yIGNvbXBhcmlzb24gYnkgc3RyaW5naWZ5aW5nIGl0LCByZW1vdmluZyBkaWFjcml0aWNzIChpZiBzcGVjaWZpZWQpXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gY2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0ge2tlZXBEaWFjcml0aWNzOiB3aGV0aGVyIHRvIHJlbW92ZSBkaWFjcml0aWNzfVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcHJlcGFyZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbih2YWx1ZSwgX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBrZWVwRGlhY3JpdGljc1xuICB9ID0gX3JlZjQ7XG4gIC8vIHZhbHVlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSBhIHN0cmluZyBhdCB0aGlzIHBvaW50ICh3ZSBkb24ndCBnZXQgdG8gY2hvb3NlKVxuICAvLyBzbyBwYXJ0IG9mIHByZXBhcmluZyB0aGUgdmFsdWUgZm9yIGNvbXBhcmlzb24gaXMgZW5zdXJlIHRoYXQgaXQgaXMgYSBzdHJpbmdcbiAgdmFsdWUgPSBgJHt2YWx1ZX1gOyAvLyB0b1N0cmluZ1xuICBpZiAoIWtlZXBEaWFjcml0aWNzKSB7XG4gICAgdmFsdWUgPSByZW1vdmVBY2NlbnRzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyB2YWx1ZSBmb3Iga2V5IGluIGl0ZW0gYXQgYXJiaXRyYXJpbHkgbmVzdGVkIGtleXBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gdGhlIGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBrZXkgLSB0aGUgcG90ZW50aWFsbHkgbmVzdGVkIGtleXBhdGggb3IgcHJvcGVydHkgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fSAtIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlKHMpIGF0IHRoZSBuZXN0ZWQga2V5cGF0aFxuICovXG5mdW5jdGlvbiBnZXRJdGVtVmFsdWVzKGl0ZW0sIGtleSkge1xuICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICBrZXkgPSBrZXkua2V5O1xuICB9XG4gIGxldCB2YWx1ZTtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IGtleShpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtID09IG51bGwpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaXRlbSwga2V5KSkge1xuICAgIHZhbHVlID0gaXRlbVtrZXldO1xuICB9IGVsc2UgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIHJldHVybiBnZXROZXN0ZWRWYWx1ZXMoa2V5LCBpdGVtKTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cblxuICAvLyBiZWNhdXNlIGB2YWx1ZWAgY2FuIGFsc28gYmUgdW5kZWZpbmVkXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gW1N0cmluZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIEdpdmVuIHBhdGg6IFwiZm9vLmJhci5iYXpcIlxuICogQW5kIGl0ZW06IHtmb286IHtiYXI6IHtiYXo6ICdidXp6J319fVxuICogICAtPiAnYnV6eidcbiAqIEBwYXJhbSBwYXRoIGEgZG90LXNlcGFyYXRlZCBzZXQgb2Yga2V5c1xuICogQHBhcmFtIGl0ZW0gdGhlIGl0ZW0gdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKi9cbmZ1bmN0aW9uIGdldE5lc3RlZFZhbHVlcyhwYXRoLCBpdGVtKSB7XG4gIGNvbnN0IGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCB2YWx1ZXMgPSBbaXRlbV07XG4gIGZvciAobGV0IGkgPSAwLCBJID0ga2V5cy5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICBjb25zdCBuZXN0ZWRLZXkgPSBrZXlzW2ldO1xuICAgIGxldCBuZXN0ZWRWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMCwgSiA9IHZhbHVlcy5sZW5ndGg7IGogPCBKOyBqKyspIHtcbiAgICAgIGNvbnN0IG5lc3RlZEl0ZW0gPSB2YWx1ZXNbal07XG4gICAgICBpZiAobmVzdGVkSXRlbSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuZXN0ZWRJdGVtLCBuZXN0ZWRLZXkpKSB7XG4gICAgICAgIGNvbnN0IG5lc3RlZFZhbHVlID0gbmVzdGVkSXRlbVtuZXN0ZWRLZXldO1xuICAgICAgICBpZiAobmVzdGVkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5lc3RlZFZhbHVlcy5wdXNoKG5lc3RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXN0ZWRLZXkgPT09ICcqJykge1xuICAgICAgICAvLyBlbnN1cmUgdGhhdCB2YWx1ZXMgaXMgYW4gYXJyYXlcbiAgICAgICAgbmVzdGVkVmFsdWVzID0gbmVzdGVkVmFsdWVzLmNvbmNhdChuZXN0ZWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzID0gbmVzdGVkVmFsdWVzO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICAvLyBrZWVwIGFsbG93aW5nIHRoZSBpbXBsaWNpdCB3aWxkY2FyZCBmb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHBhdGg7IGRvbid0IHVzZSBgLmZsYXQoKWAgYmVjYXVzZSB0aGF0J3Mgbm90IGF2YWlsYWJsZSBpbiBub2RlLmpzIHYxMFxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KC4uLnZhbHVlcyk7XG4gIH1cbiAgLy8gQmFzZWQgb24gb3VyIGxvZ2ljIGl0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGJ5IG5vdy4uLlxuICAvLyBhc3N1bWluZyB0aGUgdXNlcidzIHBhdGggdGVybWluYXRlZCBpbiBzdHJpbmdzXG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgdGhlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXMgaW4gdGhlIGdpdmVuIGl0ZW0gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UgdmFsdWVzXG4gKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIGZyb20gd2hpY2ggdGhlIHZhbHVlcyB3aWxsIGJlIHJldHJpZXZlZFxuICogQHBhcmFtIGtleXMgLSB0aGUga2V5cyB0byB1c2UgdG8gcmV0cmlldmUgdGhlIHZhbHVlc1xuICogQHJldHVybiBvYmplY3RzIHdpdGgge2l0ZW1WYWx1ZSwgYXR0cmlidXRlc31cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsVmFsdWVzVG9SYW5rKGl0ZW0sIGtleXMpIHtcbiAgY29uc3QgYWxsVmFsdWVzID0gW107XG4gIGZvciAobGV0IGogPSAwLCBKID0ga2V5cy5sZW5ndGg7IGogPCBKOyBqKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRLZXlBdHRyaWJ1dGVzKGtleSk7XG4gICAgY29uc3QgaXRlbVZhbHVlcyA9IGdldEl0ZW1WYWx1ZXMoaXRlbSwga2V5KTtcbiAgICBmb3IgKGxldCBpID0gMCwgSSA9IGl0ZW1WYWx1ZXMubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XG4gICAgICBhbGxWYWx1ZXMucHVzaCh7XG4gICAgICAgIGl0ZW1WYWx1ZTogaXRlbVZhbHVlc1tpXSxcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxWYWx1ZXM7XG59XG5jb25zdCBkZWZhdWx0S2V5QXR0cmlidXRlcyA9IHtcbiAgbWF4UmFua2luZzogSW5maW5pdHksXG4gIG1pblJhbmtpbmc6IC1JbmZpbml0eVxufTtcbi8qKlxuICogR2V0cyBhbGwgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBnaXZlbiBrZXlcbiAqIEBwYXJhbSBrZXkgLSB0aGUga2V5IGZyb20gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSByZXRyaWV2ZWRcbiAqIEByZXR1cm4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSdzIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5QXR0cmlidXRlcyhrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRLZXlBdHRyaWJ1dGVzO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGVmYXVsdEtleUF0dHJpYnV0ZXMsXG4gICAgLi4ua2V5XG4gIH07XG59XG5cbi8qXG5lc2xpbnRcbiAgbm8tY29udGludWU6IFwib2ZmXCIsXG4qL1xuXG5leHBvcnRzLmRlZmF1bHRCYXNlU29ydEZuID0gZGVmYXVsdEJhc2VTb3J0Rm47XG5leHBvcnRzLm1hdGNoU29ydGVyID0gbWF0Y2hTb3J0ZXI7XG5leHBvcnRzLnJhbmtpbmdzID0gcmFua2luZ3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/match-sorter@8.0.0/node_modules/match-sorter/dist/match-sorter.cjs.js\n");

/***/ })

};
;