"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-history@0.113.1_slate@0.112.0";
exports.ids = ["vendor-chunks/slate-history@0.113.1_slate@0.112.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/slate-history@0.113.1_slate@0.112.0/node_modules/slate-history/dist/index.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/slate-history@0.113.1_slate@0.112.0/node_modules/slate-history/dist/index.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(pages-dir-node)/../../../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js\");\nvar slate = __webpack_require__(/*! slate */ \"(pages-dir-node)/../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js\");\n\n// eslint-disable-next-line no-redeclare\nvar History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n  isHistory: function isHistory(value) {\n    return isPlainObject.isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || slate.Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || slate.Operation.isOperationList(value.undos[0].operations));\n  }\n};\n\n/**\n * Weakmaps for attaching state to the editor.\n */\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar SPLITTING_ONCE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n  isHistoryEditor: function isHistoryEditor(value) {\n    return History.isHistory(value.history) && slate.Editor.isEditor(value);\n  },\n  /**\n   * Get the merge flag's current value.\n   */\n  isMerging: function isMerging(editor) {\n    return MERGING.get(editor);\n  },\n  /**\n   * Get the splitting once flag's current value.\n   */\n  isSplittingOnce: function isSplittingOnce(editor) {\n    return SPLITTING_ONCE.get(editor);\n  },\n  setSplittingOnce: function setSplittingOnce(editor, value) {\n    SPLITTING_ONCE.set(editor, value);\n  },\n  /**\n   * Get the saving flag's current value.\n   */\n  isSaving: function isSaving(editor) {\n    return SAVING.get(editor);\n  },\n  /**\n   * Redo to the previous saved state.\n   */\n  redo: function redo(editor) {\n    editor.redo();\n  },\n  /**\n   * Undo to the previous saved state.\n   */\n  undo: function undo(editor) {\n    editor.undo();\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging: function withMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the first\n   * operation starts a new batch in the history. Subsequent operations will be\n   * merged as usual.\n   */\n  withNewBatch: function withNewBatch(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    SPLITTING_ONCE.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n    SPLITTING_ONCE[\"delete\"](editor);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n  withoutMerging: function withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n  withoutSaving: function withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    try {\n      fn();\n    } finally {\n      SAVING.set(editor, prev);\n    }\n  }\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withHistory = function withHistory(editor) {\n  var e = editor;\n  var apply = e.apply;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n  e.redo = function () {\n    var history = e.history;\n    var redos = history.redos;\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      if (batch.selectionBefore) {\n        slate.Transforms.setSelection(e, batch.selectionBefore);\n      }\n      HistoryEditor.withoutSaving(e, function () {\n        slate.Editor.withoutNormalizing(e, function () {\n          var _iterator = _createForOfIteratorHelper(batch.operations),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var op = _step.value;\n              e.apply(op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      });\n      history.redos.pop();\n      e.writeHistory('undos', batch);\n    }\n  };\n  e.undo = function () {\n    var history = e.history;\n    var undos = history.undos;\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, function () {\n        slate.Editor.withoutNormalizing(e, function () {\n          var inverseOps = batch.operations.map(slate.Operation.inverse).reverse();\n          var _iterator2 = _createForOfIteratorHelper(inverseOps),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var op = _step2.value;\n              e.apply(op);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          if (batch.selectionBefore) {\n            slate.Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n      e.writeHistory('redos', batch);\n      history.undos.pop();\n    }\n  };\n  e.apply = function (op) {\n    var operations = e.operations,\n      history = e.history;\n    var undos = history.undos;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n    if (save == null) {\n      save = shouldSave(op);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (HistoryEditor.isSplittingOnce(e)) {\n        merge = false;\n        HistoryEditor.setSplittingOnce(e, undefined);\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        var batch = {\n          operations: [op],\n          selectionBefore: e.selection\n        };\n        e.writeHistory('undos', batch);\n      }\n      while (undos.length > 100) {\n        undos.shift();\n      }\n      history.redos = [];\n    }\n    apply(op);\n  };\n  e.writeHistory = function (stack, batch) {\n    e.history[stack].push(batch);\n  };\n  return e;\n};\n/**\n * Check whether to merge an operation into the previous operation.\n */\nvar shouldMerge = function shouldMerge(op, prev) {\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && slate.Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && slate.Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  return false;\n};\n/**\n * Check whether an operation needs to be saved to the history.\n */\nvar shouldSave = function shouldSave(op, prev) {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n  return true;\n};\n\nexports.HISTORY = HISTORY;\nexports.History = History;\nexports.HistoryEditor = HistoryEditor;\nexports.MERGING = MERGING;\nexports.SAVING = SAVING;\nexports.SPLITTING_ONCE = SPLITTING_ONCE;\nexports.withHistory = withHistory;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGUtaGlzdG9yeUAwLjExMy4xX3NsYXRlQDAuMTEyLjAvbm9kZV9tb2R1bGVzL3NsYXRlLWhpc3RvcnkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyxtSkFBaUI7QUFDN0MsWUFBWSxtQkFBTyxDQUFDLDZHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7QUFDNzhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEO0FBQzdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsdUJBQXVCO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZixjQUFjO0FBQ2Qsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL2phaW1laXNyYWVsY2FtcGVhcy9rZXlzdG9uZS9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGUtaGlzdG9yeUAwLjExMy4xX3NsYXRlQDAuMTEyLjAvbm9kZV9tb2R1bGVzL3NsYXRlLWhpc3RvcnkvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG52YXIgc2xhdGUgPSByZXF1aXJlKCdzbGF0ZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgSGlzdG9yeSA9IHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgSGlzdG9yeWAgb2JqZWN0LlxuICAgKi9cbiAgaXNIaXN0b3J5OiBmdW5jdGlvbiBpc0hpc3RvcnkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlLnJlZG9zKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlLnVuZG9zKSAmJiAodmFsdWUucmVkb3MubGVuZ3RoID09PSAwIHx8IHNsYXRlLk9wZXJhdGlvbi5pc09wZXJhdGlvbkxpc3QodmFsdWUucmVkb3NbMF0ub3BlcmF0aW9ucykpICYmICh2YWx1ZS51bmRvcy5sZW5ndGggPT09IDAgfHwgc2xhdGUuT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS51bmRvc1swXS5vcGVyYXRpb25zKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2Vha21hcHMgZm9yIGF0dGFjaGluZyBzdGF0ZSB0byB0aGUgZWRpdG9yLlxuICovXG52YXIgSElTVE9SWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgU0FWSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBNRVJHSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBTUExJVFRJTkdfT05DRSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgSGlzdG9yeUVkaXRvciA9IHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgSGlzdG9yeUVkaXRvcmAgb2JqZWN0LlxuICAgKi9cbiAgaXNIaXN0b3J5RWRpdG9yOiBmdW5jdGlvbiBpc0hpc3RvcnlFZGl0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gSGlzdG9yeS5pc0hpc3RvcnkodmFsdWUuaGlzdG9yeSkgJiYgc2xhdGUuRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCB0aGUgbWVyZ2UgZmxhZydzIGN1cnJlbnQgdmFsdWUuXG4gICAqL1xuICBpc01lcmdpbmc6IGZ1bmN0aW9uIGlzTWVyZ2luZyhlZGl0b3IpIHtcbiAgICByZXR1cm4gTUVSR0lORy5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCB0aGUgc3BsaXR0aW5nIG9uY2UgZmxhZydzIGN1cnJlbnQgdmFsdWUuXG4gICAqL1xuICBpc1NwbGl0dGluZ09uY2U6IGZ1bmN0aW9uIGlzU3BsaXR0aW5nT25jZShlZGl0b3IpIHtcbiAgICByZXR1cm4gU1BMSVRUSU5HX09OQ0UuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIHNldFNwbGl0dGluZ09uY2U6IGZ1bmN0aW9uIHNldFNwbGl0dGluZ09uY2UoZWRpdG9yLCB2YWx1ZSkge1xuICAgIFNQTElUVElOR19PTkNFLnNldChlZGl0b3IsIHZhbHVlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCB0aGUgc2F2aW5nIGZsYWcncyBjdXJyZW50IHZhbHVlLlxuICAgKi9cbiAgaXNTYXZpbmc6IGZ1bmN0aW9uIGlzU2F2aW5nKGVkaXRvcikge1xuICAgIHJldHVybiBTQVZJTkcuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIC8qKlxuICAgKiBSZWRvIHRvIHRoZSBwcmV2aW91cyBzYXZlZCBzdGF0ZS5cbiAgICovXG4gIHJlZG86IGZ1bmN0aW9uIHJlZG8oZWRpdG9yKSB7XG4gICAgZWRpdG9yLnJlZG8oKTtcbiAgfSxcbiAgLyoqXG4gICAqIFVuZG8gdG8gdGhlIHByZXZpb3VzIHNhdmVkIHN0YXRlLlxuICAgKi9cbiAgdW5kbzogZnVuY3Rpb24gdW5kbyhlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5kbygpO1xuICB9LFxuICAvKipcbiAgICogQXBwbHkgYSBzZXJpZXMgb2YgY2hhbmdlcyBpbnNpZGUgYSBzeW5jaHJvbm91cyBgZm5gLCBUaGVzZSBvcGVyYXRpb25zIHdpbGxcbiAgICogYmUgbWVyZ2VkIGludG8gdGhlIHByZXZpb3VzIGhpc3RvcnkuXG4gICAqL1xuICB3aXRoTWVyZ2luZzogZnVuY3Rpb24gd2l0aE1lcmdpbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciBwcmV2ID0gSGlzdG9yeUVkaXRvci5pc01lcmdpbmcoZWRpdG9yKTtcbiAgICBNRVJHSU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgIGZuKCk7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCBwcmV2KTtcbiAgfSxcbiAgLyoqXG4gICAqIEFwcGx5IGEgc2VyaWVzIG9mIGNoYW5nZXMgaW5zaWRlIGEgc3luY2hyb25vdXMgYGZuYCwgZW5zdXJpbmcgdGhhdCB0aGUgZmlyc3RcbiAgICogb3BlcmF0aW9uIHN0YXJ0cyBhIG5ldyBiYXRjaCBpbiB0aGUgaGlzdG9yeS4gU3Vic2VxdWVudCBvcGVyYXRpb25zIHdpbGwgYmVcbiAgICogbWVyZ2VkIGFzIHVzdWFsLlxuICAgKi9cbiAgd2l0aE5ld0JhdGNoOiBmdW5jdGlvbiB3aXRoTmV3QmF0Y2goZWRpdG9yLCBmbikge1xuICAgIHZhciBwcmV2ID0gSGlzdG9yeUVkaXRvci5pc01lcmdpbmcoZWRpdG9yKTtcbiAgICBNRVJHSU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgIFNQTElUVElOR19PTkNFLnNldChlZGl0b3IsIHRydWUpO1xuICAgIGZuKCk7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCBwcmV2KTtcbiAgICBTUExJVFRJTkdfT05DRVtcImRlbGV0ZVwiXShlZGl0b3IpO1xuICB9LFxuICAvKipcbiAgICogQXBwbHkgYSBzZXJpZXMgb2YgY2hhbmdlcyBpbnNpZGUgYSBzeW5jaHJvbm91cyBgZm5gLCB3aXRob3V0IG1lcmdpbmcgYW55IG9mXG4gICAqIHRoZSBuZXcgb3BlcmF0aW9ucyBpbnRvIHByZXZpb3VzIHNhdmUgcG9pbnQgaW4gdGhlIGhpc3RvcnkuXG4gICAqL1xuICB3aXRob3V0TWVyZ2luZzogZnVuY3Rpb24gd2l0aG91dE1lcmdpbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciBwcmV2ID0gSGlzdG9yeUVkaXRvci5pc01lcmdpbmcoZWRpdG9yKTtcbiAgICBNRVJHSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICBmbigpO1xuICAgIE1FUkdJTkcuc2V0KGVkaXRvciwgcHJldik7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBhIHNlcmllcyBvZiBjaGFuZ2VzIGluc2lkZSBhIHN5bmNocm9ub3VzIGBmbmAsIHdpdGhvdXQgc2F2aW5nIGFueSBvZlxuICAgKiB0aGVpciBvcGVyYXRpb25zIGludG8gdGhlIGhpc3RvcnkuXG4gICAqL1xuICB3aXRob3V0U2F2aW5nOiBmdW5jdGlvbiB3aXRob3V0U2F2aW5nKGVkaXRvciwgZm4pIHtcbiAgICB2YXIgcHJldiA9IEhpc3RvcnlFZGl0b3IuaXNTYXZpbmcoZWRpdG9yKTtcbiAgICBTQVZJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBTQVZJTkcuc2V0KGVkaXRvciwgcHJldik7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbi8qKlxuICogVGhlIGB3aXRoSGlzdG9yeWAgcGx1Z2luIGtlZXBzIHRyYWNrIG9mIHRoZSBvcGVyYXRpb24gaGlzdG9yeSBvZiBhIFNsYXRlXG4gKiBlZGl0b3IgYXMgb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byBpdCwgdXNpbmcgdW5kbyBhbmQgcmVkbyBzdGFja3MuXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcbiAqIHRoaXMgcGx1Z2luLlxuICpcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXG4gKi9cbnZhciB3aXRoSGlzdG9yeSA9IGZ1bmN0aW9uIHdpdGhIaXN0b3J5KGVkaXRvcikge1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIGFwcGx5ID0gZS5hcHBseTtcbiAgZS5oaXN0b3J5ID0ge1xuICAgIHVuZG9zOiBbXSxcbiAgICByZWRvczogW11cbiAgfTtcbiAgZS5yZWRvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoaXN0b3J5ID0gZS5oaXN0b3J5O1xuICAgIHZhciByZWRvcyA9IGhpc3RvcnkucmVkb3M7XG4gICAgaWYgKHJlZG9zLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBiYXRjaCA9IHJlZG9zW3JlZG9zLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGJhdGNoLnNlbGVjdGlvbkJlZm9yZSkge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlLCBiYXRjaC5zZWxlY3Rpb25CZWZvcmUpO1xuICAgICAgfVxuICAgICAgSGlzdG9yeUVkaXRvci53aXRob3V0U2F2aW5nKGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2xhdGUuRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGJhdGNoLm9wZXJhdGlvbnMpLFxuICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBvcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBlLmFwcGx5KG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaGlzdG9yeS5yZWRvcy5wb3AoKTtcbiAgICAgIGUud3JpdGVIaXN0b3J5KCd1bmRvcycsIGJhdGNoKTtcbiAgICB9XG4gIH07XG4gIGUudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGlzdG9yeSA9IGUuaGlzdG9yeTtcbiAgICB2YXIgdW5kb3MgPSBoaXN0b3J5LnVuZG9zO1xuICAgIGlmICh1bmRvcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgYmF0Y2ggPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXTtcbiAgICAgIEhpc3RvcnlFZGl0b3Iud2l0aG91dFNhdmluZyhlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNsYXRlLkVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnZlcnNlT3BzID0gYmF0Y2gub3BlcmF0aW9ucy5tYXAoc2xhdGUuT3BlcmF0aW9uLmludmVyc2UpLnJldmVyc2UoKTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGludmVyc2VPcHMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgb3AgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgIGUuYXBwbHkob3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmF0Y2guc2VsZWN0aW9uQmVmb3JlKSB7XG4gICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlLCBiYXRjaC5zZWxlY3Rpb25CZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGUud3JpdGVIaXN0b3J5KCdyZWRvcycsIGJhdGNoKTtcbiAgICAgIGhpc3RvcnkudW5kb3MucG9wKCk7XG4gICAgfVxuICB9O1xuICBlLmFwcGx5ID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSBlLm9wZXJhdGlvbnMsXG4gICAgICBoaXN0b3J5ID0gZS5oaXN0b3J5O1xuICAgIHZhciB1bmRvcyA9IGhpc3RvcnkudW5kb3M7XG4gICAgdmFyIGxhc3RCYXRjaCA9IHVuZG9zW3VuZG9zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBsYXN0T3AgPSBsYXN0QmF0Y2ggJiYgbGFzdEJhdGNoLm9wZXJhdGlvbnNbbGFzdEJhdGNoLm9wZXJhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHNhdmUgPSBIaXN0b3J5RWRpdG9yLmlzU2F2aW5nKGUpO1xuICAgIHZhciBtZXJnZSA9IEhpc3RvcnlFZGl0b3IuaXNNZXJnaW5nKGUpO1xuICAgIGlmIChzYXZlID09IG51bGwpIHtcbiAgICAgIHNhdmUgPSBzaG91bGRTYXZlKG9wKTtcbiAgICB9XG4gICAgaWYgKHNhdmUpIHtcbiAgICAgIGlmIChtZXJnZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0QmF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgIG1lcmdlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9ucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBtZXJnZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVyZ2UgPSBzaG91bGRNZXJnZShvcCwgbGFzdE9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEhpc3RvcnlFZGl0b3IuaXNTcGxpdHRpbmdPbmNlKGUpKSB7XG4gICAgICAgIG1lcmdlID0gZmFsc2U7XG4gICAgICAgIEhpc3RvcnlFZGl0b3Iuc2V0U3BsaXR0aW5nT25jZShlLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RCYXRjaCAmJiBtZXJnZSkge1xuICAgICAgICBsYXN0QmF0Y2gub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXRjaCA9IHtcbiAgICAgICAgICBvcGVyYXRpb25zOiBbb3BdLFxuICAgICAgICAgIHNlbGVjdGlvbkJlZm9yZTogZS5zZWxlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgZS53cml0ZUhpc3RvcnkoJ3VuZG9zJywgYmF0Y2gpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHVuZG9zLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICB1bmRvcy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgaGlzdG9yeS5yZWRvcyA9IFtdO1xuICAgIH1cbiAgICBhcHBseShvcCk7XG4gIH07XG4gIGUud3JpdGVIaXN0b3J5ID0gZnVuY3Rpb24gKHN0YWNrLCBiYXRjaCkge1xuICAgIGUuaGlzdG9yeVtzdGFja10ucHVzaChiYXRjaCk7XG4gIH07XG4gIHJldHVybiBlO1xufTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0byBtZXJnZSBhbiBvcGVyYXRpb24gaW50byB0aGUgcHJldmlvdXMgb3BlcmF0aW9uLlxuICovXG52YXIgc2hvdWxkTWVyZ2UgPSBmdW5jdGlvbiBzaG91bGRNZXJnZShvcCwgcHJldikge1xuICBpZiAocHJldiAmJiBvcC50eXBlID09PSAnaW5zZXJ0X3RleHQnICYmIHByZXYudHlwZSA9PT0gJ2luc2VydF90ZXh0JyAmJiBvcC5vZmZzZXQgPT09IHByZXYub2Zmc2V0ICsgcHJldi50ZXh0Lmxlbmd0aCAmJiBzbGF0ZS5QYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHByZXYgJiYgb3AudHlwZSA9PT0gJ3JlbW92ZV90ZXh0JyAmJiBwcmV2LnR5cGUgPT09ICdyZW1vdmVfdGV4dCcgJiYgb3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPT09IHByZXYub2Zmc2V0ICYmIHNsYXRlLlBhdGguZXF1YWxzKG9wLnBhdGgsIHByZXYucGF0aCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9wZXJhdGlvbiBuZWVkcyB0byBiZSBzYXZlZCB0byB0aGUgaGlzdG9yeS5cbiAqL1xudmFyIHNob3VsZFNhdmUgPSBmdW5jdGlvbiBzaG91bGRTYXZlKG9wLCBwcmV2KSB7XG4gIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLkhJU1RPUlkgPSBISVNUT1JZO1xuZXhwb3J0cy5IaXN0b3J5ID0gSGlzdG9yeTtcbmV4cG9ydHMuSGlzdG9yeUVkaXRvciA9IEhpc3RvcnlFZGl0b3I7XG5leHBvcnRzLk1FUkdJTkcgPSBNRVJHSU5HO1xuZXhwb3J0cy5TQVZJTkcgPSBTQVZJTkc7XG5leHBvcnRzLlNQTElUVElOR19PTkNFID0gU1BMSVRUSU5HX09OQ0U7XG5leHBvcnRzLndpdGhIaXN0b3J5ID0gd2l0aEhpc3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/slate-history@0.113.1_slate@0.112.0/node_modules/slate-history/dist/index.js\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/slate-history@0.113.1_slate@0.112.0/node_modules/slate-history/dist/index.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/slate-history@0.113.1_slate@0.112.0/node_modules/slate-history/dist/index.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"../../../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js\");\nvar slate = __webpack_require__(/*! slate */ \"../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js\");\n\n// eslint-disable-next-line no-redeclare\nvar History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n  isHistory: function isHistory(value) {\n    return isPlainObject.isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || slate.Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || slate.Operation.isOperationList(value.undos[0].operations));\n  }\n};\n\n/**\n * Weakmaps for attaching state to the editor.\n */\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar SPLITTING_ONCE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n  isHistoryEditor: function isHistoryEditor(value) {\n    return History.isHistory(value.history) && slate.Editor.isEditor(value);\n  },\n  /**\n   * Get the merge flag's current value.\n   */\n  isMerging: function isMerging(editor) {\n    return MERGING.get(editor);\n  },\n  /**\n   * Get the splitting once flag's current value.\n   */\n  isSplittingOnce: function isSplittingOnce(editor) {\n    return SPLITTING_ONCE.get(editor);\n  },\n  setSplittingOnce: function setSplittingOnce(editor, value) {\n    SPLITTING_ONCE.set(editor, value);\n  },\n  /**\n   * Get the saving flag's current value.\n   */\n  isSaving: function isSaving(editor) {\n    return SAVING.get(editor);\n  },\n  /**\n   * Redo to the previous saved state.\n   */\n  redo: function redo(editor) {\n    editor.redo();\n  },\n  /**\n   * Undo to the previous saved state.\n   */\n  undo: function undo(editor) {\n    editor.undo();\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging: function withMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the first\n   * operation starts a new batch in the history. Subsequent operations will be\n   * merged as usual.\n   */\n  withNewBatch: function withNewBatch(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    SPLITTING_ONCE.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n    SPLITTING_ONCE[\"delete\"](editor);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n  withoutMerging: function withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n  withoutSaving: function withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    try {\n      fn();\n    } finally {\n      SAVING.set(editor, prev);\n    }\n  }\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withHistory = function withHistory(editor) {\n  var e = editor;\n  var apply = e.apply;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n  e.redo = function () {\n    var history = e.history;\n    var redos = history.redos;\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      if (batch.selectionBefore) {\n        slate.Transforms.setSelection(e, batch.selectionBefore);\n      }\n      HistoryEditor.withoutSaving(e, function () {\n        slate.Editor.withoutNormalizing(e, function () {\n          var _iterator = _createForOfIteratorHelper(batch.operations),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var op = _step.value;\n              e.apply(op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      });\n      history.redos.pop();\n      e.writeHistory('undos', batch);\n    }\n  };\n  e.undo = function () {\n    var history = e.history;\n    var undos = history.undos;\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, function () {\n        slate.Editor.withoutNormalizing(e, function () {\n          var inverseOps = batch.operations.map(slate.Operation.inverse).reverse();\n          var _iterator2 = _createForOfIteratorHelper(inverseOps),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var op = _step2.value;\n              e.apply(op);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          if (batch.selectionBefore) {\n            slate.Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n      e.writeHistory('redos', batch);\n      history.undos.pop();\n    }\n  };\n  e.apply = function (op) {\n    var operations = e.operations,\n      history = e.history;\n    var undos = history.undos;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n    if (save == null) {\n      save = shouldSave(op);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (HistoryEditor.isSplittingOnce(e)) {\n        merge = false;\n        HistoryEditor.setSplittingOnce(e, undefined);\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        var batch = {\n          operations: [op],\n          selectionBefore: e.selection\n        };\n        e.writeHistory('undos', batch);\n      }\n      while (undos.length > 100) {\n        undos.shift();\n      }\n      history.redos = [];\n    }\n    apply(op);\n  };\n  e.writeHistory = function (stack, batch) {\n    e.history[stack].push(batch);\n  };\n  return e;\n};\n/**\n * Check whether to merge an operation into the previous operation.\n */\nvar shouldMerge = function shouldMerge(op, prev) {\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && slate.Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && slate.Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  return false;\n};\n/**\n * Check whether an operation needs to be saved to the history.\n */\nvar shouldSave = function shouldSave(op, prev) {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n  return true;\n};\n\nexports.HISTORY = HISTORY;\nexports.History = History;\nexports.HistoryEditor = HistoryEditor;\nexports.MERGING = MERGING;\nexports.SAVING = SAVING;\nexports.SPLITTING_ONCE = SPLITTING_ONCE;\nexports.withHistory = withHistory;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NsYXRlLWhpc3RvcnlAMC4xMTMuMV9zbGF0ZUAwLjExMi4wL25vZGVfbW9kdWxlcy9zbGF0ZS1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsa0lBQWlCO0FBQzdDLFlBQVksbUJBQU8sQ0FBQyw0RkFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RCxpRkFBaUYsV0FBVyx3SEFBd0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVO0FBQzc4QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDtBQUM3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLHVCQUF1QjtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YsY0FBYztBQUNkLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL3NsYXRlLWhpc3RvcnlAMC4xMTMuMV9zbGF0ZUAwLjExMi4wL25vZGVfbW9kdWxlcy9zbGF0ZS1oaXN0b3J5L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xudmFyIHNsYXRlID0gcmVxdWlyZSgnc2xhdGUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEhpc3RvcnkgPSB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYEhpc3RvcnlgIG9iamVjdC5cbiAgICovXG4gIGlzSGlzdG9yeTogZnVuY3Rpb24gaXNIaXN0b3J5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5yZWRvcykgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS51bmRvcykgJiYgKHZhbHVlLnJlZG9zLmxlbmd0aCA9PT0gMCB8fCBzbGF0ZS5PcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLnJlZG9zWzBdLm9wZXJhdGlvbnMpKSAmJiAodmFsdWUudW5kb3MubGVuZ3RoID09PSAwIHx8IHNsYXRlLk9wZXJhdGlvbi5pc09wZXJhdGlvbkxpc3QodmFsdWUudW5kb3NbMF0ub3BlcmF0aW9ucykpO1xuICB9XG59O1xuXG4vKipcbiAqIFdlYWttYXBzIGZvciBhdHRhY2hpbmcgc3RhdGUgdG8gdGhlIGVkaXRvci5cbiAqL1xudmFyIEhJU1RPUlkgPSBuZXcgV2Vha01hcCgpO1xudmFyIFNBVklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTUVSR0lORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgU1BMSVRUSU5HX09OQ0UgPSBuZXcgV2Vha01hcCgpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEhpc3RvcnlFZGl0b3IgPSB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYEhpc3RvcnlFZGl0b3JgIG9iamVjdC5cbiAgICovXG4gIGlzSGlzdG9yeUVkaXRvcjogZnVuY3Rpb24gaXNIaXN0b3J5RWRpdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIEhpc3RvcnkuaXNIaXN0b3J5KHZhbHVlLmhpc3RvcnkpICYmIHNsYXRlLkVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1lcmdlIGZsYWcncyBjdXJyZW50IHZhbHVlLlxuICAgKi9cbiAgaXNNZXJnaW5nOiBmdW5jdGlvbiBpc01lcmdpbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuIE1FUkdJTkcuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNwbGl0dGluZyBvbmNlIGZsYWcncyBjdXJyZW50IHZhbHVlLlxuICAgKi9cbiAgaXNTcGxpdHRpbmdPbmNlOiBmdW5jdGlvbiBpc1NwbGl0dGluZ09uY2UoZWRpdG9yKSB7XG4gICAgcmV0dXJuIFNQTElUVElOR19PTkNFLmdldChlZGl0b3IpO1xuICB9LFxuICBzZXRTcGxpdHRpbmdPbmNlOiBmdW5jdGlvbiBzZXRTcGxpdHRpbmdPbmNlKGVkaXRvciwgdmFsdWUpIHtcbiAgICBTUExJVFRJTkdfT05DRS5zZXQoZWRpdG9yLCB2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNhdmluZyBmbGFnJ3MgY3VycmVudCB2YWx1ZS5cbiAgICovXG4gIGlzU2F2aW5nOiBmdW5jdGlvbiBpc1NhdmluZyhlZGl0b3IpIHtcbiAgICByZXR1cm4gU0FWSU5HLmdldChlZGl0b3IpO1xuICB9LFxuICAvKipcbiAgICogUmVkbyB0byB0aGUgcHJldmlvdXMgc2F2ZWQgc3RhdGUuXG4gICAqL1xuICByZWRvOiBmdW5jdGlvbiByZWRvKGVkaXRvcikge1xuICAgIGVkaXRvci5yZWRvKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBVbmRvIHRvIHRoZSBwcmV2aW91cyBzYXZlZCBzdGF0ZS5cbiAgICovXG4gIHVuZG86IGZ1bmN0aW9uIHVuZG8oZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuZG8oKTtcbiAgfSxcbiAgLyoqXG4gICAqIEFwcGx5IGEgc2VyaWVzIG9mIGNoYW5nZXMgaW5zaWRlIGEgc3luY2hyb25vdXMgYGZuYCwgVGhlc2Ugb3BlcmF0aW9ucyB3aWxsXG4gICAqIGJlIG1lcmdlZCBpbnRvIHRoZSBwcmV2aW91cyBoaXN0b3J5LlxuICAgKi9cbiAgd2l0aE1lcmdpbmc6IGZ1bmN0aW9uIHdpdGhNZXJnaW5nKGVkaXRvciwgZm4pIHtcbiAgICB2YXIgcHJldiA9IEhpc3RvcnlFZGl0b3IuaXNNZXJnaW5nKGVkaXRvcik7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICBmbigpO1xuICAgIE1FUkdJTkcuc2V0KGVkaXRvciwgcHJldik7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBhIHNlcmllcyBvZiBjaGFuZ2VzIGluc2lkZSBhIHN5bmNocm9ub3VzIGBmbmAsIGVuc3VyaW5nIHRoYXQgdGhlIGZpcnN0XG4gICAqIG9wZXJhdGlvbiBzdGFydHMgYSBuZXcgYmF0Y2ggaW4gdGhlIGhpc3RvcnkuIFN1YnNlcXVlbnQgb3BlcmF0aW9ucyB3aWxsIGJlXG4gICAqIG1lcmdlZCBhcyB1c3VhbC5cbiAgICovXG4gIHdpdGhOZXdCYXRjaDogZnVuY3Rpb24gd2l0aE5ld0JhdGNoKGVkaXRvciwgZm4pIHtcbiAgICB2YXIgcHJldiA9IEhpc3RvcnlFZGl0b3IuaXNNZXJnaW5nKGVkaXRvcik7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICBTUExJVFRJTkdfT05DRS5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICBmbigpO1xuICAgIE1FUkdJTkcuc2V0KGVkaXRvciwgcHJldik7XG4gICAgU1BMSVRUSU5HX09OQ0VbXCJkZWxldGVcIl0oZWRpdG9yKTtcbiAgfSxcbiAgLyoqXG4gICAqIEFwcGx5IGEgc2VyaWVzIG9mIGNoYW5nZXMgaW5zaWRlIGEgc3luY2hyb25vdXMgYGZuYCwgd2l0aG91dCBtZXJnaW5nIGFueSBvZlxuICAgKiB0aGUgbmV3IG9wZXJhdGlvbnMgaW50byBwcmV2aW91cyBzYXZlIHBvaW50IGluIHRoZSBoaXN0b3J5LlxuICAgKi9cbiAgd2l0aG91dE1lcmdpbmc6IGZ1bmN0aW9uIHdpdGhvdXRNZXJnaW5nKGVkaXRvciwgZm4pIHtcbiAgICB2YXIgcHJldiA9IEhpc3RvcnlFZGl0b3IuaXNNZXJnaW5nKGVkaXRvcik7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgZm4oKTtcbiAgICBNRVJHSU5HLnNldChlZGl0b3IsIHByZXYpO1xuICB9LFxuICAvKipcbiAgICogQXBwbHkgYSBzZXJpZXMgb2YgY2hhbmdlcyBpbnNpZGUgYSBzeW5jaHJvbm91cyBgZm5gLCB3aXRob3V0IHNhdmluZyBhbnkgb2ZcbiAgICogdGhlaXIgb3BlcmF0aW9ucyBpbnRvIHRoZSBoaXN0b3J5LlxuICAgKi9cbiAgd2l0aG91dFNhdmluZzogZnVuY3Rpb24gd2l0aG91dFNhdmluZyhlZGl0b3IsIGZuKSB7XG4gICAgdmFyIHByZXYgPSBIaXN0b3J5RWRpdG9yLmlzU2F2aW5nKGVkaXRvcik7XG4gICAgU0FWSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICB0cnkge1xuICAgICAgZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgU0FWSU5HLnNldChlZGl0b3IsIHByZXYpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIFRoZSBgd2l0aEhpc3RvcnlgIHBsdWdpbiBrZWVwcyB0cmFjayBvZiB0aGUgb3BlcmF0aW9uIGhpc3Rvcnkgb2YgYSBTbGF0ZVxuICogZWRpdG9yIGFzIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gaXQsIHVzaW5nIHVuZG8gYW5kIHJlZG8gc3RhY2tzLlxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdCwgeW91IG11c3QgZXh0ZW5kIFNsYXRlJ3MgQ3VzdG9tVHlwZXMgdG8gdXNlXG4gKiB0aGlzIHBsdWdpbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLnNsYXRlanMub3JnL2NvbmNlcHRzLzExLXR5cGVzY3JpcHQgdG8gbGVhcm4gaG93LlxuICovXG52YXIgd2l0aEhpc3RvcnkgPSBmdW5jdGlvbiB3aXRoSGlzdG9yeShlZGl0b3IpIHtcbiAgdmFyIGUgPSBlZGl0b3I7XG4gIHZhciBhcHBseSA9IGUuYXBwbHk7XG4gIGUuaGlzdG9yeSA9IHtcbiAgICB1bmRvczogW10sXG4gICAgcmVkb3M6IFtdXG4gIH07XG4gIGUucmVkbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGlzdG9yeSA9IGUuaGlzdG9yeTtcbiAgICB2YXIgcmVkb3MgPSBoaXN0b3J5LnJlZG9zO1xuICAgIGlmIChyZWRvcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgYmF0Y2ggPSByZWRvc1tyZWRvcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChiYXRjaC5zZWxlY3Rpb25CZWZvcmUpIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZSwgYmF0Y2guc2VsZWN0aW9uQmVmb3JlKTtcbiAgICAgIH1cbiAgICAgIEhpc3RvcnlFZGl0b3Iud2l0aG91dFNhdmluZyhlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNsYXRlLkVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihiYXRjaC5vcGVyYXRpb25zKSxcbiAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgb3AgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgZS5hcHBseShvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGhpc3RvcnkucmVkb3MucG9wKCk7XG4gICAgICBlLndyaXRlSGlzdG9yeSgndW5kb3MnLCBiYXRjaCk7XG4gICAgfVxuICB9O1xuICBlLnVuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhpc3RvcnkgPSBlLmhpc3Rvcnk7XG4gICAgdmFyIHVuZG9zID0gaGlzdG9yeS51bmRvcztcbiAgICBpZiAodW5kb3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGJhdGNoID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV07XG4gICAgICBIaXN0b3J5RWRpdG9yLndpdGhvdXRTYXZpbmcoZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzbGF0ZS5FZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW52ZXJzZU9wcyA9IGJhdGNoLm9wZXJhdGlvbnMubWFwKHNsYXRlLk9wZXJhdGlvbi5pbnZlcnNlKS5yZXZlcnNlKCk7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbnZlcnNlT3BzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIG9wID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICBlLmFwcGx5KG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhdGNoLnNlbGVjdGlvbkJlZm9yZSkge1xuICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZSwgYmF0Y2guc2VsZWN0aW9uQmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBlLndyaXRlSGlzdG9yeSgncmVkb3MnLCBiYXRjaCk7XG4gICAgICBoaXN0b3J5LnVuZG9zLnBvcCgpO1xuICAgIH1cbiAgfTtcbiAgZS5hcHBseSA9IGZ1bmN0aW9uIChvcCkge1xuICAgIHZhciBvcGVyYXRpb25zID0gZS5vcGVyYXRpb25zLFxuICAgICAgaGlzdG9yeSA9IGUuaGlzdG9yeTtcbiAgICB2YXIgdW5kb3MgPSBoaXN0b3J5LnVuZG9zO1xuICAgIHZhciBsYXN0QmF0Y2ggPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGFzdE9wID0gbGFzdEJhdGNoICYmIGxhc3RCYXRjaC5vcGVyYXRpb25zW2xhc3RCYXRjaC5vcGVyYXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBzYXZlID0gSGlzdG9yeUVkaXRvci5pc1NhdmluZyhlKTtcbiAgICB2YXIgbWVyZ2UgPSBIaXN0b3J5RWRpdG9yLmlzTWVyZ2luZyhlKTtcbiAgICBpZiAoc2F2ZSA9PSBudWxsKSB7XG4gICAgICBzYXZlID0gc2hvdWxkU2F2ZShvcCk7XG4gICAgfVxuICAgIGlmIChzYXZlKSB7XG4gICAgICBpZiAobWVyZ2UgPT0gbnVsbCkge1xuICAgICAgICBpZiAobGFzdEJhdGNoID09IG51bGwpIHtcbiAgICAgICAgICBtZXJnZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgbWVyZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlID0gc2hvdWxkTWVyZ2Uob3AsIGxhc3RPcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChIaXN0b3J5RWRpdG9yLmlzU3BsaXR0aW5nT25jZShlKSkge1xuICAgICAgICBtZXJnZSA9IGZhbHNlO1xuICAgICAgICBIaXN0b3J5RWRpdG9yLnNldFNwbGl0dGluZ09uY2UoZSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0QmF0Y2ggJiYgbWVyZ2UpIHtcbiAgICAgICAgbGFzdEJhdGNoLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmF0Y2ggPSB7XG4gICAgICAgICAgb3BlcmF0aW9uczogW29wXSxcbiAgICAgICAgICBzZWxlY3Rpb25CZWZvcmU6IGUuc2VsZWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGUud3JpdGVIaXN0b3J5KCd1bmRvcycsIGJhdGNoKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh1bmRvcy5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgdW5kb3Muc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGhpc3RvcnkucmVkb3MgPSBbXTtcbiAgICB9XG4gICAgYXBwbHkob3ApO1xuICB9O1xuICBlLndyaXRlSGlzdG9yeSA9IGZ1bmN0aW9uIChzdGFjaywgYmF0Y2gpIHtcbiAgICBlLmhpc3Rvcnlbc3RhY2tdLnB1c2goYmF0Y2gpO1xuICB9O1xuICByZXR1cm4gZTtcbn07XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdG8gbWVyZ2UgYW4gb3BlcmF0aW9uIGludG8gdGhlIHByZXZpb3VzIG9wZXJhdGlvbi5cbiAqL1xudmFyIHNob3VsZE1lcmdlID0gZnVuY3Rpb24gc2hvdWxkTWVyZ2Uob3AsIHByZXYpIHtcbiAgaWYgKHByZXYgJiYgb3AudHlwZSA9PT0gJ2luc2VydF90ZXh0JyAmJiBwcmV2LnR5cGUgPT09ICdpbnNlcnRfdGV4dCcgJiYgb3Aub2Zmc2V0ID09PSBwcmV2Lm9mZnNldCArIHByZXYudGV4dC5sZW5ndGggJiYgc2xhdGUuUGF0aC5lcXVhbHMob3AucGF0aCwgcHJldi5wYXRoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwcmV2ICYmIG9wLnR5cGUgPT09ICdyZW1vdmVfdGV4dCcgJiYgcHJldi50eXBlID09PSAncmVtb3ZlX3RleHQnICYmIG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBwcmV2Lm9mZnNldCAmJiBzbGF0ZS5QYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvcGVyYXRpb24gbmVlZHMgdG8gYmUgc2F2ZWQgdG8gdGhlIGhpc3RvcnkuXG4gKi9cbnZhciBzaG91bGRTYXZlID0gZnVuY3Rpb24gc2hvdWxkU2F2ZShvcCwgcHJldikge1xuICBpZiAob3AudHlwZSA9PT0gJ3NldF9zZWxlY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0cy5ISVNUT1JZID0gSElTVE9SWTtcbmV4cG9ydHMuSGlzdG9yeSA9IEhpc3Rvcnk7XG5leHBvcnRzLkhpc3RvcnlFZGl0b3IgPSBIaXN0b3J5RWRpdG9yO1xuZXhwb3J0cy5NRVJHSU5HID0gTUVSR0lORztcbmV4cG9ydHMuU0FWSU5HID0gU0FWSU5HO1xuZXhwb3J0cy5TUExJVFRJTkdfT05DRSA9IFNQTElUVElOR19PTkNFO1xuZXhwb3J0cy53aXRoSGlzdG9yeSA9IHdpdGhIaXN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/slate-history@0.113.1_slate@0.112.0/node_modules/slate-history/dist/index.js\n");

/***/ })

};
;