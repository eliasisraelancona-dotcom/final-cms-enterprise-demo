"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate@0.112.0";
exports.ids = ["vendor-chunks/slate@0.112.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js":
/*!*************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(pages-dir-node)/../../../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js\");\nvar immer = __webpack_require__(/*! immer */ \"(pages-dir-node)/../../../../node_modules/.pnpm/immer@10.1.1/node_modules/immer/dist/cjs/index.js\");\n\n// eslint-disable-next-line no-redeclare\nvar PathRef = {\n  transform: function transform(ref, op) {\n    var current = ref.current,\n      affinity = ref.affinity;\n    if (current == null) {\n      return;\n    }\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar PointRef = {\n  transform: function transform(ref, op) {\n    var current = ref.current,\n      affinity = ref.affinity;\n    if (current == null) {\n      return;\n    }\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar RangeRef = {\n  transform: function transform(ref, op) {\n    var current = ref.current,\n      affinity = ref.affinity;\n    if (current == null) {\n      return;\n    }\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar arrayLikeToArray = createCommonjsModule(function (module) {\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayLikeToArray);\n\nvar arrayWithoutHoles = createCommonjsModule(function (module) {\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithoutHoles);\n\nvar iterableToArray = createCommonjsModule(function (module) {\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArray);\n\nvar unsupportedIterableToArray = createCommonjsModule(function (module) {\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(unsupportedIterableToArray);\n\nvar nonIterableSpread = createCommonjsModule(function (module) {\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableSpread);\n\nvar toConsumableArray = createCommonjsModule(function (module) {\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var paths = Path.levels(path, options);\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n    return paths;\n  },\n  common: function common(path, another) {\n    var common = [];\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n      if (av !== bv) {\n        break;\n      }\n      common.push(av);\n    }\n    return common;\n  },\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n    return 0;\n  },\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n  hasPrevious: function hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse2 = options.reverse,\n      reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n    var list = [];\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n    if (reverse) {\n      list.reverse();\n    }\n    return list;\n  },\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n  operationCanTransformPath: function operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n      default:\n        return false;\n    }\n  },\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n    return path.slice(0, -1);\n  },\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n    var last = path[path.length - 1];\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n    return path.slice(0, -1).concat(last - 1);\n  },\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n    return path.slice(ancestor.length);\n  },\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null;\n    // PERF: use destructing instead of immer\n    var p = _toConsumableArray(path);\n    var _options$affinity = options.affinity,\n      affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    // PERF: Exit early if the operation is guaranteed not to have an effect.\n    if (path.length === 0) {\n      return p;\n    }\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var op = operation.path;\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n          break;\n        }\n      case 'remove_node':\n        {\n          var _op = operation.path;\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n          break;\n        }\n      case 'merge_node':\n        {\n          var _op2 = operation.path,\n            position = operation.position;\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n          break;\n        }\n      case 'split_node':\n        {\n          var _op3 = operation.path,\n            _position = operation.position;\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n          break;\n        }\n      case 'move_node':\n        {\n          var _op4 = operation.path,\n            onp = operation.newPath;\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n            p[_op4.length - 1] -= 1;\n          }\n          break;\n        }\n    }\n    return p;\n  }\n};\n\nvar _typeof_1 = createCommonjsModule(function (module) {\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(_typeof_1);\n\nvar toPrimitive = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPrimitive);\n\nvar toPropertyKey = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\n\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPropertyKey);\n\nvar defineProperty = createCommonjsModule(function (module) {\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _defineProperty = unwrapExports(defineProperty);\n\nvar arrayWithHoles = createCommonjsModule(function (module) {\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithHoles);\n\nvar iterableToArrayLimit = createCommonjsModule(function (module) {\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArrayLimit);\n\nvar nonIterableRest = createCommonjsModule(function (module) {\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableRest);\n\nvar slicedToArray = createCommonjsModule(function (module) {\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nfunction ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelper$m(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$m(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$m(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$m(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$m(o, minLen); }\nfunction _arrayLikeToArray$m(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar applyToDraft = function applyToDraft(editor, selection, op) {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var path = op.path,\n          node = op.node;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n        parent.children.splice(index, 0, node);\n        if (selection) {\n          var _iterator = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                point = _step$value[0],\n                key = _step$value[1];\n              selection[key] = Point.transform(point, op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        break;\n      }\n    case 'insert_text':\n      {\n        var _path = op.path,\n          offset = op.offset,\n          text = op.text;\n        if (text.length === 0) break;\n        var _node = Node.leaf(editor, _path);\n        var before = _node.text.slice(0, offset);\n        var after = _node.text.slice(offset);\n        _node.text = before + text + after;\n        if (selection) {\n          var _iterator2 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                _point = _step2$value[0],\n                _key = _step2$value[1];\n              selection[_key] = Point.transform(_point, op);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        break;\n      }\n    case 'merge_node':\n      {\n        var _path2 = op.path;\n        var _node2 = Node.get(editor, _path2);\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n        var _parent = Node.parent(editor, _path2);\n        var _index = _path2[_path2.length - 1];\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          var _prev$children;\n          (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n        _parent.children.splice(_index, 1);\n        if (selection) {\n          var _iterator3 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                _point2 = _step3$value[0],\n                _key2 = _step3$value[1];\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n        break;\n      }\n    case 'move_node':\n      {\n        var _path3 = op.path,\n          newPath = op.newPath;\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n        var _node3 = Node.get(editor, _path3);\n        var _parent2 = Node.parent(editor, _path3);\n        var _index2 = _path3[_path3.length - 1];\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        _parent2.children.splice(_index2, 1);\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n        if (selection) {\n          var _iterator4 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _step4$value = _slicedToArray(_step4.value, 2),\n                _point3 = _step4$value[0],\n                _key3 = _step4$value[1];\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n        break;\n      }\n    case 'remove_node':\n      {\n        var _path4 = op.path;\n        var _index3 = _path4[_path4.length - 1];\n        var _parent3 = Node.parent(editor, _path4);\n        _parent3.children.splice(_index3, 1);\n        // Transform all the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          var _iterator5 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _step5$value = _slicedToArray(_step5.value, 2),\n                _point4 = _step5$value[0],\n                _key4 = _step5$value[1];\n              var result = Point.transform(_point4, op);\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n                var next = void 0;\n                var _iterator6 = _createForOfIteratorHelper$m(Node.texts(editor)),\n                  _step6;\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var _step6$value = _slicedToArray(_step6.value, 2),\n                      n = _step6$value[0],\n                      p = _step6$value[1];\n                    if (Path.compare(p, _path4) === -1) {\n                      _prev = [n, p];\n                    } else {\n                      next = [n, p];\n                      break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n                var preferNext = false;\n                if (_prev && next) {\n                  if (Path.equals(next[1], _path4)) {\n                    preferNext = !Path.hasPrevious(next[1]);\n                  } else {\n                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                  }\n                }\n                if (_prev && !preferNext) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n        break;\n      }\n    case 'remove_text':\n      {\n        var _path5 = op.path,\n          _offset = op.offset,\n          _text = op.text;\n        if (_text.length === 0) break;\n        var _node4 = Node.leaf(editor, _path5);\n        var _before = _node4.text.slice(0, _offset);\n        var _after = _node4.text.slice(_offset + _text.length);\n        _node4.text = _before + _after;\n        if (selection) {\n          var _iterator7 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _step7$value = _slicedToArray(_step7.value, 2),\n                _point5 = _step7$value[0],\n                _key5 = _step7$value[1];\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n        break;\n      }\n    case 'set_node':\n      {\n        var _path6 = op.path,\n          properties = op.properties,\n          newProperties = op.newProperties;\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n        var _node5 = Node.get(editor, _path6);\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n          var value = newProperties[_key6];\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        }\n        // properties that were previously defined, but are now missing, must be deleted\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n        break;\n      }\n    case 'set_selection':\n      {\n        var _newProperties = op.newProperties;\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n            selection = _objectSpread$e({}, _newProperties);\n          }\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n        break;\n      }\n    case 'split_node':\n      {\n        var _path7 = op.path,\n          position = op.position,\n          _properties = op.properties;\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n        var _node6 = Node.get(editor, _path7);\n        var _parent4 = Node.parent(editor, _path7);\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n          var _after2 = _node6.text.slice(position);\n          _node6.text = _before2;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n          var _after3 = _node6.children.slice(position);\n          _node6.children = _before3;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            children: _after3\n          });\n        }\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n        if (selection) {\n          var _iterator8 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _step8$value = _slicedToArray(_step8.value, 2),\n                _point6 = _step8$value[0],\n                _key9 = _step8$value[1];\n              selection[_key9] = Point.transform(_point6, op);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n        break;\n      }\n  }\n  return selection;\n};\n// eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n  transform: function transform(editor, op) {\n    editor.children = immer.createDraft(editor.children);\n    var selection = editor.selection && immer.createDraft(editor.selection);\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = immer.finishDraft(editor.children);\n      if (selection) {\n        editor.selection = immer.isDraft(selection) ? immer.finishDraft(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n  insertNodes: function insertNodes(editor, nodes, options) {\n    editor.insertNodes(nodes, options);\n  },\n  liftNodes: function liftNodes(editor, options) {\n    editor.liftNodes(options);\n  },\n  mergeNodes: function mergeNodes(editor, options) {\n    editor.mergeNodes(options);\n  },\n  moveNodes: function moveNodes(editor, options) {\n    editor.moveNodes(options);\n  },\n  removeNodes: function removeNodes(editor, options) {\n    editor.removeNodes(options);\n  },\n  setNodes: function setNodes(editor, props, options) {\n    editor.setNodes(props, options);\n  },\n  splitNodes: function splitNodes(editor, options) {\n    editor.splitNodes(options);\n  },\n  unsetNodes: function unsetNodes(editor, props, options) {\n    editor.unsetNodes(props, options);\n  },\n  unwrapNodes: function unwrapNodes(editor, options) {\n    editor.unwrapNodes(options);\n  },\n  wrapNodes: function wrapNodes(editor, element, options) {\n    editor.wrapNodes(element, options);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n  collapse: function collapse(editor, options) {\n    editor.collapse(options);\n  },\n  deselect: function deselect(editor) {\n    editor.deselect();\n  },\n  move: function move(editor, options) {\n    editor.move(options);\n  },\n  select: function select(editor, target) {\n    editor.select(target);\n  },\n  setPoint: function setPoint(editor, props, options) {\n    editor.setPoint(props, options);\n  },\n  setSelection: function setSelection(editor, props) {\n    editor.setSelection(props);\n  }\n};\n\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */\nvar isDeepEqual = function isDeepEqual(node, another) {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n    if (isPlainObject.isPlainObject(a) && isPlainObject.isPlainObject(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n  return true;\n};\n\nvar objectWithoutPropertiesLoose = createCommonjsModule(function (module) {\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(objectWithoutPropertiesLoose);\n\nvar objectWithoutProperties = createCommonjsModule(function (module) {\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\nvar _excluded$4 = [\"anchor\", \"focus\"];\nfunction ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Range = {\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var anchor = range.anchor,\n      focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n  end: function end(range) {\n    var _Range$edges = Range.edges(range),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      end = _Range$edges2[1];\n    return end;\n  },\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n  surrounds: function surrounds(range, target) {\n    var intersectionRange = Range.intersection(range, target);\n    if (!intersectionRange) {\n      return false;\n    }\n    return Range.equals(intersectionRange, target);\n  },\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n      var _Range$edges3 = Range.edges(range),\n        _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n        rs = _Range$edges4[0],\n        re = _Range$edges4[1];\n      var _Range$edges5 = Range.edges(target),\n        _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n        ts = _Range$edges6[0],\n        te = _Range$edges6[1];\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n    var _Range$edges7 = Range.edges(range),\n      _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n      start = _Range$edges8[0],\n      end = _Range$edges8[1];\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n    return isAfterStart && isBeforeEnd;\n  },\n  intersection: function intersection(range, another) {\n    range.anchor;\n      range.focus;\n      var rest = _objectWithoutProperties(range, _excluded$4);\n    var _Range$edges9 = Range.edges(range),\n      _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n      s1 = _Range$edges10[0],\n      e1 = _Range$edges10[1];\n    var _Range$edges11 = Range.edges(another),\n      _Range$edges12 = _slicedToArray(_Range$edges11, 2),\n      s2 = _Range$edges12[0],\n      e2 = _Range$edges12[1];\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$d({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n  isRange: function isRange(value) {\n    return isPlainObject.isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n  points: function* points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n  start: function start(range) {\n    var _Range$edges13 = Range.edges(range),\n      _Range$edges14 = _slicedToArray(_Range$edges13, 1),\n      start = _Range$edges14[0];\n    return start;\n  },\n  transform: function transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(range, function (r) {\n      if (r === null) {\n        return null;\n      }\n      var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'inward' : _options$affinity;\n      var affinityAnchor;\n      var affinityFocus;\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n      if (!anchor || !focus) {\n        return null;\n      }\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\n\n/**\n * Shared the function with isElementType utility\n */\nvar isElement = function isElement(value) {\n  return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n};\n// eslint-disable-next-line no-redeclare\nvar Element = {\n  isAncestor: function isAncestor(value) {\n    return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children);\n  },\n  isElement: isElement,\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Element.isElement(val);\n    });\n  },\n  isElementProps: function isElementProps(props) {\n    return props.children !== undefined;\n  },\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nvar _excluded$3 = [\"children\"],\n  _excluded2$3 = [\"text\"];\nfunction _createForOfIteratorHelper$l(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$l(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$l(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$l(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$l(o, minLen); }\nfunction _arrayLikeToArray$l(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar IS_NODE_LIST_CACHE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Node = {\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  ancestors: function ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var _iterator = _createForOfIteratorHelper$l(Path.ancestors(path, options)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          var n = Node.ancestor(root, p);\n          var entry = [n, p];\n          yield entry;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }();\n  },\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n    var c = root.children[index];\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n    return c;\n  },\n  children: function children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n      var ancestor = Node.ancestor(root, path);\n      var children = ancestor.children;\n      var index = reverse ? children.length - 1 : 0;\n      while (reverse ? index >= 0 : index < children.length) {\n        var child = Node.child(ancestor, index);\n        var childPath = path.concat(index);\n        yield [child, childPath];\n        index = reverse ? index - 1 : index + 1;\n      }\n    }();\n  },\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  descendants: function descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var _iterator2 = _createForOfIteratorHelper$l(Node.nodes(root, options)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            node = _step2$value[0],\n            path = _step2$value[1];\n          if (path.length !== 0) {\n            // NOTE: we have to coerce here because checking the path's length does\n            // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n            yield [node, path];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }();\n  },\n  elements: function elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var _iterator3 = _createForOfIteratorHelper$l(Node.nodes(root, options)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            node = _step3$value[0],\n            path = _step3$value[1];\n          if (Element.isElement(node)) {\n            yield [node, path];\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }();\n  },\n  extractProps: function extractProps(node) {\n    if (Element.isAncestor(node)) {\n      node.children;\n        var properties = _objectWithoutProperties(node, _excluded$3);\n      return properties;\n    } else {\n      node.text;\n        var _properties = _objectWithoutProperties(node, _excluded2$3);\n      return _properties;\n    }\n  },\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n    return [n, p];\n  },\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n    var newRoot = immer.produce({\n      children: root.children\n    }, function (r) {\n      var _Range$edges = Range.edges(range),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            path = _ref2[1];\n          return !Range.includes(range, path);\n        }\n      });\n      var _iterator4 = _createForOfIteratorHelper$l(nodeEntries),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n            path = _step4$value[1];\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n  get: function get(root, path) {\n    var node = Node.getIf(root, path);\n    if (node === undefined) {\n      throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n    }\n    return node;\n  },\n  getIf: function getIf(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return;\n      }\n      node = node.children[p];\n    }\n    return node;\n  },\n  has: function has(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n      node = node.children[p];\n    }\n    return true;\n  },\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n  isNodeList: function isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n    var isNodeList = value.every(function (val) {\n      return Node.isNode(val);\n    });\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n    return [n, p];\n  },\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  levels: function levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var _iterator5 = _createForOfIteratorHelper$l(Path.levels(path, options)),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var p = _step5.value;\n          var n = Node.get(root, p);\n          yield [n, p];\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }();\n  },\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n  nodes: function nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var pass = options.pass,\n        _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n      var _options$from = options.from,\n        from = _options$from === void 0 ? [] : _options$from,\n        to = options.to;\n      var visited = new Set();\n      var p = [];\n      var n = root;\n      while (true) {\n        if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n          break;\n        }\n        if (!visited.has(n)) {\n          yield [n, p];\n        }\n        // If we're allowed to go downward and we haven't descended yet, do.\n        if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n          visited.add(n);\n          var nextIndex = reverse ? n.children.length - 1 : 0;\n          if (Path.isAncestor(p, from)) {\n            nextIndex = from[p.length];\n          }\n          p = p.concat(nextIndex);\n          n = Node.get(root, p);\n          continue;\n        }\n        // If we're at the root and we can't go down, we're done.\n        if (p.length === 0) {\n          break;\n        }\n        // If we're going forward...\n        if (!reverse) {\n          var newPath = Path.next(p);\n          if (Node.has(root, newPath)) {\n            p = newPath;\n            n = Node.get(root, p);\n            continue;\n          }\n        }\n        // If we're going backward...\n        if (reverse && p[p.length - 1] !== 0) {\n          var _newPath = Path.previous(p);\n          p = _newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n        // Otherwise we're going upward...\n        p = Path.parent(p);\n        n = Node.get(root, p);\n        visited.add(n);\n      }\n    }();\n  },\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n    return p;\n  },\n  string: function string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n  texts: function texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var _iterator6 = _createForOfIteratorHelper$l(Node.nodes(root, options)),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n            node = _step6$value[0],\n            path = _step6$value[1];\n          if (Text.isText(node)) {\n            yield [node, path];\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }();\n  }\n};\n\nfunction ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Operation = {\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n  isOperation: function isOperation(value) {\n    if (!isPlainObject.isPlainObject(value)) {\n      return false;\n    }\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties);\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject.isPlainObject(value.properties);\n      default:\n        return false;\n    }\n  },\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Operation.isOperation(val);\n    });\n  },\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n      case 'insert_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n      case 'merge_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n            path = op.path;\n          // PERF: in this case the move operation is a no-op anyways.\n          if (Path.equals(newPath, path)) {\n            return op;\n          }\n          // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          }\n          // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n      case 'remove_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n      case 'remove_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n      case 'set_node':\n        {\n          var properties = op.properties,\n            newProperties = op.newProperties;\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n            _newProperties = op.newProperties;\n          if (_properties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n      case 'split_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\n\nvar IS_EDITOR_CACHE = new WeakMap();\nvar isEditor = function isEditor(value) {\n  var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n  if (cachedIsEditor !== undefined) {\n    return cachedIsEditor;\n  }\n  if (!isPlainObject.isPlainObject(value)) {\n    return false;\n  }\n  var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isElementReadOnly === 'function' && typeof value.isInline === 'function' && typeof value.isSelectable === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || isPlainObject.isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  IS_EDITOR_CACHE.set(value, isEditor);\n  return isEditor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar Editor = {\n  above: function above(editor, options) {\n    return editor.above(options);\n  },\n  addMark: function addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n  after: function after(editor, at, options) {\n    return editor.after(at, options);\n  },\n  before: function before(editor, at, options) {\n    return editor.before(at, options);\n  },\n  deleteBackward: function deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit = options.unit,\n      unit = _options$unit === void 0 ? 'character' : _options$unit;\n    editor.deleteBackward(unit);\n  },\n  deleteForward: function deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit2 = options.unit,\n      unit = _options$unit2 === void 0 ? 'character' : _options$unit2;\n    editor.deleteForward(unit);\n  },\n  deleteFragment: function deleteFragment(editor, options) {\n    editor.deleteFragment(options);\n  },\n  edges: function edges(editor, at) {\n    return editor.edges(at);\n  },\n  elementReadOnly: function elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return editor.elementReadOnly(options);\n  },\n  end: function end(editor, at) {\n    return editor.end(at);\n  },\n  first: function first(editor, at) {\n    return editor.first(at);\n  },\n  fragment: function fragment(editor, at) {\n    return editor.fragment(at);\n  },\n  hasBlocks: function hasBlocks(editor, element) {\n    return editor.hasBlocks(element);\n  },\n  hasInlines: function hasInlines(editor, element) {\n    return editor.hasInlines(element);\n  },\n  hasPath: function hasPath(editor, path) {\n    return editor.hasPath(path);\n  },\n  hasTexts: function hasTexts(editor, element) {\n    return editor.hasTexts(element);\n  },\n  insertBreak: function insertBreak(editor) {\n    editor.insertBreak();\n  },\n  insertFragment: function insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertNode: function insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n  insertSoftBreak: function insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n  insertText: function insertText(editor, text) {\n    editor.insertText(text);\n  },\n  isBlock: function isBlock(editor, value) {\n    return editor.isBlock(value);\n  },\n  isEdge: function isEdge(editor, point, at) {\n    return editor.isEdge(point, at);\n  },\n  isEditor: function isEditor$1(value) {\n    return isEditor(value);\n  },\n  isElementReadOnly: function isElementReadOnly(editor, element) {\n    return editor.isElementReadOnly(element);\n  },\n  isEmpty: function isEmpty(editor, element) {\n    return editor.isEmpty(element);\n  },\n  isEnd: function isEnd(editor, point, at) {\n    return editor.isEnd(point, at);\n  },\n  isInline: function isInline(editor, value) {\n    return editor.isInline(value);\n  },\n  isNormalizing: function isNormalizing(editor) {\n    return editor.isNormalizing();\n  },\n  isSelectable: function isSelectable(editor, value) {\n    return editor.isSelectable(value);\n  },\n  isStart: function isStart(editor, point, at) {\n    return editor.isStart(point, at);\n  },\n  isVoid: function isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n  last: function last(editor, at) {\n    return editor.last(at);\n  },\n  leaf: function leaf(editor, at, options) {\n    return editor.leaf(at, options);\n  },\n  levels: function levels(editor, options) {\n    return editor.levels(options);\n  },\n  marks: function marks(editor) {\n    return editor.getMarks();\n  },\n  next: function next(editor, options) {\n    return editor.next(options);\n  },\n  node: function node(editor, at, options) {\n    return editor.node(at, options);\n  },\n  nodes: function nodes(editor, options) {\n    return editor.nodes(options);\n  },\n  normalize: function normalize(editor, options) {\n    editor.normalize(options);\n  },\n  parent: function parent(editor, at, options) {\n    return editor.parent(at, options);\n  },\n  path: function path(editor, at, options) {\n    return editor.path(at, options);\n  },\n  pathRef: function pathRef(editor, path, options) {\n    return editor.pathRef(path, options);\n  },\n  pathRefs: function pathRefs(editor) {\n    return editor.pathRefs();\n  },\n  point: function point(editor, at, options) {\n    return editor.point(at, options);\n  },\n  pointRef: function pointRef(editor, point, options) {\n    return editor.pointRef(point, options);\n  },\n  pointRefs: function pointRefs(editor) {\n    return editor.pointRefs();\n  },\n  positions: function positions(editor, options) {\n    return editor.positions(options);\n  },\n  previous: function previous(editor, options) {\n    return editor.previous(options);\n  },\n  range: function range(editor, at, to) {\n    return editor.range(at, to);\n  },\n  rangeRef: function rangeRef(editor, range, options) {\n    return editor.rangeRef(range, options);\n  },\n  rangeRefs: function rangeRefs(editor) {\n    return editor.rangeRefs();\n  },\n  removeMark: function removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n  setNormalizing: function setNormalizing(editor, isNormalizing) {\n    editor.setNormalizing(isNormalizing);\n  },\n  start: function start(editor, at) {\n    return editor.start(at);\n  },\n  string: function string(editor, at, options) {\n    return editor.string(at, options);\n  },\n  unhangRange: function unhangRange(editor, range, options) {\n    return editor.unhangRange(range, options);\n  },\n  \"void\": function _void(editor, options) {\n    return editor[\"void\"](options);\n  },\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    editor.withoutNormalizing(fn);\n  },\n  shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode(editor, prevNode, curNode) {\n    return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar Location = {\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\n// eslint-disable-next-line no-redeclare\nvar Span = {\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\n\nfunction ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Point = {\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n    return result;\n  },\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n  isPoint: function isPoint(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(point, function (p) {\n      if (p === null) {\n        return null;\n      }\n      var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n      var path = p.path,\n        offset = p.offset;\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n            break;\n          }\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n            break;\n          }\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n            break;\n          }\n      }\n    });\n  }\n};\n\nvar _scrubber = undefined;\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */\n// eslint-disable-next-line no-redeclare\nvar Scrubber = {\n  setScrubber: function setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify: function stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\n\nvar _excluded$2 = [\"text\"],\n  _excluded2$2 = [\"anchor\", \"focus\", \"merge\"];\nfunction _createForOfIteratorHelper$k(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$k(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$k(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$k(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$k(o, minLen); }\nfunction _arrayLikeToArray$k(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Text = {\n  equals: function equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$loose = options.loose,\n      loose = _options$loose === void 0 ? false : _options$loose;\n    function omitText(obj) {\n      obj.text;\n        var rest = _objectWithoutProperties(obj, _excluded$2);\n      return rest;\n    }\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n  isText: function isText(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.text === 'string';\n  },\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Text.isText(val);\n    });\n  },\n  isTextProps: function isTextProps(props) {\n    return props.text !== undefined;\n  },\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  decorations: function decorations(node, _decorations) {\n    var leaves = [_objectSpread$a({}, node)];\n    var _iterator = _createForOfIteratorHelper$k(_decorations),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dec = _step.value;\n        var anchor = dec.anchor,\n          focus = dec.focus,\n          mergeDecoration = dec.merge,\n          rest = _objectWithoutProperties(dec, _excluded2$2);\n        var _Range$edges = Range.edges(dec),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n        var next = [];\n        var leafEnd = 0;\n        var decorationStart = start.offset;\n        var decorationEnd = end.offset;\n        var merge = mergeDecoration !== null && mergeDecoration !== void 0 ? mergeDecoration : Object.assign;\n        var _iterator2 = _createForOfIteratorHelper$k(leaves),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var leaf = _step2.value;\n            var length = leaf.text.length;\n            var leafStart = leafEnd;\n            leafEnd += length;\n            // If the range encompasses the entire leaf, add the range.\n            if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n              merge(leaf, rest);\n              next.push(leaf);\n              continue;\n            }\n            // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n            if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n              next.push(leaf);\n              continue;\n            }\n            // Otherwise we need to split the leaf, at the start, end, or both,\n            // and add the range to the middle intersecting section. Do the end\n            // split first since we don't need to update the offset that way.\n            var middle = leaf;\n            var before = void 0;\n            var after = void 0;\n            if (decorationEnd < leafEnd) {\n              var off = decorationEnd - leafStart;\n              after = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(off)\n              });\n              middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(0, off)\n              });\n            }\n            if (decorationStart > leafStart) {\n              var _off = decorationStart - leafStart;\n              before = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(0, _off)\n              });\n              middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(_off)\n              });\n            }\n            merge(middle, rest);\n            if (before) {\n              next.push(before);\n            }\n            next.push(middle);\n            if (after) {\n              next.push(after);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        leaves = next;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return leaves;\n  }\n};\n\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */\nvar getDefaultInsertLocation = function getDefaultInsertLocation(editor) {\n  if (editor.selection) {\n    return editor.selection;\n  } else if (editor.children.length > 0) {\n    return Editor.end(editor, []);\n  } else {\n    return [0];\n  }\n};\n\nvar matchPath = function matchPath(editor, path) {\n  var _Editor$node = Editor.node(editor, path),\n    _Editor$node2 = _slicedToArray(_Editor$node, 1),\n    node = _Editor$node2[0];\n  return function (n) {\n    return n === node;\n  };\n};\n\nfunction _createForOfIteratorHelper$j(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$j(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$j(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$j(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(o, minLen); }\nfunction _arrayLikeToArray$j(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\n * Get the distance to the end of the first character in a string of text.\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0;\n  // Evaluation of these conditions are deferred.\n  var gb11 = null; // Is GB11 applicable?\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n  var _iterator = _createForOfIteratorHelper$j(codepoints),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n      var code = _char.codePointAt(0);\n      if (!code) break;\n      var type = getCodepointType(_char, code);\n      var _ref = isLTR ? [right, type] : [type, left];\n      var _ref2 = _slicedToArray(_ref, 2);\n      left = _ref2[0];\n      right = _ref2[1];\n      if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n        if (isLTR) {\n          gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n        } else {\n          gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n        }\n        if (!gb11) break;\n      }\n      if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n        if (gb12Or13 !== null) {\n          gb12Or13 = !gb12Or13;\n        } else {\n          if (isLTR) {\n            gb12Or13 = true;\n          } else {\n            gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n          }\n        }\n        if (!gb12Or13) break;\n      }\n      if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n        break;\n      }\n      distance += _char.length;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u002B\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * Get the distance to the end of the first word in a string of text.\n */\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var _splitByCharacterDist = splitByCharacterDistance(text, charDist, isRTL),\n      _splitByCharacterDist2 = _slicedToArray(_splitByCharacterDist, 2),\n      _char2 = _splitByCharacterDist2[0],\n      remaining = _splitByCharacterDist2[1];\n    if (isWordCharacter(_char2, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n    text = remaining;\n  }\n  return dist;\n};\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */\nvar splitByCharacterDistance = function splitByCharacterDistance(str, dist, isRTL) {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\nvar isWordCharacter = function isWordCharacter(_char3, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (SPACE.test(_char3)) {\n    return false;\n  }\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(_char3)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var _splitByCharacterDist3 = splitByCharacterDistance(remaining, charDist, isRTL),\n      _splitByCharacterDist4 = _slicedToArray(_splitByCharacterDist3, 2),\n      nextChar = _splitByCharacterDist4[0],\n      nextRemaining = _splitByCharacterDist4[1];\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n  if (PUNCTUATION.test(_char3)) {\n    return false;\n  }\n  return true;\n};\n/**\n * Iterate on codepoints from right to left.\n */\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n    yield char1;\n  }\n};\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isHighSurrogate = function isHighSurrogate(charCode) {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isLowSurrogate = function isLowSurrogate(charCode) {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = function getCodepointType(_char4, code) {\n  var type = CodepointType.Any;\n  if (_char4.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n  if (_char4.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n  if (_char4.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n  if (_char4.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n  if (_char4.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n  if (_char4.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n  if (_char4.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n  if (_char4.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n  if (_char4.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n  return type;\n};\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],\n// GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],\n// GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T],\n// GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],\n// GB9a\n[CodepointType.Any, CodepointType.SpacingMark],\n// GB9b\n[CodepointType.Prepend, CodepointType.Any],\n// GB11\n[CodepointType.ZWJ, CodepointType.ExtPict],\n// GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(function (r) {\n    return intersects(left, r[0]) && intersects(right, r[1]);\n  }) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = function endsWithEmojiZWJ(str) {\n  return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = function endsWithOddNumberOfRIs(str) {\n  var match = str.match(endingRIs);\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar TextTransforms = {\n  \"delete\": function _delete(editor, options) {\n    editor[\"delete\"](options);\n  },\n  insertFragment: function insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids;\n      var _options$at = options.at,\n        at = _options$at === void 0 ? getDefaultInsertLocation(editor) : _options$at;\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at,\n            voids: voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      }) || Editor.elementReadOnly(editor, {\n        at: at\n      })) {\n        return;\n      }\n      var _at = at,\n        path = _at.path,\n        offset = _at.offset;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n// perf\nvar BATCHING_DIRTY_PATHS = new WeakMap();\nvar isBatchingDirtyPaths = function isBatchingDirtyPaths(editor) {\n  return BATCHING_DIRTY_PATHS.get(editor) || false;\n};\nvar batchDirtyPaths = function batchDirtyPaths(editor, fn, update) {\n  var value = BATCHING_DIRTY_PATHS.get(editor) || false;\n  BATCHING_DIRTY_PATHS.set(editor, true);\n  try {\n    fn();\n    update();\n  } finally {\n    BATCHING_DIRTY_PATHS.set(editor, value);\n  }\n};\n\nfunction _createForOfIteratorHelper$i(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$i(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$i(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$i(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen); }\nfunction _arrayLikeToArray$i(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * update editor dirty paths\n *\n * @param newDirtyPaths: Path[]; new dirty paths\n * @param transform: (p: Path) => Path | null; how to transform existing dirty paths\n */\nfunction updateDirtyPaths(editor, newDirtyPaths, transform) {\n  var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n  var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n  var dirtyPaths;\n  var dirtyPathKeys;\n  var add = function add(path) {\n    if (path) {\n      var key = path.join(',');\n      if (!dirtyPathKeys.has(key)) {\n        dirtyPathKeys.add(key);\n        dirtyPaths.push(path);\n      }\n    }\n  };\n  if (transform) {\n    dirtyPaths = [];\n    dirtyPathKeys = new Set();\n    var _iterator = _createForOfIteratorHelper$i(oldDirtyPaths),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var path = _step.value;\n        var newPath = transform(path);\n        add(newPath);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    dirtyPaths = oldDirtyPaths;\n    dirtyPathKeys = oldDirtyPathKeys;\n  }\n  var _iterator2 = _createForOfIteratorHelper$i(newDirtyPaths),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _path = _step2.value;\n      add(_path);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  DIRTY_PATHS.set(editor, dirtyPaths);\n  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n}\n\nfunction _createForOfIteratorHelper$h(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$h(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$h(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$h(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen); }\nfunction _arrayLikeToArray$h(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar apply = function apply(editor, op) {\n  var _iterator = _createForOfIteratorHelper$h(Editor.pathRefs(editor)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ref = _step.value;\n      PathRef.transform(ref, op);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper$h(Editor.pointRefs(editor)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _ref = _step2.value;\n      PointRef.transform(_ref, op);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var _iterator3 = _createForOfIteratorHelper$h(Editor.rangeRefs(editor)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ref2 = _step3.value;\n      RangeRef.transform(_ref2, op);\n    }\n    // update dirty paths\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  if (!isBatchingDirtyPaths(editor)) {\n    var transform = Path.operationCanTransformPath(op) ? function (p) {\n      return Path.transform(p, op);\n    } : undefined;\n    updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);\n  }\n  Transforms.transform(editor, op);\n  editor.operations.push(op);\n  Editor.normalize(editor, {\n    operation: op\n  });\n  // Clear any formats applied to the cursor if the selection changes.\n  if (op.type === 'set_selection') {\n    editor.marks = null;\n  }\n  if (!FLUSHING.get(editor)) {\n    FLUSHING.set(editor, true);\n    Promise.resolve().then(function () {\n      FLUSHING.set(editor, false);\n      editor.onChange({\n        operation: op\n      });\n      editor.operations = [];\n    });\n  }\n};\n\nfunction _createForOfIteratorHelper$g(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$g(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$g(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$g(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen); }\nfunction _arrayLikeToArray$g(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\nvar getDirtyPaths = function getDirtyPaths(editor, op) {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var path = op.path;\n        return Path.levels(path);\n      }\n    case 'insert_node':\n      {\n        var node = op.node,\n          _path = op.path;\n        var levels = Path.levels(_path);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            p = _ref2[1];\n          return _path.concat(p);\n        });\n        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n      }\n    case 'merge_node':\n      {\n        var _path2 = op.path;\n        var ancestors = Path.ancestors(_path2);\n        var previousPath = Path.previous(_path2);\n        return [].concat(_toConsumableArray(ancestors), [previousPath]);\n      }\n    case 'move_node':\n      {\n        var _path3 = op.path,\n          newPath = op.newPath;\n        if (Path.equals(_path3, newPath)) {\n          return [];\n        }\n        var oldAncestors = [];\n        var newAncestors = [];\n        var _iterator = _createForOfIteratorHelper$g(Path.ancestors(_path3)),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var ancestor = _step.value;\n            var p = Path.transform(ancestor, op);\n            oldAncestors.push(p);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var _iterator2 = _createForOfIteratorHelper$g(Path.ancestors(newPath)),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _ancestor = _step2.value;\n            var _p = Path.transform(_ancestor, op);\n            newAncestors.push(_p);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [].concat(oldAncestors, newAncestors, [resultPath]);\n      }\n    case 'remove_node':\n      {\n        var _path4 = op.path;\n        var _ancestors = Path.ancestors(_path4);\n        return _toConsumableArray(_ancestors);\n      }\n    case 'split_node':\n      {\n        var _path5 = op.path;\n        var _levels = Path.levels(_path5);\n        var nextPath = Path.next(_path5);\n        return [].concat(_toConsumableArray(_levels), [nextPath]);\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nvar getFragment = function getFragment(editor) {\n  var selection = editor.selection;\n  if (selection) {\n    return Node.fragment(editor, selection);\n  }\n  return [];\n};\n\nvar normalizeNode = function normalizeNode(editor, entry) {\n  var _entry = _slicedToArray(entry, 2),\n    node = _entry[0],\n    path = _entry[1];\n  // There are no core normalizations for text nodes.\n  if (Text.isText(node)) {\n    return;\n  }\n  // Ensure that block and inline nodes have at least one text child.\n  if (Element.isElement(node) && node.children.length === 0) {\n    var child = {\n      text: ''\n    };\n    Transforms.insertNodes(editor, child, {\n      at: path.concat(0),\n      voids: true\n    });\n    return;\n  }\n  // Determine whether the node should have block or inline children.\n  var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n  // Since we'll be applying operations while iterating, keep track of an\n  // index that accounts for any added/removed nodes.\n  var n = 0;\n  for (var i = 0; i < node.children.length; i++, n++) {\n    var currentNode = Node.get(editor, path);\n    if (Text.isText(currentNode)) continue;\n    var _child = currentNode.children[n];\n    var prev = currentNode.children[n - 1];\n    var isLast = i === node.children.length - 1;\n    var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);\n    // Only allow block nodes in the top-level children and parent blocks\n    // that only contain block nodes. Similarly, only allow inline nodes in\n    // other inline nodes, or parent blocks that only contain inlines and\n    // text.\n    if (isInlineOrText !== shouldHaveInlines) {\n      if (isInlineOrText) {\n        Transforms.removeNodes(editor, {\n          at: path.concat(n),\n          voids: true\n        });\n      } else {\n        Transforms.unwrapNodes(editor, {\n          at: path.concat(n),\n          voids: true\n        });\n      }\n      n--;\n    } else if (Element.isElement(_child)) {\n      // Ensure that inline nodes are surrounded by text nodes.\n      if (editor.isInline(_child)) {\n        if (prev == null || !Text.isText(prev)) {\n          var newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n),\n            voids: true\n          });\n          n++;\n        } else if (isLast) {\n          var _newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, _newChild, {\n            at: path.concat(n + 1),\n            voids: true\n          });\n          n++;\n        }\n      }\n    } else {\n      // If the child is not a text node, and doesn't have a `children` field,\n      // then we have an invalid node that will upset slate.\n      //\n      // eg: `{ type: 'some_node' }`.\n      //\n      // To prevent slate from breaking, we can add the `children` field,\n      // and now that it is valid, we can to many more operations easily,\n      // such as extend normalizers to fix erronous structure.\n      if (!Text.isText(_child) && !('children' in _child)) {\n        var elementChild = _child;\n        elementChild.children = [];\n      }\n      // Merge adjacent text nodes that are empty or match.\n      if (prev != null && Text.isText(prev)) {\n        if (Text.equals(_child, prev, {\n          loose: true\n        })) {\n          Transforms.mergeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (prev.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n - 1),\n            voids: true\n          });\n          n--;\n        } else if (_child.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        }\n      }\n    }\n  }\n};\n\nvar shouldNormalize = function shouldNormalize(editor, _ref) {\n  var iteration = _ref.iteration,\n    initialDirtyPathsLength = _ref.initialDirtyPathsLength;\n  var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n  if (iteration > maxIterations) {\n    throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n  }\n  return true;\n};\n\nfunction _createForOfIteratorHelper$f(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$f(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$f(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$f(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen); }\nfunction _arrayLikeToArray$f(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar above = function above(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids,\n    _options$mode = options.mode,\n    mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n    _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at,\n    match = options.match;\n  if (!at) {\n    return;\n  }\n  var path = Editor.path(editor, at);\n  var reverse = mode === 'lowest';\n  var _iterator = _createForOfIteratorHelper$f(Editor.levels(editor, {\n      at: path,\n      voids: voids,\n      match: match,\n      reverse: reverse\n    })),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        n = _step$value[0],\n        p = _step$value[1];\n      if (Text.isText(n)) continue;\n      if (Range.isRange(at)) {\n        if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n          return [n, p];\n        }\n      } else {\n        if (!Path.equals(path, p)) {\n          return [n, p];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\nfunction ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar addMark = function addMark(editor, key, value) {\n  var selection = editor.selection;\n  if (selection) {\n    var match = function match(node, path) {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var _Editor$parent = Editor.parent(editor, path),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 2),\n        parentNode = _Editor$parent2[0];\n        _Editor$parent2[1];\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var _Editor$node = Editor.node(editor, selection),\n        _Editor$node2 = _slicedToArray(_Editor$node, 2),\n        selectedNode = _Editor$node2[0],\n        selectedPath = _Editor$node2[1];\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var _Editor$parent3 = Editor.parent(editor, selectedPath),\n          _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n          parentNode = _Editor$parent4[0];\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor, _defineProperty({}, key, value), {\n        match: match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, _defineProperty({}, key, value));\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nfunction ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelper$e(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$e(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$e(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen); }\nfunction _arrayLikeToArray$e(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar after = function after(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  var focus = Editor.end(editor, []);\n  var range = {\n    anchor: anchor,\n    focus: focus\n  };\n  var _options$distance = options.distance,\n    distance = _options$distance === void 0 ? 1 : _options$distance;\n  var d = 0;\n  var target;\n  var _iterator = _createForOfIteratorHelper$e(Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n      at: range\n    }))),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var p = _step.value;\n      if (d > distance) {\n        break;\n      }\n      if (d !== 0) {\n        target = p;\n      }\n      d++;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return target;\n};\n\nfunction ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelper$d(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$d(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$d(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$d(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen); }\nfunction _arrayLikeToArray$d(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar before = function before(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.start(editor, []);\n  var focus = Editor.point(editor, at, {\n    edge: 'start'\n  });\n  var range = {\n    anchor: anchor,\n    focus: focus\n  };\n  var _options$distance = options.distance,\n    distance = _options$distance === void 0 ? 1 : _options$distance;\n  var d = 0;\n  var target;\n  var _iterator = _createForOfIteratorHelper$d(Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n      at: range,\n      reverse: true\n    }))),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var p = _step.value;\n      if (d > distance) {\n        break;\n      }\n      if (d !== 0) {\n        target = p;\n      }\n      d++;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return target;\n};\n\nvar deleteBackward = function deleteBackward(editor, unit) {\n  var selection = editor.selection;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms[\"delete\"](editor, {\n      unit: unit,\n      reverse: true\n    });\n  }\n};\n\nvar deleteForward = function deleteForward(editor, unit) {\n  var selection = editor.selection;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms[\"delete\"](editor, {\n      unit: unit\n    });\n  }\n};\n\nvar deleteFragment = function deleteFragment(editor) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$direction = _ref.direction,\n    direction = _ref$direction === void 0 ? 'forward' : _ref$direction;\n  var selection = editor.selection;\n  if (selection && Range.isExpanded(selection)) {\n    Transforms[\"delete\"](editor, {\n      reverse: direction === 'backward'\n    });\n  }\n};\n\nvar edges = function edges(editor, at) {\n  return [Editor.start(editor, at), Editor.end(editor, at)];\n};\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar elementReadOnly = function elementReadOnly(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isElementReadOnly(editor, n);\n    }\n  }));\n};\n\nvar end = function end(editor, at) {\n  return Editor.point(editor, at, {\n    edge: 'end'\n  });\n};\n\nvar first = function first(editor, at) {\n  var path = Editor.path(editor, at, {\n    edge: 'start'\n  });\n  return Editor.node(editor, path);\n};\n\nvar fragment = function fragment(editor, at) {\n  var range = Editor.range(editor, at);\n  return Node.fragment(editor, range);\n};\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar getVoid = function getVoid(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isVoid(editor, n);\n    }\n  }));\n};\n\nvar hasBlocks = function hasBlocks(editor, element) {\n  return element.children.some(function (n) {\n    return Element.isElement(n) && Editor.isBlock(editor, n);\n  });\n};\n\nvar hasInlines = function hasInlines(editor, element) {\n  return element.children.some(function (n) {\n    return Text.isText(n) || Editor.isInline(editor, n);\n  });\n};\n\nvar hasPath = function hasPath(editor, path) {\n  return Node.has(editor, path);\n};\n\nvar hasTexts = function hasTexts(editor, element) {\n  return element.children.every(function (n) {\n    return Text.isText(n);\n  });\n};\n\nvar insertBreak = function insertBreak(editor) {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nvar insertNode = function insertNode(editor, node, options) {\n  Transforms.insertNodes(editor, node, options);\n};\n\nvar insertSoftBreak = function insertSoftBreak(editor) {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar insertText = function insertText(editor, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var selection = editor.selection,\n    marks = editor.marks;\n  if (selection) {\n    if (marks) {\n      var node = _objectSpread$3({\n        text: text\n      }, marks);\n      Transforms.insertNodes(editor, node, {\n        at: options.at,\n        voids: options.voids\n      });\n    } else {\n      Transforms.insertText(editor, text, options);\n    }\n    editor.marks = null;\n  }\n};\n\nvar isBlock = function isBlock(editor, value) {\n  return !editor.isInline(value);\n};\n\nvar isEdge = function isEdge(editor, point, at) {\n  return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\n\nvar isEmpty = function isEmpty(editor, element) {\n  var children = element.children;\n  var _children = _slicedToArray(children, 1),\n    first = _children[0];\n  return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n};\n\nvar isEnd = function isEnd(editor, point, at) {\n  var end = Editor.end(editor, at);\n  return Point.equals(point, end);\n};\n\nvar isNormalizing = function isNormalizing(editor) {\n  var isNormalizing = NORMALIZING.get(editor);\n  return isNormalizing === undefined ? true : isNormalizing;\n};\n\nvar isStart = function isStart(editor, point, at) {\n  // PERF: If the offset isn't `0` we know it's not the start.\n  if (point.offset !== 0) {\n    return false;\n  }\n  var start = Editor.start(editor, at);\n  return Point.equals(point, start);\n};\n\nvar last = function last(editor, at) {\n  var path = Editor.path(editor, at, {\n    edge: 'end'\n  });\n  return Editor.node(editor, path);\n};\n\nvar leaf = function leaf(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.leaf(editor, path);\n  return [node, path];\n};\n\nfunction _createForOfIteratorHelper$c(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$c(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$c(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$c(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen); }\nfunction _arrayLikeToArray$c(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction levels(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match;\n    if (match == null) {\n      match = function match() {\n        return true;\n      };\n    }\n    if (!at) {\n      return;\n    }\n    var levels = [];\n    var path = Editor.path(editor, at);\n    var _iterator = _createForOfIteratorHelper$c(Node.levels(editor, path)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          n = _step$value[0],\n          p = _step$value[1];\n        if (!match(n, p)) {\n          continue;\n        }\n        levels.push([n, p]);\n        if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (reverse) {\n      levels.reverse();\n    }\n    yield* levels;\n  }();\n}\n\nvar _excluded$1 = [\"text\"],\n  _excluded2$1 = [\"text\"];\nvar marks = function marks(editor) {\n  var marks = editor.marks,\n    selection = editor.selection;\n  if (!selection) {\n    return null;\n  }\n  var anchor = selection.anchor,\n    focus = selection.focus;\n  if (marks) {\n    return marks;\n  }\n  if (Range.isExpanded(selection)) {\n    var isBackward = Range.isBackward(selection);\n    if (isBackward) {\n      var _ref = [anchor, focus];\n      focus = _ref[0];\n      anchor = _ref[1];\n    }\n    /**\n     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)\n     * do not adversely affect the returned marks.\n     */\n    var isEnd = Editor.isEnd(editor, anchor, anchor.path);\n    if (isEnd) {\n      var after = Editor.after(editor, anchor);\n      if (after) {\n        anchor = after;\n      }\n    }\n    var _Editor$nodes = Editor.nodes(editor, {\n        match: Text.isText,\n        at: {\n          anchor: anchor,\n          focus: focus\n        }\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      match = _Editor$nodes2[0];\n    if (match) {\n      var _match = _slicedToArray(match, 1),\n        _node = _match[0];\n      _node.text;\n        var _rest = _objectWithoutProperties(_node, _excluded$1);\n      return _rest;\n    } else {\n      return {};\n    }\n  }\n  var _anchor = anchor,\n    path = _anchor.path;\n  var _Editor$leaf = Editor.leaf(editor, path),\n    _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n    node = _Editor$leaf2[0];\n  if (anchor.offset === 0) {\n    var prev = Editor.previous(editor, {\n      at: path,\n      match: Text.isText\n    });\n    var markedVoid = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n);\n      }\n    });\n    if (!markedVoid) {\n      var block = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      });\n      if (prev && block) {\n        var _prev = _slicedToArray(prev, 2),\n          prevNode = _prev[0],\n          prevPath = _prev[1];\n        var _block = _slicedToArray(block, 2),\n          blockPath = _block[1];\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n  }\n  var _node2 = node;\n    _node2.text;\n    var rest = _objectWithoutProperties(_node2, _excluded2$1);\n  return rest;\n};\n\nvar next = function next(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$mode = options.mode,\n    mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n    _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var match = options.match,\n    _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at;\n  if (!at) {\n    return;\n  }\n  var pointAfterLocation = Editor.after(editor, at, {\n    voids: voids\n  });\n  if (!pointAfterLocation) return;\n  var _Editor$last = Editor.last(editor, []),\n    _Editor$last2 = _slicedToArray(_Editor$last, 2),\n    to = _Editor$last2[1];\n  var span = [pointAfterLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the next node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var _Editor$parent = Editor.parent(editor, at),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n        parent = _Editor$parent2[0];\n      match = function match(n) {\n        return parent.children.includes(n);\n      };\n    } else {\n      match = function match() {\n        return true;\n      };\n    }\n  }\n  var _Editor$nodes = Editor.nodes(editor, {\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    next = _Editor$nodes2[0];\n  return next;\n};\n\nvar node = function node(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.get(editor, path);\n  return [node, path];\n};\n\nfunction _createForOfIteratorHelper$b(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }\nfunction _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction nodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'all' : _options$mode,\n      _options$universal = options.universal,\n      universal = _options$universal === void 0 ? false : _options$universal,\n      _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$ignoreNonSel = options.ignoreNonSelectable,\n      ignoreNonSelectable = _options$ignoreNonSel === void 0 ? false : _options$ignoreNonSel;\n    var match = options.match;\n    if (!match) {\n      match = function match() {\n        return true;\n      };\n    }\n    if (!at) {\n      return;\n    }\n    var from;\n    var to;\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n    var nodeEntries = Node.nodes(editor, {\n      reverse: reverse,\n      from: from,\n      to: to,\n      pass: function pass(_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          node = _ref2[0];\n        if (!Element.isElement(node)) return false;\n        if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n        if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;\n        return false;\n      }\n    });\n    var matches = [];\n    var hit;\n    var _iterator = _createForOfIteratorHelper$b(nodeEntries),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          node = _step$value[0],\n          path = _step$value[1];\n        if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {\n          continue;\n        }\n        var isLower = hit && Path.compare(path, hit[1]) === 0;\n        // In highest mode any node lower than the last hit is not a match.\n        if (mode === 'highest' && isLower) {\n          continue;\n        }\n        if (!match(node, path)) {\n          // If we've arrived at a leaf text node that is not lower than the last\n          // hit, then we've found a branch that doesn't include a match, which\n          // means the match is not universal.\n          if (universal && !isLower && Text.isText(node)) {\n            return;\n          } else {\n            continue;\n          }\n        }\n        // If there's a match and it's lower than the last, update the hit.\n        if (mode === 'lowest' && isLower) {\n          hit = [node, path];\n          continue;\n        }\n        // In lowest mode we emit the last hit, once it's guaranteed lowest.\n        var emit = mode === 'lowest' ? hit : [node, path];\n        if (emit) {\n          if (universal) {\n            matches.push(emit);\n          } else {\n            yield emit;\n          }\n        }\n        hit = [node, path];\n      }\n      // Since lowest is always emitting one behind, catch up at the end.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    }\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches;\n    }\n  }();\n}\n\nfunction _createForOfIteratorHelper$a(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }\nfunction _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar normalize = function normalize(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$force = options.force,\n    force = _options$force === void 0 ? false : _options$force,\n    operation = options.operation;\n  var getDirtyPaths = function getDirtyPaths(editor) {\n    return DIRTY_PATHS.get(editor) || [];\n  };\n  var getDirtyPathKeys = function getDirtyPathKeys(editor) {\n    return DIRTY_PATH_KEYS.get(editor) || new Set();\n  };\n  var popDirtyPath = function popDirtyPath(editor) {\n    var path = getDirtyPaths(editor).pop();\n    var key = path.join(',');\n    getDirtyPathKeys(editor)[\"delete\"](key);\n    return path;\n  };\n  if (!Editor.isNormalizing(editor)) {\n    return;\n  }\n  if (force) {\n    var allPaths = Array.from(Node.nodes(editor), function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return p;\n    });\n    var allPathKeys = new Set(allPaths.map(function (p) {\n      return p.join(',');\n    }));\n    DIRTY_PATHS.set(editor, allPaths);\n    DIRTY_PATH_KEYS.set(editor, allPathKeys);\n  }\n  if (getDirtyPaths(editor).length === 0) {\n    return;\n  }\n  Editor.withoutNormalizing(editor, function () {\n    /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */\n    var _iterator = _createForOfIteratorHelper$a(getDirtyPaths(editor)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _dirtyPath = _step.value;\n        if (Node.has(editor, _dirtyPath)) {\n          var _entry = Editor.node(editor, _dirtyPath);\n          var _entry2 = _slicedToArray(_entry, 2),\n            node = _entry2[0],\n            _ = _entry2[1];\n          /*\n            The default normalizer inserts an empty text node in this scenario, but it can be customised.\n            So there is some risk here.\n                     As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n            by definition adding children to an empty node can't cause other paths to change.\n          */\n          if (Element.isElement(node) && node.children.length === 0) {\n            editor.normalizeNode(_entry, {\n              operation: operation\n            });\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var dirtyPaths = getDirtyPaths(editor);\n    var initialDirtyPathsLength = dirtyPaths.length;\n    var iteration = 0;\n    while (dirtyPaths.length !== 0) {\n      if (!editor.shouldNormalize({\n        dirtyPaths: dirtyPaths,\n        iteration: iteration,\n        initialDirtyPathsLength: initialDirtyPathsLength,\n        operation: operation\n      })) {\n        return;\n      }\n      var dirtyPath = popDirtyPath(editor);\n      // If the node doesn't exist in the tree, it does not need to be normalized.\n      if (Node.has(editor, dirtyPath)) {\n        var entry = Editor.node(editor, dirtyPath);\n        editor.normalizeNode(entry, {\n          operation: operation\n        });\n      }\n      iteration++;\n      dirtyPaths = getDirtyPaths(editor);\n    }\n  });\n};\n\nvar parent = function parent(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var parentPath = Path.parent(path);\n  var entry = Editor.node(editor, parentPath);\n  return entry;\n};\n\nvar pathRef = function pathRef(editor, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$affinity = options.affinity,\n    affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n  var ref = {\n    current: path,\n    affinity: affinity,\n    unref: function unref() {\n      var current = ref.current;\n      var pathRefs = Editor.pathRefs(editor);\n      pathRefs[\"delete\"](ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pathRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pathRefs = function pathRefs(editor) {\n  var refs = PATH_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    PATH_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar path = function path(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var depth = options.depth,\n    edge = options.edge;\n  if (Path.isPath(at)) {\n    if (edge === 'start') {\n      var _Node$first = Node.first(editor, at),\n        _Node$first2 = _slicedToArray(_Node$first, 2),\n        firstPath = _Node$first2[1];\n      at = firstPath;\n    } else if (edge === 'end') {\n      var _Node$last = Node.last(editor, at),\n        _Node$last2 = _slicedToArray(_Node$last, 2),\n        lastPath = _Node$last2[1];\n      at = lastPath;\n    }\n  }\n  if (Range.isRange(at)) {\n    if (edge === 'start') {\n      at = Range.start(at);\n    } else if (edge === 'end') {\n      at = Range.end(at);\n    } else {\n      at = Path.common(at.anchor.path, at.focus.path);\n    }\n  }\n  if (Point.isPoint(at)) {\n    at = at.path;\n  }\n  if (depth != null) {\n    at = at.slice(0, depth);\n  }\n  return at;\n};\n\nvar pointRef = function pointRef(editor, point) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$affinity = options.affinity,\n    affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n  var ref = {\n    current: point,\n    affinity: affinity,\n    unref: function unref() {\n      var current = ref.current;\n      var pointRefs = Editor.pointRefs(editor);\n      pointRefs[\"delete\"](ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pointRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pointRefs = function pointRefs(editor) {\n  var refs = POINT_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    POINT_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar point = function point(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? 'start' : _options$edge;\n  if (Path.isPath(at)) {\n    var path;\n    if (edge === 'end') {\n      var _Node$last = Node.last(editor, at),\n        _Node$last2 = _slicedToArray(_Node$last, 2),\n        lastPath = _Node$last2[1];\n      path = lastPath;\n    } else {\n      var _Node$first = Node.first(editor, at),\n        _Node$first2 = _slicedToArray(_Node$first, 2),\n        firstPath = _Node$first2[1];\n      path = firstPath;\n    }\n    var node = Node.get(editor, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n    }\n    return {\n      path: path,\n      offset: edge === 'end' ? node.text.length : 0\n    };\n  }\n  if (Range.isRange(at)) {\n    var _Range$edges = Range.edges(at),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      start = _Range$edges2[0],\n      end = _Range$edges2[1];\n    return edge === 'start' ? start : end;\n  }\n  return at;\n};\n\nfunction _createForOfIteratorHelper$9(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }\nfunction _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction positions(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$unit = options.unit,\n      unit = _options$unit === void 0 ? 'offset' : _options$unit,\n      _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$ignoreNonSel = options.ignoreNonSelectable,\n      ignoreNonSelectable = _options$ignoreNonSel === void 0 ? false : _options$ignoreNonSel;\n    if (!at) {\n      return;\n    }\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n    var range = Editor.range(editor, at);\n    var _Range$edges = Range.edges(range),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      start = _Range$edges2[0],\n      end = _Range$edges2[1];\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0;\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    var _iterator = _createForOfIteratorHelper$9(Editor.nodes(editor, {\n        at: at,\n        reverse: reverse,\n        voids: voids,\n        ignoreNonSelectable: ignoreNonSelectable\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          node = _step$value[0],\n          path = _step$value[1];\n        /*\n         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n         */\n        if (Element.isElement(node)) {\n          // Void nodes are a special case, so by default we will always\n          // yield their first point. If the `voids` option is set to true,\n          // then we will iterate over their content.\n          if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n            yield Editor.start(editor, path);\n            continue;\n          }\n          // Inline element nodes are ignored as they don't themselves\n          // contribute to `blockText` or `leafText` - their parent and\n          // children do.\n          if (editor.isInline(node)) continue;\n          // Block element node - set `blockText` to its text content.\n          if (Editor.hasInlines(editor, node)) {\n            // We always exhaust block nodes before encountering a new one:\n            //   console.assert(blockText === '',\n            //     `blockText='${blockText}' - `+\n            //     `not exhausted before new block node`, path)\n            // Ensure range considered is capped to `range`, in the\n            // start/end edge cases where block extends beyond range.\n            // Equivalent to this, but presumably more performant:\n            //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n            //   blockRange = Range.intersection(range, blockRange) // intersect\n            //   blockText = Editor.string(editor, blockRange, { voids })\n            var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n            var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n            blockText = Editor.string(editor, {\n              anchor: s,\n              focus: e\n            }, {\n              voids: voids\n            });\n            isNewBlock = true;\n          }\n        }\n        /*\n         * TEXT LEAF NODE - Iterate through text content, yielding\n         * positions every `distance` offset according to `unit`.\n         */\n        if (Text.isText(node)) {\n          var isFirst = Path.equals(path, first.path);\n          // Proof that we always exhaust text nodes before encountering a new one:\n          //   console.assert(leafTextRemaining <= 0,\n          //     `leafTextRemaining=${leafTextRemaining} - `+\n          //     `not exhausted before new leaf text node`, path)\n          // Reset `leafText` counters for new text node.\n          if (isFirst) {\n            leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n            leafTextOffset = first.offset; // Works for reverse too.\n          } else {\n            leafTextRemaining = node.text.length;\n            leafTextOffset = reverse ? leafTextRemaining : 0;\n          }\n          // Yield position at the start of node (potentially).\n          if (isFirst || isNewBlock || unit === 'offset') {\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n            isNewBlock = false;\n          }\n          // Yield positions every (dynamically calculated) `distance` offset.\n          while (true) {\n            // If `leafText` has caught up with `blockText` (distance=0),\n            // and if blockText is exhausted, break to get another block node,\n            // otherwise advance blockText forward by the new `distance`.\n            if (distance === 0) {\n              if (blockText === '') break;\n              distance = calcDistance(blockText, unit, reverse);\n              // Split the string at the previously found distance and use the\n              // remaining string for the next iteration.\n              blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n            }\n            // Advance `leafText` by the current `distance`.\n            leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n            leafTextRemaining = leafTextRemaining - distance;\n            // If `leafText` is exhausted, break to get a new leaf node\n            // and set distance to the overflow amount, so we'll (maybe)\n            // catch up to blockText in the next leaf text node.\n            if (leafTextRemaining < 0) {\n              distance = -leafTextRemaining;\n              break;\n            }\n            // Successfully walked `distance` offsets through `leafText`\n            // to catch up with `blockText`, so we can reset `distance`\n            // and yield this position in this node.\n            distance = 0;\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n          }\n        }\n      }\n      // Proof that upon completion, we've exahusted both leaf and block text:\n      //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n      //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n      // Helper:\n      // Return the distance in offsets for a step of size `unit` on given string.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n      return 1;\n    }\n  }();\n}\n\nvar previous = function previous(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$mode = options.mode,\n    mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n    _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var match = options.match,\n    _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at;\n  if (!at) {\n    return;\n  }\n  var pointBeforeLocation = Editor.before(editor, at, {\n    voids: voids\n  });\n  if (!pointBeforeLocation) {\n    return;\n  }\n  var _Editor$first = Editor.first(editor, []),\n    _Editor$first2 = _slicedToArray(_Editor$first, 2),\n    to = _Editor$first2[1];\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  var span = [pointBeforeLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the previous node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var _Editor$parent = Editor.parent(editor, at),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n        parent = _Editor$parent2[0];\n      match = function match(n) {\n        return parent.children.includes(n);\n      };\n    } else {\n      match = function match() {\n        return true;\n      };\n    }\n  }\n  var _Editor$nodes = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    previous = _Editor$nodes2[0];\n  return previous;\n};\n\nvar rangeRef = function rangeRef(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$affinity = options.affinity,\n    affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n  var ref = {\n    current: range,\n    affinity: affinity,\n    unref: function unref() {\n      var current = ref.current;\n      var rangeRefs = Editor.rangeRefs(editor);\n      rangeRefs[\"delete\"](ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.rangeRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar rangeRefs = function rangeRefs(editor) {\n  var refs = RANGE_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    RANGE_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar range = function range(editor, at, to) {\n  if (Range.isRange(at) && !to) {\n    return at;\n  }\n  var start = Editor.start(editor, at);\n  var end = Editor.end(editor, to || at);\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar removeMark = function removeMark(editor, key) {\n  var selection = editor.selection;\n  if (selection) {\n    var match = function match(node, path) {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var _Editor$parent = Editor.parent(editor, path),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 2),\n        parentNode = _Editor$parent2[0];\n        _Editor$parent2[1];\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var _Editor$node = Editor.node(editor, selection),\n        _Editor$node2 = _slicedToArray(_Editor$node, 2),\n        selectedNode = _Editor$node2[0],\n        selectedPath = _Editor$node2[1];\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var _Editor$parent3 = Editor.parent(editor, selectedPath),\n          _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n          parentNode = _Editor$parent4[0];\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.unsetNodes(editor, key, {\n        match: match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n      delete marks[key];\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nvar setNormalizing = function setNormalizing(editor, isNormalizing) {\n  NORMALIZING.set(editor, isNormalizing);\n};\n\nvar start = function start(editor, at) {\n  return Editor.point(editor, at, {\n    edge: 'start'\n  });\n};\n\nfunction _createForOfIteratorHelper$8(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }\nfunction _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar string = function string(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var range = Editor.range(editor, at);\n  var _Range$edges = Range.edges(range),\n    _Range$edges2 = _slicedToArray(_Range$edges, 2),\n    start = _Range$edges2[0],\n    end = _Range$edges2[1];\n  var text = '';\n  var _iterator = _createForOfIteratorHelper$8(Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids: voids\n    })),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        node = _step$value[0],\n        path = _step$value[1];\n      var t = node.text;\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset);\n      }\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset);\n      }\n      text += t;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return text;\n};\n\nfunction _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }\nfunction _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar unhangRange = function unhangRange(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var _Range$edges = Range.edges(range),\n    _Range$edges2 = _slicedToArray(_Range$edges, 2),\n    start = _Range$edges2[0],\n    end = _Range$edges2[1];\n  // PERF: exit early if we can guarantee that the range isn't hanging.\n  if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n    return range;\n  }\n  var endBlock = Editor.above(editor, {\n    at: end,\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isBlock(editor, n);\n    },\n    voids: voids\n  });\n  var blockPath = endBlock ? endBlock[1] : [];\n  var first = Editor.start(editor, start);\n  var before = {\n    anchor: first,\n    focus: end\n  };\n  var skip = true;\n  var _iterator = _createForOfIteratorHelper$7(Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids: voids\n    })),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        node = _step$value[0],\n        path = _step$value[1];\n      if (skip) {\n        skip = false;\n        continue;\n      }\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = {\n          path: path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nvar withoutNormalizing = function withoutNormalizing(editor, fn) {\n  var value = Editor.isNormalizing(editor);\n  Editor.setNormalizing(editor, false);\n  try {\n    fn();\n  } finally {\n    Editor.setNormalizing(editor, value);\n  }\n  Editor.normalize(editor);\n};\n\nvar shouldMergeNodesRemovePrevNode = function shouldMergeNodesRemovePrevNode(editor, _ref, _ref2) {\n  var _ref3 = _slicedToArray(_ref, 2),\n    prevNode = _ref3[0],\n    prevPath = _ref3[1];\n  var _ref4 = _slicedToArray(_ref2, 2);\n    _ref4[0];\n    _ref4[1];\n  // If the target node that we're merging with is empty, remove it instead\n  // of merging the two. This is a common rich text editor behavior to\n  // prevent losing formatting when deleting entire nodes when you have a\n  // hanging selection.\n  // if prevNode is first child in parent,don't remove it.\n  return Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0;\n};\n\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }\nfunction _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar deleteText = function deleteText(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _Editor$void, _Editor$void2;\n    var _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$unit = options.unit,\n      unit = _options$unit === void 0 ? 'character' : _options$unit,\n      _options$distance = options.distance,\n      distance = _options$distance === void 0 ? 1 : _options$distance,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging;\n    if (!at) {\n      return;\n    }\n    var isCollapsed = false;\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      isCollapsed = true;\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      var furthestVoid = Editor[\"void\"](editor, {\n        at: at,\n        mode: 'highest'\n      });\n      if (!voids && furthestVoid) {\n        var _furthestVoid = _slicedToArray(furthestVoid, 2),\n          voidPath = _furthestVoid[1];\n        at = voidPath;\n      } else {\n        var opts = {\n          unit: unit,\n          distance: distance\n        };\n        var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at: at,\n        voids: voids\n      });\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      var _Range$edges = Range.edges(at),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        _end = _Range$edges2[1];\n      var endOfDoc = Editor.end(editor, []);\n      if (!Point.equals(_end, endOfDoc)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n    }\n    var _Range$edges3 = Range.edges(at),\n      _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n      start = _Range$edges4[0],\n      end = _Range$edges4[1];\n    var startBlock = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      at: start,\n      voids: voids\n    });\n    var endBlock = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      at: end,\n      voids: voids\n    });\n    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    var isSingleText = Path.equals(start.path, end.path);\n    var startNonEditable = voids ? null : (_Editor$void = Editor[\"void\"](editor, {\n      at: start,\n      mode: 'highest'\n    })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n      at: start,\n      mode: 'highest'\n    });\n    var endNonEditable = voids ? null : (_Editor$void2 = Editor[\"void\"](editor, {\n      at: end,\n      mode: 'highest'\n    })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n      at: end,\n      mode: 'highest'\n    });\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startNonEditable) {\n      var before = Editor.before(editor, start);\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n    if (endNonEditable) {\n      var after = Editor.after(editor, end);\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    var matches = [];\n    var lastPath;\n    var _iterator = _createForOfIteratorHelper$6(Editor.nodes(editor, {\n        at: at,\n        voids: voids\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n        var _entry = _slicedToArray(entry, 2),\n          _node2 = _entry[0],\n          _path2 = _entry[1];\n        if (lastPath && Path.compare(_path2, lastPath) === 0) {\n          continue;\n        }\n        if (!voids && Element.isElement(_node2) && (Editor.isVoid(editor, _node2) || Editor.isElementReadOnly(editor, _node2)) || !Path.isCommon(_path2, start.path) && !Path.isCommon(_path2, end.path)) {\n          matches.push(entry);\n          lastPath = _path2;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var pathRefs = Array.from(matches, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    var startRef = Editor.pointRef(editor, start);\n    var endRef = Editor.pointRef(editor, end);\n    var removedText = '';\n    if (!isSingleText && !startNonEditable) {\n      var _point = startRef.current;\n      var _Editor$leaf = Editor.leaf(editor, _point),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n        node = _Editor$leaf2[0];\n      var path = _point.path;\n      var _start = start,\n        offset = _start.offset;\n      var text = node.text.slice(offset);\n      if (text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: path,\n          offset: offset,\n          text: text\n        });\n        removedText = text;\n      }\n    }\n    pathRefs.reverse().map(function (r) {\n      return r.unref();\n    }).filter(function (r) {\n      return r !== null;\n    }).forEach(function (p) {\n      return Transforms.removeNodes(editor, {\n        at: p,\n        voids: voids\n      });\n    });\n    if (!endNonEditable) {\n      var _point2 = endRef.current;\n      var _Editor$leaf3 = Editor.leaf(editor, _point2),\n        _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n        _node = _Editor$leaf4[0];\n      var _path = _point2.path;\n      var _offset = isSingleText ? start.offset : 0;\n      var _text = _node.text.slice(_offset, end.offset);\n      if (_text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset: _offset,\n          text: _text\n        });\n        removedText = _text;\n      }\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids: voids\n      });\n    }\n    // For Thai script, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n    if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n      Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n    }\n    var startUnref = startRef.unref();\n    var endUnref = endRef.unref();\n    var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }\nfunction _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar insertFragment = function insertFragment(editor, fragment) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? getDefaultInsertLocation(editor) : _options$at,\n      _options$batchDirty = options.batchDirty,\n      batchDirty = _options$batchDirty === void 0 ? true : _options$batchDirty;\n    if (!fragment.length) {\n      return;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          end = _Range$edges2[1];\n        if (!voids && Editor[\"void\"](editor, {\n          at: end\n        })) {\n          return;\n        }\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n          at: at\n        });\n        at = pointRef.unref();\n      }\n    } else if (Path.isPath(at)) {\n      at = Editor.start(editor, at);\n    }\n    if (!voids && Editor[\"void\"](editor, {\n      at: at\n    })) {\n      return;\n    }\n    // If the insert point is at the edge of an inline node, move it outside\n    // instead since it will need to be split otherwise.\n    var inlineElementMatch = Editor.above(editor, {\n      at: at,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isInline(editor, n);\n      },\n      mode: 'highest',\n      voids: voids\n    });\n    if (inlineElementMatch) {\n      var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2),\n        _inlinePath = _inlineElementMatch[1];\n      if (Editor.isEnd(editor, at, _inlinePath)) {\n        var after = Editor.after(editor, _inlinePath);\n        at = after;\n      } else if (Editor.isStart(editor, at, _inlinePath)) {\n        var before = Editor.before(editor, _inlinePath);\n        at = before;\n      }\n    }\n    var blockMatch = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      at: at,\n      voids: voids\n    });\n    var _blockMatch = _slicedToArray(blockMatch, 2),\n      blockPath = _blockMatch[1];\n    var isBlockStart = Editor.isStart(editor, at, blockPath);\n    var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n    var isBlockEmpty = isBlockStart && isBlockEnd;\n    var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n    var mergeEnd = !isBlockEnd;\n    var _Node$first = Node.first({\n        children: fragment\n      }, []),\n      _Node$first2 = _slicedToArray(_Node$first, 2),\n      firstPath = _Node$first2[1];\n    var _Node$last = Node.last({\n        children: fragment\n      }, []),\n      _Node$last2 = _slicedToArray(_Node$last, 2),\n      lastPath = _Node$last2[1];\n    var matches = [];\n    var matcher = function matcher(_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        n = _ref2[0],\n        p = _ref2[1];\n      var isRoot = p.length === 0;\n      if (isRoot) {\n        return false;\n      }\n      if (isBlockEmpty) {\n        return true;\n      }\n      if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      return true;\n    };\n    var _iterator = _createForOfIteratorHelper$5(Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n        if (matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var starts = [];\n    var middles = [];\n    var ends = [];\n    var starting = true;\n    var hasBlocks = false;\n    for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n      var _matches$_i = _slicedToArray(_matches[_i], 1),\n        node = _matches$_i[0];\n      if (Element.isElement(node) && !editor.isInline(node)) {\n        starting = false;\n        hasBlocks = true;\n        middles.push(node);\n      } else if (starting) {\n        starts.push(node);\n      } else {\n        ends.push(node);\n      }\n    }\n    var _Editor$nodes = Editor.nodes(editor, {\n        at: at,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      inlineMatch = _Editor$nodes2[0];\n    var _inlineMatch = _slicedToArray(inlineMatch, 2),\n      inlinePath = _inlineMatch[1];\n    var isInlineStart = Editor.isStart(editor, at, inlinePath);\n    var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n    var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n    var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.splitNodes(editor, {\n      at: at,\n      match: function match(n) {\n        return hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n      },\n      mode: hasBlocks ? 'lowest' : 'highest',\n      always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n      voids: voids\n    });\n    var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.insertNodes(editor, starts, {\n      at: startRef.current,\n      match: function match(n) {\n        return Text.isText(n) || Editor.isInline(editor, n);\n      },\n      mode: 'highest',\n      voids: voids,\n      batchDirty: batchDirty\n    });\n    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n      Transforms[\"delete\"](editor, {\n        at: blockPath,\n        voids: voids\n      });\n    }\n    Transforms.insertNodes(editor, middles, {\n      at: middleRef.current,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      mode: 'lowest',\n      voids: voids,\n      batchDirty: batchDirty\n    });\n    Transforms.insertNodes(editor, ends, {\n      at: endRef.current,\n      match: function match(n) {\n        return Text.isText(n) || Editor.isInline(editor, n);\n      },\n      mode: 'highest',\n      voids: voids,\n      batchDirty: batchDirty\n    });\n    if (!options.at) {\n      var path;\n      if (ends.length > 0 && endRef.current) {\n        path = Path.previous(endRef.current);\n      } else if (middles.length > 0 && middleRef.current) {\n        path = Path.previous(middleRef.current);\n      } else if (startRef.current) {\n        path = Path.previous(startRef.current);\n      }\n      if (path) {\n        var _end = Editor.end(editor, path);\n        Transforms.select(editor, _end);\n      }\n    }\n    startRef.unref();\n    middleRef.unref();\n    endRef.unref();\n  });\n};\n\nvar collapse = function collapse(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? 'anchor' : _options$edge;\n  var selection = editor.selection;\n  if (!selection) {\n    return;\n  } else if (edge === 'anchor') {\n    Transforms.select(editor, selection.anchor);\n  } else if (edge === 'focus') {\n    Transforms.select(editor, selection.focus);\n  } else if (edge === 'start') {\n    var _Range$edges = Range.edges(selection),\n      _Range$edges2 = _slicedToArray(_Range$edges, 1),\n      start = _Range$edges2[0];\n    Transforms.select(editor, start);\n  } else if (edge === 'end') {\n    var _Range$edges3 = Range.edges(selection),\n      _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n      end = _Range$edges4[1];\n    Transforms.select(editor, end);\n  }\n};\n\nvar deselect = function deselect(editor) {\n  var selection = editor.selection;\n  if (selection) {\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: null\n    });\n  }\n};\n\nvar move = function move(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var selection = editor.selection;\n  var _options$distance = options.distance,\n    distance = _options$distance === void 0 ? 1 : _options$distance,\n    _options$unit = options.unit,\n    unit = _options$unit === void 0 ? 'character' : _options$unit,\n    _options$reverse = options.reverse,\n    reverse = _options$reverse === void 0 ? false : _options$reverse;\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? null : _options$edge;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var anchor = selection.anchor,\n    focus = selection.focus;\n  var opts = {\n    distance: distance,\n    unit: unit,\n    ignoreNonSelectable: true\n  };\n  var props = {};\n  if (edge == null || edge === 'anchor') {\n    var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n    if (point) {\n      props.anchor = point;\n    }\n  }\n  if (edge == null || edge === 'focus') {\n    var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n    if (_point) {\n      props.focus = _point;\n    }\n  }\n  Transforms.setSelection(editor, props);\n};\n\nvar select = function select(editor, target) {\n  var selection = editor.selection;\n  target = Editor.range(editor, target);\n  if (selection) {\n    Transforms.setSelection(editor, target);\n    return;\n  }\n  if (!Range.isRange(target)) {\n    throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n  }\n  editor.apply({\n    type: 'set_selection',\n    properties: selection,\n    newProperties: target\n  });\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar setPoint = function setPoint(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var selection = editor.selection;\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? 'both' : _options$edge;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var anchor = selection.anchor,\n    focus = selection.focus;\n  var point = edge === 'anchor' ? anchor : focus;\n  Transforms.setSelection(editor, _defineProperty({}, edge === 'anchor' ? 'anchor' : 'focus', _objectSpread$1(_objectSpread$1({}, point), props)));\n};\n\nvar setSelection = function setSelection(editor, props) {\n  var selection = editor.selection;\n  var oldProps = {};\n  var newProps = {};\n  if (!selection) {\n    return;\n  }\n  for (var k in props) {\n    if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n      oldProps[k] = selection[k];\n      newProps[k] = props[k];\n    }\n  }\n  if (Object.keys(oldProps).length > 0) {\n    editor.apply({\n      type: 'set_selection',\n      properties: oldProps,\n      newProperties: newProps\n    });\n  }\n};\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }\nfunction _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar insertNodes = function insertNodes(editor, nodes) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$batchDirty = options.batchDirty,\n      batchDirty = _options$batchDirty === void 0 ? true : _options$batchDirty;\n    var at = options.at,\n      match = options.match,\n      select = options.select;\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n    if (nodes.length === 0) {\n      return;\n    }\n    var _nodes = nodes,\n      _nodes2 = _slicedToArray(_nodes, 1),\n      node = _nodes2[0];\n    if (!at) {\n      at = getDefaultInsertLocation(editor);\n      if (select !== false) {\n        select = true;\n      }\n    }\n    if (select == null) {\n      select = false;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          end = _Range$edges2[1];\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n          at: at\n        });\n        at = pointRef.unref();\n      }\n    }\n    if (Point.isPoint(at)) {\n      if (match == null) {\n        if (Text.isText(node)) {\n          match = function match(n) {\n            return Text.isText(n);\n          };\n        } else if (editor.isInline(node)) {\n          match = function match(n) {\n            return Text.isText(n) || Editor.isInline(editor, n);\n          };\n        } else {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          };\n        }\n      }\n      var _Editor$nodes = Editor.nodes(editor, {\n          at: at.path,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n        _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n        entry = _Editor$nodes2[0];\n      if (entry) {\n        var _entry = _slicedToArray(entry, 2),\n          matchPath = _entry[1];\n        var pathRef = Editor.pathRef(editor, matchPath);\n        var isAtEnd = Editor.isEnd(editor, at, matchPath);\n        Transforms.splitNodes(editor, {\n          at: at,\n          match: match,\n          mode: mode,\n          voids: voids\n        });\n        var path = pathRef.unref();\n        at = isAtEnd ? Path.next(path) : path;\n      } else {\n        return;\n      }\n    }\n    var parentPath = Path.parent(at);\n    var index = at[at.length - 1];\n    if (!voids && Editor[\"void\"](editor, {\n      at: parentPath\n    })) {\n      return;\n    }\n    if (batchDirty) {\n      // PERF: batch update dirty paths\n      // batched ops used to transform existing dirty paths\n      var batchedOps = [];\n      var newDirtyPaths = Path.levels(parentPath);\n      batchDirtyPaths(editor, function () {\n        var _iterator = _createForOfIteratorHelper$4(nodes),\n          _step;\n        try {\n          var _loop = function _loop() {\n            var node = _step.value;\n            var path = parentPath.concat(index);\n            index++;\n            var op = {\n              type: 'insert_node',\n              path: path,\n              node: node\n            };\n            editor.apply(op);\n            at = Path.next(at);\n            batchedOps.push(op);\n            if (!Text.isText) {\n              newDirtyPaths.push(path);\n            } else {\n              newDirtyPaths.push.apply(newDirtyPaths, _toConsumableArray(Array.from(Node.nodes(node), function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                  p = _ref2[1];\n                return path.concat(p);\n              })));\n            }\n          };\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }, function () {\n        updateDirtyPaths(editor, newDirtyPaths, function (p) {\n          var newPath = p;\n          for (var _i = 0, _batchedOps = batchedOps; _i < _batchedOps.length; _i++) {\n            var op = _batchedOps[_i];\n            if (Path.operationCanTransformPath(op)) {\n              newPath = Path.transform(newPath, op);\n              if (!newPath) {\n                return null;\n              }\n            }\n          }\n          return newPath;\n        });\n      });\n    } else {\n      var _iterator2 = _createForOfIteratorHelper$4(nodes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _node = _step2.value;\n          var _path = parentPath.concat(index);\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path,\n            node: _node\n          });\n          at = Path.next(at);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    at = Path.previous(at);\n    if (select) {\n      var point = Editor.end(editor, at);\n      if (point) {\n        Transforms.select(editor, point);\n      }\n    }\n  });\n};\n\nvar liftNodes = function liftNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match;\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (!at) {\n      return;\n    }\n    var matches = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(matches, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n      var pathRef = _pathRefs[_i];\n      var path = pathRef.unref();\n      if (path.length < 2) {\n        throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n      }\n      var parentNodeEntry = Editor.node(editor, Path.parent(path));\n      var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2),\n        parent = _parentNodeEntry[0],\n        parentPath = _parentNodeEntry[1];\n      var index = path[path.length - 1];\n      var length = parent.children.length;\n      if (length === 1) {\n        var toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: toPath,\n          voids: voids\n        });\n        Transforms.removeNodes(editor, {\n          at: parentPath,\n          voids: voids\n        });\n      } else if (index === 0) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: parentPath,\n          voids: voids\n        });\n      } else if (index === length - 1) {\n        var _toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath,\n          voids: voids\n        });\n      } else {\n        var splitPath = Path.next(path);\n        var _toPath2 = Path.next(parentPath);\n        Transforms.splitNodes(editor, {\n          at: splitPath,\n          voids: voids\n        });\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath2,\n          voids: voids\n        });\n      }\n    }\n  });\n};\n\nvar _excluded = [\"text\"],\n  _excluded2 = [\"children\"];\nvar hasSingleChildNest = function hasSingleChildNest(editor, node) {\n  if (Element.isElement(node)) {\n    var element = node;\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar mergeNodes = function mergeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at;\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent = Editor.parent(editor, at),\n          _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n          parent = _Editor$parent2[0];\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids: voids\n      });\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          end = _Range$edges2[1];\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n          at: at\n        });\n        at = pointRef.unref();\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n    }\n    var _Editor$nodes = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      current = _Editor$nodes2[0];\n    var prev = Editor.previous(editor, {\n      at: at,\n      match: match,\n      voids: voids,\n      mode: mode\n    });\n    if (!current || !prev) {\n      return;\n    }\n    var _current = _slicedToArray(current, 2),\n      node = _current[0],\n      path = _current[1];\n    var _prev = _slicedToArray(prev, 2),\n      prevNode = _prev[0],\n      prevPath = _prev[1];\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n    var newPath = Path.next(prevPath);\n    var commonPath = Path.common(path, prevPath);\n    var isPreviousSibling = Path.isSibling(path, prevPath);\n    var levels = Array.from(Editor.levels(editor, {\n      at: path\n    }), function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n        n = _ref2[0];\n      return n;\n    }).slice(commonPath.length).slice(0, -1);\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    var emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: function match(n) {\n        return levels.includes(n) && hasSingleChildNest(editor, n);\n      }\n    });\n    var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n    var properties;\n    var position;\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      node.text;\n        var rest = _objectWithoutProperties(node, _excluded);\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      node.children;\n        var _rest = _objectWithoutProperties(node, _excluded2);\n      position = prevNode.children.length;\n      properties = _rest;\n    } else {\n      throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: newPath,\n        voids: voids\n      });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      Transforms.removeNodes(editor, {\n        at: emptyRef.current,\n        voids: voids\n      });\n    }\n    if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {\n      Transforms.removeNodes(editor, {\n        at: prevPath,\n        voids: voids\n      });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position: position,\n        properties: properties\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n\nvar moveNodes = function moveNodes(editor, options) {\n  Editor.withoutNormalizing(editor, function () {\n    var to = options.to,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    var toRef = Editor.pathRef(editor, to);\n    var targets = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(targets, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n      var pathRef = _pathRefs[_i];\n      var path = pathRef.unref();\n      var newPath = toRef.current;\n      if (path.length !== 0) {\n        editor.apply({\n          type: 'move_node',\n          path: path,\n          newPath: newPath\n        });\n      }\n      if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n        // When performing a sibling move to a later index, the path at the destination is shifted\n        // to before the insertion point instead of after. To ensure our group of nodes are inserted\n        // in the correct order we increment toRef to account for that\n        toRef.current = Path.next(toRef.current);\n      }\n    }\n    toRef.unref();\n  });\n};\n\nvar removeNodes = function removeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      match = options.match;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids: voids\n      });\n    }\n    var depths = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(depths, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n      var pathRef = _pathRefs[_i];\n      var path = pathRef.unref();\n      if (path) {\n        var _Editor$node = Editor.node(editor, path),\n          _Editor$node2 = _slicedToArray(_Editor$node, 1),\n          node = _Editor$node2[0];\n        editor.apply({\n          type: 'remove_node',\n          path: path,\n          node: node\n        });\n      }\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar setNodes = function setNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      compare = options.compare,\n      merge = options.merge;\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$split = options.split,\n      split = _options$split === void 0 ? false : _options$split,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids: voids\n      });\n    }\n    if (split && Range.isRange(at)) {\n      if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n        // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n        // set that won't get normalized away\n        return;\n      }\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      var _Range$edges = Range.edges(at),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n      var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n      var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n      Transforms.splitNodes(editor, {\n        at: end,\n        match: match,\n        mode: splitMode,\n        voids: voids,\n        always: !endAtEndOfNode\n      });\n      var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n      Transforms.splitNodes(editor, {\n        at: start,\n        match: match,\n        mode: splitMode,\n        voids: voids,\n        always: !startAtStartOfNode\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    if (!compare) {\n      compare = function compare(prop, nodeProp) {\n        return prop !== nodeProp;\n      };\n    }\n    var _iterator = _createForOfIteratorHelper$3(Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          node = _step$value[0],\n          path = _step$value[1];\n        var properties = {};\n        // FIXME: is this correct?\n        var newProperties = {};\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue;\n        }\n        var hasChanges = false;\n        for (var k in props) {\n          if (k === 'children' || k === 'text') {\n            continue;\n          }\n          if (compare(props[k], node[k])) {\n            hasChanges = true;\n            // Omit new properties from the old properties list\n            if (node.hasOwnProperty(k)) properties[k] = node[k];\n            // Omit properties that have been removed from the new properties list\n            if (merge) {\n              if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n            } else {\n              if (props[k] != null) newProperties[k] = props[k];\n            }\n          }\n        }\n        if (hasChanges) {\n          editor.apply({\n            type: 'set_node',\n            path: path,\n            properties: properties,\n            newProperties: newProperties\n          });\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Convert a range into a point by deleting it's content.\n */\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges = Range.edges(range),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      end = _Range$edges2[1];\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms[\"delete\"](editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\nvar splitNodes = function splitNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$height = options.height,\n      height = _options$height === void 0 ? 0 : _options$height,\n      _options$always = options.always,\n      always = _options$always === void 0 ? false : _options$always;\n    if (match == null) {\n      match = function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (Range.isRange(at)) {\n      at = deleteRange(editor, at);\n    }\n    // If the target is a path, the default height-skipping and position\n    // counters need to account for us potentially splitting at a non-leaf.\n    if (Path.isPath(at)) {\n      var path = at;\n      var point = Editor.point(editor, path);\n      var _Editor$parent = Editor.parent(editor, path),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n        parent = _Editor$parent2[0];\n      match = function match(n) {\n        return n === parent;\n      };\n      height = point.path.length - path.length + 1;\n      at = point;\n      always = true;\n    }\n    if (!at) {\n      return;\n    }\n    var beforeRef = Editor.pointRef(editor, at, {\n      affinity: 'backward'\n    });\n    var afterRef;\n    try {\n      var _Editor$nodes = Editor.nodes(editor, {\n          at: at,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n        _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n        highest = _Editor$nodes2[0];\n      if (!highest) {\n        return;\n      }\n      var voidMatch = Editor[\"void\"](editor, {\n        at: at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n      if (!voids && voidMatch) {\n        var _voidMatch = _slicedToArray(voidMatch, 2),\n          voidNode = _voidMatch[0],\n          voidPath = _voidMatch[1];\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids: voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n          at = after;\n          always = true;\n        }\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n      afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var _highest = _slicedToArray(highest, 2),\n        highestPath = _highest[1];\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n      var _iterator = _createForOfIteratorHelper$2(Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids: voids\n        })),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            node = _step$value[0],\n            _path = _step$value[1];\n          var split = false;\n          if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n            break;\n          }\n          var _point2 = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point2, _path);\n          if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path)) {\n            split = true;\n            var properties = Node.extractProps(node);\n            editor.apply({\n              type: 'split_node',\n              path: _path,\n              position: position,\n              properties: properties\n            });\n          }\n          position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (options.at == null) {\n        var _point = afterRef.current || Editor.end(editor, []);\n        Transforms.select(editor, _point);\n      }\n    } finally {\n      var _afterRef;\n      beforeRef.unref();\n      (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar unsetNodes = function unsetNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!Array.isArray(props)) {\n    props = [props];\n  }\n  var obj = {};\n  var _iterator = _createForOfIteratorHelper$1(props),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      obj[key] = null;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  Transforms.setNodes(editor, obj, options);\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar unwrapNodes = function unwrapNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$split = options.split,\n      split = _options$split === void 0 ? false : _options$split,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      match = options.match;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (Path.isPath(at)) {\n      at = Editor.range(editor, at);\n    }\n    var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n    var matches = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(matches, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    }\n    // unwrapNode will call liftNode which does not support splitting the node when nested.\n    // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n    // that wrap target node. So we reverse the order.\n    ).reverse();\n    var _iterator = _createForOfIteratorHelper(pathRefs),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var pathRef = _step.value;\n        var path = pathRef.unref();\n        var _Editor$node = Editor.node(editor, path),\n          _Editor$node2 = _slicedToArray(_Editor$node, 1),\n          node = _Editor$node2[0];\n        var range = Editor.range(editor, path);\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: function match(n) {\n            return Element.isAncestor(node) && node.children.includes(n);\n          },\n          voids: voids\n        });\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (rangeRef) {\n      rangeRef.unref();\n    }\n  });\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar wrapNodes = function wrapNodes(editor, element) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$split = options.split,\n      split = _options$split === void 0 ? false : _options$split,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        match = matchPath(editor, at);\n      } else if (editor.isInline(element)) {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n        };\n      } else {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n    }\n    if (split && Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      Transforms.splitNodes(editor, {\n        at: end,\n        match: match,\n        voids: voids\n      });\n      Transforms.splitNodes(editor, {\n        at: start,\n        match: match,\n        voids: voids\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    var roots = Array.from(Editor.nodes(editor, {\n      at: at,\n      match: editor.isInline(element) ? function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      } : function (n) {\n        return Editor.isEditor(n);\n      },\n      mode: 'lowest',\n      voids: voids\n    }));\n    var _loop = function _loop() {\n        var _roots$_i = _slicedToArray(_roots[_i], 2),\n          rootPath = _roots$_i[1];\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n        if (!a) {\n          return 0; // continue\n        }\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match: match,\n          mode: mode,\n          voids: voids\n        }));\n        if (matches.length > 0) {\n          var first = matches[0];\n          var last = matches[matches.length - 1];\n          var _first = _slicedToArray(first, 2),\n            firstPath = _first[1];\n          var _last = _slicedToArray(last, 2),\n            lastPath = _last[1];\n          if (firstPath.length === 0 && lastPath.length === 0) {\n            // if there's no matching parent - usually means the node is an editor - don't do anything\n            return 0; // continue\n          }\n          var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n          var range = Editor.range(editor, firstPath, lastPath);\n          var commonNodeEntry = Editor.node(editor, commonPath);\n          var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1),\n            commonNode = _commonNodeEntry[0];\n          var depth = commonPath.length + 1;\n          var wrapperPath = Path.next(lastPath.slice(0, depth));\n          var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n            children: []\n          });\n          Transforms.insertNodes(editor, wrapper, {\n            at: wrapperPath,\n            voids: voids\n          });\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: function match(n) {\n              return Element.isAncestor(commonNode) && commonNode.children.includes(n);\n            },\n            to: wrapperPath.concat(0),\n            voids: voids\n          });\n        }\n      },\n      _ret;\n    for (var _i = 0, _roots = roots; _i < _roots.length; _i++) {\n      _ret = _loop();\n      if (_ret === 0) continue;\n    }\n  });\n};\n\n/**\n * Create a new Slate `Editor` object.\n */\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isElementReadOnly: function isElementReadOnly() {\n      return false;\n    },\n    isInline: function isInline() {\n      return false;\n    },\n    isSelectable: function isSelectable() {\n      return true;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    markableVoid: function markableVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    // Core\n    apply: function apply$1() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return apply.apply(void 0, [editor].concat(args));\n    },\n    // Editor\n    addMark: function addMark$1() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return addMark.apply(void 0, [editor].concat(args));\n    },\n    deleteBackward: function deleteBackward$1() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return deleteBackward.apply(void 0, [editor].concat(args));\n    },\n    deleteForward: function deleteForward$1() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return deleteForward.apply(void 0, [editor].concat(args));\n    },\n    deleteFragment: function deleteFragment$1() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return deleteFragment.apply(void 0, [editor].concat(args));\n    },\n    getFragment: function getFragment$1() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return getFragment.apply(void 0, [editor].concat(args));\n    },\n    insertBreak: function insertBreak$1() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return insertBreak.apply(void 0, [editor].concat(args));\n    },\n    insertSoftBreak: function insertSoftBreak$1() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return insertSoftBreak.apply(void 0, [editor].concat(args));\n    },\n    insertFragment: function insertFragment$1() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return insertFragment.apply(void 0, [editor].concat(args));\n    },\n    insertNode: function insertNode$1() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return insertNode.apply(void 0, [editor].concat(args));\n    },\n    insertText: function insertText$1() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return insertText.apply(void 0, [editor].concat(args));\n    },\n    normalizeNode: function normalizeNode$1() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return normalizeNode.apply(void 0, [editor].concat(args));\n    },\n    removeMark: function removeMark$1() {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return removeMark.apply(void 0, [editor].concat(args));\n    },\n    getDirtyPaths: function getDirtyPaths$1() {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return getDirtyPaths.apply(void 0, [editor].concat(args));\n    },\n    shouldNormalize: function shouldNormalize$1() {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return shouldNormalize.apply(void 0, [editor].concat(args));\n    },\n    // Editor interface\n    above: function above$1() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return above.apply(void 0, [editor].concat(args));\n    },\n    after: function after$1() {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return after.apply(void 0, [editor].concat(args));\n    },\n    before: function before$1() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return before.apply(void 0, [editor].concat(args));\n    },\n    collapse: function collapse$1() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return collapse.apply(void 0, [editor].concat(args));\n    },\n    \"delete\": function _delete() {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return deleteText.apply(void 0, [editor].concat(args));\n    },\n    deselect: function deselect$1() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return deselect.apply(void 0, [editor].concat(args));\n    },\n    edges: function edges$1() {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return edges.apply(void 0, [editor].concat(args));\n    },\n    elementReadOnly: function elementReadOnly$1() {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return elementReadOnly.apply(void 0, [editor].concat(args));\n    },\n    end: function end$1() {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return end.apply(void 0, [editor].concat(args));\n    },\n    first: function first$1() {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return first.apply(void 0, [editor].concat(args));\n    },\n    fragment: function fragment$1() {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return fragment.apply(void 0, [editor].concat(args));\n    },\n    getMarks: function getMarks() {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return marks.apply(void 0, [editor].concat(args));\n    },\n    hasBlocks: function hasBlocks$1() {\n      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n        args[_key28] = arguments[_key28];\n      }\n      return hasBlocks.apply(void 0, [editor].concat(args));\n    },\n    hasInlines: function hasInlines$1() {\n      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n        args[_key29] = arguments[_key29];\n      }\n      return hasInlines.apply(void 0, [editor].concat(args));\n    },\n    hasPath: function hasPath$1() {\n      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n        args[_key30] = arguments[_key30];\n      }\n      return hasPath.apply(void 0, [editor].concat(args));\n    },\n    hasTexts: function hasTexts$1() {\n      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n        args[_key31] = arguments[_key31];\n      }\n      return hasTexts.apply(void 0, [editor].concat(args));\n    },\n    insertNodes: function insertNodes$1() {\n      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n        args[_key32] = arguments[_key32];\n      }\n      return insertNodes.apply(void 0, [editor].concat(args));\n    },\n    isBlock: function isBlock$1() {\n      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n        args[_key33] = arguments[_key33];\n      }\n      return isBlock.apply(void 0, [editor].concat(args));\n    },\n    isEdge: function isEdge$1() {\n      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n        args[_key34] = arguments[_key34];\n      }\n      return isEdge.apply(void 0, [editor].concat(args));\n    },\n    isEmpty: function isEmpty$1() {\n      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n        args[_key35] = arguments[_key35];\n      }\n      return isEmpty.apply(void 0, [editor].concat(args));\n    },\n    isEnd: function isEnd$1() {\n      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {\n        args[_key36] = arguments[_key36];\n      }\n      return isEnd.apply(void 0, [editor].concat(args));\n    },\n    isNormalizing: function isNormalizing$1() {\n      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {\n        args[_key37] = arguments[_key37];\n      }\n      return isNormalizing.apply(void 0, [editor].concat(args));\n    },\n    isStart: function isStart$1() {\n      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {\n        args[_key38] = arguments[_key38];\n      }\n      return isStart.apply(void 0, [editor].concat(args));\n    },\n    last: function last$1() {\n      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {\n        args[_key39] = arguments[_key39];\n      }\n      return last.apply(void 0, [editor].concat(args));\n    },\n    leaf: function leaf$1() {\n      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {\n        args[_key40] = arguments[_key40];\n      }\n      return leaf.apply(void 0, [editor].concat(args));\n    },\n    levels: function levels$1() {\n      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {\n        args[_key41] = arguments[_key41];\n      }\n      return levels.apply(void 0, [editor].concat(args));\n    },\n    liftNodes: function liftNodes$1() {\n      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {\n        args[_key42] = arguments[_key42];\n      }\n      return liftNodes.apply(void 0, [editor].concat(args));\n    },\n    mergeNodes: function mergeNodes$1() {\n      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {\n        args[_key43] = arguments[_key43];\n      }\n      return mergeNodes.apply(void 0, [editor].concat(args));\n    },\n    move: function move$1() {\n      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {\n        args[_key44] = arguments[_key44];\n      }\n      return move.apply(void 0, [editor].concat(args));\n    },\n    moveNodes: function moveNodes$1() {\n      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {\n        args[_key45] = arguments[_key45];\n      }\n      return moveNodes.apply(void 0, [editor].concat(args));\n    },\n    next: function next$1() {\n      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {\n        args[_key46] = arguments[_key46];\n      }\n      return next.apply(void 0, [editor].concat(args));\n    },\n    node: function node$1() {\n      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {\n        args[_key47] = arguments[_key47];\n      }\n      return node.apply(void 0, [editor].concat(args));\n    },\n    nodes: function nodes$1() {\n      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {\n        args[_key48] = arguments[_key48];\n      }\n      return nodes.apply(void 0, [editor].concat(args));\n    },\n    normalize: function normalize$1() {\n      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {\n        args[_key49] = arguments[_key49];\n      }\n      return normalize.apply(void 0, [editor].concat(args));\n    },\n    parent: function parent$1() {\n      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {\n        args[_key50] = arguments[_key50];\n      }\n      return parent.apply(void 0, [editor].concat(args));\n    },\n    path: function path$1() {\n      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {\n        args[_key51] = arguments[_key51];\n      }\n      return path.apply(void 0, [editor].concat(args));\n    },\n    pathRef: function pathRef$1() {\n      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {\n        args[_key52] = arguments[_key52];\n      }\n      return pathRef.apply(void 0, [editor].concat(args));\n    },\n    pathRefs: function pathRefs$1() {\n      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {\n        args[_key53] = arguments[_key53];\n      }\n      return pathRefs.apply(void 0, [editor].concat(args));\n    },\n    point: function point$1() {\n      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {\n        args[_key54] = arguments[_key54];\n      }\n      return point.apply(void 0, [editor].concat(args));\n    },\n    pointRef: function pointRef$1() {\n      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {\n        args[_key55] = arguments[_key55];\n      }\n      return pointRef.apply(void 0, [editor].concat(args));\n    },\n    pointRefs: function pointRefs$1() {\n      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {\n        args[_key56] = arguments[_key56];\n      }\n      return pointRefs.apply(void 0, [editor].concat(args));\n    },\n    positions: function positions$1() {\n      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {\n        args[_key57] = arguments[_key57];\n      }\n      return positions.apply(void 0, [editor].concat(args));\n    },\n    previous: function previous$1() {\n      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {\n        args[_key58] = arguments[_key58];\n      }\n      return previous.apply(void 0, [editor].concat(args));\n    },\n    range: function range$1() {\n      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {\n        args[_key59] = arguments[_key59];\n      }\n      return range.apply(void 0, [editor].concat(args));\n    },\n    rangeRef: function rangeRef$1() {\n      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {\n        args[_key60] = arguments[_key60];\n      }\n      return rangeRef.apply(void 0, [editor].concat(args));\n    },\n    rangeRefs: function rangeRefs$1() {\n      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {\n        args[_key61] = arguments[_key61];\n      }\n      return rangeRefs.apply(void 0, [editor].concat(args));\n    },\n    removeNodes: function removeNodes$1() {\n      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {\n        args[_key62] = arguments[_key62];\n      }\n      return removeNodes.apply(void 0, [editor].concat(args));\n    },\n    select: function select$1() {\n      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {\n        args[_key63] = arguments[_key63];\n      }\n      return select.apply(void 0, [editor].concat(args));\n    },\n    setNodes: function setNodes$1() {\n      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {\n        args[_key64] = arguments[_key64];\n      }\n      return setNodes.apply(void 0, [editor].concat(args));\n    },\n    setNormalizing: function setNormalizing$1() {\n      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {\n        args[_key65] = arguments[_key65];\n      }\n      return setNormalizing.apply(void 0, [editor].concat(args));\n    },\n    setPoint: function setPoint$1() {\n      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {\n        args[_key66] = arguments[_key66];\n      }\n      return setPoint.apply(void 0, [editor].concat(args));\n    },\n    setSelection: function setSelection$1() {\n      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {\n        args[_key67] = arguments[_key67];\n      }\n      return setSelection.apply(void 0, [editor].concat(args));\n    },\n    splitNodes: function splitNodes$1() {\n      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {\n        args[_key68] = arguments[_key68];\n      }\n      return splitNodes.apply(void 0, [editor].concat(args));\n    },\n    start: function start$1() {\n      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {\n        args[_key69] = arguments[_key69];\n      }\n      return start.apply(void 0, [editor].concat(args));\n    },\n    string: function string$1() {\n      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {\n        args[_key70] = arguments[_key70];\n      }\n      return string.apply(void 0, [editor].concat(args));\n    },\n    unhangRange: function unhangRange$1() {\n      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {\n        args[_key71] = arguments[_key71];\n      }\n      return unhangRange.apply(void 0, [editor].concat(args));\n    },\n    unsetNodes: function unsetNodes$1() {\n      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {\n        args[_key72] = arguments[_key72];\n      }\n      return unsetNodes.apply(void 0, [editor].concat(args));\n    },\n    unwrapNodes: function unwrapNodes$1() {\n      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {\n        args[_key73] = arguments[_key73];\n      }\n      return unwrapNodes.apply(void 0, [editor].concat(args));\n    },\n    \"void\": function _void() {\n      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {\n        args[_key74] = arguments[_key74];\n      }\n      return getVoid.apply(void 0, [editor].concat(args));\n    },\n    withoutNormalizing: function withoutNormalizing$1() {\n      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {\n        args[_key75] = arguments[_key75];\n      }\n      return withoutNormalizing.apply(void 0, [editor].concat(args));\n    },\n    wrapNodes: function wrapNodes$1() {\n      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {\n        args[_key76] = arguments[_key76];\n      }\n      return wrapNodes.apply(void 0, [editor].concat(args));\n    },\n    shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {\n      for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {\n        args[_key77] = arguments[_key77];\n      }\n      return shouldMergeNodesRemovePrevNode.apply(void 0, [editor].concat(args));\n    }\n  };\n  return editor;\n};\n\nexports.Editor = Editor;\nexports.Element = Element;\nexports.Location = Location;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Path = Path;\nexports.PathRef = PathRef;\nexports.Point = Point;\nexports.PointRef = PointRef;\nexports.Range = Range;\nexports.RangeRef = RangeRef;\nexports.Scrubber = Scrubber;\nexports.Span = Span;\nexports.Text = Text;\nexports.Transforms = Transforms;\nexports.above = above;\nexports.addMark = addMark;\nexports.after = after;\nexports.apply = apply;\nexports.before = before;\nexports.collapse = collapse;\nexports.createEditor = createEditor;\nexports.deleteBackward = deleteBackward;\nexports.deleteForward = deleteForward;\nexports.deleteFragment = deleteFragment;\nexports.deleteText = deleteText;\nexports.deselect = deselect;\nexports.edges = edges;\nexports.elementReadOnly = elementReadOnly;\nexports.end = end;\nexports.first = first;\nexports.fragment = fragment;\nexports.getDirtyPaths = getDirtyPaths;\nexports.getFragment = getFragment;\nexports.getVoid = getVoid;\nexports.hasBlocks = hasBlocks;\nexports.hasInlines = hasInlines;\nexports.hasPath = hasPath;\nexports.hasTexts = hasTexts;\nexports.insertBreak = insertBreak;\nexports.insertFragment = insertFragment;\nexports.insertNode = insertNode;\nexports.insertNodes = insertNodes;\nexports.insertSoftBreak = insertSoftBreak;\nexports.insertText = insertText;\nexports.isBlock = isBlock;\nexports.isEdge = isEdge;\nexports.isEditor = isEditor;\nexports.isEmpty = isEmpty;\nexports.isEnd = isEnd;\nexports.isNormalizing = isNormalizing;\nexports.isStart = isStart;\nexports.last = last;\nexports.leaf = leaf;\nexports.levels = levels;\nexports.liftNodes = liftNodes;\nexports.marks = marks;\nexports.mergeNodes = mergeNodes;\nexports.move = move;\nexports.moveNodes = moveNodes;\nexports.next = next;\nexports.node = node;\nexports.nodes = nodes;\nexports.normalize = normalize;\nexports.normalizeNode = normalizeNode;\nexports.parent = parent;\nexports.path = path;\nexports.pathRef = pathRef;\nexports.pathRefs = pathRefs;\nexports.point = point;\nexports.pointRef = pointRef;\nexports.pointRefs = pointRefs;\nexports.positions = positions;\nexports.previous = previous;\nexports.range = range;\nexports.rangeRef = rangeRef;\nexports.rangeRefs = rangeRefs;\nexports.removeMark = removeMark;\nexports.removeNodes = removeNodes;\nexports.select = select;\nexports.setNodes = setNodes;\nexports.setNormalizing = setNormalizing;\nexports.setPoint = setPoint;\nexports.setSelection = setSelection;\nexports.shouldMergeNodesRemovePrevNode = shouldMergeNodesRemovePrevNode;\nexports.shouldNormalize = shouldNormalize;\nexports.splitNodes = splitNodes;\nexports.start = start;\nexports.string = string;\nexports.unhangRange = unhangRange;\nexports.unsetNodes = unsetNodes;\nexports.unwrapNodes = unwrapNodes;\nexports.withoutNormalizing = withoutNormalizing;\nexports.wrapNodes = wrapNodes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGVAMC4xMTIuMC9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyxtSkFBaUI7QUFDN0MsWUFBWSxtQkFBTyxDQUFDLGdIQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQ0FBb0M7QUFDbEQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFP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LFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFH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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELGlGQUFpRixXQUFXLDBIQUEwSCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7QUFDajlCLG9EQUFvRCxnQkFBZ0Isa0VBQWtFLHdEQUF3RCw2REFBNkQsc0RBQXNEO0FBQ2pULHlDQUF5Qyx1REFBdUQsdUNBQXVDLFNBQVMsdUJBQXVCO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsT0FBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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bEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Z0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLFlBQVk7QUFDWixlQUFlO0FBQ2YsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osWUFBWTtBQUNaLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsZUFBZTtBQUNmLGFBQWE7QUFDYixhQUFhO0FBQ2IsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixZQUFZO0FBQ1osWUFBWTtBQUNaLGFBQWE7QUFDYixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLGNBQWM7QUFDZCxZQUFZO0FBQ1osZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixzQ0FBc0M7QUFDdEMsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL3NsYXRlQDAuMTEyLjAvbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xudmFyIGltbWVyID0gcmVxdWlyZSgnaW1tZXInKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGhSZWYgPSB7XG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgYWZmaW5pdHkgPSByZWYuYWZmaW5pdHk7XG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IFBhdGgudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUG9pbnRSZWYgPSB7XG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgYWZmaW5pdHkgPSByZWYuYWZmaW5pdHk7XG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcG9pbnQgPSBQb2ludC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFJhbmdlUmVmID0ge1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudCxcbiAgICAgIGFmZmluaXR5ID0gcmVmLmFmZmluaXR5O1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRElSVFlfUEFUSF9LRVlTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBGTFVTSElORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9STUFMSVpJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBBVEhfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUE9JTlRfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUkFOR0VfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBhcnJheUxpa2VUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheUxpa2VUb0FycmF5KTtcblxudmFyIGFycmF5V2l0aG91dEhvbGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5V2l0aG91dEhvbGVzKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXRlcmFibGVUb0FycmF5KTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyh1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSk7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobm9uSXRlcmFibGVTcHJlYWQpO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IHVud3JhcEV4cG9ydHModG9Db25zdW1hYmxlQXJyYXkpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aCA9IHtcbiAgYW5jZXN0b3JzOiBmdW5jdGlvbiBhbmNlc3RvcnMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2U7XG4gICAgdmFyIHBhdGhzID0gUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH0sXG4gIGNvbW1vbjogZnVuY3Rpb24gY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAmJiBpIDwgYW5vdGhlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgICBpZiAoYXYgIT09IGJ2KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uO1xuICB9LFxuICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ocGF0aC5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSA8IGFub3RoZXJbaV0pIHJldHVybiAtMTtcbiAgICAgIGlmIChwYXRoW2ldID4gYW5vdGhlcltpXSkgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBlbmRzQWZ0ZXI6IGZ1bmN0aW9uIGVuZHNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA+IGJ2O1xuICB9LFxuICBlbmRzQXQ6IGZ1bmN0aW9uIGVuZHNBdChwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG4gIGVuZHNCZWZvcmU6IGZ1bmN0aW9uIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeShmdW5jdGlvbiAobiwgaSkge1xuICAgICAgcmV0dXJuIG4gPT09IGFub3RoZXJbaV07XG4gICAgfSk7XG4gIH0sXG4gIGhhc1ByZXZpb3VzOiBmdW5jdGlvbiBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG4gIGlzQWZ0ZXI6IGZ1bmN0aW9uIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG4gIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNCZWZvcmU6IGZ1bmN0aW9uIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcbiAgaXNDaGlsZDogZnVuY3Rpb24gaXNDaGlsZChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSBhbm90aGVyLmxlbmd0aCArIDEgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc0NvbW1vbjogZnVuY3Rpb24gaXNDb21tb24ocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8PSBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG4gIGlzRGVzY2VuZGFudDogZnVuY3Rpb24gaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG4gIGlzUGFyZW50OiBmdW5jdGlvbiBpc1BhcmVudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoICsgMSA9PT0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc1BhdGg6IGZ1bmN0aW9uIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuICBpc1NpYmxpbmc6IGZ1bmN0aW9uIGlzU2libGluZyhwYXRoLCBhbm90aGVyKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYWwgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgdmFyIGJsID0gYW5vdGhlclthbm90aGVyLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBhbCAhPT0gYmwgJiYgUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcbiAgbGV2ZWxzOiBmdW5jdGlvbiBsZXZlbHMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZTIgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZTIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTI7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsaXN0LnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0sXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBuZXh0IGluZGV4LlwiKSk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCArIDEpO1xuICB9LFxuICBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoOiBmdW5jdGlvbiBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wZXJhdGlvbikge1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBwYXRoIG9mIHRoZSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0uXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICB9LFxuICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gcHJldmlvdXMgaW5kZXguXCIpKTtcbiAgICB9XG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgLSAxKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKGFuY2VzdG9yLmxlbmd0aCk7XG4gIH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuICAgIC8vIFBFUkY6IHVzZSBkZXN0cnVjdGluZyBpbnN0ZWFkIG9mIGltbWVyXG4gICAgdmFyIHAgPSBfdG9Db25zdW1hYmxlQXJyYXkocGF0aCk7XG4gICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICAgIC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgb3AgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AsIHApIHx8IFBhdGguZW5kc0JlZm9yZShvcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLCBwKSkge1xuICAgICAgICAgICAgcFtvcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcCA9IG9wZXJhdGlvbi5wYXRoO1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AsIHApIHx8IFBhdGguaXNBbmNlc3Rvcihfb3AsIHApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AsIHApKSB7XG4gICAgICAgICAgICBwW19vcC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wMiA9IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBvcGVyYXRpb24ucG9zaXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3AzID0gb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgICAgICBfcG9zaXRpb24gPSBvcGVyYXRpb24ucG9zaXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3A0ID0gb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgICAgICBvbnAgPSBvcGVyYXRpb24ubmV3UGF0aDtcbiAgICAgICAgICAvLyBJZiB0aGUgb2xkIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWUsIGl0J3MgYSBuby1vcC5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wNCwgb25wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIG9ucCkgJiYgX29wNC5sZW5ndGggPCBvbnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvcHlbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcHkuY29uY2F0KHAuc2xpY2UoX29wNC5sZW5ndGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNTaWJsaW5nKF9vcDQsIG9ucCkgJiYgKFBhdGguaXNBbmNlc3RvcihvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkpKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvbnAsIHApKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxudmFyIF90eXBlb2ZfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKF90eXBlb2ZfMSk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBfdHlwZW9mID0gX3R5cGVvZl8xW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1ByaW1pdGl2ZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHModG9QcmltaXRpdmUpO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBfdHlwZW9mID0gX3R5cGVvZl8xW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyh0b1Byb3BlcnR5S2V5KTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSB1bndyYXBFeHBvcnRzKGRlZmluZVByb3BlcnR5KTtcblxudmFyIGFycmF5V2l0aEhvbGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5V2l0aEhvbGVzKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhYmxlVG9BcnJheUxpbWl0KTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKG5vbkl0ZXJhYmxlUmVzdCk7XG5cbnZhciBzbGljZWRUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSB1bndyYXBFeHBvcnRzKHNsaWNlZFRvQXJyYXkpO1xuXG5mdW5jdGlvbiBvd25LZXlzJGUoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRlKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkZShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkZShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkbShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkbShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JG0obywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRtKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkbShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRtKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgYXBwbHlUb0RyYWZ0ID0gZnVuY3Rpb24gYXBwbHlUb0RyYWZ0KGVkaXRvciwgc2VsZWN0aW9uLCBvcCkge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXRoID0gb3AucGF0aCxcbiAgICAgICAgICBub2RlID0gb3Aubm9kZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBcXFwiaW5zZXJ0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgbm9kZS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJG0oUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBwb2ludCA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGggPSBvcC5wYXRoLFxuICAgICAgICAgIG9mZnNldCA9IG9wLm9mZnNldCxcbiAgICAgICAgICB0ZXh0ID0gb3AudGV4dDtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgdmFyIF9ub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGgpO1xuICAgICAgICB2YXIgYmVmb3JlID0gX25vZGUudGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuICAgICAgICB2YXIgYWZ0ZXIgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG4gICAgICAgIF9ub2RlLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJG0oUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBfcG9pbnQgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgX2tleSA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoMiA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgdmFyIHByZXYgPSBOb2RlLmdldChlZGl0b3IsIHByZXZQYXRoKTtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMik7XG4gICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGUyKSAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYudGV4dCArPSBfbm9kZTIudGV4dDtcbiAgICAgICAgfSBlbHNlIGlmICghVGV4dC5pc1RleHQoX25vZGUyKSAmJiAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICB2YXIgX3ByZXYkY2hpbGRyZW47XG4gICAgICAgICAgKF9wcmV2JGNoaWxkcmVuID0gcHJldi5jaGlsZHJlbikucHVzaC5hcHBseShfcHJldiRjaGlsZHJlbiwgX3RvQ29uc3VtYWJsZUFycmF5KF9ub2RlMi5jaGlsZHJlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmZhY2VzOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbm9kZTIpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2KSkpO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJG0oUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBfcG9pbnQyID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIF9rZXkyID0gX3N0ZXAzJHZhbHVlWzFdO1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoMyA9IG9wLnBhdGgsXG4gICAgICAgICAgbmV3UGF0aCA9IG9wLm5ld1BhdGg7XG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcbiAgICAgICAgdmFyIF9wYXJlbnQyID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDMpO1xuICAgICAgICB2YXIgX2luZGV4MiA9IF9wYXRoM1tfcGF0aDMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIFRoaXMgaXMgdHJpY2t5LCBidXQgc2luY2UgdGhlIGBwYXRoYCBhbmQgYG5ld1BhdGhgIGJvdGggcmVmZXIgdG9cbiAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2YgZGF0ZS4gU28gaW5zdGVhZCBvZiB1c2luZyB0aGUgYG9wLm5ld1BhdGhgIGRpcmVjdGx5LCB3ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cbiAgICAgICAgX3BhcmVudDIuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDIsIDEpO1xuICAgICAgICB2YXIgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShfcGF0aDMsIG9wKTtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQodHJ1ZVBhdGgpKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIG5ld1BhcmVudC5jaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIF9ub2RlMyk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJG0oUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgX3N0ZXA0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBfcG9pbnQzID0gX3N0ZXA0JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIF9rZXkzID0gX3N0ZXA0JHZhbHVlWzFdO1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGg0ID0gb3AucGF0aDtcbiAgICAgICAgdmFyIF9pbmRleDMgPSBfcGF0aDRbX3BhdGg0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgX3BhcmVudDMgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNCk7XG4gICAgICAgIF9wYXJlbnQzLmNoaWxkcmVuLnNwbGljZShfaW5kZXgzLCAxKTtcbiAgICAgICAgLy8gVHJhbnNmb3JtIGFsbCB0aGUgcG9pbnRzIGluIHRoZSB2YWx1ZSwgYnV0IGlmIHRoZSBwb2ludCB3YXMgaW4gdGhlXG4gICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRtKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgIF9zdGVwNTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwNSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNS52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgX3BvaW50NCA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBfa2V5NCA9IF9zdGVwNSR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ0LCBvcCk7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcmV2ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkbShOb2RlLnRleHRzKGVkaXRvcikpLFxuICAgICAgICAgICAgICAgICAgX3N0ZXA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0ZXA2JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA2LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgICBuID0gX3N0ZXA2JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgIHAgPSBfc3RlcDYkdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfcHJldiA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcmVmZXJOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXh0WzFdLCBfcGF0aDQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSBQYXRoLmNvbW1vbihfcHJldlsxXSwgX3BhdGg0KS5sZW5ndGggPCBQYXRoLmNvbW1vbihuZXh0WzFdLCBfcGF0aDQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmICFwcmVmZXJOZXh0KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDUgPSBvcC5wYXRoLFxuICAgICAgICAgIF9vZmZzZXQgPSBvcC5vZmZzZXQsXG4gICAgICAgICAgX3RleHQgPSBvcC50ZXh0O1xuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG4gICAgICAgIHZhciBfYmVmb3JlID0gX25vZGU0LnRleHQuc2xpY2UoMCwgX29mZnNldCk7XG4gICAgICAgIHZhciBfYWZ0ZXIgPSBfbm9kZTQudGV4dC5zbGljZShfb2Zmc2V0ICsgX3RleHQubGVuZ3RoKTtcbiAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRtKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgIF9zdGVwNztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwNyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgX3BvaW50NSA9IF9zdGVwNyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBfa2V5NSA9IF9zdGVwNyR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNiA9IG9wLnBhdGgsXG4gICAgICAgICAgcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllcyA9IG9wLm5ld1Byb3BlcnRpZXM7XG4gICAgICAgIGlmIChfcGF0aDYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSByb290IG5vZGUhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG4gICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0aGUgXFxcIlwiLmNvbmNhdChfa2V5NiwgXCJcXFwiIHByb3BlcnR5IG9mIG5vZGVzIVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1Byb3BlcnRpZXNbX2tleTZdO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk2XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuICAgICAgICBmb3IgKHZhciBfa2V5NyBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9rZXk3KSkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5N107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIgX25ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQkZSh7fSwgX25ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfa2V5OCBpbiBfbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IF9uZXdQcm9wZXJ0aWVzW19rZXk4XTtcbiAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoX2tleTggPT09ICdhbmNob3InIHx8IF9rZXk4ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgXFxcIlwiLmNvbmNhdChfa2V5OCwgXCJcXFwiIHNlbGVjdGlvbiBwcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGlvbltfa2V5OF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleThdID0gX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNyA9IG9wLnBhdGgsXG4gICAgICAgICAgcG9zaXRpb24gPSBvcC5wb3NpdGlvbixcbiAgICAgICAgICBfcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXM7XG4gICAgICAgIGlmIChfcGF0aDcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbm9kZTYgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNyk7XG4gICAgICAgIHZhciBfcGFyZW50NCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg3KTtcbiAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV3Tm9kZTtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlNikpIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTIgPSBfbm9kZTYudGV4dC5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgICAgdmFyIF9hZnRlcjIgPSBfbm9kZTYudGV4dC5zbGljZShwb3NpdGlvbik7XG4gICAgICAgICAgX25vZGU2LnRleHQgPSBfYmVmb3JlMjtcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogX2FmdGVyMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfYmVmb3JlMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgICAgdmFyIF9hZnRlcjMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgIF9ub2RlNi5jaGlsZHJlbiA9IF9iZWZvcmUzO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogX2FmdGVyM1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJlbnQ0LmNoaWxkcmVuLnNwbGljZShfaW5kZXg0ICsgMSwgMCwgbmV3Tm9kZSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJG0oUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgX3N0ZXA4O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXA4JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA4LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBfcG9pbnQ2ID0gX3N0ZXA4JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIF9rZXk5ID0gX3N0ZXA4JHZhbHVlWzFdO1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDYsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I4LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgR2VuZXJhbFRyYW5zZm9ybXMgPSB7XG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBpbW1lci5jcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGltbWVyLmNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgIHRyeSB7XG4gICAgICBzZWxlY3Rpb24gPSBhcHBseVRvRHJhZnQoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZWRpdG9yLmNoaWxkcmVuID0gaW1tZXIuZmluaXNoRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IGltbWVyLmlzRHJhZnQoc2VsZWN0aW9uKSA/IGltbWVyLmZpbmlzaERyYWZ0KHNlbGVjdGlvbikgOiBzZWxlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgaW5zZXJ0Tm9kZXM6IGZ1bmN0aW9uIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuaW5zZXJ0Tm9kZXMobm9kZXMsIG9wdGlvbnMpO1xuICB9LFxuICBsaWZ0Tm9kZXM6IGZ1bmN0aW9uIGxpZnROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubGlmdE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtZXJnZU5vZGVzOiBmdW5jdGlvbiBtZXJnZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5tZXJnZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtb3ZlTm9kZXM6IGZ1bmN0aW9uIG1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICByZW1vdmVOb2RlczogZnVuY3Rpb24gcmVtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnJlbW92ZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBzZXROb2RlczogZnVuY3Rpb24gc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5zZXROb2Rlcyhwcm9wcywgb3B0aW9ucyk7XG4gIH0sXG4gIHNwbGl0Tm9kZXM6IGZ1bmN0aW9uIHNwbGl0Tm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNwbGl0Tm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIHVuc2V0Tm9kZXM6IGZ1bmN0aW9uIHVuc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcywgb3B0aW9ucykge1xuICAgIGVkaXRvci51bnNldE5vZGVzKHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgdW53cmFwTm9kZXM6IGZ1bmN0aW9uIHVud3JhcE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci51bndyYXBOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgd3JhcE5vZGVzOiBmdW5jdGlvbiB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLndyYXBOb2RlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNlbGVjdGlvblRyYW5zZm9ybXMgPSB7XG4gIGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuY29sbGFwc2Uob3B0aW9ucyk7XG4gIH0sXG4gIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IuZGVzZWxlY3QoKTtcbiAgfSxcbiAgbW92ZTogZnVuY3Rpb24gbW92ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZShvcHRpb25zKTtcbiAgfSxcbiAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICBlZGl0b3Iuc2VsZWN0KHRhcmdldCk7XG4gIH0sXG4gIHNldFBvaW50OiBmdW5jdGlvbiBzZXRQb2ludChlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldFBvaW50KHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcykge1xuICAgIGVkaXRvci5zZXRTZWxlY3Rpb24ocHJvcHMpO1xuICB9XG59O1xuXG4vKlxuICBDdXN0b20gZGVlcCBlcXVhbCBjb21wYXJpc29uIGZvciBTbGF0ZSBub2Rlcy5cblxuICBXZSBkb24ndCBuZWVkIGdlbmVyYWwgcHVycG9zZSBkZWVwIGVxdWFsaXR5O1xuICBTbGF0ZSBvbmx5IHN1cHBvcnRzIHBsYWluIHZhbHVlcywgQXJyYXlzLCBhbmQgbmVzdGVkIG9iamVjdHMuXG4gIENvbXBsZXggdmFsdWVzIG5lc3RlZCBpbnNpZGUgQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG4gIFNsYXRlIG9iamVjdHMgYXJlIGRlc2lnbmVkIHRvIGJlIHNlcmlhbGlzZWQsIHNvXG4gIG1pc3Npbmcga2V5cyBhcmUgZGVsaWJlcmF0ZWx5IG5vcm1hbGlzZWQgdG8gdW5kZWZpbmVkLlxuICovXG52YXIgaXNEZWVwRXF1YWwgPSBmdW5jdGlvbiBpc0RlZXBFcXVhbChub2RlLCBhbm90aGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgdmFyIGEgPSBub2RlW2tleV07XG4gICAgdmFyIGIgPSBhbm90aGVyW2tleV07XG4gICAgaWYgKGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWwoYSwgYikpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXG4gICAgRGVlcCBvYmplY3QgZXF1YWxpdHkgaXMgb25seSBuZWNlc3NhcnkgaW4gb25lIGRpcmVjdGlvbjsgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxuICAqL1xuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UpO1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSB1bndyYXBFeHBvcnRzKG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKTtcblxudmFyIF9leGNsdWRlZCQ0ID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG5mdW5jdGlvbiBvd25LZXlzJGQoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkZChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkZChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFJhbmdlID0ge1xuICBlZGdlczogZnVuY3Rpb24gZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKSA9PT0gcmV2ZXJzZSA/IFthbmNob3IsIGZvY3VzXSA6IFtmb2N1cywgYW5jaG9yXTtcbiAgfSxcbiAgZW5kOiBmdW5jdGlvbiBlbmQocmFuZ2UpIHtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICAgIHJldHVybiBlbmQ7XG4gIH0sXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhyYW5nZS5hbmNob3IsIGFub3RoZXIuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMocmFuZ2UuZm9jdXMsIGFub3RoZXIuZm9jdXMpO1xuICB9LFxuICBzdXJyb3VuZHM6IGZ1bmN0aW9uIHN1cnJvdW5kcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgdmFyIGludGVyc2VjdGlvblJhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCB0YXJnZXQpO1xuICAgIGlmICghaW50ZXJzZWN0aW9uUmFuZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlLmVxdWFscyhpbnRlcnNlY3Rpb25SYW5nZSwgdGFyZ2V0KTtcbiAgfSxcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5hbmNob3IpIHx8IFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuZm9jdXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgcnMgPSBfUmFuZ2UkZWRnZXM0WzBdLFxuICAgICAgICByZSA9IF9SYW5nZSRlZGdlczRbMV07XG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzNSA9IFJhbmdlLmVkZ2VzKHRhcmdldCksXG4gICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgdHMgPSBfUmFuZ2UkZWRnZXM2WzBdLFxuICAgICAgICB0ZSA9IF9SYW5nZSRlZGdlczZbMV07XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuICAgIHZhciBfUmFuZ2UkZWRnZXM3ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgX1JhbmdlJGVkZ2VzOCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczcsIDIpLFxuICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM4WzBdLFxuICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzOFsxXTtcbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG4gICAgaWYgKFBvaW50LmlzUG9pbnQodGFyZ2V0KSkge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIHN0YXJ0KSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgZW5kKSA8PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBzdGFydC5wYXRoKSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBlbmQucGF0aCkgPD0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGlzQWZ0ZXJTdGFydCAmJiBpc0JlZm9yZUVuZDtcbiAgfSxcbiAgaW50ZXJzZWN0aW9uOiBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByYW5nZS5hbmNob3I7XG4gICAgICByYW5nZS5mb2N1cztcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkNCk7XG4gICAgdmFyIF9SYW5nZSRlZGdlczkgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICBfUmFuZ2UkZWRnZXMxMCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczksIDIpLFxuICAgICAgczEgPSBfUmFuZ2UkZWRnZXMxMFswXSxcbiAgICAgIGUxID0gX1JhbmdlJGVkZ2VzMTBbMV07XG4gICAgdmFyIF9SYW5nZSRlZGdlczExID0gUmFuZ2UuZWRnZXMoYW5vdGhlciksXG4gICAgICBfUmFuZ2UkZWRnZXMxMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczExLCAyKSxcbiAgICAgIHMyID0gX1JhbmdlJGVkZ2VzMTJbMF0sXG4gICAgICBlMiA9IF9SYW5nZSRlZGdlczEyWzFdO1xuICAgIHZhciBzdGFydCA9IFBvaW50LmlzQmVmb3JlKHMxLCBzMikgPyBzMiA6IHMxO1xuICAgIHZhciBlbmQgPSBQb2ludC5pc0JlZm9yZShlMSwgZTIpID8gZTEgOiBlMjtcbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRkKHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuICBpc0JhY2t3YXJkOiBmdW5jdGlvbiBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcixcbiAgICAgIGZvY3VzID0gcmFuZ2UuZm9jdXM7XG4gICAgcmV0dXJuIFBvaW50LmlzQWZ0ZXIoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG4gIGlzQ29sbGFwc2VkOiBmdW5jdGlvbiBpc0NvbGxhcHNlZChyYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG4gIGlzRXhwYW5kZWQ6IGZ1bmN0aW9uIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcbiAgaXNGb3J3YXJkOiBmdW5jdGlvbiBpc0ZvcndhcmQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICB9LFxuICBpc1JhbmdlOiBmdW5jdGlvbiBpc1JhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5hbmNob3IpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuZm9jdXMpO1xuICB9LFxuICBwb2ludHM6IGZ1bmN0aW9uKiBwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcbiAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIF9SYW5nZSRlZGdlczEzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgX1JhbmdlJGVkZ2VzMTQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMxMywgMSksXG4gICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczE0WzBdO1xuICAgIHJldHVybiBzdGFydDtcbiAgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocmFuZ2UsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBpbW1lci5wcm9kdWNlKHJhbmdlLCBmdW5jdGlvbiAocikge1xuICAgICAgaWYgKHIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnaW53YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICAgICAgdmFyIGFmZmluaXR5QW5jaG9yO1xuICAgICAgdmFyIGFmZmluaXR5Rm9jdXM7XG4gICAgICBpZiAoYWZmaW5pdHkgPT09ICdpbndhcmQnKSB7XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQsIG1ha2Ugc3VyZSB0byB1c2UgdGhlIHNhbWUgYWZmaW5pdHkgdG9cbiAgICAgICAgLy8gYXZvaWQgdGhlIHR3byBwb2ludHMgcGFzc2luZyBlYWNoIG90aGVyIGFuZCBleHBhbmRpbmcgaW4gdGhlIG9wcG9zaXRlXG4gICAgICAgIC8vIGRpcmVjdGlvblxuICAgICAgICB2YXIgaXNDb2xsYXBzZWQgPSBSYW5nZS5pc0NvbGxhcHNlZChyKTtcbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdvdXR3YXJkJykge1xuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBhZmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHZhciBhbmNob3IgPSBQb2ludC50cmFuc2Zvcm0oci5hbmNob3IsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUFuY2hvclxuICAgICAgfSk7XG4gICAgICB2YXIgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0oci5mb2N1cywgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5Rm9jdXNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhbmNob3IgfHwgIWZvY3VzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgci5hbmNob3IgPSBhbmNob3I7XG4gICAgICByLmZvY3VzID0gZm9jdXM7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hhcmVkIHRoZSBmdW5jdGlvbiB3aXRoIGlzRWxlbWVudFR5cGUgdXRpbGl0eVxuICovXG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgIUVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEVsZW1lbnQgPSB7XG4gIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIGlzQW5jZXN0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pO1xuICB9LFxuICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcbiAgaXNFbGVtZW50TGlzdDogZnVuY3Rpb24gaXNFbGVtZW50TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQodmFsKTtcbiAgICB9KTtcbiAgfSxcbiAgaXNFbGVtZW50UHJvcHM6IGZ1bmN0aW9uIGlzRWxlbWVudFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuICE9PSB1bmRlZmluZWQ7XG4gIH0sXG4gIGlzRWxlbWVudFR5cGU6IGZ1bmN0aW9uIGlzRWxlbWVudFR5cGUodmFsdWUsIGVsZW1lbnRWYWwpIHtcbiAgICB2YXIgZWxlbWVudEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3R5cGUnO1xuICAgIHJldHVybiBpc0VsZW1lbnQodmFsdWUpICYmIHZhbHVlW2VsZW1lbnRLZXldID09PSBlbGVtZW50VmFsO1xuICB9LFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDMgPSBbXCJjaGlsZHJlblwiXSxcbiAgX2V4Y2x1ZGVkMiQzID0gW1widGV4dFwiXTtcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGwobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGwobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRsKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkbChvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGwobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkbChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIElTX05PREVfTElTVF9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTm9kZSA9IHtcbiAgYW5jZXN0b3I6IGZ1bmN0aW9uIGFuY2VzdG9yKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBhbmNlc3RvcnM6IGZ1bmN0aW9uIGFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGwoUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgbiA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcCk7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gW24sIHBdO1xuICAgICAgICAgIHlpZWxkIGVudHJ5O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBjaGlsZDogZnVuY3Rpb24gY2hpbGQocm9vdCwgaW5kZXgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGNoaWxkIG9mIGEgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuICAgIHZhciBjID0gcm9vdC5jaGlsZHJlbltpbmRleF07XG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0sXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2U7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gYW5jZXN0b3IuY2hpbGRyZW47XG4gICAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG4gICAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hpbGQgPSBOb2RlLmNoaWxkKGFuY2VzdG9yLCBpbmRleCk7XG4gICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgICAgaW5kZXggPSByZXZlcnNlID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfSxcbiAgY29tbW9uOiBmdW5jdGlvbiBjb21tb24ocm9vdCwgcGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBwID0gUGF0aC5jb21tb24ocGF0aCwgYW5vdGhlcik7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBkZXNjZW5kYW50OiBmdW5jdGlvbiBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIHRoZSByb290IGVkaXRvciBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBkZXNjZW5kYW50czogZnVuY3Rpb24gZGVzY2VuZGFudHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkbChOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXAyJHZhbHVlWzFdO1xuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjb2VyY2UgaGVyZSBiZWNhdXNlIGNoZWNraW5nIHRoZSBwYXRoJ3MgbGVuZ3RoIGRvZXNcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZSB0aGF0IGBub2RlYCBpcyBub3QgYSBgRWRpdG9yYCwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93LlxuICAgICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBlbGVtZW50czogZnVuY3Rpb24gZWxlbWVudHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkbChOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXAzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXAzJHZhbHVlWzFdO1xuICAgICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBleHRyYWN0UHJvcHM6IGZ1bmN0aW9uIGV4dHJhY3RQcm9wcyhub2RlKSB7XG4gICAgaWYgKEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSkge1xuICAgICAgbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkJDMpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudGV4dDtcbiAgICAgICAgdmFyIF9wcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMyk7XG4gICAgICByZXR1cm4gX3Byb3BlcnRpZXM7XG4gICAgfVxuICB9LFxuICBmaXJzdDogZnVuY3Rpb24gZmlyc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuWzBdO1xuICAgICAgICBwLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG4gIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudChyb290LCByYW5nZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBhIGZyYWdtZW50IHN0YXJ0aW5nIGZyb20gYSByb290IHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IGltbWVyLnByb2R1Y2Uoe1xuICAgICAgY2hpbGRyZW46IHJvb3QuY2hpbGRyZW5cbiAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMociwge1xuICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIHBhdGggPSBfcmVmMlsxXTtcbiAgICAgICAgICByZXR1cm4gIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGwobm9kZUVudHJpZXMpLFxuICAgICAgICBfc3RlcDQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDIpLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwNCR2YWx1ZVsxXTtcbiAgICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KHIsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBsZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuICAgICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBfbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcbiAgICAgICAgICAgIF9sZWFmLnRleHQgPSBfbGVhZi50ZXh0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgIH1cbiAgICAgIGlmIChFZGl0b3IuaXNFZGl0b3IocikpIHtcbiAgICAgICAgci5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdSb290LmNoaWxkcmVuO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldElmKHJvb3QsIHBhdGgpO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBnZXRJZjogZnVuY3Rpb24gZ2V0SWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gaGFzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBpc05vZGU6IGZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiBUZXh0LmlzVGV4dCh2YWx1ZSkgfHwgRWxlbWVudC5pc0VsZW1lbnQodmFsdWUpIHx8IEVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG4gIGlzTm9kZUxpc3Q6IGZ1bmN0aW9uIGlzTm9kZUxpc3QodmFsdWUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZWRSZXN1bHQgPSBJU19OT0RFX0xJU1RfQ0FDSEUuZ2V0KHZhbHVlKTtcbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuICAgIHZhciBpc05vZGVMaXN0ID0gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIE5vZGUuaXNOb2RlKHZhbCk7XG4gICAgfSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gbi5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBuID0gbi5jaGlsZHJlbltpXTtcbiAgICAgICAgcC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBsZWFmOiBmdW5jdGlvbiBsZWFmKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGwoUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMobm9kZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnRQcm9wcyhwcm9wcykgJiYgRWxlbWVudC5tYXRjaGVzKG5vZGUsIHByb3BzKSB8fCBUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0LmlzVGV4dFByb3BzKHByb3BzKSAmJiBUZXh0Lm1hdGNoZXMobm9kZSwgcHJvcHMpO1xuICB9LFxuICBub2RlczogZnVuY3Rpb24gbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBwYXNzID0gb3B0aW9ucy5wYXNzLFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlMiA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UyO1xuICAgICAgdmFyIF9vcHRpb25zJGZyb20gPSBvcHRpb25zLmZyb20sXG4gICAgICAgIGZyb20gPSBfb3B0aW9ucyRmcm9tID09PSB2b2lkIDAgPyBbXSA6IF9vcHRpb25zJGZyb20sXG4gICAgICAgIHRvID0gb3B0aW9ucy50bztcbiAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgdmFyIHAgPSBbXTtcbiAgICAgIHZhciBuID0gcm9vdDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pKSB7XG4gICAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGFsbG93ZWQgdG8gZ28gZG93bndhcmQgYW5kIHdlIGhhdmVuJ3QgZGVzY2VuZGVkIHlldCwgZG8uXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gcmV2ZXJzZSA/IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBmcm9tKSkge1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHAgPSBwLmNvbmNhdChuZXh0SW5kZXgpO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgcm9vdCBhbmQgd2UgY2FuJ3QgZ28gZG93biwgd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgZ29pbmcgZm9yd2FyZC4uLlxuICAgICAgICBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwKTtcbiAgICAgICAgICBpZiAoTm9kZS5oYXMocm9vdCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIGJhY2t3YXJkLi4uXG4gICAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICAgIHZhciBfbmV3UGF0aCA9IFBhdGgucHJldmlvdXMocCk7XG4gICAgICAgICAgcCA9IF9uZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UncmUgZ29pbmcgdXB3YXJkLi4uXG4gICAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICAgIHZhciBwID0gTm9kZS5nZXQocm9vdCwgcGFyZW50UGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KHApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgb2YgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSByb290LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9LFxuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcbiAgdGV4dHM6IGZ1bmN0aW9uIHRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGwoTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwNjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXA2JHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwNiR2YWx1ZVsxXTtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyRjKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBPcGVyYXRpb24gPSB7XG4gIGlzTm9kZU9wZXJhdGlvbjogZnVuY3Rpb24gaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcbiAgaXNPcGVyYXRpb246IGZ1bmN0aW9uIGlzT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgTm9kZS5pc05vZGUodmFsdWUubm9kZSk7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIFBhdGguaXNQYXRoKHZhbHVlLm5ld1BhdGgpO1xuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgTm9kZS5pc05vZGUodmFsdWUubm9kZSk7XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm5ld1Byb3BlcnRpZXMpO1xuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgaXNPcGVyYXRpb25MaXN0OiBmdW5jdGlvbiBpc09wZXJhdGlvbkxpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWwpO1xuICAgIH0pO1xuICB9LFxuICBpc1NlbGVjdGlvbk9wZXJhdGlvbjogZnVuY3Rpb24gaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG4gIGlzVGV4dE9wZXJhdGlvbjogZnVuY3Rpb24gaXNUZXh0T3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3RleHQnKTtcbiAgfSxcbiAgaW52ZXJzZTogZnVuY3Rpb24gaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5wcmV2aW91cyhvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBvcC5uZXdQYXRoLFxuICAgICAgICAgICAgcGF0aCA9IG9wLnBhdGg7XG4gICAgICAgICAgLy8gUEVSRjogaW4gdGhpcyBjYXNlIHRoZSBtb3ZlIG9wZXJhdGlvbiBpcyBhIG5vLW9wIGFueXdheXMuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSBtb3ZlIGhhcHBlbnMgY29tcGxldGVseSB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IHRoZSBwYXRoIGFuZFxuICAgICAgICAgIC8vIG5ld1BhdGggYXJlIHN0YWJsZSB3aXRoIHJlc3BlY3QgdG8gZWFjaCBvdGhlci5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgbW92ZSBkb2VzIG5vdCBoYXBwZW4gd2l0aGluIGEgc2luZ2xlIHBhcmVudCBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAgIC8vIGZvciB0aGUgbW92ZSB0byBpbXBhY3QgdGhlIHRydWUgcGF0aCB0byB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIG5vZGVcbiAgICAgICAgICAvLyB3YXMgcmVtb3ZlZCBmcm9tIGFuZCB3aGVyZSBpdCB3YXMgaW5zZXJ0ZWQuIFdlIGhhdmUgdG8gYWRqdXN0IGZvciB0aGlzXG4gICAgICAgICAgLy8gYW5kIGZpbmQgdGhlIG9yaWdpbmFsIHBhdGguIFdlIGNhbiBhY2NvbXBsaXNoIHRoaXMgKG9ubHkgaW4gbm9uLXNpYmxpbmcpXG4gICAgICAgICAgLy8gbW92ZXMgYnkgbG9va2luZyBhdCB0aGUgaW1wYWN0IG9mIHRoZSBtb3ZlIG9wZXJhdGlvbiBvbiB0aGUgbm9kZVxuICAgICAgICAgIC8vIGFmdGVyIHRoZSBvcmlnaW5hbCBtb3ZlIHBhdGguXG4gICAgICAgICAgdmFyIGludmVyc2VQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICAgIHZhciBpbnZlcnNlTmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKFBhdGgubmV4dChwYXRoKSwgb3ApO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwYXRoOiBpbnZlcnNlUGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGg6IGludmVyc2VOZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gb3AucHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBfbmV3UHJvcGVydGllcyA9IG9wLm5ld1Byb3BlcnRpZXM7XG4gICAgICAgICAgaWYgKF9wcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgubmV4dChvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSVNfRURJVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTtcbnZhciBpc0VkaXRvciA9IGZ1bmN0aW9uIGlzRWRpdG9yKHZhbHVlKSB7XG4gIHZhciBjYWNoZWRJc0VkaXRvciA9IElTX0VESVRPUl9DQUNIRS5nZXQodmFsdWUpO1xuICBpZiAoY2FjaGVkSXNFZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjYWNoZWRJc0VkaXRvcjtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlzRWRpdG9yID0gdHlwZW9mIHZhbHVlLmFkZE1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFNvZnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzRWxlbWVudFJlYWRPbmx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc0lubGluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNTZWxlY3RhYmxlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5nZXREaXJ0eVBhdGhzID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gIHJldHVybiBpc0VkaXRvcjtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBFZGl0b3IgPSB7XG4gIGFib3ZlOiBmdW5jdGlvbiBhYm92ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmFib3ZlKG9wdGlvbnMpO1xuICB9LFxuICBhZGRNYXJrOiBmdW5jdGlvbiBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYWZ0ZXIoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5iZWZvcmUoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBkZWxldGVCYWNrd2FyZDogZnVuY3Rpb24gZGVsZXRlQmFja3dhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQgPT09IHZvaWQgMCA/ICdjaGFyYWN0ZXInIDogX29wdGlvbnMkdW5pdDtcbiAgICBlZGl0b3IuZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH0sXG4gIGRlbGV0ZUZvcndhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR1bml0MiA9IG9wdGlvbnMudW5pdCxcbiAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0MiA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0MjtcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcbiAgZGVsZXRlRnJhZ21lbnQ6IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50KGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChvcHRpb25zKTtcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmVkZ2VzKGF0KTtcbiAgfSxcbiAgZWxlbWVudFJlYWRPbmx5OiBmdW5jdGlvbiBlbGVtZW50UmVhZE9ubHkoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBlZGl0b3IuZWxlbWVudFJlYWRPbmx5KG9wdGlvbnMpO1xuICB9LFxuICBlbmQ6IGZ1bmN0aW9uIGVuZChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5lbmQoYXQpO1xuICB9LFxuICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZmlyc3QoYXQpO1xuICB9LFxuICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZnJhZ21lbnQoYXQpO1xuICB9LFxuICBoYXNCbG9ja3M6IGZ1bmN0aW9uIGhhc0Jsb2NrcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0Jsb2NrcyhlbGVtZW50KTtcbiAgfSxcbiAgaGFzSW5saW5lczogZnVuY3Rpb24gaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0lubGluZXMoZWxlbWVudCk7XG4gIH0sXG4gIGhhc1BhdGg6IGZ1bmN0aW9uIGhhc1BhdGgoZWRpdG9yLCBwYXRoKSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNQYXRoKHBhdGgpO1xuICB9LFxuICBoYXNUZXh0czogZnVuY3Rpb24gaGFzVGV4dHMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNUZXh0cyhlbGVtZW50KTtcbiAgfSxcbiAgaW5zZXJ0QnJlYWs6IGZ1bmN0aW9uIGluc2VydEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRCcmVhaygpO1xuICB9LFxuICBpbnNlcnRGcmFnbWVudDogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyk7XG4gIH0sXG4gIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG4gIGluc2VydFNvZnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoKTtcbiAgfSxcbiAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgfSxcbiAgaXNCbG9jazogZnVuY3Rpb24gaXNCbG9jayhlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0Jsb2NrKHZhbHVlKTtcbiAgfSxcbiAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRWRnZShwb2ludCwgYXQpO1xuICB9LFxuICBpc0VkaXRvcjogZnVuY3Rpb24gaXNFZGl0b3IkMSh2YWx1ZSkge1xuICAgIHJldHVybiBpc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG4gIGlzRWxlbWVudFJlYWRPbmx5OiBmdW5jdGlvbiBpc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVsZW1lbnQpO1xuICB9LFxuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eShlbGVtZW50KTtcbiAgfSxcbiAgaXNFbmQ6IGZ1bmN0aW9uIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VuZChwb2ludCwgYXQpO1xuICB9LFxuICBpc0lubGluZTogZnVuY3Rpb24gaXNJbmxpbmUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuICBpc05vcm1hbGl6aW5nOiBmdW5jdGlvbiBpc05vcm1hbGl6aW5nKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuaXNOb3JtYWxpemluZygpO1xuICB9LFxuICBpc1NlbGVjdGFibGU6IGZ1bmN0aW9uIGlzU2VsZWN0YWJsZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1NlbGVjdGFibGUodmFsdWUpO1xuICB9LFxuICBpc1N0YXJ0OiBmdW5jdGlvbiBpc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1N0YXJ0KHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzVm9pZDogZnVuY3Rpb24gaXNWb2lkKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVm9pZCh2YWx1ZSk7XG4gIH0sXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IubGFzdChhdCk7XG4gIH0sXG4gIGxlYWY6IGZ1bmN0aW9uIGxlYWYoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IubGVhZihhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IubGV2ZWxzKG9wdGlvbnMpO1xuICB9LFxuICBtYXJrczogZnVuY3Rpb24gbWFya3MoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5nZXRNYXJrcygpO1xuICB9LFxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IubmV4dChvcHRpb25zKTtcbiAgfSxcbiAgbm9kZTogZnVuY3Rpb24gbm9kZShlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5ub2RlKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5ub3JtYWxpemUob3B0aW9ucyk7XG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhcmVudChhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGF0aChhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhdGhSZWY6IGZ1bmN0aW9uIHBhdGhSZWYoZWRpdG9yLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoUmVmKHBhdGgsIG9wdGlvbnMpO1xuICB9LFxuICBwYXRoUmVmczogZnVuY3Rpb24gcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoUmVmcygpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24gcG9pbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnQoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwb2ludFJlZjogZnVuY3Rpb24gcG9pbnRSZWYoZWRpdG9yLCBwb2ludCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnRSZWYocG9pbnQsIG9wdGlvbnMpO1xuICB9LFxuICBwb2ludFJlZnM6IGZ1bmN0aW9uIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50UmVmcygpO1xuICB9LFxuICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvc2l0aW9ucyhvcHRpb25zKTtcbiAgfSxcbiAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucHJldmlvdXMob3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlOiBmdW5jdGlvbiByYW5nZShlZGl0b3IsIGF0LCB0bykge1xuICAgIHJldHVybiBlZGl0b3IucmFuZ2UoYXQsIHRvKTtcbiAgfSxcbiAgcmFuZ2VSZWY6IGZ1bmN0aW9uIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlUmVmKHJhbmdlLCBvcHRpb25zKTtcbiAgfSxcbiAgcmFuZ2VSZWZzOiBmdW5jdGlvbiByYW5nZVJlZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZVJlZnMoKTtcbiAgfSxcbiAgcmVtb3ZlTWFyazogZnVuY3Rpb24gcmVtb3ZlTWFyayhlZGl0b3IsIGtleSkge1xuICAgIGVkaXRvci5yZW1vdmVNYXJrKGtleSk7XG4gIH0sXG4gIHNldE5vcm1hbGl6aW5nOiBmdW5jdGlvbiBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBlZGl0b3Iuc2V0Tm9ybWFsaXppbmcoaXNOb3JtYWxpemluZyk7XG4gIH0sXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdGFydChhdCk7XG4gIH0sXG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnN0cmluZyhhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIHVuaGFuZ1JhbmdlOiBmdW5jdGlvbiB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci51bmhhbmdSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIFwidm9pZFwiOiBmdW5jdGlvbiBfdm9pZChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yW1widm9pZFwiXShvcHRpb25zKTtcbiAgfSxcbiAgd2l0aG91dE5vcm1hbGl6aW5nOiBmdW5jdGlvbiB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIGVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZm4pO1xuICB9LFxuICBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGU6IGZ1bmN0aW9uIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZShlZGl0b3IsIHByZXZOb2RlLCBjdXJOb2RlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUocHJldk5vZGUsIGN1ck5vZGUpO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTG9jYXRpb24gPSB7XG4gIGlzTG9jYXRpb246IGZ1bmN0aW9uIGlzTG9jYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUpIHx8IFBvaW50LmlzUG9pbnQodmFsdWUpIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUpO1xuICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNwYW4gPSB7XG4gIGlzU3BhbjogZnVuY3Rpb24gaXNTcGFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZS5ldmVyeShQYXRoLmlzUGF0aCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkYihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRiKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRiKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUG9pbnQgPSB7XG4gIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gUGF0aC5jb21wYXJlKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gLTE7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gYW5vdGhlci5vZmZzZXQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGlzQWZ0ZXI6IGZ1bmN0aW9uIGlzQWZ0ZXIocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG4gIGlzQmVmb3JlOiBmdW5jdGlvbiBpc0JlZm9yZShwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG4gIGlzUG9pbnQ6IGZ1bmN0aW9uIGlzUG9pbnQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9pbnQsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBpbW1lci5wcm9kdWNlKHBvaW50LCBmdW5jdGlvbiAocCkge1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgICAgIHZhciBwYXRoID0gcC5wYXRoLFxuICAgICAgICBvZmZzZXQgPSBwLm9mZnNldDtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIChvcC5vZmZzZXQgPCBvZmZzZXQgfHwgb3Aub2Zmc2V0ID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IFBhdGguaXNBbmNlc3RvcihvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBfc2NydWJiZXIgPSB1bmRlZmluZWQ7XG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxuICogaW50ZXJuYWxseSB3aGVuIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBjb250YWluaW5nIGVuZCB1c2VyIGRhdGEuIERldmVsb3BlcnNcbiAqIHVzaW5nIFNsYXRlIG1heSBjYWxsIFNjcnViYmVyLnNldFNjcnViYmVyKCkgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoaXNcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBwcmV2ZW50IHRoZSBjbGVhcnRleHQgbG9nZ2luZyBvZiAndGV4dCcgZmllbGRzIHdpdGhpbiBOb2RlczpcbiAqXG4gKiAgICBpbXBvcnQgeyBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcbiAqICAgIFNjcnViYmVyLnNldFNjcnViYmVyKChrZXksIHZhbCkgPT4ge1xuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXG4gKiAgICAgIHJldHVybiB2YWxcbiAqICAgIH0pO1xuICpcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNjcnViYmVyID0ge1xuICBzZXRTY3J1YmJlcjogZnVuY3Rpb24gc2V0U2NydWJiZXIoc2NydWJiZXIpIHtcbiAgICBfc2NydWJiZXIgPSBzY3J1YmJlcjtcbiAgfSxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcInRleHRcIl0sXG4gIF9leGNsdWRlZDIkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCIsIFwibWVyZ2VcIl07XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRrKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRrKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkayhvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGsobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRrKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGsoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIG93bktleXMkYShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRhKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRhKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgVGV4dCA9IHtcbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkbG9vc2UgPSBvcHRpb25zLmxvb3NlLFxuICAgICAgbG9vc2UgPSBfb3B0aW9ucyRsb29zZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRsb29zZTtcbiAgICBmdW5jdGlvbiBvbWl0VGV4dChvYmopIHtcbiAgICAgIG9iai50ZXh0O1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZCQyKTtcbiAgICAgIHJldHVybiByZXN0O1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWVwRXF1YWwobG9vc2UgPyBvbWl0VGV4dCh0ZXh0KSA6IHRleHQsIGxvb3NlID8gb21pdFRleHQoYW5vdGhlcikgOiBhbm90aGVyKTtcbiAgfSxcbiAgaXNUZXh0OiBmdW5jdGlvbiBpc1RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzVGV4dExpc3Q6IGZ1bmN0aW9uIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbCk7XG4gICAgfSk7XG4gIH0sXG4gIGlzVGV4dFByb3BzOiBmdW5jdGlvbiBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IHRleHRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWNvcmF0aW9uczogZnVuY3Rpb24gZGVjb3JhdGlvbnMobm9kZSwgX2RlY29yYXRpb25zKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtfb2JqZWN0U3ByZWFkJGEoe30sIG5vZGUpXTtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkayhfZGVjb3JhdGlvbnMpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBkZWMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGFuY2hvciA9IGRlYy5hbmNob3IsXG4gICAgICAgICAgZm9jdXMgPSBkZWMuZm9jdXMsXG4gICAgICAgICAgbWVyZ2VEZWNvcmF0aW9uID0gZGVjLm1lcmdlLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBfZXhjbHVkZWQyJDIpO1xuICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoZGVjKSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgICAgdmFyIGxlYWZFbmQgPSAwO1xuICAgICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgICB2YXIgZGVjb3JhdGlvbkVuZCA9IGVuZC5vZmZzZXQ7XG4gICAgICAgIHZhciBtZXJnZSA9IG1lcmdlRGVjb3JhdGlvbiAhPT0gbnVsbCAmJiBtZXJnZURlY29yYXRpb24gIT09IHZvaWQgMCA/IG1lcmdlRGVjb3JhdGlvbiA6IE9iamVjdC5hc3NpZ247XG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkayhsZWF2ZXMpLFxuICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGxlYWYgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGVhZi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsZWFmU3RhcnQgPSBsZWFmRW5kO1xuICAgICAgICAgICAgbGVhZkVuZCArPSBsZW5ndGg7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA8PSBsZWFmU3RhcnQgJiYgbGVhZkVuZCA8PSBkZWNvcmF0aW9uRW5kKSB7XG4gICAgICAgICAgICAgIG1lcmdlKGxlYWYsIHJlc3QpO1xuICAgICAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ICE9PSBkZWNvcmF0aW9uRW5kICYmIChkZWNvcmF0aW9uU3RhcnQgPT09IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0KSB8fCBkZWNvcmF0aW9uU3RhcnQgPiBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPCBsZWFmU3RhcnQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0ICYmIGxlYWZTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmFuZ2UgdG8gdGhlIG1pZGRsZSBpbnRlcnNlY3Rpbmcgc2VjdGlvbi4gRG8gdGhlIGVuZFxuICAgICAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cbiAgICAgICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uRW5kIDwgbGVhZkVuZCkge1xuICAgICAgICAgICAgICB2YXIgb2ZmID0gZGVjb3JhdGlvbkVuZCAtIGxlYWZTdGFydDtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKG9mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgb2ZmKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPiBsZWFmU3RhcnQpIHtcbiAgICAgICAgICAgICAgdmFyIF9vZmYgPSBkZWNvcmF0aW9uU3RhcnQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgICAgIGJlZm9yZSA9IF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZShtaWRkbGUsIHJlc3QpO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgICBuZXh0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHVzaChtaWRkbGUpO1xuICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgIG5leHQucHVzaChhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuICAgICAgICBsZWF2ZXMgPSBuZXh0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgbG9jYXRpb24gdG8gaW5zZXJ0IGNvbnRlbnQgaW50byB0aGUgZWRpdG9yLlxuICogQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXG4gKiBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxuICogY29tbW9uIHVzZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIGZyb20gYSBub24tc2VsZWN0ZWQgc3RhdGUuXG4gKi9cbnZhciBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKSB7XG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zZWxlY3Rpb247XG4gIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzBdO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gZnVuY3Rpb24gbWF0Y2hQYXRoKGVkaXRvciwgcGF0aCkge1xuICB2YXIgX0VkaXRvciRub2RlID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKSxcbiAgICBfRWRpdG9yJG5vZGUyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlLCAxKSxcbiAgICBub2RlID0gX0VkaXRvciRub2RlMlswXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4gPT09IG5vZGU7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRqKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRqKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkaihvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGoobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRqKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGooYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbi8vIENoYXJhY3RlciAoZ3JhcGhlbWUgY2x1c3RlcikgYm91bmRhcmllcyBhcmUgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG9cbi8vIHRoZSBkZWZhdWx0IGdyYXBoZW1lIGNsdXN0ZXIgYm91bmRhcnkgc3BlY2lmaWNhdGlvbiwgZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnMgdmFyaWFudFsxXS5cbi8vXG4vLyBSZWZlcmVuY2VzOlxuLy9cbi8vIFsxXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0RlZmF1bHRfR3JhcGhlbWVfQ2x1c3Rlcl9UYWJsZVxuLy8gWzJdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dFxuLy8gWzNdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QuaHRtbFxuLy8gWzRdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QudHh0XG4vKipcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIGEgc3RyaW5nIG9mIHRleHQuXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldENoYXJhY3RlckRpc3RhbmNlKHN0cikge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgaXNMVFIgPSAhaXNSVEw7XG4gIHZhciBjb2RlcG9pbnRzID0gaXNSVEwgPyBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSA6IHN0cjtcbiAgdmFyIGxlZnQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciByaWdodCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIGRpc3RhbmNlID0gMDtcbiAgLy8gRXZhbHVhdGlvbiBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBkZWZlcnJlZC5cbiAgdmFyIGdiMTEgPSBudWxsOyAvLyBJcyBHQjExIGFwcGxpY2FibGU/XG4gIHZhciBnYjEyT3IxMyA9IG51bGw7IC8vIElzIEdCMTIgb3IgR0IxMyBhcHBsaWNhYmxlP1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaihjb2RlcG9pbnRzKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9jaGFyID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgY29kZSA9IF9jaGFyLmNvZGVQb2ludEF0KDApO1xuICAgICAgaWYgKCFjb2RlKSBicmVhaztcbiAgICAgIHZhciB0eXBlID0gZ2V0Q29kZXBvaW50VHlwZShfY2hhciwgY29kZSk7XG4gICAgICB2YXIgX3JlZiA9IGlzTFRSID8gW3JpZ2h0LCB0eXBlXSA6IFt0eXBlLCBsZWZ0XTtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuICAgICAgbGVmdCA9IF9yZWYyWzBdO1xuICAgICAgcmlnaHQgPSBfcmVmMlsxXTtcbiAgICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuWldKKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLkV4dFBpY3QpKSB7XG4gICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgZGlzdGFuY2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2IxMSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlJJKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLlJJKSkge1xuICAgICAgICBpZiAoZ2IxMk9yMTMgIT09IG51bGwpIHtcbiAgICAgICAgICBnYjEyT3IxMyA9ICFnYjEyT3IxMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICAgIGdiMTJPcjEzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2IxMk9yMTMgPSBlbmRzV2l0aE9kZE51bWJlck9mUklzKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ2IxMk9yMTMpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiByaWdodCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRpc3RhbmNlICs9IF9jaGFyLmxlbmd0aDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4gZGlzdGFuY2UgfHwgMTtcbn07XG52YXIgU1BBQ0UgPSAvXFxzLztcbnZhciBQVU5DVFVBVElPTiA9IC9bXFx1MDAyQlxcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbnZhciBDSEFNRUxFT04gPSAvWydcXHUyMDE4XFx1MjAxOV0vO1xuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IHdvcmQgaW4gYSBzdHJpbmcgb2YgdGV4dC5cbiAqL1xudmFyIGdldFdvcmREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFdvcmREaXN0YW5jZSh0ZXh0KSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBkaXN0ID0gMDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgd2hpbGUgKHRleHQubGVuZ3RoID4gMCkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIGlzUlRMKTtcbiAgICB2YXIgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHRleHQsIGNoYXJEaXN0LCBpc1JUTCksXG4gICAgICBfc3BsaXRCeUNoYXJhY3RlckRpc3QyID0gX3NsaWNlZFRvQXJyYXkoX3NwbGl0QnlDaGFyYWN0ZXJEaXN0LCAyKSxcbiAgICAgIF9jaGFyMiA9IF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDJbMF0sXG4gICAgICByZW1haW5pbmcgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3QyWzFdO1xuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoX2NoYXIyLCByZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0ZXh0ID0gcmVtYWluaW5nO1xuICB9XG4gIHJldHVybiBkaXN0O1xufTtcbi8qKlxuICogU3BsaXQgYSBzdHJpbmcgaW4gdHdvIHBhcnRzIGF0IGEgZ2l2ZW4gZGlzdGFuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHdoZW5cbiAqIGBpc1JUTGAgaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xudmFyIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShzdHIsIGRpc3QsIGlzUlRMKSB7XG4gIGlmIChpc1JUTCkge1xuICAgIHZhciBhdCA9IHN0ci5sZW5ndGggLSBkaXN0O1xuICAgIHJldHVybiBbc3RyLnNsaWNlKGF0LCBzdHIubGVuZ3RoKSwgc3RyLnNsaWNlKDAsIGF0KV07XG4gIH1cbiAgcmV0dXJuIFtzdHIuc2xpY2UoMCwgZGlzdCksIHN0ci5zbGljZShkaXN0KV07XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXJhY3RlciBpcyBhIHdvcmQgY2hhcmFjdGVyLiBUaGUgYHJlbWFpbmluZ2AgYXJndW1lbnQgaXMgdXNlZFxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxuICovXG52YXIgaXNXb3JkQ2hhcmFjdGVyID0gZnVuY3Rpb24gaXNXb3JkQ2hhcmFjdGVyKF9jaGFyMywgcmVtYWluaW5nKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGlmIChTUEFDRS50ZXN0KF9jaGFyMykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuICBpZiAoQ0hBTUVMRU9OLnRlc3QoX2NoYXIzKSkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgaXNSVEwpO1xuICAgIHZhciBfc3BsaXRCeUNoYXJhY3RlckRpc3QzID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgY2hhckRpc3QsIGlzUlRMKSxcbiAgICAgIF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDQgPSBfc2xpY2VkVG9BcnJheShfc3BsaXRCeUNoYXJhY3RlckRpc3QzLCAyKSxcbiAgICAgIG5leHRDaGFyID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0NFswXSxcbiAgICAgIG5leHRSZW1haW5pbmcgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3Q0WzFdO1xuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIobmV4dENoYXIsIG5leHRSZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChQVU5DVFVBVElPTi50ZXN0KF9jaGFyMykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBJdGVyYXRlIG9uIGNvZGVwb2ludHMgZnJvbSByaWdodCB0byBsZWZ0LlxuICovXG52YXIgY29kZXBvaW50c0l0ZXJhdG9yUlRMID0gZnVuY3Rpb24qIGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIHtcbiAgdmFyIGVuZCA9IHN0ci5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyMSA9IHN0ci5jaGFyQXQoZW5kIC0gaSk7XG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcbiAgICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY2hhcjIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgeWllbGQgY2hhcjIgKyBjaGFyMTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgeWllbGQgY2hhcjE7XG4gIH1cbn07XG4vKipcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAqL1xudmFyIGlzSGlnaFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkODAwICYmIGNoYXJDb2RlIDw9IDB4ZGJmZjtcbn07XG4vKipcbiAqIElzIGBjaGFyQ29kZWAgYSBsb3cgc3Vycm9nYXRlLlxuICpcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xuICovXG52YXIgaXNMb3dTdXJyb2dhdGUgPSBmdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkYzAwICYmIGNoYXJDb2RlIDw9IDB4ZGZmZjtcbn07XG52YXIgQ29kZXBvaW50VHlwZTtcbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcbnZhciByZUV4dGVuZCA9IC9eKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDg5OC1cXHUwODlGXFx1MDhDQS1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0NcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNFXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzJcXHUxNzMzXFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODBGXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDRVxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REVGRC1cXHVERUZGXFx1REY0Ni1cXHVERjUwXFx1REY4Mi1cXHVERjg1XXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzcwXFx1REM3M1xcdURDNzRcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdURDQzJcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFNDFcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XFx1REYwMFxcdURGMDFcXHVERjM2LVxcdURGM0FcXHVERjQwXFx1REY0Ml18XFx1RDgwRFtcXHVEQzQwXFx1REM0Ny1cXHVEQzU1XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzM1tcXHVERjAwLVxcdURGMkRcXHVERjMwLVxcdURGNDZdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdURDOEZcXHVERDMwLVxcdUREMzZcXHVERUFFXFx1REVFQy1cXHVERUVGXXxcXHVEODM5W1xcdURDRUMtXFx1RENFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pJC87XG52YXIgcmVQcmVwZW5kID0gL14oPzpbXFx1MDYwMC1cXHUwNjA1XFx1MDZERFxcdTA3MEZcXHUwODkwXFx1MDg5MVxcdTA4RTJcXHUwRDRFXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXFx1RERDMlxcdUREQzNdfFxcdUQ4MDZbXFx1REQzRlxcdURENDFcXHVERTNBXFx1REU4NC1cXHVERTg5XXxcXHVEODA3XFx1REQ0NikkLztcbnZhciByZVNwYWNpbmdNYXJrID0gL14oPzpbXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRlxcdTA5QzBcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MEEwM1xcdTBBM0UtXFx1MEE0MFxcdTBBODNcXHUwQUJFLVxcdTBBQzBcXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQjAyXFx1MEIwM1xcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEJCRlxcdTBCQzFcXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMFxcdTBDQzFcXHUwQ0MzXFx1MENDNFxcdTBDQzdcXHUwQ0M4XFx1MENDQVxcdTBDQ0JcXHUwRDAyXFx1MEQwM1xcdTBEM0ZcXHUwRDQwXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ4MlxcdTBEODNcXHUwREQwXFx1MEREMVxcdTBERDgtXFx1MERERVxcdTBERjJcXHUwREYzXFx1MEUzM1xcdTBFQjNcXHUwRjNFXFx1MEYzRlxcdTBGN0ZcXHUxMDMxXFx1MTAzQlxcdTEwM0NcXHUxMDU2XFx1MTA1N1xcdTEwODRcXHUxNzE1XFx1MTczNFxcdTE3QjZcXHUxN0JFLVxcdTE3QzVcXHUxN0M3XFx1MTdDOFxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzBcXHUxOTMxXFx1MTkzMy1cXHUxOTM4XFx1MUExOVxcdTFBMUFcXHUxQTU1XFx1MUE1N1xcdTFBNkQtXFx1MUE3MlxcdTFCMDRcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0Y3XFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRS1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQUVCXFx1QUFFRVxcdUFBRUZcXHVBQUY1XFx1QUJFM1xcdUFCRTRcXHVBQkU2XFx1QUJFN1xcdUFCRTlcXHVBQkVBXFx1QUJFQ118XFx1RDgwNFtcXHVEQzAwXFx1REMwMlxcdURDODJcXHVEQ0IwLVxcdURDQjJcXHVEQ0I3XFx1RENCOFxcdUREMkNcXHVERDQ1XFx1REQ0NlxcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdUREQ0VcXHVERTJDLVxcdURFMkVcXHVERTMyXFx1REUzM1xcdURFMzVcXHVERUUwLVxcdURFRTJcXHVERjAyXFx1REYwM1xcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNjJcXHVERjYzXXxcXHVEODA1W1xcdURDMzUtXFx1REMzN1xcdURDNDBcXHVEQzQxXFx1REM0NVxcdURDQjFcXHVEQ0IyXFx1RENCOVxcdURDQkJcXHVEQ0JDXFx1RENCRVxcdURDQzFcXHVEREIwXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyNl18XFx1RDgwNltcXHVEQzJDLVxcdURDMkVcXHVEQzM4XFx1REQzMS1cXHVERDM1XFx1REQzN1xcdUREMzhcXHVERDNEXFx1REQ0MFxcdURENDJcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREZcXHVEREU0XFx1REUzOVxcdURFNTdcXHVERTU4XFx1REU5N118XFx1RDgwN1tcXHVEQzJGXFx1REMzRVxcdURDQTlcXHVEQ0IxXFx1RENCNFxcdUREOEEtXFx1REQ4RVxcdUREOTNcXHVERDk0XFx1REQ5NlxcdURFRjVcXHVERUY2XXxcXHVEODFCW1xcdURGNTEtXFx1REY4N1xcdURGRjBcXHVERkYxXXxcXHVEODM0W1xcdURENjZcXHVERDZEXSkkLztcbnZhciByZUwgPSAvXltcXHUxMTAwLVxcdTExNUZcXHVBOTYwLVxcdUE5N0NdJC87XG52YXIgcmVWID0gL15bXFx1MTE2MC1cXHUxMUE3XFx1RDdCMC1cXHVEN0M2XSQvO1xudmFyIHJlVCA9IC9eW1xcdTExQTgtXFx1MTFGRlxcdUQ3Q0ItXFx1RDdGQl0kLztcbnZhciByZUxWID0gL15bXFx1QUMwMFxcdUFDMUNcXHVBQzM4XFx1QUM1NFxcdUFDNzBcXHVBQzhDXFx1QUNBOFxcdUFDQzRcXHVBQ0UwXFx1QUNGQ1xcdUFEMThcXHVBRDM0XFx1QUQ1MFxcdUFENkNcXHVBRDg4XFx1QURBNFxcdUFEQzBcXHVBRERDXFx1QURGOFxcdUFFMTRcXHVBRTMwXFx1QUU0Q1xcdUFFNjhcXHVBRTg0XFx1QUVBMFxcdUFFQkNcXHVBRUQ4XFx1QUVGNFxcdUFGMTBcXHVBRjJDXFx1QUY0OFxcdUFGNjRcXHVBRjgwXFx1QUY5Q1xcdUFGQjhcXHVBRkQ0XFx1QUZGMFxcdUIwMENcXHVCMDI4XFx1QjA0NFxcdUIwNjBcXHVCMDdDXFx1QjA5OFxcdUIwQjRcXHVCMEQwXFx1QjBFQ1xcdUIxMDhcXHVCMTI0XFx1QjE0MFxcdUIxNUNcXHVCMTc4XFx1QjE5NFxcdUIxQjBcXHVCMUNDXFx1QjFFOFxcdUIyMDRcXHVCMjIwXFx1QjIzQ1xcdUIyNThcXHVCMjc0XFx1QjI5MFxcdUIyQUNcXHVCMkM4XFx1QjJFNFxcdUIzMDBcXHVCMzFDXFx1QjMzOFxcdUIzNTRcXHVCMzcwXFx1QjM4Q1xcdUIzQThcXHVCM0M0XFx1QjNFMFxcdUIzRkNcXHVCNDE4XFx1QjQzNFxcdUI0NTBcXHVCNDZDXFx1QjQ4OFxcdUI0QTRcXHVCNEMwXFx1QjREQ1xcdUI0RjhcXHVCNTE0XFx1QjUzMFxcdUI1NENcXHVCNTY4XFx1QjU4NFxcdUI1QTBcXHVCNUJDXFx1QjVEOFxcdUI1RjRcXHVCNjEwXFx1QjYyQ1xcdUI2NDhcXHVCNjY0XFx1QjY4MFxcdUI2OUNcXHVCNkI4XFx1QjZENFxcdUI2RjBcXHVCNzBDXFx1QjcyOFxcdUI3NDRcXHVCNzYwXFx1Qjc3Q1xcdUI3OThcXHVCN0I0XFx1QjdEMFxcdUI3RUNcXHVCODA4XFx1QjgyNFxcdUI4NDBcXHVCODVDXFx1Qjg3OFxcdUI4OTRcXHVCOEIwXFx1QjhDQ1xcdUI4RThcXHVCOTA0XFx1QjkyMFxcdUI5M0NcXHVCOTU4XFx1Qjk3NFxcdUI5OTBcXHVCOUFDXFx1QjlDOFxcdUI5RTRcXHVCQTAwXFx1QkExQ1xcdUJBMzhcXHVCQTU0XFx1QkE3MFxcdUJBOENcXHVCQUE4XFx1QkFDNFxcdUJBRTBcXHVCQUZDXFx1QkIxOFxcdUJCMzRcXHVCQjUwXFx1QkI2Q1xcdUJCODhcXHVCQkE0XFx1QkJDMFxcdUJCRENcXHVCQkY4XFx1QkMxNFxcdUJDMzBcXHVCQzRDXFx1QkM2OFxcdUJDODRcXHVCQ0EwXFx1QkNCQ1xcdUJDRDhcXHVCQ0Y0XFx1QkQxMFxcdUJEMkNcXHVCRDQ4XFx1QkQ2NFxcdUJEODBcXHVCRDlDXFx1QkRCOFxcdUJERDRcXHVCREYwXFx1QkUwQ1xcdUJFMjhcXHVCRTQ0XFx1QkU2MFxcdUJFN0NcXHVCRTk4XFx1QkVCNFxcdUJFRDBcXHVCRUVDXFx1QkYwOFxcdUJGMjRcXHVCRjQwXFx1QkY1Q1xcdUJGNzhcXHVCRjk0XFx1QkZCMFxcdUJGQ0NcXHVCRkU4XFx1QzAwNFxcdUMwMjBcXHVDMDNDXFx1QzA1OFxcdUMwNzRcXHVDMDkwXFx1QzBBQ1xcdUMwQzhcXHVDMEU0XFx1QzEwMFxcdUMxMUNcXHVDMTM4XFx1QzE1NFxcdUMxNzBcXHVDMThDXFx1QzFBOFxcdUMxQzRcXHVDMUUwXFx1QzFGQ1xcdUMyMThcXHVDMjM0XFx1QzI1MFxcdUMyNkNcXHVDMjg4XFx1QzJBNFxcdUMyQzBcXHVDMkRDXFx1QzJGOFxcdUMzMTRcXHVDMzMwXFx1QzM0Q1xcdUMzNjhcXHVDMzg0XFx1QzNBMFxcdUMzQkNcXHVDM0Q4XFx1QzNGNFxcdUM0MTBcXHVDNDJDXFx1QzQ0OFxcdUM0NjRcXHVDNDgwXFx1QzQ5Q1xcdUM0QjhcXHVDNEQ0XFx1QzRGMFxcdUM1MENcXHVDNTI4XFx1QzU0NFxcdUM1NjBcXHVDNTdDXFx1QzU5OFxcdUM1QjRcXHVDNUQwXFx1QzVFQ1xcdUM2MDhcXHVDNjI0XFx1QzY0MFxcdUM2NUNcXHVDNjc4XFx1QzY5NFxcdUM2QjBcXHVDNkNDXFx1QzZFOFxcdUM3MDRcXHVDNzIwXFx1QzczQ1xcdUM3NThcXHVDNzc0XFx1Qzc5MFxcdUM3QUNcXHVDN0M4XFx1QzdFNFxcdUM4MDBcXHVDODFDXFx1QzgzOFxcdUM4NTRcXHVDODcwXFx1Qzg4Q1xcdUM4QThcXHVDOEM0XFx1QzhFMFxcdUM4RkNcXHVDOTE4XFx1QzkzNFxcdUM5NTBcXHVDOTZDXFx1Qzk4OFxcdUM5QTRcXHVDOUMwXFx1QzlEQ1xcdUM5RjhcXHVDQTE0XFx1Q0EzMFxcdUNBNENcXHVDQTY4XFx1Q0E4NFxcdUNBQTBcXHVDQUJDXFx1Q0FEOFxcdUNBRjRcXHVDQjEwXFx1Q0IyQ1xcdUNCNDhcXHVDQjY0XFx1Q0I4MFxcdUNCOUNcXHVDQkI4XFx1Q0JENFxcdUNCRjBcXHVDQzBDXFx1Q0MyOFxcdUNDNDRcXHVDQzYwXFx1Q0M3Q1xcdUNDOThcXHVDQ0I0XFx1Q0NEMFxcdUNDRUNcXHVDRDA4XFx1Q0QyNFxcdUNENDBcXHVDRDVDXFx1Q0Q3OFxcdUNEOTRcXHVDREIwXFx1Q0RDQ1xcdUNERThcXHVDRTA0XFx1Q0UyMFxcdUNFM0NcXHVDRTU4XFx1Q0U3NFxcdUNFOTBcXHVDRUFDXFx1Q0VDOFxcdUNFRTRcXHVDRjAwXFx1Q0YxQ1xcdUNGMzhcXHVDRjU0XFx1Q0Y3MFxcdUNGOENcXHVDRkE4XFx1Q0ZDNFxcdUNGRTBcXHVDRkZDXFx1RDAxOFxcdUQwMzRcXHVEMDUwXFx1RDA2Q1xcdUQwODhcXHVEMEE0XFx1RDBDMFxcdUQwRENcXHVEMEY4XFx1RDExNFxcdUQxMzBcXHVEMTRDXFx1RDE2OFxcdUQxODRcXHVEMUEwXFx1RDFCQ1xcdUQxRDhcXHVEMUY0XFx1RDIxMFxcdUQyMkNcXHVEMjQ4XFx1RDI2NFxcdUQyODBcXHVEMjlDXFx1RDJCOFxcdUQyRDRcXHVEMkYwXFx1RDMwQ1xcdUQzMjhcXHVEMzQ0XFx1RDM2MFxcdUQzN0NcXHVEMzk4XFx1RDNCNFxcdUQzRDBcXHVEM0VDXFx1RDQwOFxcdUQ0MjRcXHVENDQwXFx1RDQ1Q1xcdUQ0NzhcXHVENDk0XFx1RDRCMFxcdUQ0Q0NcXHVENEU4XFx1RDUwNFxcdUQ1MjBcXHVENTNDXFx1RDU1OFxcdUQ1NzRcXHVENTkwXFx1RDVBQ1xcdUQ1QzhcXHVENUU0XFx1RDYwMFxcdUQ2MUNcXHVENjM4XFx1RDY1NFxcdUQ2NzBcXHVENjhDXFx1RDZBOFxcdUQ2QzRcXHVENkUwXFx1RDZGQ1xcdUQ3MThcXHVENzM0XFx1RDc1MFxcdUQ3NkNcXHVENzg4XSQvO1xudmFyIHJlTFZUID0gL15bXFx1QUMwMS1cXHVBQzFCXFx1QUMxRC1cXHVBQzM3XFx1QUMzOS1cXHVBQzUzXFx1QUM1NS1cXHVBQzZGXFx1QUM3MS1cXHVBQzhCXFx1QUM4RC1cXHVBQ0E3XFx1QUNBOS1cXHVBQ0MzXFx1QUNDNS1cXHVBQ0RGXFx1QUNFMS1cXHVBQ0ZCXFx1QUNGRC1cXHVBRDE3XFx1QUQxOS1cXHVBRDMzXFx1QUQzNS1cXHVBRDRGXFx1QUQ1MS1cXHVBRDZCXFx1QUQ2RC1cXHVBRDg3XFx1QUQ4OS1cXHVBREEzXFx1QURBNS1cXHVBREJGXFx1QURDMS1cXHVBRERCXFx1QURERC1cXHVBREY3XFx1QURGOS1cXHVBRTEzXFx1QUUxNS1cXHVBRTJGXFx1QUUzMS1cXHVBRTRCXFx1QUU0RC1cXHVBRTY3XFx1QUU2OS1cXHVBRTgzXFx1QUU4NS1cXHVBRTlGXFx1QUVBMS1cXHVBRUJCXFx1QUVCRC1cXHVBRUQ3XFx1QUVEOS1cXHVBRUYzXFx1QUVGNS1cXHVBRjBGXFx1QUYxMS1cXHVBRjJCXFx1QUYyRC1cXHVBRjQ3XFx1QUY0OS1cXHVBRjYzXFx1QUY2NS1cXHVBRjdGXFx1QUY4MS1cXHVBRjlCXFx1QUY5RC1cXHVBRkI3XFx1QUZCOS1cXHVBRkQzXFx1QUZENS1cXHVBRkVGXFx1QUZGMS1cXHVCMDBCXFx1QjAwRC1cXHVCMDI3XFx1QjAyOS1cXHVCMDQzXFx1QjA0NS1cXHVCMDVGXFx1QjA2MS1cXHVCMDdCXFx1QjA3RC1cXHVCMDk3XFx1QjA5OS1cXHVCMEIzXFx1QjBCNS1cXHVCMENGXFx1QjBEMS1cXHVCMEVCXFx1QjBFRC1cXHVCMTA3XFx1QjEwOS1cXHVCMTIzXFx1QjEyNS1cXHVCMTNGXFx1QjE0MS1cXHVCMTVCXFx1QjE1RC1cXHVCMTc3XFx1QjE3OS1cXHVCMTkzXFx1QjE5NS1cXHVCMUFGXFx1QjFCMS1cXHVCMUNCXFx1QjFDRC1cXHVCMUU3XFx1QjFFOS1cXHVCMjAzXFx1QjIwNS1cXHVCMjFGXFx1QjIyMS1cXHVCMjNCXFx1QjIzRC1cXHVCMjU3XFx1QjI1OS1cXHVCMjczXFx1QjI3NS1cXHVCMjhGXFx1QjI5MS1cXHVCMkFCXFx1QjJBRC1cXHVCMkM3XFx1QjJDOS1cXHVCMkUzXFx1QjJFNS1cXHVCMkZGXFx1QjMwMS1cXHVCMzFCXFx1QjMxRC1cXHVCMzM3XFx1QjMzOS1cXHVCMzUzXFx1QjM1NS1cXHVCMzZGXFx1QjM3MS1cXHVCMzhCXFx1QjM4RC1cXHVCM0E3XFx1QjNBOS1cXHVCM0MzXFx1QjNDNS1cXHVCM0RGXFx1QjNFMS1cXHVCM0ZCXFx1QjNGRC1cXHVCNDE3XFx1QjQxOS1cXHVCNDMzXFx1QjQzNS1cXHVCNDRGXFx1QjQ1MS1cXHVCNDZCXFx1QjQ2RC1cXHVCNDg3XFx1QjQ4OS1cXHVCNEEzXFx1QjRBNS1cXHVCNEJGXFx1QjRDMS1cXHVCNERCXFx1QjRERC1cXHVCNEY3XFx1QjRGOS1cXHVCNTEzXFx1QjUxNS1cXHVCNTJGXFx1QjUzMS1cXHVCNTRCXFx1QjU0RC1cXHVCNTY3XFx1QjU2OS1cXHVCNTgzXFx1QjU4NS1cXHVCNTlGXFx1QjVBMS1cXHVCNUJCXFx1QjVCRC1cXHVCNUQ3XFx1QjVEOS1cXHVCNUYzXFx1QjVGNS1cXHVCNjBGXFx1QjYxMS1cXHVCNjJCXFx1QjYyRC1cXHVCNjQ3XFx1QjY0OS1cXHVCNjYzXFx1QjY2NS1cXHVCNjdGXFx1QjY4MS1cXHVCNjlCXFx1QjY5RC1cXHVCNkI3XFx1QjZCOS1cXHVCNkQzXFx1QjZENS1cXHVCNkVGXFx1QjZGMS1cXHVCNzBCXFx1QjcwRC1cXHVCNzI3XFx1QjcyOS1cXHVCNzQzXFx1Qjc0NS1cXHVCNzVGXFx1Qjc2MS1cXHVCNzdCXFx1Qjc3RC1cXHVCNzk3XFx1Qjc5OS1cXHVCN0IzXFx1QjdCNS1cXHVCN0NGXFx1QjdEMS1cXHVCN0VCXFx1QjdFRC1cXHVCODA3XFx1QjgwOS1cXHVCODIzXFx1QjgyNS1cXHVCODNGXFx1Qjg0MS1cXHVCODVCXFx1Qjg1RC1cXHVCODc3XFx1Qjg3OS1cXHVCODkzXFx1Qjg5NS1cXHVCOEFGXFx1QjhCMS1cXHVCOENCXFx1QjhDRC1cXHVCOEU3XFx1QjhFOS1cXHVCOTAzXFx1QjkwNS1cXHVCOTFGXFx1QjkyMS1cXHVCOTNCXFx1QjkzRC1cXHVCOTU3XFx1Qjk1OS1cXHVCOTczXFx1Qjk3NS1cXHVCOThGXFx1Qjk5MS1cXHVCOUFCXFx1QjlBRC1cXHVCOUM3XFx1QjlDOS1cXHVCOUUzXFx1QjlFNS1cXHVCOUZGXFx1QkEwMS1cXHVCQTFCXFx1QkExRC1cXHVCQTM3XFx1QkEzOS1cXHVCQTUzXFx1QkE1NS1cXHVCQTZGXFx1QkE3MS1cXHVCQThCXFx1QkE4RC1cXHVCQUE3XFx1QkFBOS1cXHVCQUMzXFx1QkFDNS1cXHVCQURGXFx1QkFFMS1cXHVCQUZCXFx1QkFGRC1cXHVCQjE3XFx1QkIxOS1cXHVCQjMzXFx1QkIzNS1cXHVCQjRGXFx1QkI1MS1cXHVCQjZCXFx1QkI2RC1cXHVCQjg3XFx1QkI4OS1cXHVCQkEzXFx1QkJBNS1cXHVCQkJGXFx1QkJDMS1cXHVCQkRCXFx1QkJERC1cXHVCQkY3XFx1QkJGOS1cXHVCQzEzXFx1QkMxNS1cXHVCQzJGXFx1QkMzMS1cXHVCQzRCXFx1QkM0RC1cXHVCQzY3XFx1QkM2OS1cXHVCQzgzXFx1QkM4NS1cXHVCQzlGXFx1QkNBMS1cXHVCQ0JCXFx1QkNCRC1cXHVCQ0Q3XFx1QkNEOS1cXHVCQ0YzXFx1QkNGNS1cXHVCRDBGXFx1QkQxMS1cXHVCRDJCXFx1QkQyRC1cXHVCRDQ3XFx1QkQ0OS1cXHVCRDYzXFx1QkQ2NS1cXHVCRDdGXFx1QkQ4MS1cXHVCRDlCXFx1QkQ5RC1cXHVCREI3XFx1QkRCOS1cXHVCREQzXFx1QkRENS1cXHVCREVGXFx1QkRGMS1cXHVCRTBCXFx1QkUwRC1cXHVCRTI3XFx1QkUyOS1cXHVCRTQzXFx1QkU0NS1cXHVCRTVGXFx1QkU2MS1cXHVCRTdCXFx1QkU3RC1cXHVCRTk3XFx1QkU5OS1cXHVCRUIzXFx1QkVCNS1cXHVCRUNGXFx1QkVEMS1cXHVCRUVCXFx1QkVFRC1cXHVCRjA3XFx1QkYwOS1cXHVCRjIzXFx1QkYyNS1cXHVCRjNGXFx1QkY0MS1cXHVCRjVCXFx1QkY1RC1cXHVCRjc3XFx1QkY3OS1cXHVCRjkzXFx1QkY5NS1cXHVCRkFGXFx1QkZCMS1cXHVCRkNCXFx1QkZDRC1cXHVCRkU3XFx1QkZFOS1cXHVDMDAzXFx1QzAwNS1cXHVDMDFGXFx1QzAyMS1cXHVDMDNCXFx1QzAzRC1cXHVDMDU3XFx1QzA1OS1cXHVDMDczXFx1QzA3NS1cXHVDMDhGXFx1QzA5MS1cXHVDMEFCXFx1QzBBRC1cXHVDMEM3XFx1QzBDOS1cXHVDMEUzXFx1QzBFNS1cXHVDMEZGXFx1QzEwMS1cXHVDMTFCXFx1QzExRC1cXHVDMTM3XFx1QzEzOS1cXHVDMTUzXFx1QzE1NS1cXHVDMTZGXFx1QzE3MS1cXHVDMThCXFx1QzE4RC1cXHVDMUE3XFx1QzFBOS1cXHVDMUMzXFx1QzFDNS1cXHVDMURGXFx1QzFFMS1cXHVDMUZCXFx1QzFGRC1cXHVDMjE3XFx1QzIxOS1cXHVDMjMzXFx1QzIzNS1cXHVDMjRGXFx1QzI1MS1cXHVDMjZCXFx1QzI2RC1cXHVDMjg3XFx1QzI4OS1cXHVDMkEzXFx1QzJBNS1cXHVDMkJGXFx1QzJDMS1cXHVDMkRCXFx1QzJERC1cXHVDMkY3XFx1QzJGOS1cXHVDMzEzXFx1QzMxNS1cXHVDMzJGXFx1QzMzMS1cXHVDMzRCXFx1QzM0RC1cXHVDMzY3XFx1QzM2OS1cXHVDMzgzXFx1QzM4NS1cXHVDMzlGXFx1QzNBMS1cXHVDM0JCXFx1QzNCRC1cXHVDM0Q3XFx1QzNEOS1cXHVDM0YzXFx1QzNGNS1cXHVDNDBGXFx1QzQxMS1cXHVDNDJCXFx1QzQyRC1cXHVDNDQ3XFx1QzQ0OS1cXHVDNDYzXFx1QzQ2NS1cXHVDNDdGXFx1QzQ4MS1cXHVDNDlCXFx1QzQ5RC1cXHVDNEI3XFx1QzRCOS1cXHVDNEQzXFx1QzRENS1cXHVDNEVGXFx1QzRGMS1cXHVDNTBCXFx1QzUwRC1cXHVDNTI3XFx1QzUyOS1cXHVDNTQzXFx1QzU0NS1cXHVDNTVGXFx1QzU2MS1cXHVDNTdCXFx1QzU3RC1cXHVDNTk3XFx1QzU5OS1cXHVDNUIzXFx1QzVCNS1cXHVDNUNGXFx1QzVEMS1cXHVDNUVCXFx1QzVFRC1cXHVDNjA3XFx1QzYwOS1cXHVDNjIzXFx1QzYyNS1cXHVDNjNGXFx1QzY0MS1cXHVDNjVCXFx1QzY1RC1cXHVDNjc3XFx1QzY3OS1cXHVDNjkzXFx1QzY5NS1cXHVDNkFGXFx1QzZCMS1cXHVDNkNCXFx1QzZDRC1cXHVDNkU3XFx1QzZFOS1cXHVDNzAzXFx1QzcwNS1cXHVDNzFGXFx1QzcyMS1cXHVDNzNCXFx1QzczRC1cXHVDNzU3XFx1Qzc1OS1cXHVDNzczXFx1Qzc3NS1cXHVDNzhGXFx1Qzc5MS1cXHVDN0FCXFx1QzdBRC1cXHVDN0M3XFx1QzdDOS1cXHVDN0UzXFx1QzdFNS1cXHVDN0ZGXFx1QzgwMS1cXHVDODFCXFx1QzgxRC1cXHVDODM3XFx1QzgzOS1cXHVDODUzXFx1Qzg1NS1cXHVDODZGXFx1Qzg3MS1cXHVDODhCXFx1Qzg4RC1cXHVDOEE3XFx1QzhBOS1cXHVDOEMzXFx1QzhDNS1cXHVDOERGXFx1QzhFMS1cXHVDOEZCXFx1QzhGRC1cXHVDOTE3XFx1QzkxOS1cXHVDOTMzXFx1QzkzNS1cXHVDOTRGXFx1Qzk1MS1cXHVDOTZCXFx1Qzk2RC1cXHVDOTg3XFx1Qzk4OS1cXHVDOUEzXFx1QzlBNS1cXHVDOUJGXFx1QzlDMS1cXHVDOURCXFx1QzlERC1cXHVDOUY3XFx1QzlGOS1cXHVDQTEzXFx1Q0ExNS1cXHVDQTJGXFx1Q0EzMS1cXHVDQTRCXFx1Q0E0RC1cXHVDQTY3XFx1Q0E2OS1cXHVDQTgzXFx1Q0E4NS1cXHVDQTlGXFx1Q0FBMS1cXHVDQUJCXFx1Q0FCRC1cXHVDQUQ3XFx1Q0FEOS1cXHVDQUYzXFx1Q0FGNS1cXHVDQjBGXFx1Q0IxMS1cXHVDQjJCXFx1Q0IyRC1cXHVDQjQ3XFx1Q0I0OS1cXHVDQjYzXFx1Q0I2NS1cXHVDQjdGXFx1Q0I4MS1cXHVDQjlCXFx1Q0I5RC1cXHVDQkI3XFx1Q0JCOS1cXHVDQkQzXFx1Q0JENS1cXHVDQkVGXFx1Q0JGMS1cXHVDQzBCXFx1Q0MwRC1cXHVDQzI3XFx1Q0MyOS1cXHVDQzQzXFx1Q0M0NS1cXHVDQzVGXFx1Q0M2MS1cXHVDQzdCXFx1Q0M3RC1cXHVDQzk3XFx1Q0M5OS1cXHVDQ0IzXFx1Q0NCNS1cXHVDQ0NGXFx1Q0NEMS1cXHVDQ0VCXFx1Q0NFRC1cXHVDRDA3XFx1Q0QwOS1cXHVDRDIzXFx1Q0QyNS1cXHVDRDNGXFx1Q0Q0MS1cXHVDRDVCXFx1Q0Q1RC1cXHVDRDc3XFx1Q0Q3OS1cXHVDRDkzXFx1Q0Q5NS1cXHVDREFGXFx1Q0RCMS1cXHVDRENCXFx1Q0RDRC1cXHVDREU3XFx1Q0RFOS1cXHVDRTAzXFx1Q0UwNS1cXHVDRTFGXFx1Q0UyMS1cXHVDRTNCXFx1Q0UzRC1cXHVDRTU3XFx1Q0U1OS1cXHVDRTczXFx1Q0U3NS1cXHVDRThGXFx1Q0U5MS1cXHVDRUFCXFx1Q0VBRC1cXHVDRUM3XFx1Q0VDOS1cXHVDRUUzXFx1Q0VFNS1cXHVDRUZGXFx1Q0YwMS1cXHVDRjFCXFx1Q0YxRC1cXHVDRjM3XFx1Q0YzOS1cXHVDRjUzXFx1Q0Y1NS1cXHVDRjZGXFx1Q0Y3MS1cXHVDRjhCXFx1Q0Y4RC1cXHVDRkE3XFx1Q0ZBOS1cXHVDRkMzXFx1Q0ZDNS1cXHVDRkRGXFx1Q0ZFMS1cXHVDRkZCXFx1Q0ZGRC1cXHVEMDE3XFx1RDAxOS1cXHVEMDMzXFx1RDAzNS1cXHVEMDRGXFx1RDA1MS1cXHVEMDZCXFx1RDA2RC1cXHVEMDg3XFx1RDA4OS1cXHVEMEEzXFx1RDBBNS1cXHVEMEJGXFx1RDBDMS1cXHVEMERCXFx1RDBERC1cXHVEMEY3XFx1RDBGOS1cXHVEMTEzXFx1RDExNS1cXHVEMTJGXFx1RDEzMS1cXHVEMTRCXFx1RDE0RC1cXHVEMTY3XFx1RDE2OS1cXHVEMTgzXFx1RDE4NS1cXHVEMTlGXFx1RDFBMS1cXHVEMUJCXFx1RDFCRC1cXHVEMUQ3XFx1RDFEOS1cXHVEMUYzXFx1RDFGNS1cXHVEMjBGXFx1RDIxMS1cXHVEMjJCXFx1RDIyRC1cXHVEMjQ3XFx1RDI0OS1cXHVEMjYzXFx1RDI2NS1cXHVEMjdGXFx1RDI4MS1cXHVEMjlCXFx1RDI5RC1cXHVEMkI3XFx1RDJCOS1cXHVEMkQzXFx1RDJENS1cXHVEMkVGXFx1RDJGMS1cXHVEMzBCXFx1RDMwRC1cXHVEMzI3XFx1RDMyOS1cXHVEMzQzXFx1RDM0NS1cXHVEMzVGXFx1RDM2MS1cXHVEMzdCXFx1RDM3RC1cXHVEMzk3XFx1RDM5OS1cXHVEM0IzXFx1RDNCNS1cXHVEM0NGXFx1RDNEMS1cXHVEM0VCXFx1RDNFRC1cXHVENDA3XFx1RDQwOS1cXHVENDIzXFx1RDQyNS1cXHVENDNGXFx1RDQ0MS1cXHVENDVCXFx1RDQ1RC1cXHVENDc3XFx1RDQ3OS1cXHVENDkzXFx1RDQ5NS1cXHVENEFGXFx1RDRCMS1cXHVENENCXFx1RDRDRC1cXHVENEU3XFx1RDRFOS1cXHVENTAzXFx1RDUwNS1cXHVENTFGXFx1RDUyMS1cXHVENTNCXFx1RDUzRC1cXHVENTU3XFx1RDU1OS1cXHVENTczXFx1RDU3NS1cXHVENThGXFx1RDU5MS1cXHVENUFCXFx1RDVBRC1cXHVENUM3XFx1RDVDOS1cXHVENUUzXFx1RDVFNS1cXHVENUZGXFx1RDYwMS1cXHVENjFCXFx1RDYxRC1cXHVENjM3XFx1RDYzOS1cXHVENjUzXFx1RDY1NS1cXHVENjZGXFx1RDY3MS1cXHVENjhCXFx1RDY4RC1cXHVENkE3XFx1RDZBOS1cXHVENkMzXFx1RDZDNS1cXHVENkRGXFx1RDZFMS1cXHVENkZCXFx1RDZGRC1cXHVENzE3XFx1RDcxOS1cXHVENzMzXFx1RDczNS1cXHVENzRGXFx1RDc1MS1cXHVENzZCXFx1RDc2RC1cXHVENzg3XFx1RDc4OS1cXHVEN0EzXSQvO1xudmFyIHJlRXh0UGljdCA9IC9eKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSQvO1xudmFyIGdldENvZGVwb2ludFR5cGUgPSBmdW5jdGlvbiBnZXRDb2RlcG9pbnRUeXBlKF9jaGFyNCwgY29kZSkge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuICBpZiAoX2NoYXI0LnNlYXJjaChyZUV4dGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dGVuZDtcbiAgfVxuICBpZiAoY29kZSA9PT0gMHgyMDBkKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlpXSjtcbiAgfVxuICBpZiAoY29kZSA+PSAweDFmMWU2ICYmIGNvZGUgPD0gMHgxZjFmZikge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5SSTtcbiAgfVxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVByZXBlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5QcmVwZW5kO1xuICB9XG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlU3BhY2luZ01hcmspICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFyaztcbiAgfVxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUwpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MO1xuICB9XG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlY7XG4gIH1cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVDtcbiAgfVxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUxWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFY7XG4gIH1cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVMVlQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVlQ7XG4gIH1cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVFeHRQaWN0KSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0UGljdDtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn07XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHgsIHkpIHtcbiAgcmV0dXJuICh4ICYgeSkgIT09IDA7XG59XG52YXIgTm9uQm91bmRhcnlQYWlycyA9IFtcbi8vIEdCNlxuW0NvZGVwb2ludFR5cGUuTCwgQ29kZXBvaW50VHlwZS5MIHwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuTFZUXSxcbi8vIEdCN1xuW0NvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLlYsIENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuVF0sXG4vLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSxcbi8vIEdCOVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLkV4dGVuZCB8IENvZGVwb2ludFR5cGUuWldKXSxcbi8vIEdCOWFcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFya10sXG4vLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sXG4vLyBHQjExXG5bQ29kZXBvaW50VHlwZS5aV0osIENvZGVwb2ludFR5cGUuRXh0UGljdF0sXG4vLyBHQjEyIGFuZCBHQjEzXG5bQ29kZXBvaW50VHlwZS5SSSwgQ29kZXBvaW50VHlwZS5SSV1dO1xuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHMobGVmdCwgclswXSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgclsxXSk7XG4gIH0pID09PSAtMTtcbn1cbnZhciBlbmRpbmdFbW9qaVpXSiA9IC8oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDg5OC1cXHUwODlGXFx1MDhDQS1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0NcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNFXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzJcXHUxNzMzXFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODBGXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDRVxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REVGRC1cXHVERUZGXFx1REY0Ni1cXHVERjUwXFx1REY4Mi1cXHVERjg1XXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzcwXFx1REM3M1xcdURDNzRcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdURDQzJcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFNDFcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XFx1REYwMFxcdURGMDFcXHVERjM2LVxcdURGM0FcXHVERjQwXFx1REY0Ml18XFx1RDgwRFtcXHVEQzQwXFx1REM0Ny1cXHVEQzU1XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzM1tcXHVERjAwLVxcdURGMkRcXHVERjMwLVxcdURGNDZdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdURDOEZcXHVERDMwLVxcdUREMzZcXHVERUFFXFx1REVFQy1cXHVERUVGXXxcXHVEODM5W1xcdURDRUMtXFx1RENFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pKlxcdTIwMEQkLztcbnZhciBlbmRzV2l0aEVtb2ppWldKID0gZnVuY3Rpb24gZW5kc1dpdGhFbW9qaVpXSihzdHIpIHtcbiAgcmV0dXJuIHN0ci5zZWFyY2goZW5kaW5nRW1vamlaV0opICE9PSAtMTtcbn07XG52YXIgZW5kaW5nUklzID0gLyg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREZGXSkrJC9nO1xudmFyIGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMgPSBmdW5jdGlvbiBlbmRzV2l0aE9kZE51bWJlck9mUklzKHN0cikge1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goZW5kaW5nUklzKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEEgUkkgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdXJyb2dhdGUgcGFpci5cbiAgICB2YXIgbnVtUklzID0gbWF0Y2hbMF0ubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gbnVtUklzICUgMiA9PT0gMTtcbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFRleHRUcmFuc2Zvcm1zID0ge1xuICBcImRlbGV0ZVwiOiBmdW5jdGlvbiBfZGVsZXRlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvcltcImRlbGV0ZVwiXShvcHRpb25zKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICB9LFxuICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpIDogX29wdGlvbnMkYXQ7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5kID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgICAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogYXRcbiAgICAgIH0pIHx8IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIF9hdCA9IGF0LFxuICAgICAgICBwYXRoID0gX2F0LnBhdGgsXG4gICAgICAgIG9mZnNldCA9IF9hdC5vZmZzZXQ7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkOShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ5KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ5KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgVHJhbnNmb3JtcyA9IF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOSh7fSwgR2VuZXJhbFRyYW5zZm9ybXMpLCBOb2RlVHJhbnNmb3JtcyksIFNlbGVjdGlvblRyYW5zZm9ybXMpLCBUZXh0VHJhbnNmb3Jtcyk7XG5cbi8vIHBlcmZcbnZhciBCQVRDSElOR19ESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgaXNCYXRjaGluZ0RpcnR5UGF0aHMgPSBmdW5jdGlvbiBpc0JhdGNoaW5nRGlydHlQYXRocyhlZGl0b3IpIHtcbiAgcmV0dXJuIEJBVENISU5HX0RJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IGZhbHNlO1xufTtcbnZhciBiYXRjaERpcnR5UGF0aHMgPSBmdW5jdGlvbiBiYXRjaERpcnR5UGF0aHMoZWRpdG9yLCBmbiwgdXBkYXRlKSB7XG4gIHZhciB2YWx1ZSA9IEJBVENISU5HX0RJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IGZhbHNlO1xuICBCQVRDSElOR19ESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgdHJ5IHtcbiAgICBmbigpO1xuICAgIHVwZGF0ZSgpO1xuICB9IGZpbmFsbHkge1xuICAgIEJBVENISU5HX0RJUlRZX1BBVEhTLnNldChlZGl0b3IsIHZhbHVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkaShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRpKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkaShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRpKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIHVwZGF0ZSBlZGl0b3IgZGlydHkgcGF0aHNcbiAqXG4gKiBAcGFyYW0gbmV3RGlydHlQYXRoczogUGF0aFtdOyBuZXcgZGlydHkgcGF0aHNcbiAqIEBwYXJhbSB0cmFuc2Zvcm06IChwOiBQYXRoKSA9PiBQYXRoIHwgbnVsbDsgaG93IHRvIHRyYW5zZm9ybSBleGlzdGluZyBkaXJ0eSBwYXRoc1xuICovXG5mdW5jdGlvbiB1cGRhdGVEaXJ0eVBhdGhzKGVkaXRvciwgbmV3RGlydHlQYXRocywgdHJhbnNmb3JtKSB7XG4gIHZhciBvbGREaXJ0eVBhdGhzID0gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gIHZhciBvbGREaXJ0eVBhdGhLZXlzID0gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgdmFyIGRpcnR5UGF0aHM7XG4gIHZhciBkaXJ0eVBhdGhLZXlzO1xuICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKHBhdGgpIHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuICAgICAgaWYgKCFkaXJ0eVBhdGhLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGRpcnR5UGF0aEtleXMuYWRkKGtleSk7XG4gICAgICAgIGRpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBkaXJ0eVBhdGhzID0gW107XG4gICAgZGlydHlQYXRoS2V5cyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaShvbGREaXJ0eVBhdGhzKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcGF0aCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgbmV3UGF0aCA9IHRyYW5zZm9ybShwYXRoKTtcbiAgICAgICAgYWRkKG5ld1BhdGgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlydHlQYXRocyA9IG9sZERpcnR5UGF0aHM7XG4gICAgZGlydHlQYXRoS2V5cyA9IG9sZERpcnR5UGF0aEtleXM7XG4gIH1cbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRpKG5ld0RpcnR5UGF0aHMpLFxuICAgIF9zdGVwMjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9wYXRoID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgYWRkKF9wYXRoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG4gIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGRpcnR5UGF0aHMpO1xuICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgZGlydHlQYXRoS2V5cyk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGgobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGgobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRoKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkaChvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGgobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkaChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZWRpdG9yLCBvcCkge1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaChFZGl0b3IucGF0aFJlZnMoZWRpdG9yKSksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciByZWYgPSBfc3RlcC52YWx1ZTtcbiAgICAgIFBhdGhSZWYudHJhbnNmb3JtKHJlZiwgb3ApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaChFZGl0b3IucG9pbnRSZWZzKGVkaXRvcikpLFxuICAgIF9zdGVwMjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9yZWYgPSBfc3RlcDIudmFsdWU7XG4gICAgICBQb2ludFJlZi50cmFuc2Zvcm0oX3JlZiwgb3ApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cbiAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRoKEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKSksXG4gICAgX3N0ZXAzO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc3RlcDMudmFsdWU7XG4gICAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGRpcnR5IHBhdGhzXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjMuZigpO1xuICB9XG4gIGlmICghaXNCYXRjaGluZ0RpcnR5UGF0aHMoZWRpdG9yKSkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApID8gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBQYXRoLnRyYW5zZm9ybShwLCBvcCk7XG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB1cGRhdGVEaXJ0eVBhdGhzKGVkaXRvciwgZWRpdG9yLmdldERpcnR5UGF0aHMob3ApLCB0cmFuc2Zvcm0pO1xuICB9XG4gIFRyYW5zZm9ybXMudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IsIHtcbiAgICBvcGVyYXRpb246IG9wXG4gIH0pO1xuICAvLyBDbGVhciBhbnkgZm9ybWF0cyBhcHBsaWVkIHRvIHRoZSBjdXJzb3IgaWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICBpZiAob3AudHlwZSA9PT0gJ3NldF9zZWxlY3Rpb24nKSB7XG4gICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgfVxuICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICBlZGl0b3Iub25DaGFuZ2Uoe1xuICAgICAgICBvcGVyYXRpb246IG9wXG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGcobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGcobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRnKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkZyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGcobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkZyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBHZXQgdGhlIFwiZGlydHlcIiBwYXRocyBnZW5lcmF0ZWQgZnJvbSBhbiBvcGVyYXRpb24uXG4gKi9cbnZhciBnZXREaXJ0eVBhdGhzID0gZnVuY3Rpb24gZ2V0RGlydHlQYXRocyhlZGl0b3IsIG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgcGF0aCA9IG9wLnBhdGg7XG4gICAgICAgIHJldHVybiBQYXRoLmxldmVscyhwYXRoKTtcbiAgICAgIH1cbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBub2RlID0gb3Aubm9kZSxcbiAgICAgICAgICBfcGF0aCA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBsZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aCk7XG4gICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBwID0gX3JlZjJbMV07XG4gICAgICAgICAgcmV0dXJuIF9wYXRoLmNvbmNhdChwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxldmVscyksIF90b0NvbnN1bWFibGVBcnJheShkZXNjZW5kYW50cykpO1xuICAgICAgfVxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGgyID0gb3AucGF0aDtcbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2aW91c1BhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFuY2VzdG9ycyksIFtwcmV2aW91c1BhdGhdKTtcbiAgICAgIH1cbiAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGgzID0gb3AucGF0aCxcbiAgICAgICAgICBuZXdQYXRoID0gb3AubmV3UGF0aDtcbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICB2YXIgbmV3QW5jZXN0b3JzID0gW107XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRnKFBhdGguYW5jZXN0b3JzKF9wYXRoMykpLFxuICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICAgIG9sZEFuY2VzdG9ycy5wdXNoKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkZyhQYXRoLmFuY2VzdG9ycyhuZXdQYXRoKSksXG4gICAgICAgICAgX3N0ZXAyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX2FuY2VzdG9yID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3QW5jZXN0b3JzW25ld0FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gbmV3UGF0aFtuZXdQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVzdWx0UGF0aCA9IG5ld1BhcmVudC5jb25jYXQobmV3SW5kZXgpO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KG9sZEFuY2VzdG9ycywgbmV3QW5jZXN0b3JzLCBbcmVzdWx0UGF0aF0pO1xuICAgICAgfVxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNCA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg0KTtcbiAgICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShfYW5jZXN0b3JzKTtcbiAgICAgIH1cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNSA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBfbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGg1KTtcbiAgICAgICAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KF9wYXRoNSk7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF9sZXZlbHMpLCBbbmV4dFBhdGhdKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uIGdldEZyYWdtZW50KGVkaXRvcikge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG52YXIgbm9ybWFsaXplTm9kZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGUoZWRpdG9yLCBlbnRyeSkge1xuICB2YXIgX2VudHJ5ID0gX3NsaWNlZFRvQXJyYXkoZW50cnksIDIpLFxuICAgIG5vZGUgPSBfZW50cnlbMF0sXG4gICAgcGF0aCA9IF9lbnRyeVsxXTtcbiAgLy8gVGhlcmUgYXJlIG5vIGNvcmUgbm9ybWFsaXphdGlvbnMgZm9yIHRleHQgbm9kZXMuXG4gIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBFbnN1cmUgdGhhdCBibG9jayBhbmQgaW5saW5lIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIHRleHQgY2hpbGQuXG4gIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBjaGlsZCA9IHtcbiAgICAgIHRleHQ6ICcnXG4gICAgfTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgIGF0OiBwYXRoLmNvbmNhdCgwKSxcbiAgICAgIHZvaWRzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBoYXZlIGJsb2NrIG9yIGlubGluZSBjaGlsZHJlbi5cbiAgdmFyIHNob3VsZEhhdmVJbmxpbmVzID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pIHx8IGVkaXRvci5pc0lubGluZShub2RlLmNoaWxkcmVuWzBdKSk7XG4gIC8vIFNpbmNlIHdlJ2xsIGJlIGFwcGx5aW5nIG9wZXJhdGlvbnMgd2hpbGUgaXRlcmF0aW5nLCBrZWVwIHRyYWNrIG9mIGFuXG4gIC8vIGluZGV4IHRoYXQgYWNjb3VudHMgZm9yIGFueSBhZGRlZC9yZW1vdmVkIG5vZGVzLlxuICB2YXIgbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKywgbisrKSB7XG4gICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICBpZiAoVGV4dC5pc1RleHQoY3VycmVudE5vZGUpKSBjb250aW51ZTtcbiAgICB2YXIgX2NoaWxkID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbl07XG4gICAgdmFyIHByZXYgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbltuIC0gMV07XG4gICAgdmFyIGlzTGFzdCA9IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICB2YXIgaXNJbmxpbmVPclRleHQgPSBUZXh0LmlzVGV4dChfY2hpbGQpIHx8IEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkgJiYgZWRpdG9yLmlzSW5saW5lKF9jaGlsZCk7XG4gICAgLy8gT25seSBhbGxvdyBibG9jayBub2RlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGFuZCBwYXJlbnQgYmxvY2tzXG4gICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gYmxvY2sgbm9kZXMuIFNpbWlsYXJseSwgb25seSBhbGxvdyBpbmxpbmUgbm9kZXMgaW5cbiAgICAvLyBvdGhlciBpbmxpbmUgbm9kZXMsIG9yIHBhcmVudCBibG9ja3MgdGhhdCBvbmx5IGNvbnRhaW4gaW5saW5lcyBhbmRcbiAgICAvLyB0ZXh0LlxuICAgIGlmIChpc0lubGluZU9yVGV4dCAhPT0gc2hvdWxkSGF2ZUlubGluZXMpIHtcbiAgICAgIGlmIChpc0lubGluZU9yVGV4dCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgaW5saW5lIG5vZGVzIGFyZSBzdXJyb3VuZGVkIGJ5IHRleHQgbm9kZXMuXG4gICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKF9jaGlsZCkpIHtcbiAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5ld0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICB2YXIgX25ld0NoaWxkID0ge1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBfbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuICsgMSksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlLCBhbmQgZG9lc24ndCBoYXZlIGEgYGNoaWxkcmVuYCBmaWVsZCxcbiAgICAgIC8vIHRoZW4gd2UgaGF2ZSBhbiBpbnZhbGlkIG5vZGUgdGhhdCB3aWxsIHVwc2V0IHNsYXRlLlxuICAgICAgLy9cbiAgICAgIC8vIGVnOiBgeyB0eXBlOiAnc29tZV9ub2RlJyB9YC5cbiAgICAgIC8vXG4gICAgICAvLyBUbyBwcmV2ZW50IHNsYXRlIGZyb20gYnJlYWtpbmcsIHdlIGNhbiBhZGQgdGhlIGBjaGlsZHJlbmAgZmllbGQsXG4gICAgICAvLyBhbmQgbm93IHRoYXQgaXQgaXMgdmFsaWQsIHdlIGNhbiB0byBtYW55IG1vcmUgb3BlcmF0aW9ucyBlYXNpbHksXG4gICAgICAvLyBzdWNoIGFzIGV4dGVuZCBub3JtYWxpemVycyB0byBmaXggZXJyb25vdXMgc3RydWN0dXJlLlxuICAgICAgaWYgKCFUZXh0LmlzVGV4dChfY2hpbGQpICYmICEoJ2NoaWxkcmVuJyBpbiBfY2hpbGQpKSB7XG4gICAgICAgIHZhciBlbGVtZW50Q2hpbGQgPSBfY2hpbGQ7XG4gICAgICAgIGVsZW1lbnRDaGlsZC5jaGlsZHJlbiA9IFtdO1xuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyB0aGF0IGFyZSBlbXB0eSBvciBtYXRjaC5cbiAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiAtIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvdWxkTm9ybWFsaXplID0gZnVuY3Rpb24gc2hvdWxkTm9ybWFsaXplKGVkaXRvciwgX3JlZikge1xuICB2YXIgaXRlcmF0aW9uID0gX3JlZi5pdGVyYXRpb24sXG4gICAgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggPSBfcmVmLmluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoO1xuICB2YXIgbWF4SXRlcmF0aW9ucyA9IGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoICogNDI7IC8vIEhBQ0s6IGJldHRlciB3YXk/XG4gIGlmIChpdGVyYXRpb24gPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBsZXRlbHkgbm9ybWFsaXplIHRoZSBlZGl0b3IgYWZ0ZXIgXCIuY29uY2F0KG1heEl0ZXJhdGlvbnMsIFwiIGl0ZXJhdGlvbnMhIFRoaXMgaXMgdXN1YWxseSBkdWUgdG8gaW5jb3JyZWN0IG5vcm1hbGl6YXRpb24gbG9naWMgdGhhdCBsZWF2ZXMgYSBub2RlIGluIGFuIGludmFsaWQgc3RhdGUuXCIpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGYobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGYobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRmKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkZihvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGYobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkZihhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIGFib3ZlID0gZnVuY3Rpb24gYWJvdmUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzLFxuICAgIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZSxcbiAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICB2YXIgcmV2ZXJzZSA9IG1vZGUgPT09ICdsb3dlc3QnO1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkZihFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICB2b2lkczogdm9pZHMsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICByZXZlcnNlOiByZXZlcnNlXG4gICAgfSkpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgIG4gPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgcCA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pKSBjb250aW51ZTtcbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmFuY2hvci5wYXRoKSAmJiBQYXRoLmlzQW5jZXN0b3IocCwgYXQuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKHBhdGgsIHApKSB7XG4gICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDgoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkOChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkOChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGFkZE1hcmsgPSBmdW5jdGlvbiBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG5vZGUsIHBhdGgpIHtcbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgIH1cblxuICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpLFxuICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMiksXG4gICAgICAgIHBhcmVudE5vZGUgPSBfRWRpdG9yJHBhcmVudDJbMF07XG4gICAgICAgIF9FZGl0b3IkcGFyZW50MlsxXTtcbiAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgIHZhciBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgdmFyIF9FZGl0b3Ikbm9kZSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKSxcbiAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMiksXG4gICAgICAgIHNlbGVjdGVkTm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF0sXG4gICAgICAgIHNlbGVjdGVkUGF0aCA9IF9FZGl0b3Ikbm9kZTJbMV07XG4gICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQzID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCksXG4gICAgICAgICAgX0VkaXRvciRwYXJlbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQzLCAxKSxcbiAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQ0WzBdO1xuICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSksIHtcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpKTtcbiAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDcoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ3KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ3KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRlKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkZShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGUobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRlKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGUoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBhZnRlciA9IGZ1bmN0aW9uIGFmdGVyKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIGFuY2hvcjogYW5jaG9yLFxuICAgIGZvY3VzOiBmb2N1c1xuICB9O1xuICB2YXIgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZTtcbiAgdmFyIGQgPSAwO1xuICB2YXIgdGFyZ2V0O1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkZShFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KSkpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIHRhcmdldCA9IHA7XG4gICAgICB9XG4gICAgICBkKys7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDYoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ2KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ2KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRkKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRkKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkZChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGQobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRkKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGQoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBiZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gIHZhciBmb2N1cyA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIGFuY2hvcjogYW5jaG9yLFxuICAgIGZvY3VzOiBmb2N1c1xuICB9O1xuICB2YXIgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZTtcbiAgdmFyIGQgPSAwO1xuICB2YXIgdGFyZ2V0O1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkZChFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuICAgICAgZCsrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgZGVsZXRlQmFja3dhcmQgPSBmdW5jdGlvbiBkZWxldGVCYWNrd2FyZChlZGl0b3IsIHVuaXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICB1bml0OiB1bml0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVsZXRlRm9yd2FyZCA9IGZ1bmN0aW9uIGRlbGV0ZUZvcndhcmQoZWRpdG9yLCB1bml0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgdW5pdDogdW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVsZXRlRnJhZ21lbnQgPSBmdW5jdGlvbiBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgIF9yZWYkZGlyZWN0aW9uID0gX3JlZi5kaXJlY3Rpb24sXG4gICAgZGlyZWN0aW9uID0gX3JlZiRkaXJlY3Rpb24gPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9yZWYkZGlyZWN0aW9uO1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogZGlyZWN0aW9uID09PSAnYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBlZGdlcyA9IGZ1bmN0aW9uIGVkZ2VzKGVkaXRvciwgYXQpIHtcbiAgcmV0dXJuIFtFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCksIEVkaXRvci5lbmQoZWRpdG9yLCBhdCldO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ1KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDUoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDUoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBlbGVtZW50UmVhZE9ubHkgPSBmdW5jdGlvbiBlbGVtZW50UmVhZE9ubHkoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkNShfb2JqZWN0U3ByZWFkJDUoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbik7XG4gICAgfVxuICB9KSk7XG59O1xuXG52YXIgZW5kID0gZnVuY3Rpb24gZW5kKGVkaXRvciwgYXQpIHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG59O1xuXG52YXIgZmlyc3QgPSBmdW5jdGlvbiBmaXJzdChlZGl0b3IsIGF0KSB7XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdzdGFydCdcbiAgfSk7XG4gIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGZyYWdtZW50ID0gZnVuY3Rpb24gZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBnZXRWb2lkID0gZnVuY3Rpb24gZ2V0Vm9pZChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgfVxuICB9KSk7XG59O1xuXG52YXIgaGFzQmxvY2tzID0gZnVuY3Rpb24gaGFzQmxvY2tzKGVkaXRvciwgZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gIH0pO1xufTtcblxudmFyIGhhc0lubGluZXMgPSBmdW5jdGlvbiBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICB9KTtcbn07XG5cbnZhciBoYXNQYXRoID0gZnVuY3Rpb24gaGFzUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgcmV0dXJuIE5vZGUuaGFzKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgaGFzVGV4dHMgPSBmdW5jdGlvbiBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gVGV4dC5pc1RleHQobik7XG4gIH0pO1xufTtcblxudmFyIGluc2VydEJyZWFrID0gZnVuY3Rpb24gaW5zZXJ0QnJlYWsoZWRpdG9yKSB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uIGluc2VydE5vZGUoZWRpdG9yLCBub2RlLCBvcHRpb25zKSB7XG4gIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlLCBvcHRpb25zKTtcbn07XG5cbnZhciBpbnNlcnRTb2Z0QnJlYWsgPSBmdW5jdGlvbiBpbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKSB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGluc2VydFRleHQgPSBmdW5jdGlvbiBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1hcmtzID0gZWRpdG9yLm1hcmtzO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgaWYgKG1hcmtzKSB7XG4gICAgICB2YXIgbm9kZSA9IF9vYmplY3RTcHJlYWQkMyh7XG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH0sIG1hcmtzKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlLCB7XG4gICAgICAgIGF0OiBvcHRpb25zLmF0LFxuICAgICAgICB2b2lkczogb3B0aW9ucy52b2lkc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICB9XG59O1xuXG52YXIgaXNCbG9jayA9IGZ1bmN0aW9uIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICByZXR1cm4gIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG59O1xuXG52YXIgaXNFZGdlID0gZnVuY3Rpb24gaXNFZGdlKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbn07XG5cbnZhciBpc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgdmFyIF9jaGlsZHJlbiA9IF9zbGljZWRUb0FycmF5KGNoaWxkcmVuLCAxKSxcbiAgICBmaXJzdCA9IF9jaGlsZHJlblswXTtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xufTtcblxudmFyIGlzRW5kID0gZnVuY3Rpb24gaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG59O1xuXG52YXIgaXNOb3JtYWxpemluZyA9IGZ1bmN0aW9uIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gIHJldHVybiBpc05vcm1hbGl6aW5nID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNOb3JtYWxpemluZztcbn07XG5cbnZhciBpc1N0YXJ0ID0gZnVuY3Rpb24gaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgaWYgKHBvaW50Lm9mZnNldCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbn07XG5cbnZhciBsYXN0ID0gZnVuY3Rpb24gbGFzdChlZGl0b3IsIGF0KSB7XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xuICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbn07XG5cbnZhciBsZWFmID0gZnVuY3Rpb24gbGVhZihlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgdmFyIG5vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGMobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGMobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRjKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkYyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGMobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkYyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gbGV2ZWxzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZSxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRjKE5vZGUubGV2ZWxzKGVkaXRvciwgcGF0aCkpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICBuID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgcCA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWxzLnB1c2goW24sIHBdKTtcbiAgICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxldmVscy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHlpZWxkKiBsZXZlbHM7XG4gIH0oKTtcbn1cblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgX2V4Y2x1ZGVkMiQxID0gW1widGV4dFwiXTtcbnZhciBtYXJrcyA9IGZ1bmN0aW9uIG1hcmtzKGVkaXRvcikge1xuICB2YXIgbWFya3MgPSBlZGl0b3IubWFya3MsXG4gICAgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcixcbiAgICBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgaWYgKG1hcmtzKSB7XG4gICAgcmV0dXJuIG1hcmtzO1xuICB9XG4gIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKTtcbiAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgdmFyIF9yZWYgPSBbYW5jaG9yLCBmb2N1c107XG4gICAgICBmb2N1cyA9IF9yZWZbMF07XG4gICAgICBhbmNob3IgPSBfcmVmWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDT01QQVQ6IE1ha2Ugc3VyZSBoYW5naW5nIHJhbmdlcyAoY2F1c2VkIGJ5IGRvdWJsZSBjbGlja2luZyBpbiBGaXJlZm94KVxuICAgICAqIGRvIG5vdCBhZHZlcnNlbHkgYWZmZWN0IHRoZSByZXR1cm5lZCBtYXJrcy5cbiAgICAgKi9cbiAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhbmNob3IsIGFuY2hvci5wYXRoKTtcbiAgICBpZiAoaXNFbmQpIHtcbiAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvcik7XG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgYW5jaG9yID0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgIGF0OiB7XG4gICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgICAgZm9jdXM6IGZvY3VzXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICAgIG1hdGNoID0gX0VkaXRvciRub2RlczJbMF07XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgX21hdGNoID0gX3NsaWNlZFRvQXJyYXkobWF0Y2gsIDEpLFxuICAgICAgICBfbm9kZSA9IF9tYXRjaFswXTtcbiAgICAgIF9ub2RlLnRleHQ7XG4gICAgICAgIHZhciBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbm9kZSwgX2V4Y2x1ZGVkJDEpO1xuICAgICAgcmV0dXJuIF9yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIHZhciBfYW5jaG9yID0gYW5jaG9yLFxuICAgIHBhdGggPSBfYW5jaG9yLnBhdGg7XG4gIHZhciBfRWRpdG9yJGxlYWYgPSBFZGl0b3IubGVhZihlZGl0b3IsIHBhdGgpLFxuICAgIF9FZGl0b3IkbGVhZjIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGxlYWYsIDEpLFxuICAgIG5vZGUgPSBfRWRpdG9yJGxlYWYyWzBdO1xuICBpZiAoYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICB9KTtcbiAgICB2YXIgbWFya2VkVm9pZCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocHJldiAmJiBibG9jaykge1xuICAgICAgICB2YXIgX3ByZXYgPSBfc2xpY2VkVG9BcnJheShwcmV2LCAyKSxcbiAgICAgICAgICBwcmV2Tm9kZSA9IF9wcmV2WzBdLFxuICAgICAgICAgIHByZXZQYXRoID0gX3ByZXZbMV07XG4gICAgICAgIHZhciBfYmxvY2sgPSBfc2xpY2VkVG9BcnJheShibG9jaywgMiksXG4gICAgICAgICAgYmxvY2tQYXRoID0gX2Jsb2NrWzFdO1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgbm9kZSA9IHByZXZOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBfbm9kZTIgPSBub2RlO1xuICAgIF9ub2RlMi50ZXh0O1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlMiwgX2V4Y2x1ZGVkMiQxKTtcbiAgcmV0dXJuIHJlc3Q7XG59O1xuXG52YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZSxcbiAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0O1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgIHZvaWRzOiB2b2lkc1xuICB9KTtcbiAgaWYgKCFwb2ludEFmdGVyTG9jYXRpb24pIHJldHVybjtcbiAgdmFyIF9FZGl0b3IkbGFzdCA9IEVkaXRvci5sYXN0KGVkaXRvciwgW10pLFxuICAgIF9FZGl0b3IkbGFzdDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGxhc3QsIDIpLFxuICAgIHRvID0gX0VkaXRvciRsYXN0MlsxXTtcbiAgdmFyIHNwYW4gPSBbcG9pbnRBZnRlckxvY2F0aW9uLnBhdGgsIHRvXTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgfVxuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBfRWRpdG9yJHBhcmVudCA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCksXG4gICAgICAgIF9FZGl0b3IkcGFyZW50MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50LCAxKSxcbiAgICAgICAgcGFyZW50ID0gX0VkaXRvciRwYXJlbnQyWzBdO1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSksXG4gICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICBuZXh0ID0gX0VkaXRvciRub2RlczJbMF07XG4gIHJldHVybiBuZXh0O1xufTtcblxudmFyIG5vZGUgPSBmdW5jdGlvbiBub2RlKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBbbm9kZSwgcGF0aF07XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRiKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRiKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkYihvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGIobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRiKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGIoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIG5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdhbGwnIDogX29wdGlvbnMkbW9kZSxcbiAgICAgIF9vcHRpb25zJHVuaXZlcnNhbCA9IG9wdGlvbnMudW5pdmVyc2FsLFxuICAgICAgdW5pdmVyc2FsID0gX29wdGlvbnMkdW5pdmVyc2FsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHVuaXZlcnNhbCxcbiAgICAgIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlLFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcyxcbiAgICAgIF9vcHRpb25zJGlnbm9yZU5vblNlbCA9IG9wdGlvbnMuaWdub3JlTm9uU2VsZWN0YWJsZSxcbiAgICAgIGlnbm9yZU5vblNlbGVjdGFibGUgPSBfb3B0aW9ucyRpZ25vcmVOb25TZWwgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaWdub3JlTm9uU2VsO1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAoU3Bhbi5pc1NwYW4oYXQpKSB7XG4gICAgICBmcm9tID0gYXRbMF07XG4gICAgICB0byA9IGF0WzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIGZyb20gPSByZXZlcnNlID8gbGFzdCA6IGZpcnN0O1xuICAgICAgdG8gPSByZXZlcnNlID8gZmlyc3QgOiBsYXN0O1xuICAgIH1cbiAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgIGZyb206IGZyb20sXG4gICAgICB0bzogdG8sXG4gICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgbm9kZSA9IF9yZWYyWzBdO1xuICAgICAgICBpZiAoIUVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdm9pZHMgJiYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSB8fCBFZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBub2RlKSkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoaWdub3JlTm9uU2VsZWN0YWJsZSAmJiAhRWRpdG9yLmlzU2VsZWN0YWJsZShlZGl0b3IsIG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIGhpdDtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYihub2RlRW50cmllcyksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgIG5vZGUgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICBwYXRoID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgIGlmIChpZ25vcmVOb25TZWxlY3RhYmxlICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFFZGl0b3IuaXNTZWxlY3RhYmxlKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDtcbiAgICAgICAgLy8gSW4gaGlnaGVzdCBtb2RlIGFueSBub2RlIGxvd2VyIHRoYW4gdGhlIGxhc3QgaGl0IGlzIG5vdCBhIG1hdGNoLlxuICAgICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hdGNoKG5vZGUsIHBhdGgpKSB7XG4gICAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgICAvLyBoaXQsIHRoZW4gd2UndmUgZm91bmQgYSBicmFuY2ggdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBtYXRjaCwgd2hpY2hcbiAgICAgICAgICAvLyBtZWFucyB0aGUgbWF0Y2ggaXMgbm90IHVuaXZlcnNhbC5cbiAgICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgbWF0Y2ggYW5kIGl0J3MgbG93ZXIgdGhhbiB0aGUgbGFzdCwgdXBkYXRlIHRoZSBoaXQuXG4gICAgICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGxvd2VzdCBtb2RlIHdlIGVtaXQgdGhlIGxhc3QgaGl0LCBvbmNlIGl0J3MgZ3VhcmFudGVlZCBsb3dlc3QuXG4gICAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG4gICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVtaXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBlbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSBsb3dlc3QgaXMgYWx3YXlzIGVtaXR0aW5nIG9uZSBiZWhpbmQsIGNhdGNoIHVwIGF0IHRoZSBlbmQuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaGl0KSB7XG4gICAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChoaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgaGl0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAgIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG4gICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgeWllbGQqIG1hdGNoZXM7XG4gICAgfVxuICB9KCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGEobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGEobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRhKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkYShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGEobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkYShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX29wdGlvbnMkZm9yY2UgPSBvcHRpb25zLmZvcmNlLFxuICAgIGZvcmNlID0gX29wdGlvbnMkZm9yY2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkZm9yY2UsXG4gICAgb3BlcmF0aW9uID0gb3B0aW9ucy5vcGVyYXRpb247XG4gIHZhciBnZXREaXJ0eVBhdGhzID0gZnVuY3Rpb24gZ2V0RGlydHlQYXRocyhlZGl0b3IpIHtcbiAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gIH07XG4gIHZhciBnZXREaXJ0eVBhdGhLZXlzID0gZnVuY3Rpb24gZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpIHtcbiAgICByZXR1cm4gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgfTtcbiAgdmFyIHBvcERpcnR5UGF0aCA9IGZ1bmN0aW9uIHBvcERpcnR5UGF0aChlZGl0b3IpIHtcbiAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG4gICAgZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG4gIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZm9yY2UpIHtcbiAgICB2YXIgYWxsUGF0aHMgPSBBcnJheS5mcm9tKE5vZGUubm9kZXMoZWRpdG9yKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBwID0gX3JlZjJbMV07XG4gICAgICByZXR1cm4gcDtcbiAgICB9KTtcbiAgICB2YXIgYWxsUGF0aEtleXMgPSBuZXcgU2V0KGFsbFBhdGhzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHAuam9pbignLCcpO1xuICAgIH0pKTtcbiAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGFsbFBhdGhLZXlzKTtcbiAgfVxuICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIC8qXG4gICAgICBGaXggZGlydHkgZWxlbWVudHMgd2l0aCBubyBjaGlsZHJlbi5cbiAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKCkgZG9lcyBmaXggdGhpcywgYnV0IHNvbWUgbm9ybWFsaXphdGlvbiBmaXhlcyBhbHNvIHJlcXVpcmUgaXQgdG8gd29yay5cbiAgICAgIFJ1bm5pbmcgYW4gaW5pdGlhbCBwYXNzIGF2b2lkcyB0aGUgY2F0Y2gtMjIgcmFjZSBjb25kaXRpb24uXG4gICAgKi9cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYShnZXREaXJ0eVBhdGhzKGVkaXRvcikpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfZGlydHlQYXRoID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIF9kaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9lbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgX2RpcnR5UGF0aCk7XG4gICAgICAgICAgdmFyIF9lbnRyeTIgPSBfc2xpY2VkVG9BcnJheShfZW50cnksIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9lbnRyeTJbMF0sXG4gICAgICAgICAgICBfID0gX2VudHJ5MlsxXTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgVGhlIGRlZmF1bHQgbm9ybWFsaXplciBpbnNlcnRzIGFuIGVtcHR5IHRleHQgbm9kZSBpbiB0aGlzIHNjZW5hcmlvLCBidXQgaXQgY2FuIGJlIGN1c3RvbWlzZWQuXG4gICAgICAgICAgICBTbyB0aGVyZSBpcyBzb21lIHJpc2sgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgIEFzIGxvbmcgYXMgdGhlIG5vcm1hbGl6ZXIgb25seSBpbnNlcnRzIGNoaWxkIG5vZGVzIGZvciB0aGlzIGNhc2UgaXQgaXMgc2FmZSB0byBkbyBpbiBhbnkgb3JkZXI7XG4gICAgICAgICAgICBieSBkZWZpbml0aW9uIGFkZGluZyBjaGlsZHJlbiB0byBhbiBlbXB0eSBub2RlIGNhbid0IGNhdXNlIG90aGVyIHBhdGhzIHRvIGNoYW5nZS5cbiAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoX2VudHJ5LCB7XG4gICAgICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIHZhciBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaWYgKCFlZGl0b3Iuc2hvdWxkTm9ybWFsaXplKHtcbiAgICAgICAgZGlydHlQYXRoczogZGlydHlQYXRocyxcbiAgICAgICAgaXRlcmF0aW9uOiBpdGVyYXRpb24sXG4gICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoOiBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCxcbiAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25cbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaXJ0eVBhdGggPSBwb3BEaXJ0eVBhdGgoZWRpdG9yKTtcbiAgICAgIC8vIElmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUsIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIGRpcnR5UGF0aCkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBkaXJ0eVBhdGgpO1xuICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSwge1xuICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaXRlcmF0aW9uKys7XG4gICAgICBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgcGFyZW50ID0gZnVuY3Rpb24gcGFyZW50KGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhcmVudFBhdGgpO1xuICByZXR1cm4gZW50cnk7XG59O1xuXG52YXIgcGF0aFJlZiA9IGZ1bmN0aW9uIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiBwYXRoLFxuICAgIGFmZmluaXR5OiBhZmZpbml0eSxcbiAgICB1bnJlZjogZnVuY3Rpb24gdW5yZWYoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICBwYXRoUmVmc1tcImRlbGV0ZVwiXShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHBhdGhSZWZzID0gZnVuY3Rpb24gcGF0aFJlZnMoZWRpdG9yKSB7XG4gIHZhciByZWZzID0gUEFUSF9SRUZTLmdldChlZGl0b3IpO1xuICBpZiAoIXJlZnMpIHtcbiAgICByZWZzID0gbmV3IFNldCgpO1xuICAgIFBBVEhfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciBwYXRoID0gZnVuY3Rpb24gcGF0aChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGRlcHRoID0gb3B0aW9ucy5kZXB0aCxcbiAgICBlZGdlID0gb3B0aW9ucy5lZGdlO1xuICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBfTm9kZSRmaXJzdCA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCksXG4gICAgICAgIF9Ob2RlJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0LCAyKSxcbiAgICAgICAgZmlyc3RQYXRoID0gX05vZGUkZmlyc3QyWzFdO1xuICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIF9Ob2RlJGxhc3QgPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCksXG4gICAgICAgIF9Ob2RlJGxhc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkbGFzdCwgMiksXG4gICAgICAgIGxhc3RQYXRoID0gX05vZGUkbGFzdDJbMV07XG4gICAgICBhdCA9IGxhc3RQYXRoO1xuICAgIH1cbiAgfVxuICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgYXQgPSBSYW5nZS5lbmQoYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdCA9IFBhdGguY29tbW9uKGF0LmFuY2hvci5wYXRoLCBhdC5mb2N1cy5wYXRoKTtcbiAgICB9XG4gIH1cbiAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgYXQgPSBhdC5wYXRoO1xuICB9XG4gIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgYXQgPSBhdC5zbGljZSgwLCBkZXB0aCk7XG4gIH1cbiAgcmV0dXJuIGF0O1xufTtcblxudmFyIHBvaW50UmVmID0gZnVuY3Rpb24gcG9pbnRSZWYoZWRpdG9yLCBwb2ludCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcG9pbnQsXG4gICAgYWZmaW5pdHk6IGFmZmluaXR5LFxuICAgIHVucmVmOiBmdW5jdGlvbiB1bnJlZigpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgcG9pbnRSZWZzW1wiZGVsZXRlXCJdKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gIH07XG4gIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHBvaW50UmVmcyA9IGZ1bmN0aW9uIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgdmFyIHJlZnMgPSBQT0lOVF9SRUZTLmdldChlZGl0b3IpO1xuICBpZiAoIXJlZnMpIHtcbiAgICByZWZzID0gbmV3IFNldCgpO1xuICAgIFBPSU5UX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gIH1cbiAgcmV0dXJuIHJlZnM7XG59O1xuXG52YXIgcG9pbnQgPSBmdW5jdGlvbiBwb2ludChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJGVkZ2UgPSBvcHRpb25zLmVkZ2UsXG4gICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UgPT09IHZvaWQgMCA/ICdzdGFydCcgOiBfb3B0aW9ucyRlZGdlO1xuICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgdmFyIHBhdGg7XG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICB2YXIgX05vZGUkbGFzdCA9IE5vZGUubGFzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgX05vZGUkbGFzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRsYXN0LCAyKSxcbiAgICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0MlsxXTtcbiAgICAgIHBhdGggPSBsYXN0UGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9Ob2RlJGZpcnN0ID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgX05vZGUkZmlyc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkZmlyc3QsIDIpLFxuICAgICAgICBmaXJzdFBhdGggPSBfTm9kZSRmaXJzdDJbMV07XG4gICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9mZnNldDogZWRnZSA9PT0gJ2VuZCcgPyBub2RlLnRleHQubGVuZ3RoIDogMFxuICAgIH07XG4gIH1cbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICByZXR1cm4gZWRnZSA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogZW5kO1xuICB9XG4gIHJldHVybiBhdDtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDkobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkOShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gcG9zaXRpb25zKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQgPT09IHZvaWQgMCA/ICdvZmZzZXQnIDogX29wdGlvbnMkdW5pdCxcbiAgICAgIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlLFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcyxcbiAgICAgIF9vcHRpb25zJGlnbm9yZU5vblNlbCA9IG9wdGlvbnMuaWdub3JlTm9uU2VsZWN0YWJsZSxcbiAgICAgIGlnbm9yZU5vblNlbGVjdGFibGUgPSBfb3B0aW9ucyRpZ25vcmVOb25TZWwgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaWdub3JlTm9uU2VsO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxnb3JpdGhtIG5vdGVzOlxuICAgICAqXG4gICAgICogRWFjaCBzdGVwIGBkaXN0YW5jZWAgaXMgZHluYW1pYyBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgdGV4dFxuICAgICAqIGFuZCB0aGUgYHVuaXRgIHNwZWNpZmllZC4gIEVhY2ggc3RlcCwgZS5nLiwgYSBsaW5lIG9yIHdvcmQsIG1heVxuICAgICAqIHNwYW4gbXVsdGlwbGUgdGV4dCBub2Rlcywgc28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSB0ZXh0IGJvdGggb25cbiAgICAgKiB0d28gbGV2ZWxzIGluIHN0ZXAtc3luYzpcbiAgICAgKlxuICAgICAqIGBsZWFmVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgdGV4dCBsZWFmIGxldmVsLCBhbmQgaXMgYWR2YW5jZWRcbiAgICAgKiB0aHJvdWdoIHVzaW5nIHRoZSBjb3VudGVycyBgbGVhZlRleHRPZmZzZXRgIGFuZCBgbGVhZlRleHRSZW1haW5pbmdgLlxuICAgICAqXG4gICAgICogYGJsb2NrVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgYmxvY2sgbGV2ZWwsIGFuZCBpcyBzaG9ydGVuZWRcbiAgICAgKiBieSBgZGlzdGFuY2VgIGV2ZXJ5IHRpbWUgaXQgaXMgYWR2YW5jZWQuXG4gICAgICpcbiAgICAgKiBXZSBvbmx5IG1haW50YWluIGEgd2luZG93IG9mIG9uZSBibG9ja1RleHQgYW5kIG9uZSBsZWFmVGV4dCBiZWNhdXNlXG4gICAgICogYSBibG9jayBub2RlIGFsd2F5cyBhcHBlYXJzIGJlZm9yZSBhbGwgb2YgaXRzIGxlYWYgbm9kZXMuXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgdmFyIGJsb2NrVGV4dCA9ICcnO1xuICAgIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG4gICAgdmFyIGxlYWZUZXh0UmVtYWluaW5nID0gMDtcbiAgICB2YXIgbGVhZlRleHRPZmZzZXQgPSAwO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ5KEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICByZXZlcnNlOiByZXZlcnNlLFxuICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgIGlnbm9yZU5vblNlbGVjdGFibGU6IGlnbm9yZU5vblNlbGVjdGFibGVcbiAgICAgIH0pKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgbm9kZSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHBhdGggPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgLypcbiAgICAgICAgICogRUxFTUVOVCBOT0RFIC0gWWllbGQgcG9zaXRpb24ocykgZm9yIHZvaWRzLCBjb2xsZWN0IGJsb2NrVGV4dCBmb3IgYmxvY2tzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc28gYnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5c1xuICAgICAgICAgIC8vIHlpZWxkIHRoZWlyIGZpcnN0IHBvaW50LiBJZiB0aGUgYHZvaWRzYCBvcHRpb24gaXMgc2V0IHRvIHRydWUsXG4gICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciB0aGVpciBjb250ZW50LlxuICAgICAgICAgIGlmICghdm9pZHMgJiYgKGVkaXRvci5pc1ZvaWQobm9kZSkgfHwgZWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KG5vZGUpKSkge1xuICAgICAgICAgICAgeWllbGQgRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5saW5lIGVsZW1lbnQgbm9kZXMgYXJlIGlnbm9yZWQgYXMgdGhleSBkb24ndCB0aGVtc2VsdmVzXG4gICAgICAgICAgLy8gY29udHJpYnV0ZSB0byBgYmxvY2tUZXh0YCBvciBgbGVhZlRleHRgIC0gdGhlaXIgcGFyZW50IGFuZFxuICAgICAgICAgIC8vIGNoaWxkcmVuIGRvLlxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuICAgICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJyxcbiAgICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAgICAgLy8gRW5zdXJlIHJhbmdlIGNvbnNpZGVyZWQgaXMgY2FwcGVkIHRvIGByYW5nZWAsIGluIHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIC4uLkVkaXRvci5lZGdlcyhlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgICAgIHZhciBlID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGVuZC5wYXRoKSA/IGVuZCA6IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGFuY2hvcjogcyxcbiAgICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBURVhUIExFQUYgTk9ERSAtIEl0ZXJhdGUgdGhyb3VnaCB0ZXh0IGNvbnRlbnQsIHlpZWxkaW5nXG4gICAgICAgICAqIHBvc2l0aW9ucyBldmVyeSBgZGlzdGFuY2VgIG9mZnNldCBhY2NvcmRpbmcgdG8gYHVuaXRgLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgdmFyIGlzRmlyc3QgPSBQYXRoLmVxdWFscyhwYXRoLCBmaXJzdC5wYXRoKTtcbiAgICAgICAgICAvLyBQcm9vZiB0aGF0IHdlIGFsd2F5cyBleGhhdXN0IHRleHQgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLFxuICAgICAgICAgIC8vICAgICBgbGVhZlRleHRSZW1haW5pbmc9JHtsZWFmVGV4dFJlbWFpbmluZ30gLSBgK1xuICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGxlYWYgdGV4dCBub2RlYCwgcGF0aClcbiAgICAgICAgICAvLyBSZXNldCBgbGVhZlRleHRgIGNvdW50ZXJzIGZvciBuZXcgdGV4dCBub2RlLlxuICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IHJldmVyc2UgPyBmaXJzdC5vZmZzZXQgOiBub2RlLnRleHQubGVuZ3RoIC0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSBmaXJzdC5vZmZzZXQ7IC8vIFdvcmtzIGZvciByZXZlcnNlIHRvby5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBub2RlLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRSZW1haW5pbmcgOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBZaWVsZCBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2Ygbm9kZSAocG90ZW50aWFsbHkpLlxuICAgICAgICAgIGlmIChpc0ZpcnN0IHx8IGlzTmV3QmxvY2sgfHwgdW5pdCA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gWWllbGQgcG9zaXRpb25zIGV2ZXJ5IChkeW5hbWljYWxseSBjYWxjdWxhdGVkKSBgZGlzdGFuY2VgIG9mZnNldC5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAgICAgLy8gYW5kIGlmIGJsb2NrVGV4dCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhbm90aGVyIGJsb2NrIG5vZGUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWR2YW5jZSBibG9ja1RleHQgZm9yd2FyZCBieSB0aGUgbmV3IGBkaXN0YW5jZWAuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrVGV4dCA9PT0gJycpIGJyZWFrO1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZShibG9ja1RleHQsIHVuaXQsIHJldmVyc2UpO1xuICAgICAgICAgICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGF0IHRoZSBwcmV2aW91c2x5IGZvdW5kIGRpc3RhbmNlIGFuZCB1c2UgdGhlXG4gICAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgYmxvY2tUZXh0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKGJsb2NrVGV4dCwgZGlzdGFuY2UsIHJldmVyc2UpWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG4gICAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dE9mZnNldCAtIGRpc3RhbmNlIDogbGVhZlRleHRPZmZzZXQgKyBkaXN0YW5jZTtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbGVhZlRleHRSZW1haW5pbmcgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgIC8vIElmIGBsZWFmVGV4dGAgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYSBuZXcgbGVhZiBub2RlXG4gICAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAgIC8vIGNhdGNoIHVwIHRvIGJsb2NrVGV4dCBpbiB0aGUgbmV4dCBsZWFmIHRleHQgbm9kZS5cbiAgICAgICAgICAgIGlmIChsZWFmVGV4dFJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSAtbGVhZlRleHRSZW1haW5pbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IHdhbGtlZCBgZGlzdGFuY2VgIG9mZnNldHMgdGhyb3VnaCBgbGVhZlRleHRgXG4gICAgICAgICAgICAvLyB0byBjYXRjaCB1cCB3aXRoIGBibG9ja1RleHRgLCBzbyB3ZSBjYW4gcmVzZXQgYGRpc3RhbmNlYFxuICAgICAgICAgICAgLy8gYW5kIHlpZWxkIHRoaXMgcG9zaXRpb24gaW4gdGhpcyBub2RlLlxuICAgICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUHJvb2YgdGhhdCB1cG9uIGNvbXBsZXRpb24sIHdlJ3ZlIGV4YWh1c3RlZCBib3RoIGxlYWYgYW5kIGJsb2NrIHRleHQ6XG4gICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsIFwibGVhZlRleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLCBcImJsb2NrVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgICAvLyBIZWxwZXI6XG4gICAgICAvLyBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIG9mZnNldHMgZm9yIGEgc3RlcCBvZiBzaXplIGB1bml0YCBvbiBnaXZlbiBzdHJpbmcuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxjRGlzdGFuY2UodGV4dCwgdW5pdCwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHVuaXQgPT09ICdjaGFyYWN0ZXInKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCByZXZlcnNlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3dvcmQnKSB7XG4gICAgICAgIHJldHVybiBnZXRXb3JkRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdsaW5lJyB8fCB1bml0ID09PSAnYmxvY2snKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSgpO1xufVxuXG52YXIgcHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBvaW50QmVmb3JlTG9jYXRpb24gPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIHtcbiAgICB2b2lkczogdm9pZHNcbiAgfSk7XG4gIGlmICghcG9pbnRCZWZvcmVMb2NhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX0VkaXRvciRmaXJzdCA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKSxcbiAgICBfRWRpdG9yJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkZmlyc3QsIDIpLFxuICAgIHRvID0gX0VkaXRvciRmaXJzdDJbMV07XG4gIC8vIFRoZSBzZWFyY2ggbG9jYXRpb24gaXMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHRvIHRoZSBwYXRoIG9mXG4gIC8vIHRoZSBwb2ludCBiZWZvcmUgdGhlIGxvY2F0aW9uIHBhc3NlZCBpblxuICB2YXIgc3BhbiA9IFtwb2ludEJlZm9yZUxvY2F0aW9uLnBhdGgsIHRvXTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gIH1cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgX0VkaXRvciRwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpLFxuICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMSksXG4gICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50MlswXTtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSxcbiAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgIHByZXZpb3VzID0gX0VkaXRvciRub2RlczJbMF07XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cbnZhciByYW5nZVJlZiA9IGZ1bmN0aW9uIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IHJhbmdlLFxuICAgIGFmZmluaXR5OiBhZmZpbml0eSxcbiAgICB1bnJlZjogZnVuY3Rpb24gdW5yZWYoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgdmFyIHJhbmdlUmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICAgIHJhbmdlUmVmc1tcImRlbGV0ZVwiXShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciByYW5nZVJlZnMgPSBmdW5jdGlvbiByYW5nZVJlZnMoZWRpdG9yKSB7XG4gIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBSQU5HRV9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZWRpdG9yLCBhdCwgdG8pIHtcbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmICF0bykge1xuICAgIHJldHVybiBhdDtcbiAgfVxuICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgdG8gfHwgYXQpO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcjogc3RhcnQsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDIoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDIoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciByZW1vdmVNYXJrID0gZnVuY3Rpb24gcmVtb3ZlTWFyayhlZGl0b3IsIGtleSkge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG5vZGUsIHBhdGgpIHtcbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgIH1cblxuICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpLFxuICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMiksXG4gICAgICAgIHBhcmVudE5vZGUgPSBfRWRpdG9yJHBhcmVudDJbMF07XG4gICAgICAgIF9FZGl0b3IkcGFyZW50MlsxXTtcbiAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgIHZhciBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgdmFyIF9FZGl0b3Ikbm9kZSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKSxcbiAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMiksXG4gICAgICAgIHNlbGVjdGVkTm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF0sXG4gICAgICAgIHNlbGVjdGVkUGF0aCA9IF9FZGl0b3Ikbm9kZTJbMV07XG4gICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQzID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCksXG4gICAgICAgICAgX0VkaXRvciRwYXJlbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQzLCAxKSxcbiAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQ0WzBdO1xuICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQyKHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG4gICAgICBkZWxldGUgbWFya3Nba2V5XTtcbiAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzZXROb3JtYWxpemluZyA9IGZ1bmN0aW9uIHNldE5vcm1hbGl6aW5nKGVkaXRvciwgaXNOb3JtYWxpemluZykge1xuICBOT1JNQUxJWklORy5zZXQoZWRpdG9yLCBpc05vcm1hbGl6aW5nKTtcbn07XG5cbnZhciBzdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGVkaXRvciwgYXQpIHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDgobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDgobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ4KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOChvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDgobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkOChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gIHZhciB0ZXh0ID0gJyc7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICBub2RlID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgIHBhdGggPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBzdGFydC5wYXRoKSkge1xuICAgICAgICB0ID0gdC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgICAgfVxuICAgICAgdGV4dCArPSB0O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiB0ZXh0O1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ3KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgdW5oYW5nUmFuZ2UgPSBmdW5jdGlvbiB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICAvLyBQRVJGOiBleGl0IGVhcmx5IGlmIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2UgaXNuJ3QgaGFuZ2luZy5cbiAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgYXQ6IGVuZCxcbiAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfSxcbiAgICB2b2lkczogdm9pZHNcbiAgfSk7XG4gIHZhciBibG9ja1BhdGggPSBlbmRCbG9jayA/IGVuZEJsb2NrWzFdIDogW107XG4gIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgdmFyIGJlZm9yZSA9IHtcbiAgICBhbmNob3I6IGZpcnN0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbiAgdmFyIHNraXAgPSB0cnVlO1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICBub2RlID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgIHBhdGggPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS50ZXh0ICE9PSAnJyB8fCBQYXRoLmlzQmVmb3JlKHBhdGgsIGJsb2NrUGF0aCkpIHtcbiAgICAgICAgZW5kID0ge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBub2RlLnRleHQubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiBzdGFydCxcbiAgICBmb2N1czogZW5kXG4gIH07XG59O1xuXG52YXIgd2l0aG91dE5vcm1hbGl6aW5nID0gZnVuY3Rpb24gd2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZm4pIHtcbiAgdmFyIHZhbHVlID0gRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKTtcbiAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgdmFsdWUpO1xuICB9XG4gIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTtcbn07XG5cbnZhciBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUgPSBmdW5jdGlvbiBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUoZWRpdG9yLCBfcmVmLCBfcmVmMikge1xuICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICBwcmV2Tm9kZSA9IF9yZWYzWzBdLFxuICAgIHByZXZQYXRoID0gX3JlZjNbMV07XG4gIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKTtcbiAgICBfcmVmNFswXTtcbiAgICBfcmVmNFsxXTtcbiAgLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuICAvLyBvZiBtZXJnaW5nIHRoZSB0d28uIFRoaXMgaXMgYSBjb21tb24gcmljaCB0ZXh0IGVkaXRvciBiZWhhdmlvciB0b1xuICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbiAgLy8gaWYgcHJldk5vZGUgaXMgZmlyc3QgY2hpbGQgaW4gcGFyZW50LGRvbid0IHJlbW92ZSBpdC5cbiAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSB8fCBUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycgJiYgcHJldlBhdGhbcHJldlBhdGgubGVuZ3RoIC0gMV0gIT09IDA7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDYoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBkZWxldGVUZXh0ID0gZnVuY3Rpb24gZGVsZXRlVGV4dChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfRWRpdG9yJHZvaWQsIF9FZGl0b3Ikdm9pZDI7XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlLFxuICAgICAgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQsXG4gICAgICBfb3B0aW9ucyRkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UsXG4gICAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2UsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICBfb3B0aW9ucyRoYW5naW5nID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiBSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgIGlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgIH1cbiAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgIHZhciBmdXJ0aGVzdFZvaWQgPSBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICB2YXIgX2Z1cnRoZXN0Vm9pZCA9IF9zbGljZWRUb0FycmF5KGZ1cnRoZXN0Vm9pZCwgMiksXG4gICAgICAgICAgdm9pZFBhdGggPSBfZnVydGhlc3RWb2lkWzFdO1xuICAgICAgICBhdCA9IHZvaWRQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICBhdCA9IHtcbiAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICAgICAgaGFuZ2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICBfZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgIHZhciBlbmRPZkRvYyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczRbMF0sXG4gICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuICAgIHZhciBzdGFydEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgYXQ6IGVuZCxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICB2YXIgaXNTaW5nbGVUZXh0ID0gUGF0aC5lcXVhbHMoc3RhcnQucGF0aCwgZW5kLnBhdGgpO1xuICAgIHZhciBzdGFydE5vbkVkaXRhYmxlID0gdm9pZHMgPyBudWxsIDogKF9FZGl0b3Ikdm9pZCA9IEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICBhdDogc3RhcnQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkgIT09IG51bGwgJiYgX0VkaXRvciR2b2lkICE9PSB2b2lkIDAgPyBfRWRpdG9yJHZvaWQgOiBFZGl0b3IuZWxlbWVudFJlYWRPbmx5KGVkaXRvciwge1xuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSk7XG4gICAgdmFyIGVuZE5vbkVkaXRhYmxlID0gdm9pZHMgPyBudWxsIDogKF9FZGl0b3Ikdm9pZDIgPSBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfRWRpdG9yJHZvaWQyICE9PSB2b2lkIDAgPyBfRWRpdG9yJHZvaWQyIDogRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KTtcbiAgICAvLyBJZiB0aGUgc3RhcnQgb3IgZW5kIHBvaW50cyBhcmUgaW5zaWRlIGFuIGlubGluZSB2b2lkLCBudWRnZSB0aGVtIG91dC5cbiAgICBpZiAoc3RhcnROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydCk7XG4gICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0QmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKHN0YXJ0QmxvY2tbMV0sIGJlZm9yZS5wYXRoKSkge1xuICAgICAgICBzdGFydCA9IGJlZm9yZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlbmQpO1xuICAgICAgaWYgKGFmdGVyICYmIGVuZEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihlbmRCbG9ja1sxXSwgYWZ0ZXIucGF0aCkpIHtcbiAgICAgICAgZW5kID0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAvLyB0aGUgc3RhcnQgYW5kIGVuZCBub2Rlcy5cbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBsYXN0UGF0aDtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KSksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBfZW50cnkgPSBfc2xpY2VkVG9BcnJheShlbnRyeSwgMiksXG4gICAgICAgICAgX25vZGUyID0gX2VudHJ5WzBdLFxuICAgICAgICAgIF9wYXRoMiA9IF9lbnRyeVsxXTtcbiAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShfcGF0aDIsIGxhc3RQYXRoKSA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQoX25vZGUyKSAmJiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIF9ub2RlMikgfHwgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgX25vZGUyKSkgfHwgIVBhdGguaXNDb21tb24oX3BhdGgyLCBzdGFydC5wYXRoKSAmJiAhUGF0aC5pc0NvbW1vbihfcGF0aDIsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgbGFzdFBhdGggPSBfcGF0aDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBwID0gX3JlZjJbMV07XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgdmFyIHJlbW92ZWRUZXh0ID0gJyc7XG4gICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgIXN0YXJ0Tm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgdmFyIF9FZGl0b3IkbGVhZiA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KSxcbiAgICAgICAgX0VkaXRvciRsZWFmMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZiwgMSksXG4gICAgICAgIG5vZGUgPSBfRWRpdG9yJGxlYWYyWzBdO1xuICAgICAgdmFyIHBhdGggPSBfcG9pbnQucGF0aDtcbiAgICAgIHZhciBfc3RhcnQgPSBzdGFydCxcbiAgICAgICAgb2Zmc2V0ID0gX3N0YXJ0Lm9mZnNldDtcbiAgICAgIHZhciB0ZXh0ID0gbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aFJlZnMucmV2ZXJzZSgpLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIHIudW5yZWYoKTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByICE9PSBudWxsO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWVuZE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgX3BvaW50MiA9IGVuZFJlZi5jdXJyZW50O1xuICAgICAgdmFyIF9FZGl0b3IkbGVhZjMgPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludDIpLFxuICAgICAgICBfRWRpdG9yJGxlYWY0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsZWFmMywgMSksXG4gICAgICAgIF9ub2RlID0gX0VkaXRvciRsZWFmNFswXTtcbiAgICAgIHZhciBfcGF0aCA9IF9wb2ludDIucGF0aDtcbiAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcbiAgICAgIHZhciBfdGV4dCA9IF9ub2RlLnRleHQuc2xpY2UoX29mZnNldCwgZW5kLm9mZnNldCk7XG4gICAgICBpZiAoX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiBpc0Fjcm9zc0Jsb2NrcyAmJiBlbmRSZWYuY3VycmVudCAmJiBzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gRm9yIFRoYWkgc2NyaXB0LCBkZWxldGluZyBOIGNoYXJhY3RlcihzKSBiYWNrd2FyZCBzaG91bGQgZGVsZXRlXG4gICAgLy8gTiBjb2RlIHBvaW50KHMpIGluc3RlYWQgb2YgYW4gZW50aXJlIGdyYXBoZW1lIGNsdXN0ZXIuXG4gICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRVbnJlZiA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgdmFyIGVuZFVucmVmID0gZW5kUmVmLnVucmVmKCk7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwgJiYgcG9pbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDUoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBpbnNlcnRGcmFnbWVudCA9IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfb3B0aW9ucyRoYW5naW5nID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZyxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgdmFyIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpIDogX29wdGlvbnMkYXQsXG4gICAgICBfb3B0aW9ucyRiYXRjaERpcnR5ID0gb3B0aW9ucy5iYXRjaERpcnR5LFxuICAgICAgYmF0Y2hEaXJ0eSA9IF9vcHRpb25zJGJhdGNoRGlydHkgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRiYXRjaERpcnR5O1xuICAgIGlmICghZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdFxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IGF0XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgLy8gaW5zdGVhZCBzaW5jZSBpdCB3aWxsIG5lZWQgdG8gYmUgc3BsaXQgb3RoZXJ3aXNlLlxuICAgIHZhciBpbmxpbmVFbGVtZW50TWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdDogYXQsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgaWYgKGlubGluZUVsZW1lbnRNYXRjaCkge1xuICAgICAgdmFyIF9pbmxpbmVFbGVtZW50TWF0Y2ggPSBfc2xpY2VkVG9BcnJheShpbmxpbmVFbGVtZW50TWF0Y2gsIDIpLFxuICAgICAgICBfaW5saW5lUGF0aCA9IF9pbmxpbmVFbGVtZW50TWF0Y2hbMV07XG4gICAgICBpZiAoRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICB9IGVsc2UgaWYgKEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBibG9ja01hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgYXQ6IGF0LFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIF9ibG9ja01hdGNoID0gX3NsaWNlZFRvQXJyYXkoYmxvY2tNYXRjaCwgMiksXG4gICAgICBibG9ja1BhdGggPSBfYmxvY2tNYXRjaFsxXTtcbiAgICB2YXIgaXNCbG9ja1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICB2YXIgaXNCbG9ja0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgIHZhciBpc0Jsb2NrRW1wdHkgPSBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICB2YXIgbWVyZ2VTdGFydCA9ICFpc0Jsb2NrU3RhcnQgfHwgaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgdmFyIG1lcmdlRW5kID0gIWlzQmxvY2tFbmQ7XG4gICAgdmFyIF9Ob2RlJGZpcnN0ID0gTm9kZS5maXJzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pLFxuICAgICAgX05vZGUkZmlyc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkZmlyc3QsIDIpLFxuICAgICAgZmlyc3RQYXRoID0gX05vZGUkZmlyc3QyWzFdO1xuICAgIHZhciBfTm9kZSRsYXN0ID0gTm9kZS5sYXN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSksXG4gICAgICBfTm9kZSRsYXN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGxhc3QsIDIpLFxuICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0MlsxXTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBtYXRjaGVyID0gZnVuY3Rpb24gbWF0Y2hlcihfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgbiA9IF9yZWYyWzBdLFxuICAgICAgICBwID0gX3JlZjJbMV07XG4gICAgICB2YXIgaXNSb290ID0gcC5sZW5ndGggPT09IDA7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobWVyZ2VTdGFydCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgZmlyc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXJnZUVuZCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgbGFzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShOb2RlLm5vZGVzKHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3M6IG1hdGNoZXJcbiAgICAgIH0pKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgZW50cnkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgaWYgKG1hdGNoZXIoZW50cnkpKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgIHZhciBtaWRkbGVzID0gW107XG4gICAgdmFyIGVuZHMgPSBbXTtcbiAgICB2YXIgc3RhcnRpbmcgPSB0cnVlO1xuICAgIHZhciBoYXNCbG9ja3MgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9tYXRjaGVzID0gbWF0Y2hlczsgX2kgPCBfbWF0Y2hlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbWF0Y2hlcyRfaSA9IF9zbGljZWRUb0FycmF5KF9tYXRjaGVzW19pXSwgMSksXG4gICAgICAgIG5vZGUgPSBfbWF0Y2hlcyRfaVswXTtcbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIGhhc0Jsb2NrcyA9IHRydWU7XG4gICAgICAgIG1pZGRsZXMucHVzaChub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSksXG4gICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgaW5saW5lTWF0Y2ggPSBfRWRpdG9yJG5vZGVzMlswXTtcbiAgICB2YXIgX2lubGluZU1hdGNoID0gX3NsaWNlZFRvQXJyYXkoaW5saW5lTWF0Y2gsIDIpLFxuICAgICAgaW5saW5lUGF0aCA9IF9pbmxpbmVNYXRjaFsxXTtcbiAgICB2YXIgaXNJbmxpbmVTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgIHZhciBpc0lubGluZUVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICB2YXIgbWlkZGxlUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0Jsb2NrRW5kICYmICFlbmRzLmxlbmd0aCA/IFBhdGgubmV4dChibG9ja1BhdGgpIDogYmxvY2tQYXRoKTtcbiAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBhdCxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBoYXNCbG9ja3MgPyBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgbW9kZTogaGFzQmxvY2tzID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCcsXG4gICAgICBhbHdheXM6IGhhc0Jsb2NrcyAmJiAoIWlzQmxvY2tTdGFydCB8fCBzdGFydHMubGVuZ3RoID4gMCkgJiYgKCFpc0Jsb2NrRW5kIHx8IGVuZHMubGVuZ3RoID4gMCksXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgc3RhcnRzLCB7XG4gICAgICBhdDogc3RhcnRSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgIH0sXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkczogdm9pZHMsXG4gICAgICBiYXRjaERpcnR5OiBiYXRjaERpcnR5XG4gICAgfSk7XG4gICAgaWYgKGlzQmxvY2tFbXB0eSAmJiAhc3RhcnRzLmxlbmd0aCAmJiBtaWRkbGVzLmxlbmd0aCAmJiAhZW5kcy5sZW5ndGgpIHtcbiAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBtaWRkbGVzLCB7XG4gICAgICBhdDogbWlkZGxlUmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH0sXG4gICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgIGJhdGNoRGlydHk6IGJhdGNoRGlydHlcbiAgICB9KTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZW5kcywge1xuICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgIGJhdGNoRGlydHk6IGJhdGNoRGlydHlcbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMuYXQpIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhlbmRSZWYuY3VycmVudCk7XG4gICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhtaWRkbGVSZWYuY3VycmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB2YXIgX2VuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWYudW5yZWYoKTtcbiAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICBlbmRSZWYudW5yZWYoKTtcbiAgfSk7XG59O1xuXG52YXIgY29sbGFwc2UgPSBmdW5jdGlvbiBjb2xsYXBzZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX29wdGlvbnMkZWRnZSA9IG9wdGlvbnMuZWRnZSxcbiAgICBlZGdlID0gX29wdGlvbnMkZWRnZSA9PT0gdm9pZCAwID8gJ2FuY2hvcicgOiBfb3B0aW9ucyRlZGdlO1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5mb2N1cyk7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLFxuICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMSksXG4gICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF07XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzdGFydCk7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbiksXG4gICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgfVxufTtcblxudmFyIGRlc2VsZWN0ID0gZnVuY3Rpb24gZGVzZWxlY3QoZWRpdG9yKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIG1vdmUgPSBmdW5jdGlvbiBtb3ZlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICB2YXIgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZSxcbiAgICBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQsXG4gICAgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICB2YXIgX29wdGlvbnMkZWRnZSA9IG9wdGlvbnMuZWRnZSxcbiAgICBlZGdlID0gX29wdGlvbnMkZWRnZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJGVkZ2U7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICB9XG4gIHZhciBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLFxuICAgIGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICB2YXIgb3B0cyA9IHtcbiAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgdW5pdDogdW5pdCxcbiAgICBpZ25vcmVOb25TZWxlY3RhYmxlOiB0cnVlXG4gIH07XG4gIHZhciBwcm9wcyA9IHt9O1xuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcbiAgICBpZiAocG9pbnQpIHtcbiAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgIH1cbiAgfVxuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICB2YXIgX3BvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBmb2N1cywgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBmb2N1cywgb3B0cyk7XG4gICAgaWYgKF9wb2ludCkge1xuICAgICAgcHJvcHMuZm9jdXMgPSBfcG9pbnQ7XG4gICAgfVxuICB9XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xufTtcblxudmFyIHNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdChlZGl0b3IsIHRhcmdldCkge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgdGFyZ2V0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgdGFyZ2V0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gIH1cbiAgZWRpdG9yLmFwcGx5KHtcbiAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQxKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQxKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgc2V0UG9pbnQgPSBmdW5jdGlvbiBzZXRQb2ludChlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIHZhciBfb3B0aW9ucyRlZGdlID0gb3B0aW9ucy5lZGdlLFxuICAgIGVkZ2UgPSBfb3B0aW9ucyRlZGdlID09PSB2b2lkIDAgPyAnYm90aCcgOiBfb3B0aW9ucyRlZGdlO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gIH1cbiAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgfVxuICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcixcbiAgICBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgdmFyIHBvaW50ID0gZWRnZSA9PT0gJ2FuY2hvcicgPyBhbmNob3IgOiBmb2N1cztcbiAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCBfZGVmaW5lUHJvcGVydHkoe30sIGVkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnLCBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBwb2ludCksIHByb3BzKSkpO1xufTtcblxudmFyIHNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgdmFyIG5ld1Byb3BzID0ge307XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICBpZiAoayA9PT0gJ2FuY2hvcicgJiYgcHJvcHMuYW5jaG9yICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5hbmNob3IsIHNlbGVjdGlvbi5hbmNob3IpIHx8IGsgPT09ICdmb2N1cycgJiYgcHJvcHMuZm9jdXMgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmZvY3VzLCBzZWxlY3Rpb24uZm9jdXMpIHx8IGsgIT09ICdhbmNob3InICYmIGsgIT09ICdmb2N1cycgJiYgcHJvcHNba10gIT09IHNlbGVjdGlvbltrXSkge1xuICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICBuZXdQcm9wc1trXSA9IHByb3BzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXMob2xkUHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgcHJvcGVydGllczogb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDQoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBpbnNlcnROb2RlcyA9IGZ1bmN0aW9uIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfb3B0aW9ucyRoYW5naW5nID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZyxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMsXG4gICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZSxcbiAgICAgIF9vcHRpb25zJGJhdGNoRGlydHkgPSBvcHRpb25zLmJhdGNoRGlydHksXG4gICAgICBiYXRjaERpcnR5ID0gX29wdGlvbnMkYmF0Y2hEaXJ0eSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGJhdGNoRGlydHk7XG4gICAgdmFyIGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgIHNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0O1xuICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICB9XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX25vZGVzID0gbm9kZXMsXG4gICAgICBfbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX25vZGVzLCAxKSxcbiAgICAgIG5vZGUgPSBfbm9kZXMyWzBdO1xuICAgIGlmICghYXQpIHtcbiAgICAgIGF0ID0gZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uKGVkaXRvcik7XG4gICAgICBpZiAoc2VsZWN0ICE9PSBmYWxzZSkge1xuICAgICAgICBzZWxlY3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgIHNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSksXG4gICAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICAgIGVudHJ5ID0gX0VkaXRvciRub2RlczJbMF07XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdmFyIF9lbnRyeSA9IF9zbGljZWRUb0FycmF5KGVudHJ5LCAyKSxcbiAgICAgICAgICBtYXRjaFBhdGggPSBfZW50cnlbMV07XG4gICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBtYXRjaFBhdGgpO1xuICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBtYXRjaFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIGF0ID0gaXNBdEVuZCA/IFBhdGgubmV4dChwYXRoKSA6IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQoYXQpO1xuICAgIHZhciBpbmRleCA9IGF0W2F0Lmxlbmd0aCAtIDFdO1xuICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXJlbnRQYXRoXG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJhdGNoRGlydHkpIHtcbiAgICAgIC8vIFBFUkY6IGJhdGNoIHVwZGF0ZSBkaXJ0eSBwYXRoc1xuICAgICAgLy8gYmF0Y2hlZCBvcHMgdXNlZCB0byB0cmFuc2Zvcm0gZXhpc3RpbmcgZGlydHkgcGF0aHNcbiAgICAgIHZhciBiYXRjaGVkT3BzID0gW107XG4gICAgICB2YXIgbmV3RGlydHlQYXRocyA9IFBhdGgubGV2ZWxzKHBhcmVudFBhdGgpO1xuICAgICAgYmF0Y2hEaXJ0eVBhdGhzKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChub2RlcyksXG4gICAgICAgICAgX3N0ZXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBwYXJlbnRQYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgdmFyIG9wID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KG9wKTtcbiAgICAgICAgICAgIGF0ID0gUGF0aC5uZXh0KGF0KTtcbiAgICAgICAgICAgIGJhdGNoZWRPcHMucHVzaChvcCk7XG4gICAgICAgICAgICBpZiAoIVRleHQuaXNUZXh0KSB7XG4gICAgICAgICAgICAgIG5ld0RpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0RpcnR5UGF0aHMucHVzaC5hcHBseShuZXdEaXJ0eVBhdGhzLCBfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkuZnJvbShOb2RlLm5vZGVzKG5vZGUpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmNvbmNhdChwKTtcbiAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICBfbG9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVwZGF0ZURpcnR5UGF0aHMoZWRpdG9yLCBuZXdEaXJ0eVBhdGhzLCBmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gcDtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iYXRjaGVkT3BzID0gYmF0Y2hlZE9wczsgX2kgPCBfYmF0Y2hlZE9wcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBvcCA9IF9iYXRjaGVkT3BzW19pXTtcbiAgICAgICAgICAgIGlmIChQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApKSB7XG4gICAgICAgICAgICAgIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShuZXdQYXRoLCBvcCk7XG4gICAgICAgICAgICAgIGlmICghbmV3UGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdQYXRoO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobm9kZXMpLFxuICAgICAgICBfc3RlcDI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfbm9kZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB2YXIgX3BhdGggPSBwYXJlbnRQYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgbm9kZTogX25vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IFBhdGgubmV4dChhdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH1cbiAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuICAgIGlmIChzZWxlY3QpIHtcbiAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBsaWZ0Tm9kZXMgPSBmdW5jdGlvbiBsaWZ0Tm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGF0LFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBwID0gX3JlZjJbMV07XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9wYXRoUmVmcyA9IHBhdGhSZWZzOyBfaSA8IF9wYXRoUmVmcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBwYXRoUmVmID0gX3BhdGhSZWZzW19pXTtcbiAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgIHZhciBfcGFyZW50Tm9kZUVudHJ5ID0gX3NsaWNlZFRvQXJyYXkocGFyZW50Tm9kZUVudHJ5LCAyKSxcbiAgICAgICAgcGFyZW50ID0gX3BhcmVudE5vZGVFbnRyeVswXSxcbiAgICAgICAgcGFyZW50UGF0aCA9IF9wYXJlbnROb2RlRW50cnlbMV07XG4gICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGVuZ3RoID0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIHRvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IHRvUGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhcmVudFBhdGgsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogcGFyZW50UGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBfdG9QYXRoID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogX3RvUGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3BsaXRQYXRoID0gUGF0aC5uZXh0KHBhdGgpO1xuICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIF9leGNsdWRlZCA9IFtcInRleHRcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiXTtcbnZhciBoYXNTaW5nbGVDaGlsZE5lc3QgPSBmdW5jdGlvbiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBub2RlKSB7XG4gIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgZWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIG1lcmdlTm9kZXMgPSBmdW5jdGlvbiBtZXJnZU5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDtcbiAgICB2YXIgX29wdGlvbnMkaGFuZ2luZyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmcsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzLFxuICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpLFxuICAgICAgICAgIF9FZGl0b3IkcGFyZW50MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50LCAxKSxcbiAgICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDJbMF07XG4gICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KSxcbiAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICBjdXJyZW50ID0gX0VkaXRvciRub2RlczJbMF07XG4gICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICBhdDogYXQsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICB2b2lkczogdm9pZHMsXG4gICAgICBtb2RlOiBtb2RlXG4gICAgfSk7XG4gICAgaWYgKCFjdXJyZW50IHx8ICFwcmV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfY3VycmVudCA9IF9zbGljZWRUb0FycmF5KGN1cnJlbnQsIDIpLFxuICAgICAgbm9kZSA9IF9jdXJyZW50WzBdLFxuICAgICAgcGF0aCA9IF9jdXJyZW50WzFdO1xuICAgIHZhciBfcHJldiA9IF9zbGljZWRUb0FycmF5KHByZXYsIDIpLFxuICAgICAgcHJldk5vZGUgPSBfcHJldlswXSxcbiAgICAgIHByZXZQYXRoID0gX3ByZXZbMV07XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihwYXRoLCBwcmV2UGF0aCk7XG4gICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgIG4gPSBfcmVmMlswXTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0pLnNsaWNlKGNvbW1vblBhdGgubGVuZ3RoKS5zbGljZSgwLCAtMSk7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAvLyByZXN1bHQsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byByZW1vdmUgaXQgYWZ0ZXIgbWVyZ2luZy5cbiAgICB2YXIgZW1wdHlBbmNlc3RvciA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIGxldmVscy5pbmNsdWRlcyhuKSAmJiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSk7XG4gICAgdmFyIHByb3BlcnRpZXM7XG4gICAgdmFyIHBvc2l0aW9uO1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBub2RlcyBhcmUgZXF1aXZhbGVudCwgYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgcG9zaXRpb25cbiAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4gICAgICBub2RlLnRleHQ7XG4gICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCk7XG4gICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLnRleHQubGVuZ3RoO1xuICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW47XG4gICAgICAgIHZhciBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcbiAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgcHJvcGVydGllcyA9IF9yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2Tm9kZSkpKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgaXNuJ3QgYWxyZWFkeSB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBwcmV2aW91cyBub2RlLCBtb3ZlXG4gICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cbiAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIHRvOiBuZXdQYXRoLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuICAgIC8vIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSB0cmVlLlxuICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChFZGl0b3Iuc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlKGVkaXRvciwgcHJldiwgY3VycmVudCkpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwcmV2UGF0aCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgIGVtcHR5UmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBtb3ZlTm9kZXMgPSBmdW5jdGlvbiBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvID0gb3B0aW9ucy50byxcbiAgICAgIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgdG9SZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHRvKTtcbiAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBhdCxcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfcGF0aFJlZnMgPSBwYXRoUmVmczsgX2kgPCBfcGF0aFJlZnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgcGF0aFJlZiA9IF9wYXRoUmVmc1tfaV07XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtb3ZlX25vZGUnLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgbmV3UGF0aDogbmV3UGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0b1JlZi5jdXJyZW50ICYmIFBhdGguaXNTaWJsaW5nKG5ld1BhdGgsIHBhdGgpICYmIFBhdGguaXNBZnRlcihuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBzaWJsaW5nIG1vdmUgdG8gYSBsYXRlciBpbmRleCwgdGhlIHBhdGggYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHNoaWZ0ZWRcbiAgICAgICAgLy8gdG8gYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgaW5zdGVhZCBvZiBhZnRlci4gVG8gZW5zdXJlIG91ciBncm91cCBvZiBub2RlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgLy8gaW4gdGhlIGNvcnJlY3Qgb3JkZXIgd2UgaW5jcmVtZW50IHRvUmVmIHRvIGFjY291bnQgZm9yIHRoYXRcbiAgICAgICAgdG9SZWYuY3VycmVudCA9IFBhdGgubmV4dCh0b1JlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9SZWYudW5yZWYoKTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlTm9kZXMgPSBmdW5jdGlvbiByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfb3B0aW9ucyRoYW5naW5nID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZyxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMsXG4gICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTtcbiAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGRlcHRocyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBhdCxcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKGRlcHRocywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBwID0gX3JlZjJbMV07XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9wYXRoUmVmcyA9IHBhdGhSZWZzOyBfaSA8IF9wYXRoUmVmcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBwYXRoUmVmID0gX3BhdGhSZWZzW19pXTtcbiAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgICAgICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF07XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIHNldE5vZGVzID0gZnVuY3Rpb24gc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgIGNvbXBhcmUgPSBvcHRpb25zLmNvbXBhcmUsXG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWVyZ2U7XG4gICAgdmFyIF9vcHRpb25zJGhhbmdpbmcgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nLFxuICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICBfb3B0aW9ucyRzcGxpdCA9IG9wdGlvbnMuc3BsaXQsXG4gICAgICBzcGxpdCA9IF9vcHRpb25zJHNwbGl0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0LFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQgaW4gYSBub24tZW1wdHkgbm9kZSBhbmQgJ3NwbGl0JyBpcyB0cnVlLCB0aGVyZSdzIG5vdGhpbmcgdG9cbiAgICAgICAgLy8gc2V0IHRoYXQgd29uJ3QgZ2V0IG5vcm1hbGl6ZWQgYXdheVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgIHZhciBzcGxpdE1vZGUgPSBtb2RlID09PSAnbG93ZXN0JyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnO1xuICAgICAgdmFyIGVuZEF0RW5kT2ZOb2RlID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgZW5kLCBlbmQucGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgIGFsd2F5czogIWVuZEF0RW5kT2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICBhbHdheXM6ICFzdGFydEF0U3RhcnRPZk5vZGVcbiAgICAgIH0pO1xuICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb21wYXJlKSB7XG4gICAgICBjb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShwcm9wLCBub2RlUHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcCAhPT0gbm9kZVByb3A7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgbm9kZSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHBhdGggPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgLy8gRklYTUU6IGlzIHRoaXMgY29ycmVjdD9cbiAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21wYXJlKHByb3BzW2tdLCBub2RlW2tdKSkge1xuICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAvLyBPbWl0IG5ldyBwcm9wZXJ0aWVzIGZyb20gdGhlIG9sZCBwcm9wZXJ0aWVzIGxpc3RcbiAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTtcbiAgICAgICAgICAgIC8vIE9taXQgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG5ldyBwcm9wZXJ0aWVzIGxpc3RcbiAgICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IG1lcmdlKG5vZGVba10sIHByb3BzW2tdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wc1trXSAhPSBudWxsKSBuZXdQcm9wZXJ0aWVzW2tdID0gcHJvcHNba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQyKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgcG9pbnQgYnkgZGVsZXRpbmcgaXQncyBjb250ZW50LlxuICovXG52YXIgZGVsZXRlUmFuZ2UgPSBmdW5jdGlvbiBkZWxldGVSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2UuYW5jaG9yO1xuICB9IGVsc2Uge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlXG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50UmVmLnVucmVmKCk7XG4gIH1cbn07XG52YXIgc3BsaXROb2RlcyA9IGZ1bmN0aW9uIHNwbGl0Tm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICBfb3B0aW9ucyRoZWlnaHQgPSBvcHRpb25zLmhlaWdodCxcbiAgICAgIGhlaWdodCA9IF9vcHRpb25zJGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJGhlaWdodCxcbiAgICAgIF9vcHRpb25zJGFsd2F5cyA9IG9wdGlvbnMuYWx3YXlzLFxuICAgICAgYWx3YXlzID0gX29wdGlvbnMkYWx3YXlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsd2F5cztcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IGRlbGV0ZVJhbmdlKGVkaXRvciwgYXQpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgIC8vIGNvdW50ZXJzIG5lZWQgdG8gYWNjb3VudCBmb3IgdXMgcG90ZW50aWFsbHkgc3BsaXR0aW5nIGF0IGEgbm9uLWxlYWYuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIHBhdGggPSBhdDtcbiAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpLFxuICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMSksXG4gICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50MlswXTtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gbiA9PT0gcGFyZW50O1xuICAgICAgfTtcbiAgICAgIGhlaWdodCA9IHBvaW50LnBhdGgubGVuZ3RoIC0gcGF0aC5sZW5ndGggKyAxO1xuICAgICAgYXQgPSBwb2ludDtcbiAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgfVxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJlZm9yZVJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0LCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICAgIHZhciBhZnRlclJlZjtcbiAgICB0cnkge1xuICAgICAgdmFyIF9FZGl0b3Ikbm9kZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSxcbiAgICAgICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICAgICAgaGlnaGVzdCA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuICAgICAgaWYgKCFoaWdoZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2b2lkTWF0Y2ggPSBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbnVkZ2UgPSAwO1xuICAgICAgaWYgKCF2b2lkcyAmJiB2b2lkTWF0Y2gpIHtcbiAgICAgICAgdmFyIF92b2lkTWF0Y2ggPSBfc2xpY2VkVG9BcnJheSh2b2lkTWF0Y2gsIDIpLFxuICAgICAgICAgIHZvaWROb2RlID0gX3ZvaWRNYXRjaFswXSxcbiAgICAgICAgICB2b2lkUGF0aCA9IF92b2lkTWF0Y2hbMV07XG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudCh2b2lkTm9kZSkgJiYgZWRpdG9yLmlzSW5saW5lKHZvaWROb2RlKSkge1xuICAgICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIHZvaWRQYXRoKTtcbiAgICAgICAgICBpZiAoIWFmdGVyKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHtcbiAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgYWZ0ZXJQYXRoID0gUGF0aC5uZXh0KHZvaWRQYXRoKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgIGF0OiBhZnRlclBhdGgsXG4gICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZnRlciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGFmdGVyUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICBoZWlnaHQgPSBzaWJsaW5nSGVpZ2h0ICsgMTtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGFmdGVyUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQpO1xuICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICB2YXIgX2hpZ2hlc3QgPSBfc2xpY2VkVG9BcnJheShoaWdoZXN0LCAyKSxcbiAgICAgICAgaGlnaGVzdFBhdGggPSBfaGlnaGVzdFsxXTtcbiAgICAgIHZhciBsb3dlc3RQYXRoID0gYXQucGF0aC5zbGljZSgwLCBkZXB0aCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogbG93ZXN0UGF0aCxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICBfcGF0aCA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChfcGF0aC5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgubGVuZ3RoID09PSAwIHx8ICF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX3BvaW50MiA9IGJlZm9yZVJlZi5jdXJyZW50O1xuICAgICAgICAgIHZhciBpc0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIF9wb2ludDIsIF9wYXRoKTtcbiAgICAgICAgICBpZiAoYWx3YXlzIHx8ICFiZWZvcmVSZWYgfHwgIUVkaXRvci5pc0VkZ2UoZWRpdG9yLCBfcG9pbnQyLCBfcGF0aCkpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gTm9kZS5leHRyYWN0UHJvcHMobm9kZSk7XG4gICAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgICB0eXBlOiAnc3BsaXRfbm9kZScsXG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3NpdGlvbiA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdICsgKHNwbGl0IHx8IGlzRW5kID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3BvaW50KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdmFyIF9hZnRlclJlZjtcbiAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgKF9hZnRlclJlZiA9IGFmdGVyUmVmKSA9PT0gbnVsbCB8fCBfYWZ0ZXJSZWYgPT09IHZvaWQgMCB8fCBfYWZ0ZXJSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQxKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgdW5zZXROb2RlcyA9IGZ1bmN0aW9uIHVuc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBwcm9wcyA9IFtwcm9wc107XG4gIH1cbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShwcm9wcyksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgIG9ialtrZXldID0gbnVsbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgb2JqLCBvcHRpb25zKTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIHVud3JhcE5vZGVzID0gZnVuY3Rpb24gdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICBfb3B0aW9ucyRzcGxpdCA9IG9wdGlvbnMuc3BsaXQsXG4gICAgICBzcGxpdCA9IF9vcHRpb25zJHNwbGl0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0LFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGF0LFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBwID0gX3JlZjJbMV07XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9XG4gICAgLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgLy8gSWYgd2UgZG8gbm90IHJldmVyc2UgdGhlIG9yZGVyIGFuZCBjYWxsIGl0IGZyb20gdG9wIHRvIHRoZSBib3R0b20sIGl0IHdpbGwgcmVtb3ZlIGFsbCBibG9ja3NcbiAgICAvLyB0aGF0IHdyYXAgdGFyZ2V0IG5vZGUuIFNvIHdlIHJldmVyc2UgdGhlIG9yZGVyLlxuICAgICkucmV2ZXJzZSgpO1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwYXRoUmVmcyksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBwYXRoUmVmID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgX0VkaXRvciRub2RlID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgICBfRWRpdG9yJG5vZGUyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlLCAxKSxcbiAgICAgICAgICBub2RlID0gX0VkaXRvciRub2RlMlswXTtcbiAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGlmIChzcGxpdCAmJiByYW5nZVJlZikge1xuICAgICAgICAgIHJhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlUmVmLmN1cnJlbnQsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBUcmFuc2Zvcm1zLmxpZnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICByYW5nZVJlZi51bnJlZigpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciB3cmFwTm9kZXMgPSBmdW5jdGlvbiB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICBfb3B0aW9ucyRzcGxpdCA9IG9wdGlvbnMuc3BsaXQsXG4gICAgICBzcGxpdCA9IF9vcHRpb25zJHNwbGl0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0LFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0O1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShlbGVtZW50KSkge1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikgfHwgVGV4dC5pc1RleHQobik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByb290cyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGF0LFxuICAgICAgbWF0Y2g6IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3IuaXNFZGl0b3Iobik7XG4gICAgICB9LFxuICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSk7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBfcm9vdHMkX2kgPSBfc2xpY2VkVG9BcnJheShfcm9vdHNbX2ldLCAyKSxcbiAgICAgICAgICByb290UGF0aCA9IF9yb290cyRfaVsxXTtcbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSBtYXRjaGVzWzBdO1xuICAgICAgICAgIHZhciBsYXN0ID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBfZmlyc3QgPSBfc2xpY2VkVG9BcnJheShmaXJzdCwgMiksXG4gICAgICAgICAgICBmaXJzdFBhdGggPSBfZmlyc3RbMV07XG4gICAgICAgICAgdmFyIF9sYXN0ID0gX3NsaWNlZFRvQXJyYXkobGFzdCwgMiksXG4gICAgICAgICAgICBsYXN0UGF0aCA9IF9sYXN0WzFdO1xuICAgICAgICAgIGlmIChmaXJzdFBhdGgubGVuZ3RoID09PSAwICYmIGxhc3RQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtYXRjaGluZyBwYXJlbnQgLSB1c3VhbGx5IG1lYW5zIHRoZSBub2RlIGlzIGFuIGVkaXRvciAtIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmVxdWFscyhmaXJzdFBhdGgsIGxhc3RQYXRoKSA/IFBhdGgucGFyZW50KGZpcnN0UGF0aCkgOiBQYXRoLmNvbW1vbihmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICB2YXIgX2NvbW1vbk5vZGVFbnRyeSA9IF9zbGljZWRUb0FycmF5KGNvbW1vbk5vZGVFbnRyeSwgMSksXG4gICAgICAgICAgICBjb21tb25Ob2RlID0gX2NvbW1vbk5vZGVFbnRyeVswXTtcbiAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgdmFyIHdyYXBwZXJQYXRoID0gUGF0aC5uZXh0KGxhc3RQYXRoLnNsaWNlKDAsIGRlcHRoKSk7XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgIGF0OiB3cmFwcGVyUGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNBbmNlc3Rvcihjb21tb25Ob2RlKSAmJiBjb21tb25Ob2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvOiB3cmFwcGVyUGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9yZXQ7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfcm9vdHMgPSByb290czsgX2kgPCBfcm9vdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICAgIGlmIChfcmV0ID09PSAwKSBjb250aW51ZTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgU2xhdGUgYEVkaXRvcmAgb2JqZWN0LlxuICovXG52YXIgY3JlYXRlRWRpdG9yID0gZnVuY3Rpb24gY3JlYXRlRWRpdG9yKCkge1xuICB2YXIgZWRpdG9yID0ge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgbWFya3M6IG51bGwsXG4gICAgaXNFbGVtZW50UmVhZE9ubHk6IGZ1bmN0aW9uIGlzRWxlbWVudFJlYWRPbmx5KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNJbmxpbmU6IGZ1bmN0aW9uIGlzSW5saW5lKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNTZWxlY3RhYmxlOiBmdW5jdGlvbiBpc1NlbGVjdGFibGUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGlzVm9pZDogZnVuY3Rpb24gaXNWb2lkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbWFya2FibGVWb2lkOiBmdW5jdGlvbiBtYXJrYWJsZVZvaWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7fSxcbiAgICAvLyBDb3JlXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcHBseS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICAvLyBFZGl0b3JcbiAgICBhZGRNYXJrOiBmdW5jdGlvbiBhZGRNYXJrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZE1hcmsuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZGVsZXRlQmFja3dhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUJhY2t3YXJkJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGRlbGV0ZUZvcndhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUZvcndhcmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlRm9yd2FyZC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBkZWxldGVGcmFnbWVudDogZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlRnJhZ21lbnQuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uIGdldEZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZyYWdtZW50LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGluc2VydEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRCcmVhayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRCcmVhay5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpbnNlcnRTb2Z0QnJlYWs6IGZ1bmN0aW9uIGluc2VydFNvZnRCcmVhayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleThdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRTb2Z0QnJlYWsuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OV0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydEZyYWdtZW50LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEwKSwgX2tleTEwID0gMDsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgICAgICBhcmdzW19rZXkxMF0gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnROb2RlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjExKSwgX2tleTExID0gMDsgX2tleTExIDwgX2xlbjExOyBfa2V5MTErKykge1xuICAgICAgICBhcmdzW19rZXkxMV0gPSBhcmd1bWVudHNbX2tleTExXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRUZXh0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5vZGU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEyKSwgX2tleTEyID0gMDsgX2tleTEyIDwgX2xlbjEyOyBfa2V5MTIrKykge1xuICAgICAgICBhcmdzW19rZXkxMl0gPSBhcmd1bWVudHNbX2tleTEyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemVOb2RlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHJlbW92ZU1hcms6IGZ1bmN0aW9uIHJlbW92ZU1hcmskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEzKSwgX2tleTEzID0gMDsgX2tleTEzIDwgX2xlbjEzOyBfa2V5MTMrKykge1xuICAgICAgICBhcmdzW19rZXkxM10gPSBhcmd1bWVudHNbX2tleTEzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVNYXJrLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGdldERpcnR5UGF0aHM6IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE0KSwgX2tleTE0ID0gMDsgX2tleTE0IDwgX2xlbjE0OyBfa2V5MTQrKykge1xuICAgICAgICBhcmdzW19rZXkxNF0gPSBhcmd1bWVudHNbX2tleTE0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXREaXJ0eVBhdGhzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNob3VsZE5vcm1hbGl6ZTogZnVuY3Rpb24gc2hvdWxkTm9ybWFsaXplJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNSksIF9rZXkxNSA9IDA7IF9rZXkxNSA8IF9sZW4xNTsgX2tleTE1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTVdID0gYXJndW1lbnRzW19rZXkxNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkTm9ybWFsaXplLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIC8vIEVkaXRvciBpbnRlcmZhY2VcbiAgICBhYm92ZTogZnVuY3Rpb24gYWJvdmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE2KSwgX2tleTE2ID0gMDsgX2tleTE2IDwgX2xlbjE2OyBfa2V5MTYrKykge1xuICAgICAgICBhcmdzW19rZXkxNl0gPSBhcmd1bWVudHNbX2tleTE2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhYm92ZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE3KSwgX2tleTE3ID0gMDsgX2tleTE3IDwgX2xlbjE3OyBfa2V5MTcrKykge1xuICAgICAgICBhcmdzW19rZXkxN10gPSBhcmd1bWVudHNbX2tleTE3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZnRlci5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTgpLCBfa2V5MTggPSAwOyBfa2V5MTggPCBfbGVuMTg7IF9rZXkxOCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE4XSA9IGFyZ3VtZW50c1tfa2V5MThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJlZm9yZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBjb2xsYXBzZTogZnVuY3Rpb24gY29sbGFwc2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE5KSwgX2tleTE5ID0gMDsgX2tleTE5IDwgX2xlbjE5OyBfa2V5MTkrKykge1xuICAgICAgICBhcmdzW19rZXkxOV0gPSBhcmd1bWVudHNbX2tleTE5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsYXBzZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbiBfZGVsZXRlKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjApLCBfa2V5MjAgPSAwOyBfa2V5MjAgPCBfbGVuMjA7IF9rZXkyMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIwXSA9IGFyZ3VtZW50c1tfa2V5MjBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZVRleHQuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMSksIF9rZXkyMSA9IDA7IF9rZXkyMSA8IF9sZW4yMTsgX2tleTIxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjFdID0gYXJndW1lbnRzW19rZXkyMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzZWxlY3QuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMiksIF9rZXkyMiA9IDA7IF9rZXkyMiA8IF9sZW4yMjsgX2tleTIyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjJdID0gYXJndW1lbnRzW19rZXkyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRnZXMuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZWxlbWVudFJlYWRPbmx5OiBmdW5jdGlvbiBlbGVtZW50UmVhZE9ubHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIzKSwgX2tleTIzID0gMDsgX2tleTIzIDwgX2xlbjIzOyBfa2V5MjMrKykge1xuICAgICAgICBhcmdzW19rZXkyM10gPSBhcmd1bWVudHNbX2tleTIzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50UmVhZE9ubHkuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI0KSwgX2tleTI0ID0gMDsgX2tleTI0IDwgX2xlbjI0OyBfa2V5MjQrKykge1xuICAgICAgICBhcmdzW19rZXkyNF0gPSBhcmd1bWVudHNbX2tleTI0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmQuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNSksIF9rZXkyNSA9IDA7IF9rZXkyNSA8IF9sZW4yNTsgX2tleTI1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjVdID0gYXJndW1lbnRzW19rZXkyNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3QuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNiksIF9rZXkyNiA9IDA7IF9rZXkyNiA8IF9sZW4yNjsgX2tleTI2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjZdID0gYXJndW1lbnRzW19rZXkyNl07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZ2V0TWFya3M6IGZ1bmN0aW9uIGdldE1hcmtzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjcpLCBfa2V5MjcgPSAwOyBfa2V5MjcgPCBfbGVuMjc7IF9rZXkyNysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI3XSA9IGFyZ3VtZW50c1tfa2V5MjddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmtzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGhhc0Jsb2NrczogZnVuY3Rpb24gaGFzQmxvY2tzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOCksIF9rZXkyOCA9IDA7IF9rZXkyOCA8IF9sZW4yODsgX2tleTI4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjhdID0gYXJndW1lbnRzW19rZXkyOF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzQmxvY2tzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGhhc0lubGluZXM6IGZ1bmN0aW9uIGhhc0lubGluZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI5KSwgX2tleTI5ID0gMDsgX2tleTI5IDwgX2xlbjI5OyBfa2V5MjkrKykge1xuICAgICAgICBhcmdzW19rZXkyOV0gPSBhcmd1bWVudHNbX2tleTI5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNJbmxpbmVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGhhc1BhdGg6IGZ1bmN0aW9uIGhhc1BhdGgkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMwKSwgX2tleTMwID0gMDsgX2tleTMwIDwgX2xlbjMwOyBfa2V5MzArKykge1xuICAgICAgICBhcmdzW19rZXkzMF0gPSBhcmd1bWVudHNbX2tleTMwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNQYXRoLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGhhc1RleHRzOiBmdW5jdGlvbiBoYXNUZXh0cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzEpLCBfa2V5MzEgPSAwOyBfa2V5MzEgPCBfbGVuMzE7IF9rZXkzMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMxXSA9IGFyZ3VtZW50c1tfa2V5MzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1RleHRzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGluc2VydE5vZGVzOiBmdW5jdGlvbiBpbnNlcnROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzIpLCBfa2V5MzIgPSAwOyBfa2V5MzIgPCBfbGVuMzI7IF9rZXkzMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMyXSA9IGFyZ3VtZW50c1tfa2V5MzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydE5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGlzQmxvY2s6IGZ1bmN0aW9uIGlzQmxvY2skMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMzKSwgX2tleTMzID0gMDsgX2tleTMzIDwgX2xlbjMzOyBfa2V5MzMrKykge1xuICAgICAgICBhcmdzW19rZXkzM10gPSBhcmd1bWVudHNbX2tleTMzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Jsb2NrLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNCksIF9rZXkzNCA9IDA7IF9rZXkzNCA8IF9sZW4zNDsgX2tleTM0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzRdID0gYXJndW1lbnRzW19rZXkzNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFZGdlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM1KSwgX2tleTM1ID0gMDsgX2tleTM1IDwgX2xlbjM1OyBfa2V5MzUrKykge1xuICAgICAgICBhcmdzW19rZXkzNV0gPSBhcmd1bWVudHNbX2tleTM1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VtcHR5LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGlzRW5kOiBmdW5jdGlvbiBpc0VuZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzYpLCBfa2V5MzYgPSAwOyBfa2V5MzYgPCBfbGVuMzY7IF9rZXkzNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM2XSA9IGFyZ3VtZW50c1tfa2V5MzZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRW5kLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGlzTm9ybWFsaXppbmc6IGZ1bmN0aW9uIGlzTm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM3KSwgX2tleTM3ID0gMDsgX2tleTM3IDwgX2xlbjM3OyBfa2V5MzcrKykge1xuICAgICAgICBhcmdzW19rZXkzN10gPSBhcmd1bWVudHNbX2tleTM3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc05vcm1hbGl6aW5nLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGlzU3RhcnQ6IGZ1bmN0aW9uIGlzU3RhcnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM4KSwgX2tleTM4ID0gMDsgX2tleTM4IDwgX2xlbjM4OyBfa2V5MzgrKykge1xuICAgICAgICBhcmdzW19rZXkzOF0gPSBhcmd1bWVudHNbX2tleTM4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0YXJ0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM5KSwgX2tleTM5ID0gMDsgX2tleTM5IDwgX2xlbjM5OyBfa2V5MzkrKykge1xuICAgICAgICBhcmdzW19rZXkzOV0gPSBhcmd1bWVudHNbX2tleTM5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGxlYWY6IGZ1bmN0aW9uIGxlYWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQwKSwgX2tleTQwID0gMDsgX2tleTQwIDwgX2xlbjQwOyBfa2V5NDArKykge1xuICAgICAgICBhcmdzW19rZXk0MF0gPSBhcmd1bWVudHNbX2tleTQwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWFmLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MSksIF9rZXk0MSA9IDA7IF9rZXk0MSA8IF9sZW40MTsgX2tleTQxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDFdID0gYXJndW1lbnRzW19rZXk0MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWxzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGxpZnROb2RlczogZnVuY3Rpb24gbGlmdE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MiksIF9rZXk0MiA9IDA7IF9rZXk0MiA8IF9sZW40MjsgX2tleTQyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDJdID0gYXJndW1lbnRzW19rZXk0Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlmdE5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG1lcmdlTm9kZXM6IGZ1bmN0aW9uIG1lcmdlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQzKSwgX2tleTQzID0gMDsgX2tleTQzIDwgX2xlbjQzOyBfa2V5NDMrKykge1xuICAgICAgICBhcmdzW19rZXk0M10gPSBhcmd1bWVudHNbX2tleTQzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZU5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ0KSwgX2tleTQ0ID0gMDsgX2tleTQ0IDwgX2xlbjQ0OyBfa2V5NDQrKykge1xuICAgICAgICBhcmdzW19rZXk0NF0gPSBhcmd1bWVudHNbX2tleTQ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3ZlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG1vdmVOb2RlczogZnVuY3Rpb24gbW92ZU5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NSksIF9rZXk0NSA9IDA7IF9rZXk0NSA8IF9sZW40NTsgX2tleTQ1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDVdID0gYXJndW1lbnRzW19rZXk0NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbW92ZU5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ2KSwgX2tleTQ2ID0gMDsgX2tleTQ2IDwgX2xlbjQ2OyBfa2V5NDYrKykge1xuICAgICAgICBhcmdzW19rZXk0Nl0gPSBhcmd1bWVudHNbX2tleTQ2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG5vZGU6IGZ1bmN0aW9uIG5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ3KSwgX2tleTQ3ID0gMDsgX2tleTQ3IDwgX2xlbjQ3OyBfa2V5NDcrKykge1xuICAgICAgICBhcmdzW19rZXk0N10gPSBhcmd1bWVudHNbX2tleTQ3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG5vZGVzOiBmdW5jdGlvbiBub2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDgpLCBfa2V5NDggPSAwOyBfa2V5NDggPCBfbGVuNDg7IF9rZXk0OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ4XSA9IGFyZ3VtZW50c1tfa2V5NDhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40OSksIF9rZXk0OSA9IDA7IF9rZXk0OSA8IF9sZW40OTsgX2tleTQ5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDldID0gYXJndW1lbnRzW19rZXk0OV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MCksIF9rZXk1MCA9IDA7IF9rZXk1MCA8IF9sZW41MDsgX2tleTUwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTBdID0gYXJndW1lbnRzW19rZXk1MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUxKSwgX2tleTUxID0gMDsgX2tleTUxIDwgX2xlbjUxOyBfa2V5NTErKykge1xuICAgICAgICBhcmdzW19rZXk1MV0gPSBhcmd1bWVudHNbX2tleTUxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBhdGhSZWY6IGZ1bmN0aW9uIHBhdGhSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUyKSwgX2tleTUyID0gMDsgX2tleTUyIDwgX2xlbjUyOyBfa2V5NTIrKykge1xuICAgICAgICBhcmdzW19rZXk1Ml0gPSBhcmd1bWVudHNbX2tleTUyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoUmVmLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBhdGhSZWZzOiBmdW5jdGlvbiBwYXRoUmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTMpLCBfa2V5NTMgPSAwOyBfa2V5NTMgPCBfbGVuNTM7IF9rZXk1MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUzXSA9IGFyZ3VtZW50c1tfa2V5NTNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhSZWZzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbiBwb2ludCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTQpLCBfa2V5NTQgPSAwOyBfa2V5NTQgPCBfbGVuNTQ7IF9rZXk1NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU0XSA9IGFyZ3VtZW50c1tfa2V5NTRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBvaW50UmVmOiBmdW5jdGlvbiBwb2ludFJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTUpLCBfa2V5NTUgPSAwOyBfa2V5NTUgPCBfbGVuNTU7IF9rZXk1NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU1XSA9IGFyZ3VtZW50c1tfa2V5NTVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50UmVmLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBvaW50UmVmczogZnVuY3Rpb24gcG9pbnRSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NiksIF9rZXk1NiA9IDA7IF9rZXk1NiA8IF9sZW41NjsgX2tleTU2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTZdID0gYXJndW1lbnRzW19rZXk1Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnRSZWZzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uczogZnVuY3Rpb24gcG9zaXRpb25zJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NyksIF9rZXk1NyA9IDA7IF9rZXk1NyA8IF9sZW41NzsgX2tleTU3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTddID0gYXJndW1lbnRzW19rZXk1N107XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zaXRpb25zLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTgpLCBfa2V5NTggPSAwOyBfa2V5NTggPCBfbGVuNTg7IF9rZXk1OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU4XSA9IGFyZ3VtZW50c1tfa2V5NThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHJhbmdlOiBmdW5jdGlvbiByYW5nZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTkpLCBfa2V5NTkgPSAwOyBfa2V5NTkgPCBfbGVuNTk7IF9rZXk1OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU5XSA9IGFyZ3VtZW50c1tfa2V5NTldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHJhbmdlUmVmOiBmdW5jdGlvbiByYW5nZVJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjApLCBfa2V5NjAgPSAwOyBfa2V5NjAgPCBfbGVuNjA7IF9rZXk2MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYwXSA9IGFyZ3VtZW50c1tfa2V5NjBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlUmVmLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHJhbmdlUmVmczogZnVuY3Rpb24gcmFuZ2VSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MSksIF9rZXk2MSA9IDA7IF9rZXk2MSA8IF9sZW42MTsgX2tleTYxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjFdID0gYXJndW1lbnRzW19rZXk2MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VSZWZzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHJlbW92ZU5vZGVzOiBmdW5jdGlvbiByZW1vdmVOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjIpLCBfa2V5NjIgPSAwOyBfa2V5NjIgPCBfbGVuNjI7IF9rZXk2MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYyXSA9IGFyZ3VtZW50c1tfa2V5NjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZU5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MyksIF9rZXk2MyA9IDA7IF9rZXk2MyA8IF9sZW42MzsgX2tleTYzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjNdID0gYXJndW1lbnRzW19rZXk2M107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNldE5vZGVzOiBmdW5jdGlvbiBzZXROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjQpLCBfa2V5NjQgPSAwOyBfa2V5NjQgPCBfbGVuNjQ7IF9rZXk2NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY0XSA9IGFyZ3VtZW50c1tfa2V5NjRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldE5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNldE5vcm1hbGl6aW5nOiBmdW5jdGlvbiBzZXROb3JtYWxpemluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjUpLCBfa2V5NjUgPSAwOyBfa2V5NjUgPCBfbGVuNjU7IF9rZXk2NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY1XSA9IGFyZ3VtZW50c1tfa2V5NjVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldE5vcm1hbGl6aW5nLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNldFBvaW50OiBmdW5jdGlvbiBzZXRQb2ludCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjYpLCBfa2V5NjYgPSAwOyBfa2V5NjYgPCBfbGVuNjY7IF9rZXk2NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY2XSA9IGFyZ3VtZW50c1tfa2V5NjZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFBvaW50LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NyksIF9rZXk2NyA9IDA7IF9rZXk2NyA8IF9sZW42NzsgX2tleTY3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjddID0gYXJndW1lbnRzW19rZXk2N107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0U2VsZWN0aW9uLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNwbGl0Tm9kZXM6IGZ1bmN0aW9uIHNwbGl0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY4KSwgX2tleTY4ID0gMDsgX2tleTY4IDwgX2xlbjY4OyBfa2V5NjgrKykge1xuICAgICAgICBhcmdzW19rZXk2OF0gPSBhcmd1bWVudHNbX2tleTY4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGxpdE5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjkpLCBfa2V5NjkgPSAwOyBfa2V5NjkgPCBfbGVuNjk7IF9rZXk2OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY5XSA9IGFyZ3VtZW50c1tfa2V5NjldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MCksIF9rZXk3MCA9IDA7IF9rZXk3MCA8IF9sZW43MDsgX2tleTcwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzBdID0gYXJndW1lbnRzW19rZXk3MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHVuaGFuZ1JhbmdlOiBmdW5jdGlvbiB1bmhhbmdSYW5nZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzEpLCBfa2V5NzEgPSAwOyBfa2V5NzEgPCBfbGVuNzE7IF9rZXk3MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcxXSA9IGFyZ3VtZW50c1tfa2V5NzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuaGFuZ1JhbmdlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHVuc2V0Tm9kZXM6IGZ1bmN0aW9uIHVuc2V0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcyKSwgX2tleTcyID0gMDsgX2tleTcyIDwgX2xlbjcyOyBfa2V5NzIrKykge1xuICAgICAgICBhcmdzW19rZXk3Ml0gPSBhcmd1bWVudHNbX2tleTcyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bnNldE5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHVud3JhcE5vZGVzOiBmdW5jdGlvbiB1bndyYXBOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjczID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzMpLCBfa2V5NzMgPSAwOyBfa2V5NzMgPCBfbGVuNzM7IF9rZXk3MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTczXSA9IGFyZ3VtZW50c1tfa2V5NzNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVud3JhcE5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIFwidm9pZFwiOiBmdW5jdGlvbiBfdm9pZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc0KSwgX2tleTc0ID0gMDsgX2tleTc0IDwgX2xlbjc0OyBfa2V5NzQrKykge1xuICAgICAgICBhcmdzW19rZXk3NF0gPSBhcmd1bWVudHNbX2tleTc0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRWb2lkLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHdpdGhvdXROb3JtYWxpemluZzogZnVuY3Rpb24gd2l0aG91dE5vcm1hbGl6aW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NSksIF9rZXk3NSA9IDA7IF9rZXk3NSA8IF9sZW43NTsgX2tleTc1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzVdID0gYXJndW1lbnRzW19rZXk3NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gd2l0aG91dE5vcm1hbGl6aW5nLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHdyYXBOb2RlczogZnVuY3Rpb24gd3JhcE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NiksIF9rZXk3NiA9IDA7IF9rZXk3NiA8IF9sZW43NjsgX2tleTc2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzZdID0gYXJndW1lbnRzW19rZXk3Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcE5vZGVzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZTogZnVuY3Rpb24gc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NyksIF9rZXk3NyA9IDA7IF9rZXk3NyA8IF9sZW43NzsgX2tleTc3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzddID0gYXJndW1lbnRzW19rZXk3N107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5leHBvcnRzLkVkaXRvciA9IEVkaXRvcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkxvY2F0aW9uID0gTG9jYXRpb247XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuZXhwb3J0cy5PcGVyYXRpb24gPSBPcGVyYXRpb247XG5leHBvcnRzLlBhdGggPSBQYXRoO1xuZXhwb3J0cy5QYXRoUmVmID0gUGF0aFJlZjtcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbmV4cG9ydHMuUG9pbnRSZWYgPSBQb2ludFJlZjtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuUmFuZ2VSZWYgPSBSYW5nZVJlZjtcbmV4cG9ydHMuU2NydWJiZXIgPSBTY3J1YmJlcjtcbmV4cG9ydHMuU3BhbiA9IFNwYW47XG5leHBvcnRzLlRleHQgPSBUZXh0O1xuZXhwb3J0cy5UcmFuc2Zvcm1zID0gVHJhbnNmb3JtcztcbmV4cG9ydHMuYWJvdmUgPSBhYm92ZTtcbmV4cG9ydHMuYWRkTWFyayA9IGFkZE1hcms7XG5leHBvcnRzLmFmdGVyID0gYWZ0ZXI7XG5leHBvcnRzLmFwcGx5ID0gYXBwbHk7XG5leHBvcnRzLmJlZm9yZSA9IGJlZm9yZTtcbmV4cG9ydHMuY29sbGFwc2UgPSBjb2xsYXBzZTtcbmV4cG9ydHMuY3JlYXRlRWRpdG9yID0gY3JlYXRlRWRpdG9yO1xuZXhwb3J0cy5kZWxldGVCYWNrd2FyZCA9IGRlbGV0ZUJhY2t3YXJkO1xuZXhwb3J0cy5kZWxldGVGb3J3YXJkID0gZGVsZXRlRm9yd2FyZDtcbmV4cG9ydHMuZGVsZXRlRnJhZ21lbnQgPSBkZWxldGVGcmFnbWVudDtcbmV4cG9ydHMuZGVsZXRlVGV4dCA9IGRlbGV0ZVRleHQ7XG5leHBvcnRzLmRlc2VsZWN0ID0gZGVzZWxlY3Q7XG5leHBvcnRzLmVkZ2VzID0gZWRnZXM7XG5leHBvcnRzLmVsZW1lbnRSZWFkT25seSA9IGVsZW1lbnRSZWFkT25seTtcbmV4cG9ydHMuZW5kID0gZW5kO1xuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xuZXhwb3J0cy5mcmFnbWVudCA9IGZyYWdtZW50O1xuZXhwb3J0cy5nZXREaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocztcbmV4cG9ydHMuZ2V0RnJhZ21lbnQgPSBnZXRGcmFnbWVudDtcbmV4cG9ydHMuZ2V0Vm9pZCA9IGdldFZvaWQ7XG5leHBvcnRzLmhhc0Jsb2NrcyA9IGhhc0Jsb2NrcztcbmV4cG9ydHMuaGFzSW5saW5lcyA9IGhhc0lubGluZXM7XG5leHBvcnRzLmhhc1BhdGggPSBoYXNQYXRoO1xuZXhwb3J0cy5oYXNUZXh0cyA9IGhhc1RleHRzO1xuZXhwb3J0cy5pbnNlcnRCcmVhayA9IGluc2VydEJyZWFrO1xuZXhwb3J0cy5pbnNlcnRGcmFnbWVudCA9IGluc2VydEZyYWdtZW50O1xuZXhwb3J0cy5pbnNlcnROb2RlID0gaW5zZXJ0Tm9kZTtcbmV4cG9ydHMuaW5zZXJ0Tm9kZXMgPSBpbnNlcnROb2RlcztcbmV4cG9ydHMuaW5zZXJ0U29mdEJyZWFrID0gaW5zZXJ0U29mdEJyZWFrO1xuZXhwb3J0cy5pbnNlcnRUZXh0ID0gaW5zZXJ0VGV4dDtcbmV4cG9ydHMuaXNCbG9jayA9IGlzQmxvY2s7XG5leHBvcnRzLmlzRWRnZSA9IGlzRWRnZTtcbmV4cG9ydHMuaXNFZGl0b3IgPSBpc0VkaXRvcjtcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5leHBvcnRzLmlzRW5kID0gaXNFbmQ7XG5leHBvcnRzLmlzTm9ybWFsaXppbmcgPSBpc05vcm1hbGl6aW5nO1xuZXhwb3J0cy5pc1N0YXJ0ID0gaXNTdGFydDtcbmV4cG9ydHMubGFzdCA9IGxhc3Q7XG5leHBvcnRzLmxlYWYgPSBsZWFmO1xuZXhwb3J0cy5sZXZlbHMgPSBsZXZlbHM7XG5leHBvcnRzLmxpZnROb2RlcyA9IGxpZnROb2RlcztcbmV4cG9ydHMubWFya3MgPSBtYXJrcztcbmV4cG9ydHMubWVyZ2VOb2RlcyA9IG1lcmdlTm9kZXM7XG5leHBvcnRzLm1vdmUgPSBtb3ZlO1xuZXhwb3J0cy5tb3ZlTm9kZXMgPSBtb3ZlTm9kZXM7XG5leHBvcnRzLm5leHQgPSBuZXh0O1xuZXhwb3J0cy5ub2RlID0gbm9kZTtcbmV4cG9ydHMubm9kZXMgPSBub2RlcztcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5ub3JtYWxpemVOb2RlID0gbm9ybWFsaXplTm9kZTtcbmV4cG9ydHMucGFyZW50ID0gcGFyZW50O1xuZXhwb3J0cy5wYXRoID0gcGF0aDtcbmV4cG9ydHMucGF0aFJlZiA9IHBhdGhSZWY7XG5leHBvcnRzLnBhdGhSZWZzID0gcGF0aFJlZnM7XG5leHBvcnRzLnBvaW50ID0gcG9pbnQ7XG5leHBvcnRzLnBvaW50UmVmID0gcG9pbnRSZWY7XG5leHBvcnRzLnBvaW50UmVmcyA9IHBvaW50UmVmcztcbmV4cG9ydHMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuZXhwb3J0cy5wcmV2aW91cyA9IHByZXZpb3VzO1xuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuZXhwb3J0cy5yYW5nZVJlZiA9IHJhbmdlUmVmO1xuZXhwb3J0cy5yYW5nZVJlZnMgPSByYW5nZVJlZnM7XG5leHBvcnRzLnJlbW92ZU1hcmsgPSByZW1vdmVNYXJrO1xuZXhwb3J0cy5yZW1vdmVOb2RlcyA9IHJlbW92ZU5vZGVzO1xuZXhwb3J0cy5zZWxlY3QgPSBzZWxlY3Q7XG5leHBvcnRzLnNldE5vZGVzID0gc2V0Tm9kZXM7XG5leHBvcnRzLnNldE5vcm1hbGl6aW5nID0gc2V0Tm9ybWFsaXppbmc7XG5leHBvcnRzLnNldFBvaW50ID0gc2V0UG9pbnQ7XG5leHBvcnRzLnNldFNlbGVjdGlvbiA9IHNldFNlbGVjdGlvbjtcbmV4cG9ydHMuc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlID0gc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlO1xuZXhwb3J0cy5zaG91bGROb3JtYWxpemUgPSBzaG91bGROb3JtYWxpemU7XG5leHBvcnRzLnNwbGl0Tm9kZXMgPSBzcGxpdE5vZGVzO1xuZXhwb3J0cy5zdGFydCA9IHN0YXJ0O1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5leHBvcnRzLnVuaGFuZ1JhbmdlID0gdW5oYW5nUmFuZ2U7XG5leHBvcnRzLnVuc2V0Tm9kZXMgPSB1bnNldE5vZGVzO1xuZXhwb3J0cy51bndyYXBOb2RlcyA9IHVud3JhcE5vZGVzO1xuZXhwb3J0cy53aXRob3V0Tm9ybWFsaXppbmcgPSB3aXRob3V0Tm9ybWFsaXppbmc7XG5leHBvcnRzLndyYXBOb2RlcyA9IHdyYXBOb2Rlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js":
/*!*************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"../../../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js\");\nvar immer = __webpack_require__(/*! immer */ \"../../../../node_modules/.pnpm/immer@10.1.1/node_modules/immer/dist/cjs/index.js\");\n\n// eslint-disable-next-line no-redeclare\nvar PathRef = {\n  transform: function transform(ref, op) {\n    var current = ref.current,\n      affinity = ref.affinity;\n    if (current == null) {\n      return;\n    }\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar PointRef = {\n  transform: function transform(ref, op) {\n    var current = ref.current,\n      affinity = ref.affinity;\n    if (current == null) {\n      return;\n    }\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar RangeRef = {\n  transform: function transform(ref, op) {\n    var current = ref.current,\n      affinity = ref.affinity;\n    if (current == null) {\n      return;\n    }\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar arrayLikeToArray = createCommonjsModule(function (module) {\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayLikeToArray);\n\nvar arrayWithoutHoles = createCommonjsModule(function (module) {\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithoutHoles);\n\nvar iterableToArray = createCommonjsModule(function (module) {\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArray);\n\nvar unsupportedIterableToArray = createCommonjsModule(function (module) {\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(unsupportedIterableToArray);\n\nvar nonIterableSpread = createCommonjsModule(function (module) {\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableSpread);\n\nvar toConsumableArray = createCommonjsModule(function (module) {\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var paths = Path.levels(path, options);\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n    return paths;\n  },\n  common: function common(path, another) {\n    var common = [];\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n      if (av !== bv) {\n        break;\n      }\n      common.push(av);\n    }\n    return common;\n  },\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n    return 0;\n  },\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n  hasPrevious: function hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse2 = options.reverse,\n      reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n    var list = [];\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n    if (reverse) {\n      list.reverse();\n    }\n    return list;\n  },\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n  operationCanTransformPath: function operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n      default:\n        return false;\n    }\n  },\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n    return path.slice(0, -1);\n  },\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n    var last = path[path.length - 1];\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n    return path.slice(0, -1).concat(last - 1);\n  },\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n    return path.slice(ancestor.length);\n  },\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null;\n    // PERF: use destructing instead of immer\n    var p = _toConsumableArray(path);\n    var _options$affinity = options.affinity,\n      affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    // PERF: Exit early if the operation is guaranteed not to have an effect.\n    if (path.length === 0) {\n      return p;\n    }\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var op = operation.path;\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n          break;\n        }\n      case 'remove_node':\n        {\n          var _op = operation.path;\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n          break;\n        }\n      case 'merge_node':\n        {\n          var _op2 = operation.path,\n            position = operation.position;\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n          break;\n        }\n      case 'split_node':\n        {\n          var _op3 = operation.path,\n            _position = operation.position;\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n          break;\n        }\n      case 'move_node':\n        {\n          var _op4 = operation.path,\n            onp = operation.newPath;\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n            p[_op4.length - 1] -= 1;\n          }\n          break;\n        }\n    }\n    return p;\n  }\n};\n\nvar _typeof_1 = createCommonjsModule(function (module) {\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(_typeof_1);\n\nvar toPrimitive = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPrimitive);\n\nvar toPropertyKey = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\n\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPropertyKey);\n\nvar defineProperty = createCommonjsModule(function (module) {\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _defineProperty = unwrapExports(defineProperty);\n\nvar arrayWithHoles = createCommonjsModule(function (module) {\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithHoles);\n\nvar iterableToArrayLimit = createCommonjsModule(function (module) {\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArrayLimit);\n\nvar nonIterableRest = createCommonjsModule(function (module) {\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableRest);\n\nvar slicedToArray = createCommonjsModule(function (module) {\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nfunction ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelper$m(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$m(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$m(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$m(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$m(o, minLen); }\nfunction _arrayLikeToArray$m(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar applyToDraft = function applyToDraft(editor, selection, op) {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var path = op.path,\n          node = op.node;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n        parent.children.splice(index, 0, node);\n        if (selection) {\n          var _iterator = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                point = _step$value[0],\n                key = _step$value[1];\n              selection[key] = Point.transform(point, op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        break;\n      }\n    case 'insert_text':\n      {\n        var _path = op.path,\n          offset = op.offset,\n          text = op.text;\n        if (text.length === 0) break;\n        var _node = Node.leaf(editor, _path);\n        var before = _node.text.slice(0, offset);\n        var after = _node.text.slice(offset);\n        _node.text = before + text + after;\n        if (selection) {\n          var _iterator2 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                _point = _step2$value[0],\n                _key = _step2$value[1];\n              selection[_key] = Point.transform(_point, op);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        break;\n      }\n    case 'merge_node':\n      {\n        var _path2 = op.path;\n        var _node2 = Node.get(editor, _path2);\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n        var _parent = Node.parent(editor, _path2);\n        var _index = _path2[_path2.length - 1];\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          var _prev$children;\n          (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n        _parent.children.splice(_index, 1);\n        if (selection) {\n          var _iterator3 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                _point2 = _step3$value[0],\n                _key2 = _step3$value[1];\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n        break;\n      }\n    case 'move_node':\n      {\n        var _path3 = op.path,\n          newPath = op.newPath;\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n        var _node3 = Node.get(editor, _path3);\n        var _parent2 = Node.parent(editor, _path3);\n        var _index2 = _path3[_path3.length - 1];\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        _parent2.children.splice(_index2, 1);\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n        if (selection) {\n          var _iterator4 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _step4$value = _slicedToArray(_step4.value, 2),\n                _point3 = _step4$value[0],\n                _key3 = _step4$value[1];\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n        break;\n      }\n    case 'remove_node':\n      {\n        var _path4 = op.path;\n        var _index3 = _path4[_path4.length - 1];\n        var _parent3 = Node.parent(editor, _path4);\n        _parent3.children.splice(_index3, 1);\n        // Transform all the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          var _iterator5 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _step5$value = _slicedToArray(_step5.value, 2),\n                _point4 = _step5$value[0],\n                _key4 = _step5$value[1];\n              var result = Point.transform(_point4, op);\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n                var next = void 0;\n                var _iterator6 = _createForOfIteratorHelper$m(Node.texts(editor)),\n                  _step6;\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var _step6$value = _slicedToArray(_step6.value, 2),\n                      n = _step6$value[0],\n                      p = _step6$value[1];\n                    if (Path.compare(p, _path4) === -1) {\n                      _prev = [n, p];\n                    } else {\n                      next = [n, p];\n                      break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n                var preferNext = false;\n                if (_prev && next) {\n                  if (Path.equals(next[1], _path4)) {\n                    preferNext = !Path.hasPrevious(next[1]);\n                  } else {\n                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                  }\n                }\n                if (_prev && !preferNext) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n        break;\n      }\n    case 'remove_text':\n      {\n        var _path5 = op.path,\n          _offset = op.offset,\n          _text = op.text;\n        if (_text.length === 0) break;\n        var _node4 = Node.leaf(editor, _path5);\n        var _before = _node4.text.slice(0, _offset);\n        var _after = _node4.text.slice(_offset + _text.length);\n        _node4.text = _before + _after;\n        if (selection) {\n          var _iterator7 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _step7$value = _slicedToArray(_step7.value, 2),\n                _point5 = _step7$value[0],\n                _key5 = _step7$value[1];\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n        break;\n      }\n    case 'set_node':\n      {\n        var _path6 = op.path,\n          properties = op.properties,\n          newProperties = op.newProperties;\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n        var _node5 = Node.get(editor, _path6);\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n          var value = newProperties[_key6];\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        }\n        // properties that were previously defined, but are now missing, must be deleted\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n        break;\n      }\n    case 'set_selection':\n      {\n        var _newProperties = op.newProperties;\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n            selection = _objectSpread$e({}, _newProperties);\n          }\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n        break;\n      }\n    case 'split_node':\n      {\n        var _path7 = op.path,\n          position = op.position,\n          _properties = op.properties;\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n        var _node6 = Node.get(editor, _path7);\n        var _parent4 = Node.parent(editor, _path7);\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n          var _after2 = _node6.text.slice(position);\n          _node6.text = _before2;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n          var _after3 = _node6.children.slice(position);\n          _node6.children = _before3;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            children: _after3\n          });\n        }\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n        if (selection) {\n          var _iterator8 = _createForOfIteratorHelper$m(Range.points(selection)),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _step8$value = _slicedToArray(_step8.value, 2),\n                _point6 = _step8$value[0],\n                _key9 = _step8$value[1];\n              selection[_key9] = Point.transform(_point6, op);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n        break;\n      }\n  }\n  return selection;\n};\n// eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n  transform: function transform(editor, op) {\n    editor.children = immer.createDraft(editor.children);\n    var selection = editor.selection && immer.createDraft(editor.selection);\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = immer.finishDraft(editor.children);\n      if (selection) {\n        editor.selection = immer.isDraft(selection) ? immer.finishDraft(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n  insertNodes: function insertNodes(editor, nodes, options) {\n    editor.insertNodes(nodes, options);\n  },\n  liftNodes: function liftNodes(editor, options) {\n    editor.liftNodes(options);\n  },\n  mergeNodes: function mergeNodes(editor, options) {\n    editor.mergeNodes(options);\n  },\n  moveNodes: function moveNodes(editor, options) {\n    editor.moveNodes(options);\n  },\n  removeNodes: function removeNodes(editor, options) {\n    editor.removeNodes(options);\n  },\n  setNodes: function setNodes(editor, props, options) {\n    editor.setNodes(props, options);\n  },\n  splitNodes: function splitNodes(editor, options) {\n    editor.splitNodes(options);\n  },\n  unsetNodes: function unsetNodes(editor, props, options) {\n    editor.unsetNodes(props, options);\n  },\n  unwrapNodes: function unwrapNodes(editor, options) {\n    editor.unwrapNodes(options);\n  },\n  wrapNodes: function wrapNodes(editor, element, options) {\n    editor.wrapNodes(element, options);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n  collapse: function collapse(editor, options) {\n    editor.collapse(options);\n  },\n  deselect: function deselect(editor) {\n    editor.deselect();\n  },\n  move: function move(editor, options) {\n    editor.move(options);\n  },\n  select: function select(editor, target) {\n    editor.select(target);\n  },\n  setPoint: function setPoint(editor, props, options) {\n    editor.setPoint(props, options);\n  },\n  setSelection: function setSelection(editor, props) {\n    editor.setSelection(props);\n  }\n};\n\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */\nvar isDeepEqual = function isDeepEqual(node, another) {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n    if (isPlainObject.isPlainObject(a) && isPlainObject.isPlainObject(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n  return true;\n};\n\nvar objectWithoutPropertiesLoose = createCommonjsModule(function (module) {\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(objectWithoutPropertiesLoose);\n\nvar objectWithoutProperties = createCommonjsModule(function (module) {\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\nvar _excluded$4 = [\"anchor\", \"focus\"];\nfunction ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Range = {\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var anchor = range.anchor,\n      focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n  end: function end(range) {\n    var _Range$edges = Range.edges(range),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      end = _Range$edges2[1];\n    return end;\n  },\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n  surrounds: function surrounds(range, target) {\n    var intersectionRange = Range.intersection(range, target);\n    if (!intersectionRange) {\n      return false;\n    }\n    return Range.equals(intersectionRange, target);\n  },\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n      var _Range$edges3 = Range.edges(range),\n        _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n        rs = _Range$edges4[0],\n        re = _Range$edges4[1];\n      var _Range$edges5 = Range.edges(target),\n        _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n        ts = _Range$edges6[0],\n        te = _Range$edges6[1];\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n    var _Range$edges7 = Range.edges(range),\n      _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n      start = _Range$edges8[0],\n      end = _Range$edges8[1];\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n    return isAfterStart && isBeforeEnd;\n  },\n  intersection: function intersection(range, another) {\n    range.anchor;\n      range.focus;\n      var rest = _objectWithoutProperties(range, _excluded$4);\n    var _Range$edges9 = Range.edges(range),\n      _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n      s1 = _Range$edges10[0],\n      e1 = _Range$edges10[1];\n    var _Range$edges11 = Range.edges(another),\n      _Range$edges12 = _slicedToArray(_Range$edges11, 2),\n      s2 = _Range$edges12[0],\n      e2 = _Range$edges12[1];\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$d({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n  isRange: function isRange(value) {\n    return isPlainObject.isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n  points: function* points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n  start: function start(range) {\n    var _Range$edges13 = Range.edges(range),\n      _Range$edges14 = _slicedToArray(_Range$edges13, 1),\n      start = _Range$edges14[0];\n    return start;\n  },\n  transform: function transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(range, function (r) {\n      if (r === null) {\n        return null;\n      }\n      var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'inward' : _options$affinity;\n      var affinityAnchor;\n      var affinityFocus;\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n      if (!anchor || !focus) {\n        return null;\n      }\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\n\n/**\n * Shared the function with isElementType utility\n */\nvar isElement = function isElement(value) {\n  return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n};\n// eslint-disable-next-line no-redeclare\nvar Element = {\n  isAncestor: function isAncestor(value) {\n    return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children);\n  },\n  isElement: isElement,\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Element.isElement(val);\n    });\n  },\n  isElementProps: function isElementProps(props) {\n    return props.children !== undefined;\n  },\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nvar _excluded$3 = [\"children\"],\n  _excluded2$3 = [\"text\"];\nfunction _createForOfIteratorHelper$l(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$l(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$l(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$l(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$l(o, minLen); }\nfunction _arrayLikeToArray$l(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar IS_NODE_LIST_CACHE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Node = {\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  ancestors: function ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var _iterator = _createForOfIteratorHelper$l(Path.ancestors(path, options)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          var n = Node.ancestor(root, p);\n          var entry = [n, p];\n          yield entry;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }();\n  },\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n    var c = root.children[index];\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n    return c;\n  },\n  children: function children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n      var ancestor = Node.ancestor(root, path);\n      var children = ancestor.children;\n      var index = reverse ? children.length - 1 : 0;\n      while (reverse ? index >= 0 : index < children.length) {\n        var child = Node.child(ancestor, index);\n        var childPath = path.concat(index);\n        yield [child, childPath];\n        index = reverse ? index - 1 : index + 1;\n      }\n    }();\n  },\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  descendants: function descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var _iterator2 = _createForOfIteratorHelper$l(Node.nodes(root, options)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            node = _step2$value[0],\n            path = _step2$value[1];\n          if (path.length !== 0) {\n            // NOTE: we have to coerce here because checking the path's length does\n            // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n            yield [node, path];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }();\n  },\n  elements: function elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var _iterator3 = _createForOfIteratorHelper$l(Node.nodes(root, options)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            node = _step3$value[0],\n            path = _step3$value[1];\n          if (Element.isElement(node)) {\n            yield [node, path];\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }();\n  },\n  extractProps: function extractProps(node) {\n    if (Element.isAncestor(node)) {\n      node.children;\n        var properties = _objectWithoutProperties(node, _excluded$3);\n      return properties;\n    } else {\n      node.text;\n        var _properties = _objectWithoutProperties(node, _excluded2$3);\n      return _properties;\n    }\n  },\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n    return [n, p];\n  },\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n    var newRoot = immer.produce({\n      children: root.children\n    }, function (r) {\n      var _Range$edges = Range.edges(range),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            path = _ref2[1];\n          return !Range.includes(range, path);\n        }\n      });\n      var _iterator4 = _createForOfIteratorHelper$l(nodeEntries),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n            path = _step4$value[1];\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n  get: function get(root, path) {\n    var node = Node.getIf(root, path);\n    if (node === undefined) {\n      throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n    }\n    return node;\n  },\n  getIf: function getIf(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return;\n      }\n      node = node.children[p];\n    }\n    return node;\n  },\n  has: function has(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n      node = node.children[p];\n    }\n    return true;\n  },\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n  isNodeList: function isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n    var isNodeList = value.every(function (val) {\n      return Node.isNode(val);\n    });\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n    return [n, p];\n  },\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  levels: function levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var _iterator5 = _createForOfIteratorHelper$l(Path.levels(path, options)),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var p = _step5.value;\n          var n = Node.get(root, p);\n          yield [n, p];\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }();\n  },\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n  nodes: function nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var pass = options.pass,\n        _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n      var _options$from = options.from,\n        from = _options$from === void 0 ? [] : _options$from,\n        to = options.to;\n      var visited = new Set();\n      var p = [];\n      var n = root;\n      while (true) {\n        if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n          break;\n        }\n        if (!visited.has(n)) {\n          yield [n, p];\n        }\n        // If we're allowed to go downward and we haven't descended yet, do.\n        if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n          visited.add(n);\n          var nextIndex = reverse ? n.children.length - 1 : 0;\n          if (Path.isAncestor(p, from)) {\n            nextIndex = from[p.length];\n          }\n          p = p.concat(nextIndex);\n          n = Node.get(root, p);\n          continue;\n        }\n        // If we're at the root and we can't go down, we're done.\n        if (p.length === 0) {\n          break;\n        }\n        // If we're going forward...\n        if (!reverse) {\n          var newPath = Path.next(p);\n          if (Node.has(root, newPath)) {\n            p = newPath;\n            n = Node.get(root, p);\n            continue;\n          }\n        }\n        // If we're going backward...\n        if (reverse && p[p.length - 1] !== 0) {\n          var _newPath = Path.previous(p);\n          p = _newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n        // Otherwise we're going upward...\n        p = Path.parent(p);\n        n = Node.get(root, p);\n        visited.add(n);\n      }\n    }();\n  },\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n    return p;\n  },\n  string: function string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n  texts: function texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var _iterator6 = _createForOfIteratorHelper$l(Node.nodes(root, options)),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n            node = _step6$value[0],\n            path = _step6$value[1];\n          if (Text.isText(node)) {\n            yield [node, path];\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }();\n  }\n};\n\nfunction ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Operation = {\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n  isOperation: function isOperation(value) {\n    if (!isPlainObject.isPlainObject(value)) {\n      return false;\n    }\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties);\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject.isPlainObject(value.properties);\n      default:\n        return false;\n    }\n  },\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Operation.isOperation(val);\n    });\n  },\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n      case 'insert_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n      case 'merge_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n            path = op.path;\n          // PERF: in this case the move operation is a no-op anyways.\n          if (Path.equals(newPath, path)) {\n            return op;\n          }\n          // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          }\n          // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n      case 'remove_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n      case 'remove_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n      case 'set_node':\n        {\n          var properties = op.properties,\n            newProperties = op.newProperties;\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n            _newProperties = op.newProperties;\n          if (_properties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n      case 'split_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\n\nvar IS_EDITOR_CACHE = new WeakMap();\nvar isEditor = function isEditor(value) {\n  var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n  if (cachedIsEditor !== undefined) {\n    return cachedIsEditor;\n  }\n  if (!isPlainObject.isPlainObject(value)) {\n    return false;\n  }\n  var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isElementReadOnly === 'function' && typeof value.isInline === 'function' && typeof value.isSelectable === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || isPlainObject.isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  IS_EDITOR_CACHE.set(value, isEditor);\n  return isEditor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar Editor = {\n  above: function above(editor, options) {\n    return editor.above(options);\n  },\n  addMark: function addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n  after: function after(editor, at, options) {\n    return editor.after(at, options);\n  },\n  before: function before(editor, at, options) {\n    return editor.before(at, options);\n  },\n  deleteBackward: function deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit = options.unit,\n      unit = _options$unit === void 0 ? 'character' : _options$unit;\n    editor.deleteBackward(unit);\n  },\n  deleteForward: function deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit2 = options.unit,\n      unit = _options$unit2 === void 0 ? 'character' : _options$unit2;\n    editor.deleteForward(unit);\n  },\n  deleteFragment: function deleteFragment(editor, options) {\n    editor.deleteFragment(options);\n  },\n  edges: function edges(editor, at) {\n    return editor.edges(at);\n  },\n  elementReadOnly: function elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return editor.elementReadOnly(options);\n  },\n  end: function end(editor, at) {\n    return editor.end(at);\n  },\n  first: function first(editor, at) {\n    return editor.first(at);\n  },\n  fragment: function fragment(editor, at) {\n    return editor.fragment(at);\n  },\n  hasBlocks: function hasBlocks(editor, element) {\n    return editor.hasBlocks(element);\n  },\n  hasInlines: function hasInlines(editor, element) {\n    return editor.hasInlines(element);\n  },\n  hasPath: function hasPath(editor, path) {\n    return editor.hasPath(path);\n  },\n  hasTexts: function hasTexts(editor, element) {\n    return editor.hasTexts(element);\n  },\n  insertBreak: function insertBreak(editor) {\n    editor.insertBreak();\n  },\n  insertFragment: function insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertNode: function insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n  insertSoftBreak: function insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n  insertText: function insertText(editor, text) {\n    editor.insertText(text);\n  },\n  isBlock: function isBlock(editor, value) {\n    return editor.isBlock(value);\n  },\n  isEdge: function isEdge(editor, point, at) {\n    return editor.isEdge(point, at);\n  },\n  isEditor: function isEditor$1(value) {\n    return isEditor(value);\n  },\n  isElementReadOnly: function isElementReadOnly(editor, element) {\n    return editor.isElementReadOnly(element);\n  },\n  isEmpty: function isEmpty(editor, element) {\n    return editor.isEmpty(element);\n  },\n  isEnd: function isEnd(editor, point, at) {\n    return editor.isEnd(point, at);\n  },\n  isInline: function isInline(editor, value) {\n    return editor.isInline(value);\n  },\n  isNormalizing: function isNormalizing(editor) {\n    return editor.isNormalizing();\n  },\n  isSelectable: function isSelectable(editor, value) {\n    return editor.isSelectable(value);\n  },\n  isStart: function isStart(editor, point, at) {\n    return editor.isStart(point, at);\n  },\n  isVoid: function isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n  last: function last(editor, at) {\n    return editor.last(at);\n  },\n  leaf: function leaf(editor, at, options) {\n    return editor.leaf(at, options);\n  },\n  levels: function levels(editor, options) {\n    return editor.levels(options);\n  },\n  marks: function marks(editor) {\n    return editor.getMarks();\n  },\n  next: function next(editor, options) {\n    return editor.next(options);\n  },\n  node: function node(editor, at, options) {\n    return editor.node(at, options);\n  },\n  nodes: function nodes(editor, options) {\n    return editor.nodes(options);\n  },\n  normalize: function normalize(editor, options) {\n    editor.normalize(options);\n  },\n  parent: function parent(editor, at, options) {\n    return editor.parent(at, options);\n  },\n  path: function path(editor, at, options) {\n    return editor.path(at, options);\n  },\n  pathRef: function pathRef(editor, path, options) {\n    return editor.pathRef(path, options);\n  },\n  pathRefs: function pathRefs(editor) {\n    return editor.pathRefs();\n  },\n  point: function point(editor, at, options) {\n    return editor.point(at, options);\n  },\n  pointRef: function pointRef(editor, point, options) {\n    return editor.pointRef(point, options);\n  },\n  pointRefs: function pointRefs(editor) {\n    return editor.pointRefs();\n  },\n  positions: function positions(editor, options) {\n    return editor.positions(options);\n  },\n  previous: function previous(editor, options) {\n    return editor.previous(options);\n  },\n  range: function range(editor, at, to) {\n    return editor.range(at, to);\n  },\n  rangeRef: function rangeRef(editor, range, options) {\n    return editor.rangeRef(range, options);\n  },\n  rangeRefs: function rangeRefs(editor) {\n    return editor.rangeRefs();\n  },\n  removeMark: function removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n  setNormalizing: function setNormalizing(editor, isNormalizing) {\n    editor.setNormalizing(isNormalizing);\n  },\n  start: function start(editor, at) {\n    return editor.start(at);\n  },\n  string: function string(editor, at, options) {\n    return editor.string(at, options);\n  },\n  unhangRange: function unhangRange(editor, range, options) {\n    return editor.unhangRange(range, options);\n  },\n  \"void\": function _void(editor, options) {\n    return editor[\"void\"](options);\n  },\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    editor.withoutNormalizing(fn);\n  },\n  shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode(editor, prevNode, curNode) {\n    return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar Location = {\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\n// eslint-disable-next-line no-redeclare\nvar Span = {\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\n\nfunction ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Point = {\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n    return result;\n  },\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n  isPoint: function isPoint(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(point, function (p) {\n      if (p === null) {\n        return null;\n      }\n      var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n      var path = p.path,\n        offset = p.offset;\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n            break;\n          }\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n            break;\n          }\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n            break;\n          }\n      }\n    });\n  }\n};\n\nvar _scrubber = undefined;\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */\n// eslint-disable-next-line no-redeclare\nvar Scrubber = {\n  setScrubber: function setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify: function stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\n\nvar _excluded$2 = [\"text\"],\n  _excluded2$2 = [\"anchor\", \"focus\", \"merge\"];\nfunction _createForOfIteratorHelper$k(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$k(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$k(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$k(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$k(o, minLen); }\nfunction _arrayLikeToArray$k(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Text = {\n  equals: function equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$loose = options.loose,\n      loose = _options$loose === void 0 ? false : _options$loose;\n    function omitText(obj) {\n      obj.text;\n        var rest = _objectWithoutProperties(obj, _excluded$2);\n      return rest;\n    }\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n  isText: function isText(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.text === 'string';\n  },\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Text.isText(val);\n    });\n  },\n  isTextProps: function isTextProps(props) {\n    return props.text !== undefined;\n  },\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  decorations: function decorations(node, _decorations) {\n    var leaves = [_objectSpread$a({}, node)];\n    var _iterator = _createForOfIteratorHelper$k(_decorations),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dec = _step.value;\n        var anchor = dec.anchor,\n          focus = dec.focus,\n          mergeDecoration = dec.merge,\n          rest = _objectWithoutProperties(dec, _excluded2$2);\n        var _Range$edges = Range.edges(dec),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n        var next = [];\n        var leafEnd = 0;\n        var decorationStart = start.offset;\n        var decorationEnd = end.offset;\n        var merge = mergeDecoration !== null && mergeDecoration !== void 0 ? mergeDecoration : Object.assign;\n        var _iterator2 = _createForOfIteratorHelper$k(leaves),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var leaf = _step2.value;\n            var length = leaf.text.length;\n            var leafStart = leafEnd;\n            leafEnd += length;\n            // If the range encompasses the entire leaf, add the range.\n            if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n              merge(leaf, rest);\n              next.push(leaf);\n              continue;\n            }\n            // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n            if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n              next.push(leaf);\n              continue;\n            }\n            // Otherwise we need to split the leaf, at the start, end, or both,\n            // and add the range to the middle intersecting section. Do the end\n            // split first since we don't need to update the offset that way.\n            var middle = leaf;\n            var before = void 0;\n            var after = void 0;\n            if (decorationEnd < leafEnd) {\n              var off = decorationEnd - leafStart;\n              after = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(off)\n              });\n              middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(0, off)\n              });\n            }\n            if (decorationStart > leafStart) {\n              var _off = decorationStart - leafStart;\n              before = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(0, _off)\n              });\n              middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                text: middle.text.slice(_off)\n              });\n            }\n            merge(middle, rest);\n            if (before) {\n              next.push(before);\n            }\n            next.push(middle);\n            if (after) {\n              next.push(after);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        leaves = next;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return leaves;\n  }\n};\n\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */\nvar getDefaultInsertLocation = function getDefaultInsertLocation(editor) {\n  if (editor.selection) {\n    return editor.selection;\n  } else if (editor.children.length > 0) {\n    return Editor.end(editor, []);\n  } else {\n    return [0];\n  }\n};\n\nvar matchPath = function matchPath(editor, path) {\n  var _Editor$node = Editor.node(editor, path),\n    _Editor$node2 = _slicedToArray(_Editor$node, 1),\n    node = _Editor$node2[0];\n  return function (n) {\n    return n === node;\n  };\n};\n\nfunction _createForOfIteratorHelper$j(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$j(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$j(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$j(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(o, minLen); }\nfunction _arrayLikeToArray$j(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\n * Get the distance to the end of the first character in a string of text.\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0;\n  // Evaluation of these conditions are deferred.\n  var gb11 = null; // Is GB11 applicable?\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n  var _iterator = _createForOfIteratorHelper$j(codepoints),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n      var code = _char.codePointAt(0);\n      if (!code) break;\n      var type = getCodepointType(_char, code);\n      var _ref = isLTR ? [right, type] : [type, left];\n      var _ref2 = _slicedToArray(_ref, 2);\n      left = _ref2[0];\n      right = _ref2[1];\n      if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n        if (isLTR) {\n          gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n        } else {\n          gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n        }\n        if (!gb11) break;\n      }\n      if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n        if (gb12Or13 !== null) {\n          gb12Or13 = !gb12Or13;\n        } else {\n          if (isLTR) {\n            gb12Or13 = true;\n          } else {\n            gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n          }\n        }\n        if (!gb12Or13) break;\n      }\n      if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n        break;\n      }\n      distance += _char.length;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u002B\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * Get the distance to the end of the first word in a string of text.\n */\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var _splitByCharacterDist = splitByCharacterDistance(text, charDist, isRTL),\n      _splitByCharacterDist2 = _slicedToArray(_splitByCharacterDist, 2),\n      _char2 = _splitByCharacterDist2[0],\n      remaining = _splitByCharacterDist2[1];\n    if (isWordCharacter(_char2, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n    text = remaining;\n  }\n  return dist;\n};\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */\nvar splitByCharacterDistance = function splitByCharacterDistance(str, dist, isRTL) {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\nvar isWordCharacter = function isWordCharacter(_char3, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (SPACE.test(_char3)) {\n    return false;\n  }\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(_char3)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var _splitByCharacterDist3 = splitByCharacterDistance(remaining, charDist, isRTL),\n      _splitByCharacterDist4 = _slicedToArray(_splitByCharacterDist3, 2),\n      nextChar = _splitByCharacterDist4[0],\n      nextRemaining = _splitByCharacterDist4[1];\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n  if (PUNCTUATION.test(_char3)) {\n    return false;\n  }\n  return true;\n};\n/**\n * Iterate on codepoints from right to left.\n */\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n    yield char1;\n  }\n};\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isHighSurrogate = function isHighSurrogate(charCode) {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isLowSurrogate = function isLowSurrogate(charCode) {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = function getCodepointType(_char4, code) {\n  var type = CodepointType.Any;\n  if (_char4.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n  if (_char4.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n  if (_char4.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n  if (_char4.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n  if (_char4.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n  if (_char4.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n  if (_char4.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n  if (_char4.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n  if (_char4.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n  return type;\n};\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],\n// GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],\n// GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T],\n// GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],\n// GB9a\n[CodepointType.Any, CodepointType.SpacingMark],\n// GB9b\n[CodepointType.Prepend, CodepointType.Any],\n// GB11\n[CodepointType.ZWJ, CodepointType.ExtPict],\n// GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(function (r) {\n    return intersects(left, r[0]) && intersects(right, r[1]);\n  }) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = function endsWithEmojiZWJ(str) {\n  return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = function endsWithOddNumberOfRIs(str) {\n  var match = str.match(endingRIs);\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar TextTransforms = {\n  \"delete\": function _delete(editor, options) {\n    editor[\"delete\"](options);\n  },\n  insertFragment: function insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids;\n      var _options$at = options.at,\n        at = _options$at === void 0 ? getDefaultInsertLocation(editor) : _options$at;\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at,\n            voids: voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      }) || Editor.elementReadOnly(editor, {\n        at: at\n      })) {\n        return;\n      }\n      var _at = at,\n        path = _at.path,\n        offset = _at.offset;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n// perf\nvar BATCHING_DIRTY_PATHS = new WeakMap();\nvar isBatchingDirtyPaths = function isBatchingDirtyPaths(editor) {\n  return BATCHING_DIRTY_PATHS.get(editor) || false;\n};\nvar batchDirtyPaths = function batchDirtyPaths(editor, fn, update) {\n  var value = BATCHING_DIRTY_PATHS.get(editor) || false;\n  BATCHING_DIRTY_PATHS.set(editor, true);\n  try {\n    fn();\n    update();\n  } finally {\n    BATCHING_DIRTY_PATHS.set(editor, value);\n  }\n};\n\nfunction _createForOfIteratorHelper$i(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$i(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$i(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$i(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen); }\nfunction _arrayLikeToArray$i(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * update editor dirty paths\n *\n * @param newDirtyPaths: Path[]; new dirty paths\n * @param transform: (p: Path) => Path | null; how to transform existing dirty paths\n */\nfunction updateDirtyPaths(editor, newDirtyPaths, transform) {\n  var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n  var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n  var dirtyPaths;\n  var dirtyPathKeys;\n  var add = function add(path) {\n    if (path) {\n      var key = path.join(',');\n      if (!dirtyPathKeys.has(key)) {\n        dirtyPathKeys.add(key);\n        dirtyPaths.push(path);\n      }\n    }\n  };\n  if (transform) {\n    dirtyPaths = [];\n    dirtyPathKeys = new Set();\n    var _iterator = _createForOfIteratorHelper$i(oldDirtyPaths),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var path = _step.value;\n        var newPath = transform(path);\n        add(newPath);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    dirtyPaths = oldDirtyPaths;\n    dirtyPathKeys = oldDirtyPathKeys;\n  }\n  var _iterator2 = _createForOfIteratorHelper$i(newDirtyPaths),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _path = _step2.value;\n      add(_path);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  DIRTY_PATHS.set(editor, dirtyPaths);\n  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n}\n\nfunction _createForOfIteratorHelper$h(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$h(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$h(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$h(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen); }\nfunction _arrayLikeToArray$h(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar apply = function apply(editor, op) {\n  var _iterator = _createForOfIteratorHelper$h(Editor.pathRefs(editor)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ref = _step.value;\n      PathRef.transform(ref, op);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper$h(Editor.pointRefs(editor)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _ref = _step2.value;\n      PointRef.transform(_ref, op);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var _iterator3 = _createForOfIteratorHelper$h(Editor.rangeRefs(editor)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ref2 = _step3.value;\n      RangeRef.transform(_ref2, op);\n    }\n    // update dirty paths\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  if (!isBatchingDirtyPaths(editor)) {\n    var transform = Path.operationCanTransformPath(op) ? function (p) {\n      return Path.transform(p, op);\n    } : undefined;\n    updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);\n  }\n  Transforms.transform(editor, op);\n  editor.operations.push(op);\n  Editor.normalize(editor, {\n    operation: op\n  });\n  // Clear any formats applied to the cursor if the selection changes.\n  if (op.type === 'set_selection') {\n    editor.marks = null;\n  }\n  if (!FLUSHING.get(editor)) {\n    FLUSHING.set(editor, true);\n    Promise.resolve().then(function () {\n      FLUSHING.set(editor, false);\n      editor.onChange({\n        operation: op\n      });\n      editor.operations = [];\n    });\n  }\n};\n\nfunction _createForOfIteratorHelper$g(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$g(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$g(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$g(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen); }\nfunction _arrayLikeToArray$g(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\nvar getDirtyPaths = function getDirtyPaths(editor, op) {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var path = op.path;\n        return Path.levels(path);\n      }\n    case 'insert_node':\n      {\n        var node = op.node,\n          _path = op.path;\n        var levels = Path.levels(_path);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            p = _ref2[1];\n          return _path.concat(p);\n        });\n        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n      }\n    case 'merge_node':\n      {\n        var _path2 = op.path;\n        var ancestors = Path.ancestors(_path2);\n        var previousPath = Path.previous(_path2);\n        return [].concat(_toConsumableArray(ancestors), [previousPath]);\n      }\n    case 'move_node':\n      {\n        var _path3 = op.path,\n          newPath = op.newPath;\n        if (Path.equals(_path3, newPath)) {\n          return [];\n        }\n        var oldAncestors = [];\n        var newAncestors = [];\n        var _iterator = _createForOfIteratorHelper$g(Path.ancestors(_path3)),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var ancestor = _step.value;\n            var p = Path.transform(ancestor, op);\n            oldAncestors.push(p);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var _iterator2 = _createForOfIteratorHelper$g(Path.ancestors(newPath)),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _ancestor = _step2.value;\n            var _p = Path.transform(_ancestor, op);\n            newAncestors.push(_p);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [].concat(oldAncestors, newAncestors, [resultPath]);\n      }\n    case 'remove_node':\n      {\n        var _path4 = op.path;\n        var _ancestors = Path.ancestors(_path4);\n        return _toConsumableArray(_ancestors);\n      }\n    case 'split_node':\n      {\n        var _path5 = op.path;\n        var _levels = Path.levels(_path5);\n        var nextPath = Path.next(_path5);\n        return [].concat(_toConsumableArray(_levels), [nextPath]);\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nvar getFragment = function getFragment(editor) {\n  var selection = editor.selection;\n  if (selection) {\n    return Node.fragment(editor, selection);\n  }\n  return [];\n};\n\nvar normalizeNode = function normalizeNode(editor, entry) {\n  var _entry = _slicedToArray(entry, 2),\n    node = _entry[0],\n    path = _entry[1];\n  // There are no core normalizations for text nodes.\n  if (Text.isText(node)) {\n    return;\n  }\n  // Ensure that block and inline nodes have at least one text child.\n  if (Element.isElement(node) && node.children.length === 0) {\n    var child = {\n      text: ''\n    };\n    Transforms.insertNodes(editor, child, {\n      at: path.concat(0),\n      voids: true\n    });\n    return;\n  }\n  // Determine whether the node should have block or inline children.\n  var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n  // Since we'll be applying operations while iterating, keep track of an\n  // index that accounts for any added/removed nodes.\n  var n = 0;\n  for (var i = 0; i < node.children.length; i++, n++) {\n    var currentNode = Node.get(editor, path);\n    if (Text.isText(currentNode)) continue;\n    var _child = currentNode.children[n];\n    var prev = currentNode.children[n - 1];\n    var isLast = i === node.children.length - 1;\n    var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);\n    // Only allow block nodes in the top-level children and parent blocks\n    // that only contain block nodes. Similarly, only allow inline nodes in\n    // other inline nodes, or parent blocks that only contain inlines and\n    // text.\n    if (isInlineOrText !== shouldHaveInlines) {\n      if (isInlineOrText) {\n        Transforms.removeNodes(editor, {\n          at: path.concat(n),\n          voids: true\n        });\n      } else {\n        Transforms.unwrapNodes(editor, {\n          at: path.concat(n),\n          voids: true\n        });\n      }\n      n--;\n    } else if (Element.isElement(_child)) {\n      // Ensure that inline nodes are surrounded by text nodes.\n      if (editor.isInline(_child)) {\n        if (prev == null || !Text.isText(prev)) {\n          var newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n),\n            voids: true\n          });\n          n++;\n        } else if (isLast) {\n          var _newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, _newChild, {\n            at: path.concat(n + 1),\n            voids: true\n          });\n          n++;\n        }\n      }\n    } else {\n      // If the child is not a text node, and doesn't have a `children` field,\n      // then we have an invalid node that will upset slate.\n      //\n      // eg: `{ type: 'some_node' }`.\n      //\n      // To prevent slate from breaking, we can add the `children` field,\n      // and now that it is valid, we can to many more operations easily,\n      // such as extend normalizers to fix erronous structure.\n      if (!Text.isText(_child) && !('children' in _child)) {\n        var elementChild = _child;\n        elementChild.children = [];\n      }\n      // Merge adjacent text nodes that are empty or match.\n      if (prev != null && Text.isText(prev)) {\n        if (Text.equals(_child, prev, {\n          loose: true\n        })) {\n          Transforms.mergeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (prev.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n - 1),\n            voids: true\n          });\n          n--;\n        } else if (_child.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        }\n      }\n    }\n  }\n};\n\nvar shouldNormalize = function shouldNormalize(editor, _ref) {\n  var iteration = _ref.iteration,\n    initialDirtyPathsLength = _ref.initialDirtyPathsLength;\n  var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n  if (iteration > maxIterations) {\n    throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n  }\n  return true;\n};\n\nfunction _createForOfIteratorHelper$f(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$f(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$f(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$f(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen); }\nfunction _arrayLikeToArray$f(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar above = function above(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids,\n    _options$mode = options.mode,\n    mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n    _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at,\n    match = options.match;\n  if (!at) {\n    return;\n  }\n  var path = Editor.path(editor, at);\n  var reverse = mode === 'lowest';\n  var _iterator = _createForOfIteratorHelper$f(Editor.levels(editor, {\n      at: path,\n      voids: voids,\n      match: match,\n      reverse: reverse\n    })),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        n = _step$value[0],\n        p = _step$value[1];\n      if (Text.isText(n)) continue;\n      if (Range.isRange(at)) {\n        if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n          return [n, p];\n        }\n      } else {\n        if (!Path.equals(path, p)) {\n          return [n, p];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\nfunction ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar addMark = function addMark(editor, key, value) {\n  var selection = editor.selection;\n  if (selection) {\n    var match = function match(node, path) {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var _Editor$parent = Editor.parent(editor, path),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 2),\n        parentNode = _Editor$parent2[0];\n        _Editor$parent2[1];\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var _Editor$node = Editor.node(editor, selection),\n        _Editor$node2 = _slicedToArray(_Editor$node, 2),\n        selectedNode = _Editor$node2[0],\n        selectedPath = _Editor$node2[1];\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var _Editor$parent3 = Editor.parent(editor, selectedPath),\n          _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n          parentNode = _Editor$parent4[0];\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor, _defineProperty({}, key, value), {\n        match: match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, _defineProperty({}, key, value));\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nfunction ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelper$e(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$e(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$e(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen); }\nfunction _arrayLikeToArray$e(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar after = function after(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  var focus = Editor.end(editor, []);\n  var range = {\n    anchor: anchor,\n    focus: focus\n  };\n  var _options$distance = options.distance,\n    distance = _options$distance === void 0 ? 1 : _options$distance;\n  var d = 0;\n  var target;\n  var _iterator = _createForOfIteratorHelper$e(Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n      at: range\n    }))),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var p = _step.value;\n      if (d > distance) {\n        break;\n      }\n      if (d !== 0) {\n        target = p;\n      }\n      d++;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return target;\n};\n\nfunction ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelper$d(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$d(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$d(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$d(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen); }\nfunction _arrayLikeToArray$d(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar before = function before(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.start(editor, []);\n  var focus = Editor.point(editor, at, {\n    edge: 'start'\n  });\n  var range = {\n    anchor: anchor,\n    focus: focus\n  };\n  var _options$distance = options.distance,\n    distance = _options$distance === void 0 ? 1 : _options$distance;\n  var d = 0;\n  var target;\n  var _iterator = _createForOfIteratorHelper$d(Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n      at: range,\n      reverse: true\n    }))),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var p = _step.value;\n      if (d > distance) {\n        break;\n      }\n      if (d !== 0) {\n        target = p;\n      }\n      d++;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return target;\n};\n\nvar deleteBackward = function deleteBackward(editor, unit) {\n  var selection = editor.selection;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms[\"delete\"](editor, {\n      unit: unit,\n      reverse: true\n    });\n  }\n};\n\nvar deleteForward = function deleteForward(editor, unit) {\n  var selection = editor.selection;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms[\"delete\"](editor, {\n      unit: unit\n    });\n  }\n};\n\nvar deleteFragment = function deleteFragment(editor) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$direction = _ref.direction,\n    direction = _ref$direction === void 0 ? 'forward' : _ref$direction;\n  var selection = editor.selection;\n  if (selection && Range.isExpanded(selection)) {\n    Transforms[\"delete\"](editor, {\n      reverse: direction === 'backward'\n    });\n  }\n};\n\nvar edges = function edges(editor, at) {\n  return [Editor.start(editor, at), Editor.end(editor, at)];\n};\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar elementReadOnly = function elementReadOnly(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isElementReadOnly(editor, n);\n    }\n  }));\n};\n\nvar end = function end(editor, at) {\n  return Editor.point(editor, at, {\n    edge: 'end'\n  });\n};\n\nvar first = function first(editor, at) {\n  var path = Editor.path(editor, at, {\n    edge: 'start'\n  });\n  return Editor.node(editor, path);\n};\n\nvar fragment = function fragment(editor, at) {\n  var range = Editor.range(editor, at);\n  return Node.fragment(editor, range);\n};\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar getVoid = function getVoid(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isVoid(editor, n);\n    }\n  }));\n};\n\nvar hasBlocks = function hasBlocks(editor, element) {\n  return element.children.some(function (n) {\n    return Element.isElement(n) && Editor.isBlock(editor, n);\n  });\n};\n\nvar hasInlines = function hasInlines(editor, element) {\n  return element.children.some(function (n) {\n    return Text.isText(n) || Editor.isInline(editor, n);\n  });\n};\n\nvar hasPath = function hasPath(editor, path) {\n  return Node.has(editor, path);\n};\n\nvar hasTexts = function hasTexts(editor, element) {\n  return element.children.every(function (n) {\n    return Text.isText(n);\n  });\n};\n\nvar insertBreak = function insertBreak(editor) {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nvar insertNode = function insertNode(editor, node, options) {\n  Transforms.insertNodes(editor, node, options);\n};\n\nvar insertSoftBreak = function insertSoftBreak(editor) {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar insertText = function insertText(editor, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var selection = editor.selection,\n    marks = editor.marks;\n  if (selection) {\n    if (marks) {\n      var node = _objectSpread$3({\n        text: text\n      }, marks);\n      Transforms.insertNodes(editor, node, {\n        at: options.at,\n        voids: options.voids\n      });\n    } else {\n      Transforms.insertText(editor, text, options);\n    }\n    editor.marks = null;\n  }\n};\n\nvar isBlock = function isBlock(editor, value) {\n  return !editor.isInline(value);\n};\n\nvar isEdge = function isEdge(editor, point, at) {\n  return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\n\nvar isEmpty = function isEmpty(editor, element) {\n  var children = element.children;\n  var _children = _slicedToArray(children, 1),\n    first = _children[0];\n  return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n};\n\nvar isEnd = function isEnd(editor, point, at) {\n  var end = Editor.end(editor, at);\n  return Point.equals(point, end);\n};\n\nvar isNormalizing = function isNormalizing(editor) {\n  var isNormalizing = NORMALIZING.get(editor);\n  return isNormalizing === undefined ? true : isNormalizing;\n};\n\nvar isStart = function isStart(editor, point, at) {\n  // PERF: If the offset isn't `0` we know it's not the start.\n  if (point.offset !== 0) {\n    return false;\n  }\n  var start = Editor.start(editor, at);\n  return Point.equals(point, start);\n};\n\nvar last = function last(editor, at) {\n  var path = Editor.path(editor, at, {\n    edge: 'end'\n  });\n  return Editor.node(editor, path);\n};\n\nvar leaf = function leaf(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.leaf(editor, path);\n  return [node, path];\n};\n\nfunction _createForOfIteratorHelper$c(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$c(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$c(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$c(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen); }\nfunction _arrayLikeToArray$c(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction levels(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match;\n    if (match == null) {\n      match = function match() {\n        return true;\n      };\n    }\n    if (!at) {\n      return;\n    }\n    var levels = [];\n    var path = Editor.path(editor, at);\n    var _iterator = _createForOfIteratorHelper$c(Node.levels(editor, path)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          n = _step$value[0],\n          p = _step$value[1];\n        if (!match(n, p)) {\n          continue;\n        }\n        levels.push([n, p]);\n        if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (reverse) {\n      levels.reverse();\n    }\n    yield* levels;\n  }();\n}\n\nvar _excluded$1 = [\"text\"],\n  _excluded2$1 = [\"text\"];\nvar marks = function marks(editor) {\n  var marks = editor.marks,\n    selection = editor.selection;\n  if (!selection) {\n    return null;\n  }\n  var anchor = selection.anchor,\n    focus = selection.focus;\n  if (marks) {\n    return marks;\n  }\n  if (Range.isExpanded(selection)) {\n    var isBackward = Range.isBackward(selection);\n    if (isBackward) {\n      var _ref = [anchor, focus];\n      focus = _ref[0];\n      anchor = _ref[1];\n    }\n    /**\n     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)\n     * do not adversely affect the returned marks.\n     */\n    var isEnd = Editor.isEnd(editor, anchor, anchor.path);\n    if (isEnd) {\n      var after = Editor.after(editor, anchor);\n      if (after) {\n        anchor = after;\n      }\n    }\n    var _Editor$nodes = Editor.nodes(editor, {\n        match: Text.isText,\n        at: {\n          anchor: anchor,\n          focus: focus\n        }\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      match = _Editor$nodes2[0];\n    if (match) {\n      var _match = _slicedToArray(match, 1),\n        _node = _match[0];\n      _node.text;\n        var _rest = _objectWithoutProperties(_node, _excluded$1);\n      return _rest;\n    } else {\n      return {};\n    }\n  }\n  var _anchor = anchor,\n    path = _anchor.path;\n  var _Editor$leaf = Editor.leaf(editor, path),\n    _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n    node = _Editor$leaf2[0];\n  if (anchor.offset === 0) {\n    var prev = Editor.previous(editor, {\n      at: path,\n      match: Text.isText\n    });\n    var markedVoid = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n);\n      }\n    });\n    if (!markedVoid) {\n      var block = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      });\n      if (prev && block) {\n        var _prev = _slicedToArray(prev, 2),\n          prevNode = _prev[0],\n          prevPath = _prev[1];\n        var _block = _slicedToArray(block, 2),\n          blockPath = _block[1];\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n  }\n  var _node2 = node;\n    _node2.text;\n    var rest = _objectWithoutProperties(_node2, _excluded2$1);\n  return rest;\n};\n\nvar next = function next(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$mode = options.mode,\n    mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n    _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var match = options.match,\n    _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at;\n  if (!at) {\n    return;\n  }\n  var pointAfterLocation = Editor.after(editor, at, {\n    voids: voids\n  });\n  if (!pointAfterLocation) return;\n  var _Editor$last = Editor.last(editor, []),\n    _Editor$last2 = _slicedToArray(_Editor$last, 2),\n    to = _Editor$last2[1];\n  var span = [pointAfterLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the next node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var _Editor$parent = Editor.parent(editor, at),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n        parent = _Editor$parent2[0];\n      match = function match(n) {\n        return parent.children.includes(n);\n      };\n    } else {\n      match = function match() {\n        return true;\n      };\n    }\n  }\n  var _Editor$nodes = Editor.nodes(editor, {\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    next = _Editor$nodes2[0];\n  return next;\n};\n\nvar node = function node(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.get(editor, path);\n  return [node, path];\n};\n\nfunction _createForOfIteratorHelper$b(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }\nfunction _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction nodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'all' : _options$mode,\n      _options$universal = options.universal,\n      universal = _options$universal === void 0 ? false : _options$universal,\n      _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$ignoreNonSel = options.ignoreNonSelectable,\n      ignoreNonSelectable = _options$ignoreNonSel === void 0 ? false : _options$ignoreNonSel;\n    var match = options.match;\n    if (!match) {\n      match = function match() {\n        return true;\n      };\n    }\n    if (!at) {\n      return;\n    }\n    var from;\n    var to;\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n    var nodeEntries = Node.nodes(editor, {\n      reverse: reverse,\n      from: from,\n      to: to,\n      pass: function pass(_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          node = _ref2[0];\n        if (!Element.isElement(node)) return false;\n        if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n        if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;\n        return false;\n      }\n    });\n    var matches = [];\n    var hit;\n    var _iterator = _createForOfIteratorHelper$b(nodeEntries),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          node = _step$value[0],\n          path = _step$value[1];\n        if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {\n          continue;\n        }\n        var isLower = hit && Path.compare(path, hit[1]) === 0;\n        // In highest mode any node lower than the last hit is not a match.\n        if (mode === 'highest' && isLower) {\n          continue;\n        }\n        if (!match(node, path)) {\n          // If we've arrived at a leaf text node that is not lower than the last\n          // hit, then we've found a branch that doesn't include a match, which\n          // means the match is not universal.\n          if (universal && !isLower && Text.isText(node)) {\n            return;\n          } else {\n            continue;\n          }\n        }\n        // If there's a match and it's lower than the last, update the hit.\n        if (mode === 'lowest' && isLower) {\n          hit = [node, path];\n          continue;\n        }\n        // In lowest mode we emit the last hit, once it's guaranteed lowest.\n        var emit = mode === 'lowest' ? hit : [node, path];\n        if (emit) {\n          if (universal) {\n            matches.push(emit);\n          } else {\n            yield emit;\n          }\n        }\n        hit = [node, path];\n      }\n      // Since lowest is always emitting one behind, catch up at the end.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    }\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches;\n    }\n  }();\n}\n\nfunction _createForOfIteratorHelper$a(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }\nfunction _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar normalize = function normalize(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$force = options.force,\n    force = _options$force === void 0 ? false : _options$force,\n    operation = options.operation;\n  var getDirtyPaths = function getDirtyPaths(editor) {\n    return DIRTY_PATHS.get(editor) || [];\n  };\n  var getDirtyPathKeys = function getDirtyPathKeys(editor) {\n    return DIRTY_PATH_KEYS.get(editor) || new Set();\n  };\n  var popDirtyPath = function popDirtyPath(editor) {\n    var path = getDirtyPaths(editor).pop();\n    var key = path.join(',');\n    getDirtyPathKeys(editor)[\"delete\"](key);\n    return path;\n  };\n  if (!Editor.isNormalizing(editor)) {\n    return;\n  }\n  if (force) {\n    var allPaths = Array.from(Node.nodes(editor), function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return p;\n    });\n    var allPathKeys = new Set(allPaths.map(function (p) {\n      return p.join(',');\n    }));\n    DIRTY_PATHS.set(editor, allPaths);\n    DIRTY_PATH_KEYS.set(editor, allPathKeys);\n  }\n  if (getDirtyPaths(editor).length === 0) {\n    return;\n  }\n  Editor.withoutNormalizing(editor, function () {\n    /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */\n    var _iterator = _createForOfIteratorHelper$a(getDirtyPaths(editor)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _dirtyPath = _step.value;\n        if (Node.has(editor, _dirtyPath)) {\n          var _entry = Editor.node(editor, _dirtyPath);\n          var _entry2 = _slicedToArray(_entry, 2),\n            node = _entry2[0],\n            _ = _entry2[1];\n          /*\n            The default normalizer inserts an empty text node in this scenario, but it can be customised.\n            So there is some risk here.\n                     As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n            by definition adding children to an empty node can't cause other paths to change.\n          */\n          if (Element.isElement(node) && node.children.length === 0) {\n            editor.normalizeNode(_entry, {\n              operation: operation\n            });\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var dirtyPaths = getDirtyPaths(editor);\n    var initialDirtyPathsLength = dirtyPaths.length;\n    var iteration = 0;\n    while (dirtyPaths.length !== 0) {\n      if (!editor.shouldNormalize({\n        dirtyPaths: dirtyPaths,\n        iteration: iteration,\n        initialDirtyPathsLength: initialDirtyPathsLength,\n        operation: operation\n      })) {\n        return;\n      }\n      var dirtyPath = popDirtyPath(editor);\n      // If the node doesn't exist in the tree, it does not need to be normalized.\n      if (Node.has(editor, dirtyPath)) {\n        var entry = Editor.node(editor, dirtyPath);\n        editor.normalizeNode(entry, {\n          operation: operation\n        });\n      }\n      iteration++;\n      dirtyPaths = getDirtyPaths(editor);\n    }\n  });\n};\n\nvar parent = function parent(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var parentPath = Path.parent(path);\n  var entry = Editor.node(editor, parentPath);\n  return entry;\n};\n\nvar pathRef = function pathRef(editor, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$affinity = options.affinity,\n    affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n  var ref = {\n    current: path,\n    affinity: affinity,\n    unref: function unref() {\n      var current = ref.current;\n      var pathRefs = Editor.pathRefs(editor);\n      pathRefs[\"delete\"](ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pathRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pathRefs = function pathRefs(editor) {\n  var refs = PATH_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    PATH_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar path = function path(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var depth = options.depth,\n    edge = options.edge;\n  if (Path.isPath(at)) {\n    if (edge === 'start') {\n      var _Node$first = Node.first(editor, at),\n        _Node$first2 = _slicedToArray(_Node$first, 2),\n        firstPath = _Node$first2[1];\n      at = firstPath;\n    } else if (edge === 'end') {\n      var _Node$last = Node.last(editor, at),\n        _Node$last2 = _slicedToArray(_Node$last, 2),\n        lastPath = _Node$last2[1];\n      at = lastPath;\n    }\n  }\n  if (Range.isRange(at)) {\n    if (edge === 'start') {\n      at = Range.start(at);\n    } else if (edge === 'end') {\n      at = Range.end(at);\n    } else {\n      at = Path.common(at.anchor.path, at.focus.path);\n    }\n  }\n  if (Point.isPoint(at)) {\n    at = at.path;\n  }\n  if (depth != null) {\n    at = at.slice(0, depth);\n  }\n  return at;\n};\n\nvar pointRef = function pointRef(editor, point) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$affinity = options.affinity,\n    affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n  var ref = {\n    current: point,\n    affinity: affinity,\n    unref: function unref() {\n      var current = ref.current;\n      var pointRefs = Editor.pointRefs(editor);\n      pointRefs[\"delete\"](ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pointRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pointRefs = function pointRefs(editor) {\n  var refs = POINT_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    POINT_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar point = function point(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? 'start' : _options$edge;\n  if (Path.isPath(at)) {\n    var path;\n    if (edge === 'end') {\n      var _Node$last = Node.last(editor, at),\n        _Node$last2 = _slicedToArray(_Node$last, 2),\n        lastPath = _Node$last2[1];\n      path = lastPath;\n    } else {\n      var _Node$first = Node.first(editor, at),\n        _Node$first2 = _slicedToArray(_Node$first, 2),\n        firstPath = _Node$first2[1];\n      path = firstPath;\n    }\n    var node = Node.get(editor, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n    }\n    return {\n      path: path,\n      offset: edge === 'end' ? node.text.length : 0\n    };\n  }\n  if (Range.isRange(at)) {\n    var _Range$edges = Range.edges(at),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      start = _Range$edges2[0],\n      end = _Range$edges2[1];\n    return edge === 'start' ? start : end;\n  }\n  return at;\n};\n\nfunction _createForOfIteratorHelper$9(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }\nfunction _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction positions(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$unit = options.unit,\n      unit = _options$unit === void 0 ? 'offset' : _options$unit,\n      _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$ignoreNonSel = options.ignoreNonSelectable,\n      ignoreNonSelectable = _options$ignoreNonSel === void 0 ? false : _options$ignoreNonSel;\n    if (!at) {\n      return;\n    }\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n    var range = Editor.range(editor, at);\n    var _Range$edges = Range.edges(range),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      start = _Range$edges2[0],\n      end = _Range$edges2[1];\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0;\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    var _iterator = _createForOfIteratorHelper$9(Editor.nodes(editor, {\n        at: at,\n        reverse: reverse,\n        voids: voids,\n        ignoreNonSelectable: ignoreNonSelectable\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          node = _step$value[0],\n          path = _step$value[1];\n        /*\n         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n         */\n        if (Element.isElement(node)) {\n          // Void nodes are a special case, so by default we will always\n          // yield their first point. If the `voids` option is set to true,\n          // then we will iterate over their content.\n          if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n            yield Editor.start(editor, path);\n            continue;\n          }\n          // Inline element nodes are ignored as they don't themselves\n          // contribute to `blockText` or `leafText` - their parent and\n          // children do.\n          if (editor.isInline(node)) continue;\n          // Block element node - set `blockText` to its text content.\n          if (Editor.hasInlines(editor, node)) {\n            // We always exhaust block nodes before encountering a new one:\n            //   console.assert(blockText === '',\n            //     `blockText='${blockText}' - `+\n            //     `not exhausted before new block node`, path)\n            // Ensure range considered is capped to `range`, in the\n            // start/end edge cases where block extends beyond range.\n            // Equivalent to this, but presumably more performant:\n            //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n            //   blockRange = Range.intersection(range, blockRange) // intersect\n            //   blockText = Editor.string(editor, blockRange, { voids })\n            var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n            var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n            blockText = Editor.string(editor, {\n              anchor: s,\n              focus: e\n            }, {\n              voids: voids\n            });\n            isNewBlock = true;\n          }\n        }\n        /*\n         * TEXT LEAF NODE - Iterate through text content, yielding\n         * positions every `distance` offset according to `unit`.\n         */\n        if (Text.isText(node)) {\n          var isFirst = Path.equals(path, first.path);\n          // Proof that we always exhaust text nodes before encountering a new one:\n          //   console.assert(leafTextRemaining <= 0,\n          //     `leafTextRemaining=${leafTextRemaining} - `+\n          //     `not exhausted before new leaf text node`, path)\n          // Reset `leafText` counters for new text node.\n          if (isFirst) {\n            leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n            leafTextOffset = first.offset; // Works for reverse too.\n          } else {\n            leafTextRemaining = node.text.length;\n            leafTextOffset = reverse ? leafTextRemaining : 0;\n          }\n          // Yield position at the start of node (potentially).\n          if (isFirst || isNewBlock || unit === 'offset') {\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n            isNewBlock = false;\n          }\n          // Yield positions every (dynamically calculated) `distance` offset.\n          while (true) {\n            // If `leafText` has caught up with `blockText` (distance=0),\n            // and if blockText is exhausted, break to get another block node,\n            // otherwise advance blockText forward by the new `distance`.\n            if (distance === 0) {\n              if (blockText === '') break;\n              distance = calcDistance(blockText, unit, reverse);\n              // Split the string at the previously found distance and use the\n              // remaining string for the next iteration.\n              blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n            }\n            // Advance `leafText` by the current `distance`.\n            leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n            leafTextRemaining = leafTextRemaining - distance;\n            // If `leafText` is exhausted, break to get a new leaf node\n            // and set distance to the overflow amount, so we'll (maybe)\n            // catch up to blockText in the next leaf text node.\n            if (leafTextRemaining < 0) {\n              distance = -leafTextRemaining;\n              break;\n            }\n            // Successfully walked `distance` offsets through `leafText`\n            // to catch up with `blockText`, so we can reset `distance`\n            // and yield this position in this node.\n            distance = 0;\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n          }\n        }\n      }\n      // Proof that upon completion, we've exahusted both leaf and block text:\n      //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n      //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n      // Helper:\n      // Return the distance in offsets for a step of size `unit` on given string.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n      return 1;\n    }\n  }();\n}\n\nvar previous = function previous(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$mode = options.mode,\n    mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n    _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var match = options.match,\n    _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at;\n  if (!at) {\n    return;\n  }\n  var pointBeforeLocation = Editor.before(editor, at, {\n    voids: voids\n  });\n  if (!pointBeforeLocation) {\n    return;\n  }\n  var _Editor$first = Editor.first(editor, []),\n    _Editor$first2 = _slicedToArray(_Editor$first, 2),\n    to = _Editor$first2[1];\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  var span = [pointBeforeLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the previous node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var _Editor$parent = Editor.parent(editor, at),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n        parent = _Editor$parent2[0];\n      match = function match(n) {\n        return parent.children.includes(n);\n      };\n    } else {\n      match = function match() {\n        return true;\n      };\n    }\n  }\n  var _Editor$nodes = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    previous = _Editor$nodes2[0];\n  return previous;\n};\n\nvar rangeRef = function rangeRef(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$affinity = options.affinity,\n    affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n  var ref = {\n    current: range,\n    affinity: affinity,\n    unref: function unref() {\n      var current = ref.current;\n      var rangeRefs = Editor.rangeRefs(editor);\n      rangeRefs[\"delete\"](ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.rangeRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar rangeRefs = function rangeRefs(editor) {\n  var refs = RANGE_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    RANGE_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar range = function range(editor, at, to) {\n  if (Range.isRange(at) && !to) {\n    return at;\n  }\n  var start = Editor.start(editor, at);\n  var end = Editor.end(editor, to || at);\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar removeMark = function removeMark(editor, key) {\n  var selection = editor.selection;\n  if (selection) {\n    var match = function match(node, path) {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var _Editor$parent = Editor.parent(editor, path),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 2),\n        parentNode = _Editor$parent2[0];\n        _Editor$parent2[1];\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var _Editor$node = Editor.node(editor, selection),\n        _Editor$node2 = _slicedToArray(_Editor$node, 2),\n        selectedNode = _Editor$node2[0],\n        selectedPath = _Editor$node2[1];\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var _Editor$parent3 = Editor.parent(editor, selectedPath),\n          _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n          parentNode = _Editor$parent4[0];\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.unsetNodes(editor, key, {\n        match: match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n      delete marks[key];\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nvar setNormalizing = function setNormalizing(editor, isNormalizing) {\n  NORMALIZING.set(editor, isNormalizing);\n};\n\nvar start = function start(editor, at) {\n  return Editor.point(editor, at, {\n    edge: 'start'\n  });\n};\n\nfunction _createForOfIteratorHelper$8(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }\nfunction _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar string = function string(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var range = Editor.range(editor, at);\n  var _Range$edges = Range.edges(range),\n    _Range$edges2 = _slicedToArray(_Range$edges, 2),\n    start = _Range$edges2[0],\n    end = _Range$edges2[1];\n  var text = '';\n  var _iterator = _createForOfIteratorHelper$8(Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids: voids\n    })),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        node = _step$value[0],\n        path = _step$value[1];\n      var t = node.text;\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset);\n      }\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset);\n      }\n      text += t;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return text;\n};\n\nfunction _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }\nfunction _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar unhangRange = function unhangRange(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids;\n  var _Range$edges = Range.edges(range),\n    _Range$edges2 = _slicedToArray(_Range$edges, 2),\n    start = _Range$edges2[0],\n    end = _Range$edges2[1];\n  // PERF: exit early if we can guarantee that the range isn't hanging.\n  if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n    return range;\n  }\n  var endBlock = Editor.above(editor, {\n    at: end,\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isBlock(editor, n);\n    },\n    voids: voids\n  });\n  var blockPath = endBlock ? endBlock[1] : [];\n  var first = Editor.start(editor, start);\n  var before = {\n    anchor: first,\n    focus: end\n  };\n  var skip = true;\n  var _iterator = _createForOfIteratorHelper$7(Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids: voids\n    })),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        node = _step$value[0],\n        path = _step$value[1];\n      if (skip) {\n        skip = false;\n        continue;\n      }\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = {\n          path: path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nvar withoutNormalizing = function withoutNormalizing(editor, fn) {\n  var value = Editor.isNormalizing(editor);\n  Editor.setNormalizing(editor, false);\n  try {\n    fn();\n  } finally {\n    Editor.setNormalizing(editor, value);\n  }\n  Editor.normalize(editor);\n};\n\nvar shouldMergeNodesRemovePrevNode = function shouldMergeNodesRemovePrevNode(editor, _ref, _ref2) {\n  var _ref3 = _slicedToArray(_ref, 2),\n    prevNode = _ref3[0],\n    prevPath = _ref3[1];\n  var _ref4 = _slicedToArray(_ref2, 2);\n    _ref4[0];\n    _ref4[1];\n  // If the target node that we're merging with is empty, remove it instead\n  // of merging the two. This is a common rich text editor behavior to\n  // prevent losing formatting when deleting entire nodes when you have a\n  // hanging selection.\n  // if prevNode is first child in parent,don't remove it.\n  return Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0;\n};\n\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }\nfunction _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar deleteText = function deleteText(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _Editor$void, _Editor$void2;\n    var _options$reverse = options.reverse,\n      reverse = _options$reverse === void 0 ? false : _options$reverse,\n      _options$unit = options.unit,\n      unit = _options$unit === void 0 ? 'character' : _options$unit,\n      _options$distance = options.distance,\n      distance = _options$distance === void 0 ? 1 : _options$distance,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging;\n    if (!at) {\n      return;\n    }\n    var isCollapsed = false;\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      isCollapsed = true;\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      var furthestVoid = Editor[\"void\"](editor, {\n        at: at,\n        mode: 'highest'\n      });\n      if (!voids && furthestVoid) {\n        var _furthestVoid = _slicedToArray(furthestVoid, 2),\n          voidPath = _furthestVoid[1];\n        at = voidPath;\n      } else {\n        var opts = {\n          unit: unit,\n          distance: distance\n        };\n        var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at: at,\n        voids: voids\n      });\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      var _Range$edges = Range.edges(at),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        _end = _Range$edges2[1];\n      var endOfDoc = Editor.end(editor, []);\n      if (!Point.equals(_end, endOfDoc)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n    }\n    var _Range$edges3 = Range.edges(at),\n      _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n      start = _Range$edges4[0],\n      end = _Range$edges4[1];\n    var startBlock = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      at: start,\n      voids: voids\n    });\n    var endBlock = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      at: end,\n      voids: voids\n    });\n    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    var isSingleText = Path.equals(start.path, end.path);\n    var startNonEditable = voids ? null : (_Editor$void = Editor[\"void\"](editor, {\n      at: start,\n      mode: 'highest'\n    })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n      at: start,\n      mode: 'highest'\n    });\n    var endNonEditable = voids ? null : (_Editor$void2 = Editor[\"void\"](editor, {\n      at: end,\n      mode: 'highest'\n    })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n      at: end,\n      mode: 'highest'\n    });\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startNonEditable) {\n      var before = Editor.before(editor, start);\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n    if (endNonEditable) {\n      var after = Editor.after(editor, end);\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    var matches = [];\n    var lastPath;\n    var _iterator = _createForOfIteratorHelper$6(Editor.nodes(editor, {\n        at: at,\n        voids: voids\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n        var _entry = _slicedToArray(entry, 2),\n          _node2 = _entry[0],\n          _path2 = _entry[1];\n        if (lastPath && Path.compare(_path2, lastPath) === 0) {\n          continue;\n        }\n        if (!voids && Element.isElement(_node2) && (Editor.isVoid(editor, _node2) || Editor.isElementReadOnly(editor, _node2)) || !Path.isCommon(_path2, start.path) && !Path.isCommon(_path2, end.path)) {\n          matches.push(entry);\n          lastPath = _path2;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var pathRefs = Array.from(matches, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    var startRef = Editor.pointRef(editor, start);\n    var endRef = Editor.pointRef(editor, end);\n    var removedText = '';\n    if (!isSingleText && !startNonEditable) {\n      var _point = startRef.current;\n      var _Editor$leaf = Editor.leaf(editor, _point),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n        node = _Editor$leaf2[0];\n      var path = _point.path;\n      var _start = start,\n        offset = _start.offset;\n      var text = node.text.slice(offset);\n      if (text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: path,\n          offset: offset,\n          text: text\n        });\n        removedText = text;\n      }\n    }\n    pathRefs.reverse().map(function (r) {\n      return r.unref();\n    }).filter(function (r) {\n      return r !== null;\n    }).forEach(function (p) {\n      return Transforms.removeNodes(editor, {\n        at: p,\n        voids: voids\n      });\n    });\n    if (!endNonEditable) {\n      var _point2 = endRef.current;\n      var _Editor$leaf3 = Editor.leaf(editor, _point2),\n        _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n        _node = _Editor$leaf4[0];\n      var _path = _point2.path;\n      var _offset = isSingleText ? start.offset : 0;\n      var _text = _node.text.slice(_offset, end.offset);\n      if (_text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset: _offset,\n          text: _text\n        });\n        removedText = _text;\n      }\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids: voids\n      });\n    }\n    // For Thai script, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n    if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n      Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n    }\n    var startUnref = startRef.unref();\n    var endUnref = endRef.unref();\n    var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }\nfunction _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar insertFragment = function insertFragment(editor, fragment) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? getDefaultInsertLocation(editor) : _options$at,\n      _options$batchDirty = options.batchDirty,\n      batchDirty = _options$batchDirty === void 0 ? true : _options$batchDirty;\n    if (!fragment.length) {\n      return;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          end = _Range$edges2[1];\n        if (!voids && Editor[\"void\"](editor, {\n          at: end\n        })) {\n          return;\n        }\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n          at: at\n        });\n        at = pointRef.unref();\n      }\n    } else if (Path.isPath(at)) {\n      at = Editor.start(editor, at);\n    }\n    if (!voids && Editor[\"void\"](editor, {\n      at: at\n    })) {\n      return;\n    }\n    // If the insert point is at the edge of an inline node, move it outside\n    // instead since it will need to be split otherwise.\n    var inlineElementMatch = Editor.above(editor, {\n      at: at,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isInline(editor, n);\n      },\n      mode: 'highest',\n      voids: voids\n    });\n    if (inlineElementMatch) {\n      var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2),\n        _inlinePath = _inlineElementMatch[1];\n      if (Editor.isEnd(editor, at, _inlinePath)) {\n        var after = Editor.after(editor, _inlinePath);\n        at = after;\n      } else if (Editor.isStart(editor, at, _inlinePath)) {\n        var before = Editor.before(editor, _inlinePath);\n        at = before;\n      }\n    }\n    var blockMatch = Editor.above(editor, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      at: at,\n      voids: voids\n    });\n    var _blockMatch = _slicedToArray(blockMatch, 2),\n      blockPath = _blockMatch[1];\n    var isBlockStart = Editor.isStart(editor, at, blockPath);\n    var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n    var isBlockEmpty = isBlockStart && isBlockEnd;\n    var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n    var mergeEnd = !isBlockEnd;\n    var _Node$first = Node.first({\n        children: fragment\n      }, []),\n      _Node$first2 = _slicedToArray(_Node$first, 2),\n      firstPath = _Node$first2[1];\n    var _Node$last = Node.last({\n        children: fragment\n      }, []),\n      _Node$last2 = _slicedToArray(_Node$last, 2),\n      lastPath = _Node$last2[1];\n    var matches = [];\n    var matcher = function matcher(_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        n = _ref2[0],\n        p = _ref2[1];\n      var isRoot = p.length === 0;\n      if (isRoot) {\n        return false;\n      }\n      if (isBlockEmpty) {\n        return true;\n      }\n      if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      return true;\n    };\n    var _iterator = _createForOfIteratorHelper$5(Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n        if (matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var starts = [];\n    var middles = [];\n    var ends = [];\n    var starting = true;\n    var hasBlocks = false;\n    for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n      var _matches$_i = _slicedToArray(_matches[_i], 1),\n        node = _matches$_i[0];\n      if (Element.isElement(node) && !editor.isInline(node)) {\n        starting = false;\n        hasBlocks = true;\n        middles.push(node);\n      } else if (starting) {\n        starts.push(node);\n      } else {\n        ends.push(node);\n      }\n    }\n    var _Editor$nodes = Editor.nodes(editor, {\n        at: at,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      inlineMatch = _Editor$nodes2[0];\n    var _inlineMatch = _slicedToArray(inlineMatch, 2),\n      inlinePath = _inlineMatch[1];\n    var isInlineStart = Editor.isStart(editor, at, inlinePath);\n    var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n    var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n    var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.splitNodes(editor, {\n      at: at,\n      match: function match(n) {\n        return hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n      },\n      mode: hasBlocks ? 'lowest' : 'highest',\n      always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n      voids: voids\n    });\n    var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.insertNodes(editor, starts, {\n      at: startRef.current,\n      match: function match(n) {\n        return Text.isText(n) || Editor.isInline(editor, n);\n      },\n      mode: 'highest',\n      voids: voids,\n      batchDirty: batchDirty\n    });\n    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n      Transforms[\"delete\"](editor, {\n        at: blockPath,\n        voids: voids\n      });\n    }\n    Transforms.insertNodes(editor, middles, {\n      at: middleRef.current,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      mode: 'lowest',\n      voids: voids,\n      batchDirty: batchDirty\n    });\n    Transforms.insertNodes(editor, ends, {\n      at: endRef.current,\n      match: function match(n) {\n        return Text.isText(n) || Editor.isInline(editor, n);\n      },\n      mode: 'highest',\n      voids: voids,\n      batchDirty: batchDirty\n    });\n    if (!options.at) {\n      var path;\n      if (ends.length > 0 && endRef.current) {\n        path = Path.previous(endRef.current);\n      } else if (middles.length > 0 && middleRef.current) {\n        path = Path.previous(middleRef.current);\n      } else if (startRef.current) {\n        path = Path.previous(startRef.current);\n      }\n      if (path) {\n        var _end = Editor.end(editor, path);\n        Transforms.select(editor, _end);\n      }\n    }\n    startRef.unref();\n    middleRef.unref();\n    endRef.unref();\n  });\n};\n\nvar collapse = function collapse(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? 'anchor' : _options$edge;\n  var selection = editor.selection;\n  if (!selection) {\n    return;\n  } else if (edge === 'anchor') {\n    Transforms.select(editor, selection.anchor);\n  } else if (edge === 'focus') {\n    Transforms.select(editor, selection.focus);\n  } else if (edge === 'start') {\n    var _Range$edges = Range.edges(selection),\n      _Range$edges2 = _slicedToArray(_Range$edges, 1),\n      start = _Range$edges2[0];\n    Transforms.select(editor, start);\n  } else if (edge === 'end') {\n    var _Range$edges3 = Range.edges(selection),\n      _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n      end = _Range$edges4[1];\n    Transforms.select(editor, end);\n  }\n};\n\nvar deselect = function deselect(editor) {\n  var selection = editor.selection;\n  if (selection) {\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: null\n    });\n  }\n};\n\nvar move = function move(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var selection = editor.selection;\n  var _options$distance = options.distance,\n    distance = _options$distance === void 0 ? 1 : _options$distance,\n    _options$unit = options.unit,\n    unit = _options$unit === void 0 ? 'character' : _options$unit,\n    _options$reverse = options.reverse,\n    reverse = _options$reverse === void 0 ? false : _options$reverse;\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? null : _options$edge;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var anchor = selection.anchor,\n    focus = selection.focus;\n  var opts = {\n    distance: distance,\n    unit: unit,\n    ignoreNonSelectable: true\n  };\n  var props = {};\n  if (edge == null || edge === 'anchor') {\n    var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n    if (point) {\n      props.anchor = point;\n    }\n  }\n  if (edge == null || edge === 'focus') {\n    var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n    if (_point) {\n      props.focus = _point;\n    }\n  }\n  Transforms.setSelection(editor, props);\n};\n\nvar select = function select(editor, target) {\n  var selection = editor.selection;\n  target = Editor.range(editor, target);\n  if (selection) {\n    Transforms.setSelection(editor, target);\n    return;\n  }\n  if (!Range.isRange(target)) {\n    throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n  }\n  editor.apply({\n    type: 'set_selection',\n    properties: selection,\n    newProperties: target\n  });\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar setPoint = function setPoint(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var selection = editor.selection;\n  var _options$edge = options.edge,\n    edge = _options$edge === void 0 ? 'both' : _options$edge;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var anchor = selection.anchor,\n    focus = selection.focus;\n  var point = edge === 'anchor' ? anchor : focus;\n  Transforms.setSelection(editor, _defineProperty({}, edge === 'anchor' ? 'anchor' : 'focus', _objectSpread$1(_objectSpread$1({}, point), props)));\n};\n\nvar setSelection = function setSelection(editor, props) {\n  var selection = editor.selection;\n  var oldProps = {};\n  var newProps = {};\n  if (!selection) {\n    return;\n  }\n  for (var k in props) {\n    if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n      oldProps[k] = selection[k];\n      newProps[k] = props[k];\n    }\n  }\n  if (Object.keys(oldProps).length > 0) {\n    editor.apply({\n      type: 'set_selection',\n      properties: oldProps,\n      newProperties: newProps\n    });\n  }\n};\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }\nfunction _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar insertNodes = function insertNodes(editor, nodes) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$batchDirty = options.batchDirty,\n      batchDirty = _options$batchDirty === void 0 ? true : _options$batchDirty;\n    var at = options.at,\n      match = options.match,\n      select = options.select;\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n    if (nodes.length === 0) {\n      return;\n    }\n    var _nodes = nodes,\n      _nodes2 = _slicedToArray(_nodes, 1),\n      node = _nodes2[0];\n    if (!at) {\n      at = getDefaultInsertLocation(editor);\n      if (select !== false) {\n        select = true;\n      }\n    }\n    if (select == null) {\n      select = false;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          end = _Range$edges2[1];\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n          at: at\n        });\n        at = pointRef.unref();\n      }\n    }\n    if (Point.isPoint(at)) {\n      if (match == null) {\n        if (Text.isText(node)) {\n          match = function match(n) {\n            return Text.isText(n);\n          };\n        } else if (editor.isInline(node)) {\n          match = function match(n) {\n            return Text.isText(n) || Editor.isInline(editor, n);\n          };\n        } else {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          };\n        }\n      }\n      var _Editor$nodes = Editor.nodes(editor, {\n          at: at.path,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n        _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n        entry = _Editor$nodes2[0];\n      if (entry) {\n        var _entry = _slicedToArray(entry, 2),\n          matchPath = _entry[1];\n        var pathRef = Editor.pathRef(editor, matchPath);\n        var isAtEnd = Editor.isEnd(editor, at, matchPath);\n        Transforms.splitNodes(editor, {\n          at: at,\n          match: match,\n          mode: mode,\n          voids: voids\n        });\n        var path = pathRef.unref();\n        at = isAtEnd ? Path.next(path) : path;\n      } else {\n        return;\n      }\n    }\n    var parentPath = Path.parent(at);\n    var index = at[at.length - 1];\n    if (!voids && Editor[\"void\"](editor, {\n      at: parentPath\n    })) {\n      return;\n    }\n    if (batchDirty) {\n      // PERF: batch update dirty paths\n      // batched ops used to transform existing dirty paths\n      var batchedOps = [];\n      var newDirtyPaths = Path.levels(parentPath);\n      batchDirtyPaths(editor, function () {\n        var _iterator = _createForOfIteratorHelper$4(nodes),\n          _step;\n        try {\n          var _loop = function _loop() {\n            var node = _step.value;\n            var path = parentPath.concat(index);\n            index++;\n            var op = {\n              type: 'insert_node',\n              path: path,\n              node: node\n            };\n            editor.apply(op);\n            at = Path.next(at);\n            batchedOps.push(op);\n            if (!Text.isText) {\n              newDirtyPaths.push(path);\n            } else {\n              newDirtyPaths.push.apply(newDirtyPaths, _toConsumableArray(Array.from(Node.nodes(node), function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                  p = _ref2[1];\n                return path.concat(p);\n              })));\n            }\n          };\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }, function () {\n        updateDirtyPaths(editor, newDirtyPaths, function (p) {\n          var newPath = p;\n          for (var _i = 0, _batchedOps = batchedOps; _i < _batchedOps.length; _i++) {\n            var op = _batchedOps[_i];\n            if (Path.operationCanTransformPath(op)) {\n              newPath = Path.transform(newPath, op);\n              if (!newPath) {\n                return null;\n              }\n            }\n          }\n          return newPath;\n        });\n      });\n    } else {\n      var _iterator2 = _createForOfIteratorHelper$4(nodes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _node = _step2.value;\n          var _path = parentPath.concat(index);\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path,\n            node: _node\n          });\n          at = Path.next(at);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    at = Path.previous(at);\n    if (select) {\n      var point = Editor.end(editor, at);\n      if (point) {\n        Transforms.select(editor, point);\n      }\n    }\n  });\n};\n\nvar liftNodes = function liftNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match;\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (!at) {\n      return;\n    }\n    var matches = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(matches, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n      var pathRef = _pathRefs[_i];\n      var path = pathRef.unref();\n      if (path.length < 2) {\n        throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n      }\n      var parentNodeEntry = Editor.node(editor, Path.parent(path));\n      var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2),\n        parent = _parentNodeEntry[0],\n        parentPath = _parentNodeEntry[1];\n      var index = path[path.length - 1];\n      var length = parent.children.length;\n      if (length === 1) {\n        var toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: toPath,\n          voids: voids\n        });\n        Transforms.removeNodes(editor, {\n          at: parentPath,\n          voids: voids\n        });\n      } else if (index === 0) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: parentPath,\n          voids: voids\n        });\n      } else if (index === length - 1) {\n        var _toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath,\n          voids: voids\n        });\n      } else {\n        var splitPath = Path.next(path);\n        var _toPath2 = Path.next(parentPath);\n        Transforms.splitNodes(editor, {\n          at: splitPath,\n          voids: voids\n        });\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath2,\n          voids: voids\n        });\n      }\n    }\n  });\n};\n\nvar _excluded = [\"text\"],\n  _excluded2 = [\"children\"];\nvar hasSingleChildNest = function hasSingleChildNest(editor, node) {\n  if (Element.isElement(node)) {\n    var element = node;\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar mergeNodes = function mergeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at;\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent = Editor.parent(editor, at),\n          _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n          parent = _Editor$parent2[0];\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids: voids\n      });\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          end = _Range$edges2[1];\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n          at: at\n        });\n        at = pointRef.unref();\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n    }\n    var _Editor$nodes = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      current = _Editor$nodes2[0];\n    var prev = Editor.previous(editor, {\n      at: at,\n      match: match,\n      voids: voids,\n      mode: mode\n    });\n    if (!current || !prev) {\n      return;\n    }\n    var _current = _slicedToArray(current, 2),\n      node = _current[0],\n      path = _current[1];\n    var _prev = _slicedToArray(prev, 2),\n      prevNode = _prev[0],\n      prevPath = _prev[1];\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n    var newPath = Path.next(prevPath);\n    var commonPath = Path.common(path, prevPath);\n    var isPreviousSibling = Path.isSibling(path, prevPath);\n    var levels = Array.from(Editor.levels(editor, {\n      at: path\n    }), function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n        n = _ref2[0];\n      return n;\n    }).slice(commonPath.length).slice(0, -1);\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    var emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: function match(n) {\n        return levels.includes(n) && hasSingleChildNest(editor, n);\n      }\n    });\n    var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n    var properties;\n    var position;\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      node.text;\n        var rest = _objectWithoutProperties(node, _excluded);\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      node.children;\n        var _rest = _objectWithoutProperties(node, _excluded2);\n      position = prevNode.children.length;\n      properties = _rest;\n    } else {\n      throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: newPath,\n        voids: voids\n      });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      Transforms.removeNodes(editor, {\n        at: emptyRef.current,\n        voids: voids\n      });\n    }\n    if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {\n      Transforms.removeNodes(editor, {\n        at: prevPath,\n        voids: voids\n      });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position: position,\n        properties: properties\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n\nvar moveNodes = function moveNodes(editor, options) {\n  Editor.withoutNormalizing(editor, function () {\n    var to = options.to,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    var toRef = Editor.pathRef(editor, to);\n    var targets = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(targets, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n      var pathRef = _pathRefs[_i];\n      var path = pathRef.unref();\n      var newPath = toRef.current;\n      if (path.length !== 0) {\n        editor.apply({\n          type: 'move_node',\n          path: path,\n          newPath: newPath\n        });\n      }\n      if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n        // When performing a sibling move to a later index, the path at the destination is shifted\n        // to before the insertion point instead of after. To ensure our group of nodes are inserted\n        // in the correct order we increment toRef to account for that\n        toRef.current = Path.next(toRef.current);\n      }\n    }\n    toRef.unref();\n  });\n};\n\nvar removeNodes = function removeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      match = options.match;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids: voids\n      });\n    }\n    var depths = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(depths, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    });\n    for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n      var pathRef = _pathRefs[_i];\n      var path = pathRef.unref();\n      if (path) {\n        var _Editor$node = Editor.node(editor, path),\n          _Editor$node2 = _slicedToArray(_Editor$node, 1),\n          node = _Editor$node2[0];\n        editor.apply({\n          type: 'remove_node',\n          path: path,\n          node: node\n        });\n      }\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar setNodes = function setNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      compare = options.compare,\n      merge = options.merge;\n    var _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging,\n      _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$split = options.split,\n      split = _options$split === void 0 ? false : _options$split,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids: voids\n      });\n    }\n    if (split && Range.isRange(at)) {\n      if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n        // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n        // set that won't get normalized away\n        return;\n      }\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      var _Range$edges = Range.edges(at),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n      var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n      var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n      Transforms.splitNodes(editor, {\n        at: end,\n        match: match,\n        mode: splitMode,\n        voids: voids,\n        always: !endAtEndOfNode\n      });\n      var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n      Transforms.splitNodes(editor, {\n        at: start,\n        match: match,\n        mode: splitMode,\n        voids: voids,\n        always: !startAtStartOfNode\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    if (!compare) {\n      compare = function compare(prop, nodeProp) {\n        return prop !== nodeProp;\n      };\n    }\n    var _iterator = _createForOfIteratorHelper$3(Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      })),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          node = _step$value[0],\n          path = _step$value[1];\n        var properties = {};\n        // FIXME: is this correct?\n        var newProperties = {};\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue;\n        }\n        var hasChanges = false;\n        for (var k in props) {\n          if (k === 'children' || k === 'text') {\n            continue;\n          }\n          if (compare(props[k], node[k])) {\n            hasChanges = true;\n            // Omit new properties from the old properties list\n            if (node.hasOwnProperty(k)) properties[k] = node[k];\n            // Omit properties that have been removed from the new properties list\n            if (merge) {\n              if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n            } else {\n              if (props[k] != null) newProperties[k] = props[k];\n            }\n          }\n        }\n        if (hasChanges) {\n          editor.apply({\n            type: 'set_node',\n            path: path,\n            properties: properties,\n            newProperties: newProperties\n          });\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Convert a range into a point by deleting it's content.\n */\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges = Range.edges(range),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      end = _Range$edges2[1];\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms[\"delete\"](editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\nvar splitNodes = function splitNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$height = options.height,\n      height = _options$height === void 0 ? 0 : _options$height,\n      _options$always = options.always,\n      always = _options$always === void 0 ? false : _options$always;\n    if (match == null) {\n      match = function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (Range.isRange(at)) {\n      at = deleteRange(editor, at);\n    }\n    // If the target is a path, the default height-skipping and position\n    // counters need to account for us potentially splitting at a non-leaf.\n    if (Path.isPath(at)) {\n      var path = at;\n      var point = Editor.point(editor, path);\n      var _Editor$parent = Editor.parent(editor, path),\n        _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n        parent = _Editor$parent2[0];\n      match = function match(n) {\n        return n === parent;\n      };\n      height = point.path.length - path.length + 1;\n      at = point;\n      always = true;\n    }\n    if (!at) {\n      return;\n    }\n    var beforeRef = Editor.pointRef(editor, at, {\n      affinity: 'backward'\n    });\n    var afterRef;\n    try {\n      var _Editor$nodes = Editor.nodes(editor, {\n          at: at,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n        _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n        highest = _Editor$nodes2[0];\n      if (!highest) {\n        return;\n      }\n      var voidMatch = Editor[\"void\"](editor, {\n        at: at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n      if (!voids && voidMatch) {\n        var _voidMatch = _slicedToArray(voidMatch, 2),\n          voidNode = _voidMatch[0],\n          voidPath = _voidMatch[1];\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids: voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n          at = after;\n          always = true;\n        }\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n      afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var _highest = _slicedToArray(highest, 2),\n        highestPath = _highest[1];\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n      var _iterator = _createForOfIteratorHelper$2(Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids: voids\n        })),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            node = _step$value[0],\n            _path = _step$value[1];\n          var split = false;\n          if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n            break;\n          }\n          var _point2 = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point2, _path);\n          if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path)) {\n            split = true;\n            var properties = Node.extractProps(node);\n            editor.apply({\n              type: 'split_node',\n              path: _path,\n              position: position,\n              properties: properties\n            });\n          }\n          position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (options.at == null) {\n        var _point = afterRef.current || Editor.end(editor, []);\n        Transforms.select(editor, _point);\n      }\n    } finally {\n      var _afterRef;\n      beforeRef.unref();\n      (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();\n    }\n  });\n};\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar unsetNodes = function unsetNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!Array.isArray(props)) {\n    props = [props];\n  }\n  var obj = {};\n  var _iterator = _createForOfIteratorHelper$1(props),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      obj[key] = null;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  Transforms.setNodes(editor, obj, options);\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar unwrapNodes = function unwrapNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$split = options.split,\n      split = _options$split === void 0 ? false : _options$split,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      match = options.match;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      };\n    }\n    if (Path.isPath(at)) {\n      at = Editor.range(editor, at);\n    }\n    var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n    var matches = Editor.nodes(editor, {\n      at: at,\n      match: match,\n      mode: mode,\n      voids: voids\n    });\n    var pathRefs = Array.from(matches, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        p = _ref2[1];\n      return Editor.pathRef(editor, p);\n    }\n    // unwrapNode will call liftNode which does not support splitting the node when nested.\n    // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n    // that wrap target node. So we reverse the order.\n    ).reverse();\n    var _iterator = _createForOfIteratorHelper(pathRefs),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var pathRef = _step.value;\n        var path = pathRef.unref();\n        var _Editor$node = Editor.node(editor, path),\n          _Editor$node2 = _slicedToArray(_Editor$node, 1),\n          node = _Editor$node2[0];\n        var range = Editor.range(editor, path);\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: function match(n) {\n            return Element.isAncestor(node) && node.children.includes(n);\n          },\n          voids: voids\n        });\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (rangeRef) {\n      rangeRef.unref();\n    }\n  });\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar wrapNodes = function wrapNodes(editor, element) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, function () {\n    var _options$mode = options.mode,\n      mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n      _options$split = options.split,\n      split = _options$split === void 0 ? false : _options$split,\n      _options$voids = options.voids,\n      voids = _options$voids === void 0 ? false : _options$voids;\n    var match = options.match,\n      _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        match = matchPath(editor, at);\n      } else if (editor.isInline(element)) {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n        };\n      } else {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n    }\n    if (split && Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      Transforms.splitNodes(editor, {\n        at: end,\n        match: match,\n        voids: voids\n      });\n      Transforms.splitNodes(editor, {\n        at: start,\n        match: match,\n        voids: voids\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    var roots = Array.from(Editor.nodes(editor, {\n      at: at,\n      match: editor.isInline(element) ? function (n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      } : function (n) {\n        return Editor.isEditor(n);\n      },\n      mode: 'lowest',\n      voids: voids\n    }));\n    var _loop = function _loop() {\n        var _roots$_i = _slicedToArray(_roots[_i], 2),\n          rootPath = _roots$_i[1];\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n        if (!a) {\n          return 0; // continue\n        }\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match: match,\n          mode: mode,\n          voids: voids\n        }));\n        if (matches.length > 0) {\n          var first = matches[0];\n          var last = matches[matches.length - 1];\n          var _first = _slicedToArray(first, 2),\n            firstPath = _first[1];\n          var _last = _slicedToArray(last, 2),\n            lastPath = _last[1];\n          if (firstPath.length === 0 && lastPath.length === 0) {\n            // if there's no matching parent - usually means the node is an editor - don't do anything\n            return 0; // continue\n          }\n          var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n          var range = Editor.range(editor, firstPath, lastPath);\n          var commonNodeEntry = Editor.node(editor, commonPath);\n          var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1),\n            commonNode = _commonNodeEntry[0];\n          var depth = commonPath.length + 1;\n          var wrapperPath = Path.next(lastPath.slice(0, depth));\n          var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n            children: []\n          });\n          Transforms.insertNodes(editor, wrapper, {\n            at: wrapperPath,\n            voids: voids\n          });\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: function match(n) {\n              return Element.isAncestor(commonNode) && commonNode.children.includes(n);\n            },\n            to: wrapperPath.concat(0),\n            voids: voids\n          });\n        }\n      },\n      _ret;\n    for (var _i = 0, _roots = roots; _i < _roots.length; _i++) {\n      _ret = _loop();\n      if (_ret === 0) continue;\n    }\n  });\n};\n\n/**\n * Create a new Slate `Editor` object.\n */\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isElementReadOnly: function isElementReadOnly() {\n      return false;\n    },\n    isInline: function isInline() {\n      return false;\n    },\n    isSelectable: function isSelectable() {\n      return true;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    markableVoid: function markableVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    // Core\n    apply: function apply$1() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return apply.apply(void 0, [editor].concat(args));\n    },\n    // Editor\n    addMark: function addMark$1() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return addMark.apply(void 0, [editor].concat(args));\n    },\n    deleteBackward: function deleteBackward$1() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return deleteBackward.apply(void 0, [editor].concat(args));\n    },\n    deleteForward: function deleteForward$1() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return deleteForward.apply(void 0, [editor].concat(args));\n    },\n    deleteFragment: function deleteFragment$1() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return deleteFragment.apply(void 0, [editor].concat(args));\n    },\n    getFragment: function getFragment$1() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return getFragment.apply(void 0, [editor].concat(args));\n    },\n    insertBreak: function insertBreak$1() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return insertBreak.apply(void 0, [editor].concat(args));\n    },\n    insertSoftBreak: function insertSoftBreak$1() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return insertSoftBreak.apply(void 0, [editor].concat(args));\n    },\n    insertFragment: function insertFragment$1() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return insertFragment.apply(void 0, [editor].concat(args));\n    },\n    insertNode: function insertNode$1() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return insertNode.apply(void 0, [editor].concat(args));\n    },\n    insertText: function insertText$1() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return insertText.apply(void 0, [editor].concat(args));\n    },\n    normalizeNode: function normalizeNode$1() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return normalizeNode.apply(void 0, [editor].concat(args));\n    },\n    removeMark: function removeMark$1() {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return removeMark.apply(void 0, [editor].concat(args));\n    },\n    getDirtyPaths: function getDirtyPaths$1() {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return getDirtyPaths.apply(void 0, [editor].concat(args));\n    },\n    shouldNormalize: function shouldNormalize$1() {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return shouldNormalize.apply(void 0, [editor].concat(args));\n    },\n    // Editor interface\n    above: function above$1() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return above.apply(void 0, [editor].concat(args));\n    },\n    after: function after$1() {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return after.apply(void 0, [editor].concat(args));\n    },\n    before: function before$1() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return before.apply(void 0, [editor].concat(args));\n    },\n    collapse: function collapse$1() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return collapse.apply(void 0, [editor].concat(args));\n    },\n    \"delete\": function _delete() {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return deleteText.apply(void 0, [editor].concat(args));\n    },\n    deselect: function deselect$1() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return deselect.apply(void 0, [editor].concat(args));\n    },\n    edges: function edges$1() {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return edges.apply(void 0, [editor].concat(args));\n    },\n    elementReadOnly: function elementReadOnly$1() {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return elementReadOnly.apply(void 0, [editor].concat(args));\n    },\n    end: function end$1() {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return end.apply(void 0, [editor].concat(args));\n    },\n    first: function first$1() {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return first.apply(void 0, [editor].concat(args));\n    },\n    fragment: function fragment$1() {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return fragment.apply(void 0, [editor].concat(args));\n    },\n    getMarks: function getMarks() {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return marks.apply(void 0, [editor].concat(args));\n    },\n    hasBlocks: function hasBlocks$1() {\n      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n        args[_key28] = arguments[_key28];\n      }\n      return hasBlocks.apply(void 0, [editor].concat(args));\n    },\n    hasInlines: function hasInlines$1() {\n      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n        args[_key29] = arguments[_key29];\n      }\n      return hasInlines.apply(void 0, [editor].concat(args));\n    },\n    hasPath: function hasPath$1() {\n      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n        args[_key30] = arguments[_key30];\n      }\n      return hasPath.apply(void 0, [editor].concat(args));\n    },\n    hasTexts: function hasTexts$1() {\n      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n        args[_key31] = arguments[_key31];\n      }\n      return hasTexts.apply(void 0, [editor].concat(args));\n    },\n    insertNodes: function insertNodes$1() {\n      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n        args[_key32] = arguments[_key32];\n      }\n      return insertNodes.apply(void 0, [editor].concat(args));\n    },\n    isBlock: function isBlock$1() {\n      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n        args[_key33] = arguments[_key33];\n      }\n      return isBlock.apply(void 0, [editor].concat(args));\n    },\n    isEdge: function isEdge$1() {\n      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n        args[_key34] = arguments[_key34];\n      }\n      return isEdge.apply(void 0, [editor].concat(args));\n    },\n    isEmpty: function isEmpty$1() {\n      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n        args[_key35] = arguments[_key35];\n      }\n      return isEmpty.apply(void 0, [editor].concat(args));\n    },\n    isEnd: function isEnd$1() {\n      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {\n        args[_key36] = arguments[_key36];\n      }\n      return isEnd.apply(void 0, [editor].concat(args));\n    },\n    isNormalizing: function isNormalizing$1() {\n      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {\n        args[_key37] = arguments[_key37];\n      }\n      return isNormalizing.apply(void 0, [editor].concat(args));\n    },\n    isStart: function isStart$1() {\n      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {\n        args[_key38] = arguments[_key38];\n      }\n      return isStart.apply(void 0, [editor].concat(args));\n    },\n    last: function last$1() {\n      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {\n        args[_key39] = arguments[_key39];\n      }\n      return last.apply(void 0, [editor].concat(args));\n    },\n    leaf: function leaf$1() {\n      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {\n        args[_key40] = arguments[_key40];\n      }\n      return leaf.apply(void 0, [editor].concat(args));\n    },\n    levels: function levels$1() {\n      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {\n        args[_key41] = arguments[_key41];\n      }\n      return levels.apply(void 0, [editor].concat(args));\n    },\n    liftNodes: function liftNodes$1() {\n      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {\n        args[_key42] = arguments[_key42];\n      }\n      return liftNodes.apply(void 0, [editor].concat(args));\n    },\n    mergeNodes: function mergeNodes$1() {\n      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {\n        args[_key43] = arguments[_key43];\n      }\n      return mergeNodes.apply(void 0, [editor].concat(args));\n    },\n    move: function move$1() {\n      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {\n        args[_key44] = arguments[_key44];\n      }\n      return move.apply(void 0, [editor].concat(args));\n    },\n    moveNodes: function moveNodes$1() {\n      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {\n        args[_key45] = arguments[_key45];\n      }\n      return moveNodes.apply(void 0, [editor].concat(args));\n    },\n    next: function next$1() {\n      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {\n        args[_key46] = arguments[_key46];\n      }\n      return next.apply(void 0, [editor].concat(args));\n    },\n    node: function node$1() {\n      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {\n        args[_key47] = arguments[_key47];\n      }\n      return node.apply(void 0, [editor].concat(args));\n    },\n    nodes: function nodes$1() {\n      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {\n        args[_key48] = arguments[_key48];\n      }\n      return nodes.apply(void 0, [editor].concat(args));\n    },\n    normalize: function normalize$1() {\n      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {\n        args[_key49] = arguments[_key49];\n      }\n      return normalize.apply(void 0, [editor].concat(args));\n    },\n    parent: function parent$1() {\n      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {\n        args[_key50] = arguments[_key50];\n      }\n      return parent.apply(void 0, [editor].concat(args));\n    },\n    path: function path$1() {\n      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {\n        args[_key51] = arguments[_key51];\n      }\n      return path.apply(void 0, [editor].concat(args));\n    },\n    pathRef: function pathRef$1() {\n      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {\n        args[_key52] = arguments[_key52];\n      }\n      return pathRef.apply(void 0, [editor].concat(args));\n    },\n    pathRefs: function pathRefs$1() {\n      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {\n        args[_key53] = arguments[_key53];\n      }\n      return pathRefs.apply(void 0, [editor].concat(args));\n    },\n    point: function point$1() {\n      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {\n        args[_key54] = arguments[_key54];\n      }\n      return point.apply(void 0, [editor].concat(args));\n    },\n    pointRef: function pointRef$1() {\n      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {\n        args[_key55] = arguments[_key55];\n      }\n      return pointRef.apply(void 0, [editor].concat(args));\n    },\n    pointRefs: function pointRefs$1() {\n      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {\n        args[_key56] = arguments[_key56];\n      }\n      return pointRefs.apply(void 0, [editor].concat(args));\n    },\n    positions: function positions$1() {\n      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {\n        args[_key57] = arguments[_key57];\n      }\n      return positions.apply(void 0, [editor].concat(args));\n    },\n    previous: function previous$1() {\n      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {\n        args[_key58] = arguments[_key58];\n      }\n      return previous.apply(void 0, [editor].concat(args));\n    },\n    range: function range$1() {\n      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {\n        args[_key59] = arguments[_key59];\n      }\n      return range.apply(void 0, [editor].concat(args));\n    },\n    rangeRef: function rangeRef$1() {\n      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {\n        args[_key60] = arguments[_key60];\n      }\n      return rangeRef.apply(void 0, [editor].concat(args));\n    },\n    rangeRefs: function rangeRefs$1() {\n      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {\n        args[_key61] = arguments[_key61];\n      }\n      return rangeRefs.apply(void 0, [editor].concat(args));\n    },\n    removeNodes: function removeNodes$1() {\n      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {\n        args[_key62] = arguments[_key62];\n      }\n      return removeNodes.apply(void 0, [editor].concat(args));\n    },\n    select: function select$1() {\n      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {\n        args[_key63] = arguments[_key63];\n      }\n      return select.apply(void 0, [editor].concat(args));\n    },\n    setNodes: function setNodes$1() {\n      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {\n        args[_key64] = arguments[_key64];\n      }\n      return setNodes.apply(void 0, [editor].concat(args));\n    },\n    setNormalizing: function setNormalizing$1() {\n      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {\n        args[_key65] = arguments[_key65];\n      }\n      return setNormalizing.apply(void 0, [editor].concat(args));\n    },\n    setPoint: function setPoint$1() {\n      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {\n        args[_key66] = arguments[_key66];\n      }\n      return setPoint.apply(void 0, [editor].concat(args));\n    },\n    setSelection: function setSelection$1() {\n      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {\n        args[_key67] = arguments[_key67];\n      }\n      return setSelection.apply(void 0, [editor].concat(args));\n    },\n    splitNodes: function splitNodes$1() {\n      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {\n        args[_key68] = arguments[_key68];\n      }\n      return splitNodes.apply(void 0, [editor].concat(args));\n    },\n    start: function start$1() {\n      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {\n        args[_key69] = arguments[_key69];\n      }\n      return start.apply(void 0, [editor].concat(args));\n    },\n    string: function string$1() {\n      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {\n        args[_key70] = arguments[_key70];\n      }\n      return string.apply(void 0, [editor].concat(args));\n    },\n    unhangRange: function unhangRange$1() {\n      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {\n        args[_key71] = arguments[_key71];\n      }\n      return unhangRange.apply(void 0, [editor].concat(args));\n    },\n    unsetNodes: function unsetNodes$1() {\n      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {\n        args[_key72] = arguments[_key72];\n      }\n      return unsetNodes.apply(void 0, [editor].concat(args));\n    },\n    unwrapNodes: function unwrapNodes$1() {\n      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {\n        args[_key73] = arguments[_key73];\n      }\n      return unwrapNodes.apply(void 0, [editor].concat(args));\n    },\n    \"void\": function _void() {\n      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {\n        args[_key74] = arguments[_key74];\n      }\n      return getVoid.apply(void 0, [editor].concat(args));\n    },\n    withoutNormalizing: function withoutNormalizing$1() {\n      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {\n        args[_key75] = arguments[_key75];\n      }\n      return withoutNormalizing.apply(void 0, [editor].concat(args));\n    },\n    wrapNodes: function wrapNodes$1() {\n      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {\n        args[_key76] = arguments[_key76];\n      }\n      return wrapNodes.apply(void 0, [editor].concat(args));\n    },\n    shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {\n      for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {\n        args[_key77] = arguments[_key77];\n      }\n      return shouldMergeNodesRemovePrevNode.apply(void 0, [editor].concat(args));\n    }\n  };\n  return editor;\n};\n\nexports.Editor = Editor;\nexports.Element = Element;\nexports.Location = Location;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Path = Path;\nexports.PathRef = PathRef;\nexports.Point = Point;\nexports.PointRef = PointRef;\nexports.Range = Range;\nexports.RangeRef = RangeRef;\nexports.Scrubber = Scrubber;\nexports.Span = Span;\nexports.Text = Text;\nexports.Transforms = Transforms;\nexports.above = above;\nexports.addMark = addMark;\nexports.after = after;\nexports.apply = apply;\nexports.before = before;\nexports.collapse = collapse;\nexports.createEditor = createEditor;\nexports.deleteBackward = deleteBackward;\nexports.deleteForward = deleteForward;\nexports.deleteFragment = deleteFragment;\nexports.deleteText = deleteText;\nexports.deselect = deselect;\nexports.edges = edges;\nexports.elementReadOnly = elementReadOnly;\nexports.end = end;\nexports.first = first;\nexports.fragment = fragment;\nexports.getDirtyPaths = getDirtyPaths;\nexports.getFragment = getFragment;\nexports.getVoid = getVoid;\nexports.hasBlocks = hasBlocks;\nexports.hasInlines = hasInlines;\nexports.hasPath = hasPath;\nexports.hasTexts = hasTexts;\nexports.insertBreak = insertBreak;\nexports.insertFragment = insertFragment;\nexports.insertNode = insertNode;\nexports.insertNodes = insertNodes;\nexports.insertSoftBreak = insertSoftBreak;\nexports.insertText = insertText;\nexports.isBlock = isBlock;\nexports.isEdge = isEdge;\nexports.isEditor = isEditor;\nexports.isEmpty = isEmpty;\nexports.isEnd = isEnd;\nexports.isNormalizing = isNormalizing;\nexports.isStart = isStart;\nexports.last = last;\nexports.leaf = leaf;\nexports.levels = levels;\nexports.liftNodes = liftNodes;\nexports.marks = marks;\nexports.mergeNodes = mergeNodes;\nexports.move = move;\nexports.moveNodes = moveNodes;\nexports.next = next;\nexports.node = node;\nexports.nodes = nodes;\nexports.normalize = normalize;\nexports.normalizeNode = normalizeNode;\nexports.parent = parent;\nexports.path = path;\nexports.pathRef = pathRef;\nexports.pathRefs = pathRefs;\nexports.point = point;\nexports.pointRef = pointRef;\nexports.pointRefs = pointRefs;\nexports.positions = positions;\nexports.previous = previous;\nexports.range = range;\nexports.rangeRef = rangeRef;\nexports.rangeRefs = rangeRefs;\nexports.removeMark = removeMark;\nexports.removeNodes = removeNodes;\nexports.select = select;\nexports.setNodes = setNodes;\nexports.setNormalizing = setNormalizing;\nexports.setPoint = setPoint;\nexports.setSelection = setSelection;\nexports.shouldMergeNodesRemovePrevNode = shouldMergeNodesRemovePrevNode;\nexports.shouldNormalize = shouldNormalize;\nexports.splitNodes = splitNodes;\nexports.start = start;\nexports.string = string;\nexports.unhangRange = unhangRange;\nexports.unsetNodes = unsetNodes;\nexports.unwrapNodes = unwrapNodes;\nexports.withoutNormalizing = withoutNormalizing;\nexports.wrapNodes = wrapNodes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NsYXRlQDAuMTEyLjAvbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsa0lBQWlCO0FBQzdDLFlBQVksbUJBQU8sQ0FBQywrRkFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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d0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDbGI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtB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aUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxH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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCxpRkFBaUYsV0FBVywwSEFBMEgsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVO0FBQ2o5QixvREFBb0QsZ0JBQWdCLGtFQUFrRSx3REFBd0QsNkRBQTZELHNEQUFzRDtBQUNqVCx5Q0FBeUMsdURBQXVELHVDQUF1QyxTQUFTLHVCQUF1QjtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJB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QUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixZQUFZO0FBQ1osZUFBZTtBQUNmLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLGVBQWU7QUFDZixhQUFhO0FBQ2IsYUFBYTtBQUNiLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QixXQUFXO0FBQ1gsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsWUFBWTtBQUNaLFlBQVk7QUFDWixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QsWUFBWTtBQUNaLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsc0NBQXNDO0FBQ3RDLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9zbGF0ZUAwLjExMi4wL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmplY3QnKTtcbnZhciBpbW1lciA9IHJlcXVpcmUoJ2ltbWVyJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBQYXRoUmVmID0ge1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudCxcbiAgICAgIGFmZmluaXR5ID0gcmVmLmFmZmluaXR5O1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhdGggPSBQYXRoLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBvaW50UmVmID0ge1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudCxcbiAgICAgIGFmZmluaXR5ID0gcmVmLmFmZmluaXR5O1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBvaW50O1xuICAgIGlmIChwb2ludCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBSYW5nZVJlZiA9IHtcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQsXG4gICAgICBhZmZpbml0eSA9IHJlZi5hZmZpbml0eTtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoID0gUmFuZ2UudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIERJUlRZX1BBVEhfS0VZUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRkxVU0hJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PUk1BTElaSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQQVRIX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBPSU5UX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFJBTkdFX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgYXJyYXlMaWtlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlMaWtlVG9BcnJheSk7XG5cbnZhciBhcnJheVdpdGhvdXRIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhvdXRIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhYmxlVG9BcnJheSk7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHModW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKG5vbkl0ZXJhYmxlU3ByZWFkKTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkgPSB1bndyYXBFeHBvcnRzKHRvQ29uc3VtYWJsZUFycmF5KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGggPSB7XG4gIGFuY2VzdG9yczogZnVuY3Rpb24gYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhzO1xuICB9LFxuICBjb21tb246IGZ1bmN0aW9uIGNvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGNvbW1vbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggJiYgaSA8IGFub3RoZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbW1vbi5wdXNoKGF2KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vbjtcbiAgfSxcbiAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHBhdGgubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgZW5kc0FmdGVyOiBmdW5jdGlvbiBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcbiAgZW5kc0F0OiBmdW5jdGlvbiBlbmRzQXQocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGg7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuICBlbmRzQmVmb3JlOiBmdW5jdGlvbiBlbmRzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2IDwgYnY7XG4gIH0sXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICYmIHBhdGguZXZlcnkoZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgIHJldHVybiBuID09PSBhbm90aGVyW2ldO1xuICAgIH0pO1xuICB9LFxuICBoYXNQcmV2aW91czogZnVuY3Rpb24gaGFzUHJldmlvdXMocGF0aCkge1xuICAgIHJldHVybiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPiAwO1xuICB9LFxuICBpc0FmdGVyOiBmdW5jdGlvbiBpc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAxO1xuICB9LFxuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiBpc0FuY2VzdG9yKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPCBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG4gIGlzQmVmb3JlOiBmdW5jdGlvbiBpc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggKyAxICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNDb21tb246IGZ1bmN0aW9uIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc0Rlc2NlbmRhbnQ6IGZ1bmN0aW9uIGlzRGVzY2VuZGFudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc1BhcmVudDogZnVuY3Rpb24gaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNQYXRoOiBmdW5jdGlvbiBpc1BhdGgodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKTtcbiAgfSxcbiAgaXNTaWJsaW5nOiBmdW5jdGlvbiBpc1NpYmxpbmcocGF0aCwgYW5vdGhlcikge1xuICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gYW5vdGhlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG4gIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UyID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UyO1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKHBhdGguc2xpY2UoMCwgaSkpO1xuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGlzdC5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gbmV4dCBpbmRleC5cIikpO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aDogZnVuY3Rpb24gb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgcGF0aCBvZiB0aGUgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcbiAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIHByZXZpb3VzIGluZGV4LlwiKSk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSBmaXJzdCBjaGlsZCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgd291bGQgcmVzdWx0IGluIGEgbmVnYXRpdmUgaW5kZXguXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0IC0gMSk7XG4gIH0sXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiByZWxhdGl2ZShwYXRoLCBhbmNlc3Rvcikge1xuICAgIGlmICghUGF0aC5pc0FuY2VzdG9yKGFuY2VzdG9yLCBwYXRoKSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgYW5jZXN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSByZWxhdGl2ZSBwYXRoIG9mIFtcIi5jb25jYXQocGF0aCwgXCJdIGluc2lkZSBhbmNlc3RvciBbXCIpLmNvbmNhdChhbmNlc3RvciwgXCJdLCBiZWNhdXNlIGl0IGlzIG5vdCBhYm92ZSBvciBlcXVhbCB0byB0aGUgcGF0aC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZShhbmNlc3Rvci5sZW5ndGgpO1xuICB9LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShwYXRoLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcbiAgICAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuICAgIHZhciBwID0gX3RvQ29uc3VtYWJsZUFycmF5KHBhdGgpO1xuICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgICAvLyBQRVJGOiBFeGl0IGVhcmx5IGlmIHRoZSBvcGVyYXRpb24gaXMgZ3VhcmFudGVlZCBub3QgdG8gaGF2ZSBhbiBlZmZlY3QuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG9wID0gb3BlcmF0aW9uLnBhdGg7XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUob3AsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvcCwgcCkpIHtcbiAgICAgICAgICAgIHBbb3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3AgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcDIgPSBvcGVyYXRpb24ucGF0aCxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gb3BlcmF0aW9uLnBvc2l0aW9uO1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AyLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDIsIHApKSB7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGhdICs9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wMyA9IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgX3Bvc2l0aW9uID0gb3BlcmF0aW9uLnBvc2l0aW9uO1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AzLCBwKSkge1xuICAgICAgICAgICAgaWYgKGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgcFtwLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnYmFja3dhcmQnKSA7IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AzLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMywgcCkgJiYgcGF0aFtfb3AzLmxlbmd0aF0gPj0gX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGhdIC09IF9wb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wNCA9IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgb25wID0gb3BlcmF0aW9uLm5ld1BhdGg7XG4gICAgICAgICAgLy8gSWYgdGhlIG9sZCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lLCBpdCdzIGEgbm8tb3AuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDQsIG9ucCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDQsIHApIHx8IFBhdGguZXF1YWxzKF9vcDQsIHApKSB7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ucC5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBvbnApICYmIF9vcDQubGVuZ3RoIDwgb25wLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb3B5W19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzU2libGluZyhfb3A0LCBvbnApICYmIChQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvbnAsIHApKSB7XG4gICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbn07XG5cbnZhciBfdHlwZW9mXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhfdHlwZW9mXzEpO1xuXG52YXIgdG9QcmltaXRpdmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgX3R5cGVvZiA9IF90eXBlb2ZfMVtcImRlZmF1bHRcIl07XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9QcmltaXRpdmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKHRvUHJpbWl0aXZlKTtcblxudmFyIHRvUHJvcGVydHlLZXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgX3R5cGVvZiA9IF90eXBlb2ZfMVtcImRlZmF1bHRcIl07XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9Qcm9wZXJ0eUtleSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHModG9Qcm9wZXJ0eUtleSk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gdW53cmFwRXhwb3J0cyhkZWZpbmVQcm9wZXJ0eSk7XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhpdGVyYWJsZVRvQXJyYXlMaW1pdCk7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhub25JdGVyYWJsZVJlc3QpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gdW53cmFwRXhwb3J0cyhzbGljZWRUb0FycmF5KTtcblxuZnVuY3Rpb24gb3duS2V5cyRlKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGUoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGUoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJG0obywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JG0obykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRtKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkbShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JG0obywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkbShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIGFwcGx5VG9EcmFmdCA9IGZ1bmN0aW9uIGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApIHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgcGF0aCA9IG9wLnBhdGgsXG4gICAgICAgICAgbm9kZSA9IG9wLm5vZGU7XG4gICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpbmRleCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gXFxcImluc2VydF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIG5vZGUuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRtKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW2tleV0gPSBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoID0gb3AucGF0aCxcbiAgICAgICAgICBvZmZzZXQgPSBvcC5vZmZzZXQsXG4gICAgICAgICAgdGV4dCA9IG9wLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIHZhciBfbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoKTtcbiAgICAgICAgdmFyIGJlZm9yZSA9IF9ub2RlLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuICAgICAgICBfbm9kZS50ZXh0ID0gYmVmb3JlICsgdGV4dCArIGFmdGVyO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRtKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgX3BvaW50ID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIF9rZXkgPSBfc3RlcDIkdmFsdWVbMV07XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDIgPSBvcC5wYXRoO1xuICAgICAgICB2YXIgX25vZGUyID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2ID0gTm9kZS5nZXQoZWRpdG9yLCBwcmV2UGF0aCk7XG4gICAgICAgIHZhciBfcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDIpO1xuICAgICAgICB2YXIgX2luZGV4ID0gX3BhdGgyW19wYXRoMi5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlMikgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICBwcmV2LnRleHQgKz0gX25vZGUyLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIVRleHQuaXNUZXh0KF9ub2RlMikgJiYgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgdmFyIF9wcmV2JGNoaWxkcmVuO1xuICAgICAgICAgIChfcHJldiRjaGlsZHJlbiA9IHByZXYuY2hpbGRyZW4pLnB1c2guYXBwbHkoX3ByZXYkY2hpbGRyZW4sIF90b0NvbnN1bWFibGVBcnJheShfbm9kZTIuY2hpbGRyZW4pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwibWVyZ2Vfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDIsIFwiXSB0byBub2RlcyBvZiBkaWZmZXJlbnQgaW50ZXJmYWNlczogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25vZGUyKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldikpKTtcbiAgICAgICAgfVxuICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRtKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgIF9zdGVwMztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgX3BvaW50MiA9IF9zdGVwMyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBfa2V5MiA9IF9zdGVwMyR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkyXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQyLCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDMgPSBvcC5wYXRoLFxuICAgICAgICAgIG5ld1BhdGggPSBvcC5uZXdQYXRoO1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBhIHBhdGggW1wiLmNvbmNhdChfcGF0aDMsIFwiXSB0byBuZXcgcGF0aCBbXCIpLmNvbmNhdChuZXdQYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgaW5zaWRlIGl0c2VsZi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbm9kZTMgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMyk7XG4gICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcbiAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIHNlY29uZCBzdGVwJ3MgcGF0aCBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGFwcGxpZWQuXG4gICAgICAgIF9wYXJlbnQyLmNoaWxkcmVuLnNwbGljZShfaW5kZXgyLCAxKTtcbiAgICAgICAgdmFyIHRydWVQYXRoID0gUGF0aC50cmFuc2Zvcm0oX3BhdGgzLCBvcCk7XG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBuZXdQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBfbm9kZTMpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRtKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgIF9zdGVwNDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgX3BvaW50MyA9IF9zdGVwNCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBfa2V5MyA9IF9zdGVwNCR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNCA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBfaW5kZXgzID0gX3BhdGg0W19wYXRoNC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIF9wYXJlbnQzID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDQpO1xuICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7XG4gICAgICAgIC8vIFRyYW5zZm9ybSBhbGwgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkbShSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICBfc3RlcDU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDUudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIF9wb2ludDQgPSBfc3RlcDUkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgX2tleTQgPSBfc3RlcDUkdmFsdWVbMV07XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgcmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTRdID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfcHJldiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJG0oTm9kZS50ZXh0cyhlZGl0b3IpKSxcbiAgICAgICAgICAgICAgICAgIF9zdGVwNjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgbiA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICBwID0gX3N0ZXA2JHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUGF0aC5jb21wYXJlKHAsIF9wYXRoNCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3ByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJlZmVyTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChfcHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMobmV4dFsxXSwgX3BhdGg0KSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gIVBhdGguaGFzUHJldmlvdXMobmV4dFsxXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gUGF0aC5jb21tb24oX3ByZXZbMV0sIF9wYXRoNCkubGVuZ3RoIDwgUGF0aC5jb21tb24obmV4dFsxXSwgX3BhdGg0KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfcHJldiAmJiAhcHJlZmVyTmV4dCkge1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gX3ByZXZbMV07XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IF9wcmV2WzBdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gbmV4dFsxXTtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGg1ID0gb3AucGF0aCxcbiAgICAgICAgICBfb2Zmc2V0ID0gb3Aub2Zmc2V0LFxuICAgICAgICAgIF90ZXh0ID0gb3AudGV4dDtcbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aDUpO1xuICAgICAgICB2YXIgX2JlZm9yZSA9IF9ub2RlNC50ZXh0LnNsaWNlKDAsIF9vZmZzZXQpO1xuICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU0LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Lmxlbmd0aCk7XG4gICAgICAgIF9ub2RlNC50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkbShSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICBfc3RlcDc7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDckdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDcudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIF9wb2ludDUgPSBfc3RlcDckdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgX2tleTUgPSBfc3RlcDckdmFsdWVbMV07XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NSwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDYgPSBvcC5wYXRoLFxuICAgICAgICAgIHByb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzLFxuICAgICAgICAgIG5ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX25vZGU1ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDYpO1xuICAgICAgICBmb3IgKHZhciBfa2V5NiBpbiBuZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKF9rZXk2ID09PSAnY2hpbGRyZW4nIHx8IF9rZXk2ID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIFxcXCJcIi5jb25jYXQoX2tleTYsIFwiXFxcIiBwcm9wZXJ0eSBvZiBub2RlcyFcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5Nl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ub2RlNVtfa2V5Nl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGVydGllcyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZpbmVkLCBidXQgYXJlIG5vdyBtaXNzaW5nLCBtdXN0IGJlIGRlbGV0ZWRcbiAgICAgICAgZm9yICh2YXIgX2tleTcgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGlmICghbmV3UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfa2V5NykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9uZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcbiAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3Rpb24gPSBfbmV3UHJvcGVydGllcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25ld1Byb3BlcnRpZXMpLCBcIiB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2VsZWN0aW9uLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkJGUoe30sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgX2tleTggaW4gX25ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBfdmFsdWUgPSBfbmV3UHJvcGVydGllc1tfa2V5OF07XG4gICAgICAgICAgICBpZiAoX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKF9rZXk4ID09PSAnYW5jaG9yJyB8fCBfa2V5OCA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIFxcXCJcIi5jb25jYXQoX2tleTgsIFwiXFxcIiBzZWxlY3Rpb24gcHJvcGVydHlcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25bX2tleThdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk4XSA9IF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDcgPSBvcC5wYXRoLFxuICAgICAgICAgIHBvc2l0aW9uID0gb3AucG9zaXRpb24sXG4gICAgICAgICAgX3Byb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJzcGxpdF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoNywgXCJdIGJlY2F1c2UgdGhlIHJvb3Qgbm9kZSBjYW5ub3QgYmUgc3BsaXQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX25vZGU2ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG4gICAgICAgIHZhciBfaW5kZXg0ID0gX3BhdGg3W19wYXRoNy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld05vZGU7XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTYpKSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU2LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAgIHZhciBfYWZ0ZXIyID0gX25vZGU2LnRleHQuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgIF9ub2RlNi50ZXh0ID0gX2JlZm9yZTI7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IF9hZnRlcjJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAgIHZhciBfYWZ0ZXIzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgICBfbm9kZTYuY2hpbGRyZW4gPSBfYmVmb3JlMztcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlcjNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfcGFyZW50NC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4NCArIDEsIDAsIG5ld05vZGUpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRtKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgIF9zdGVwODtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgX3BvaW50NiA9IF9zdGVwOCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBfa2V5OSA9IF9zdGVwOCR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBzZWxlY3Rpb247XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEdlbmVyYWxUcmFuc2Zvcm1zID0ge1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShlZGl0b3IsIG9wKSB7XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gaW1tZXIuY3JlYXRlRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBpbW1lci5jcmVhdGVEcmFmdChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICB0cnkge1xuICAgICAgc2VsZWN0aW9uID0gYXBwbHlUb0RyYWZ0KGVkaXRvciwgc2VsZWN0aW9uLCBvcCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5jaGlsZHJlbiA9IGltbWVyLmZpbmlzaERyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBpbW1lci5pc0RyYWZ0KHNlbGVjdGlvbikgPyBpbW1lci5maW5pc2hEcmFmdChzZWxlY3Rpb24pIDogc2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTm9kZVRyYW5zZm9ybXMgPSB7XG4gIGluc2VydE5vZGVzOiBmdW5jdGlvbiBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGVzKG5vZGVzLCBvcHRpb25zKTtcbiAgfSxcbiAgbGlmdE5vZGVzOiBmdW5jdGlvbiBsaWZ0Tm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmxpZnROb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgbWVyZ2VOb2RlczogZnVuY3Rpb24gbWVyZ2VOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubWVyZ2VOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgbW92ZU5vZGVzOiBmdW5jdGlvbiBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm1vdmVOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgcmVtb3ZlTm9kZXM6IGZ1bmN0aW9uIHJlbW92ZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5yZW1vdmVOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgc2V0Tm9kZXM6IGZ1bmN0aW9uIHNldE5vZGVzKGVkaXRvciwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iuc2V0Tm9kZXMocHJvcHMsIG9wdGlvbnMpO1xuICB9LFxuICBzcGxpdE5vZGVzOiBmdW5jdGlvbiBzcGxpdE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5zcGxpdE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICB1bnNldE5vZGVzOiBmdW5jdGlvbiB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW5zZXROb2Rlcyhwcm9wcywgb3B0aW9ucyk7XG4gIH0sXG4gIHVud3JhcE5vZGVzOiBmdW5jdGlvbiB1bndyYXBOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW53cmFwTm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIHdyYXBOb2RlczogZnVuY3Rpb24gd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci53cmFwTm9kZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBTZWxlY3Rpb25UcmFuc2Zvcm1zID0ge1xuICBjb2xsYXBzZTogZnVuY3Rpb24gY29sbGFwc2UoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmNvbGxhcHNlKG9wdGlvbnMpO1xuICB9LFxuICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmRlc2VsZWN0KCk7XG4gIH0sXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm1vdmUob3B0aW9ucyk7XG4gIH0sXG4gIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgZWRpdG9yLnNlbGVjdCh0YXJnZXQpO1xuICB9LFxuICBzZXRQb2ludDogZnVuY3Rpb24gc2V0UG9pbnQoZWRpdG9yLCBwcm9wcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5zZXRQb2ludChwcm9wcywgb3B0aW9ucyk7XG4gIH0sXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHByb3BzKTtcbiAgfVxufTtcblxuLypcbiAgQ3VzdG9tIGRlZXAgZXF1YWwgY29tcGFyaXNvbiBmb3IgU2xhdGUgbm9kZXMuXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxuICBDb21wbGV4IHZhbHVlcyBuZXN0ZWQgaW5zaWRlIEFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cbiAqL1xudmFyIGlzRGVlcEVxdWFsID0gZnVuY3Rpb24gaXNEZWVwRXF1YWwobm9kZSwgYW5vdGhlcikge1xuICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgIHZhciBhID0gbm9kZVtrZXldO1xuICAgIHZhciBiID0gYW5vdGhlcltrZXldO1xuICAgIGlmIChpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYSAhPT0gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKlxuICAgIERlZXAgb2JqZWN0IGVxdWFsaXR5IGlzIG9ubHkgbmVjZXNzYXJ5IGluIG9uZSBkaXJlY3Rpb247IGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxuICAgIHdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGtleXMgdGhhdCBhcmUgbWlzc2luZy5cbiAgICBBcyBhYm92ZSwgdW5kZWZpbmVkIGtleXMgYXJlIG5vcm1hbGlzZWQgdG8gbWlzc2luZy5cbiAgKi9cbiAgZm9yICh2YXIgX2tleSBpbiBhbm90aGVyKSB7XG4gICAgaWYgKG5vZGVbX2tleV0gPT09IHVuZGVmaW5lZCAmJiBhbm90aGVyW19rZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gdW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllcyk7XG5cbnZhciBfZXhjbHVkZWQkNCA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRkKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBSYW5nZSA9IHtcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG4gIGVuZDogZnVuY3Rpb24gZW5kKHJhbmdlKSB7XG4gICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICByZXR1cm4gZW5kO1xuICB9LFxuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhyYW5nZSwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocmFuZ2UuYW5jaG9yLCBhbm90aGVyLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKHJhbmdlLmZvY3VzLCBhbm90aGVyLmZvY3VzKTtcbiAgfSxcbiAgc3Vycm91bmRzOiBmdW5jdGlvbiBzdXJyb3VuZHMocmFuZ2UsIHRhcmdldCkge1xuICAgIHZhciBpbnRlcnNlY3Rpb25SYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgdGFyZ2V0KTtcbiAgICBpZiAoIWludGVyc2VjdGlvblJhbmdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBSYW5nZS5lcXVhbHMoaW50ZXJzZWN0aW9uUmFuZ2UsIHRhcmdldCk7XG4gIH0sXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgaWYgKFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuYW5jaG9yKSB8fCBSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmZvY3VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICAgIHJzID0gX1JhbmdlJGVkZ2VzNFswXSxcbiAgICAgICAgcmUgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuICAgICAgdmFyIF9SYW5nZSRlZGdlczUgPSBSYW5nZS5lZGdlcyh0YXJnZXQpLFxuICAgICAgICBfUmFuZ2UkZWRnZXM2ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNSwgMiksXG4gICAgICAgIHRzID0gX1JhbmdlJGVkZ2VzNlswXSxcbiAgICAgICAgdGUgPSBfUmFuZ2UkZWRnZXM2WzFdO1xuICAgICAgcmV0dXJuIFBvaW50LmlzQmVmb3JlKHJzLCB0cykgJiYgUG9pbnQuaXNBZnRlcihyZSwgdGUpO1xuICAgIH1cbiAgICB2YXIgX1JhbmdlJGVkZ2VzNyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgIF9SYW5nZSRlZGdlczggPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM3LCAyKSxcbiAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzOFswXSxcbiAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczhbMV07XG4gICAgdmFyIGlzQWZ0ZXJTdGFydCA9IGZhbHNlO1xuICAgIHZhciBpc0JlZm9yZUVuZCA9IGZhbHNlO1xuICAgIGlmIChQb2ludC5pc1BvaW50KHRhcmdldCkpIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBzdGFydCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIGVuZCkgPD0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUGF0aC5jb21wYXJlKHRhcmdldCwgc3RhcnQucGF0aCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUGF0aC5jb21wYXJlKHRhcmdldCwgZW5kLnBhdGgpIDw9IDA7XG4gICAgfVxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG4gIGludGVyc2VjdGlvbjogZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmFuZ2UuYW5jaG9yO1xuICAgICAgcmFuZ2UuZm9jdXM7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgX2V4Y2x1ZGVkJDQpO1xuICAgIHZhciBfUmFuZ2UkZWRnZXM5ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgX1JhbmdlJGVkZ2VzMTAgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM5LCAyKSxcbiAgICAgIHMxID0gX1JhbmdlJGVkZ2VzMTBbMF0sXG4gICAgICBlMSA9IF9SYW5nZSRlZGdlczEwWzFdO1xuICAgIHZhciBfUmFuZ2UkZWRnZXMxMSA9IFJhbmdlLmVkZ2VzKGFub3RoZXIpLFxuICAgICAgX1JhbmdlJGVkZ2VzMTIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMxMSwgMiksXG4gICAgICBzMiA9IF9SYW5nZSRlZGdlczEyWzBdLFxuICAgICAgZTIgPSBfUmFuZ2UkZWRnZXMxMlsxXTtcbiAgICB2YXIgc3RhcnQgPSBQb2ludC5pc0JlZm9yZShzMSwgczIpID8gczIgOiBzMTtcbiAgICB2YXIgZW5kID0gUG9pbnQuaXNCZWZvcmUoZTEsIGUyKSA/IGUxIDogZTI7XG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkZCh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcbiAgaXNCYWNrd2FyZDogZnVuY3Rpb24gaXNCYWNrd2FyZChyYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0NvbGxhcHNlZDogZnVuY3Rpb24gaXNDb2xsYXBzZWQocmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0V4cGFuZGVkOiBmdW5jdGlvbiBpc0V4cGFuZGVkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSk7XG4gIH0sXG4gIGlzRm9yd2FyZDogZnVuY3Rpb24gaXNGb3J3YXJkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgfSxcbiAgaXNSYW5nZTogZnVuY3Rpb24gaXNSYW5nZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcbiAgcG9pbnRzOiBmdW5jdGlvbiogcG9pbnRzKHJhbmdlKSB7XG4gICAgeWllbGQgW3JhbmdlLmFuY2hvciwgJ2FuY2hvciddO1xuICAgIHlpZWxkIFtyYW5nZS5mb2N1cywgJ2ZvY3VzJ107XG4gIH0sXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChyYW5nZSkge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMxMyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgIF9SYW5nZSRlZGdlczE0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMTMsIDEpLFxuICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMxNFswXTtcbiAgICByZXR1cm4gc3RhcnQ7XG4gIH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gaW1tZXIucHJvZHVjZShyYW5nZSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2lud2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICAgIHZhciBhZmZpbml0eUZvY3VzO1xuICAgICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAgIC8vIGF2b2lkIHRoZSB0d28gcG9pbnRzIHBhc3NpbmcgZWFjaCBvdGhlciBhbmQgZXhwYW5kaW5nIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocik7XG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdiYWNrd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2ZvcndhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnb3V0d2FyZCcpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2ZvcndhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnYmFja3dhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9IGFmZmluaXR5O1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gYWZmaW5pdHk7XG4gICAgICB9XG4gICAgICB2YXIgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHIuYW5jaG9yLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlBbmNob3JcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHIuZm9jdXMsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUZvY3VzXG4gICAgICB9KTtcbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHIuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgci5mb2N1cyA9IGZvY3VzO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcbiAqL1xudmFyIGlzRWxlbWVudCA9IGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pICYmICFFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBFbGVtZW50ID0ge1xuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiBpc0FuY2VzdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKTtcbiAgfSxcbiAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gIGlzRWxlbWVudExpc3Q6IGZ1bmN0aW9uIGlzRWxlbWVudExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbCk7XG4gICAgfSk7XG4gIH0sXG4gIGlzRWxlbWVudFByb3BzOiBmdW5jdGlvbiBpc0VsZW1lbnRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc0VsZW1lbnRUeXBlOiBmdW5jdGlvbiBpc0VsZW1lbnRUeXBlKHZhbHVlLCBlbGVtZW50VmFsKSB7XG4gICAgdmFyIGVsZW1lbnRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd0eXBlJztcbiAgICByZXR1cm4gaXNFbGVtZW50KHZhbHVlKSAmJiB2YWx1ZVtlbGVtZW50S2V5XSA9PT0gZWxlbWVudFZhbDtcbiAgfSxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiY2hpbGRyZW5cIl0sXG4gIF9leGNsdWRlZDIkMyA9IFtcInRleHRcIl07XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRsKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRsKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkbChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGwobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRsKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGwoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBJU19OT0RFX0xJU1RfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIE5vZGUgPSB7XG4gIGFuY2VzdG9yOiBmdW5jdGlvbiBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGFuY2VzdG9yIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIHRleHQgbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgYW5jZXN0b3JzOiBmdW5jdGlvbiBhbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRsKFBhdGguYW5jZXN0b3JzKHBhdGgsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIG4gPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHApO1xuICAgICAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgICAgICB5aWVsZCBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfSxcbiAgY2hpbGQ6IGZ1bmN0aW9uIGNoaWxkKHJvb3QsIGluZGV4KSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBjaGlsZCBvZiBhIHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgY2hpbGQgYXQgaW5kZXggYFwiLmNvbmNhdChpbmRleCwgXCJgIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9LFxuICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4ocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgICAgdmFyIGFuY2VzdG9yID0gTm9kZS5hbmNlc3Rvcihyb290LCBwYXRoKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGFuY2VzdG9yLmNoaWxkcmVuO1xuICAgICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IGNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgd2hpbGUgKHJldmVyc2UgPyBpbmRleCA+PSAwIDogaW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5jb25jYXQoaW5kZXgpO1xuICAgICAgICB5aWVsZCBbY2hpbGQsIGNoaWxkUGF0aF07XG4gICAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIGNvbW1vbjogZnVuY3Rpb24gY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcbiAgZGVzY2VuZGFudDogZnVuY3Rpb24gZGVzY2VuZGFudChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcbiAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBkZXNjZW5kYW50IG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byB0aGUgcm9vdCBlZGl0b3Igbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGwoTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgdG8gY29lcmNlIGhlcmUgYmVjYXVzZSBjaGVja2luZyB0aGUgcGF0aCdzIGxlbmd0aCBkb2VzXG4gICAgICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfSxcbiAgZWxlbWVudHM6IGZ1bmN0aW9uIGVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGwoTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwMztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwMyR2YWx1ZVsxXTtcbiAgICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgIH0oKTtcbiAgfSxcbiAgZXh0cmFjdFByb3BzOiBmdW5jdGlvbiBleHRyYWN0UHJvcHMobm9kZSkge1xuICAgIGlmIChFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW47XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCQzKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnRleHQ7XG4gICAgICAgIHZhciBfcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDMpO1xuICAgICAgcmV0dXJuIF9wcm9wZXJ0aWVzO1xuICAgIH1cbiAgfSxcbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQocm9vdCwgcmFuZ2UpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgYSBmcmFnbWVudCBzdGFydGluZyBmcm9tIGEgcm9vdCB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgdmFyIG5ld1Jvb3QgPSBpbW1lci5wcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKHIsIHtcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgcGFzczogZnVuY3Rpb24gcGFzcyhfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBwYXRoID0gX3JlZjJbMV07XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRsKG5vZGVFbnRyaWVzKSxcbiAgICAgICAgX3N0ZXA0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDQkdmFsdWVbMV07XG4gICAgICAgICAgaWYgKCFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcbiAgICAgICAgICAgIGxlYWYudGV4dCA9IGxlYWYudGV4dC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgX2xlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgICBfbGVhZi50ZXh0ID0gX2xlYWYudGV4dC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXRJZihyb290LCBwYXRoKTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRlc2NlbmRhbnQgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgZ2V0SWY6IGZ1bmN0aW9uIGdldElmKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gVGV4dC5pc1RleHQodmFsdWUpIHx8IEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSB8fCBFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xuICB9LFxuICBpc05vZGVMaXN0OiBmdW5jdGlvbiBpc05vZGVMaXN0KHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIH1cbiAgICB2YXIgaXNOb2RlTGlzdCA9IHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBOb2RlLmlzTm9kZSh2YWwpO1xuICAgIH0pO1xuICAgIElTX05PREVfTElTVF9DQUNIRS5zZXQodmFsdWUsIGlzTm9kZUxpc3QpO1xuICAgIHJldHVybiBpc05vZGVMaXN0O1xuICB9LFxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5baV07XG4gICAgICAgIHAucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcbiAgbGVhZjogZnVuY3Rpb24gbGVhZihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBsZXZlbHM6IGZ1bmN0aW9uIGxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRsKFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXA1O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKG5vZGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50UHJvcHMocHJvcHMpICYmIEVsZW1lbnQubWF0Y2hlcyhub2RlLCBwcm9wcykgfHwgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHRQcm9wcyhwcm9wcykgJiYgVGV4dC5tYXRjaGVzKG5vZGUsIHByb3BzKTtcbiAgfSxcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgcGFzcyA9IG9wdGlvbnMucGFzcyxcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZTIgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlMjtcbiAgICAgIHZhciBfb3B0aW9ucyRmcm9tID0gb3B0aW9ucy5mcm9tLFxuICAgICAgICBmcm9tID0gX29wdGlvbnMkZnJvbSA9PT0gdm9pZCAwID8gW10gOiBfb3B0aW9ucyRmcm9tLFxuICAgICAgICB0byA9IG9wdGlvbnMudG87XG4gICAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgIHZhciBwID0gW107XG4gICAgICB2YXIgbiA9IHJvb3Q7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodG8gJiYgKHJldmVyc2UgPyBQYXRoLmlzQmVmb3JlKHAsIHRvKSA6IFBhdGguaXNBZnRlcihwLCB0bykpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuKSkge1xuICAgICAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pICYmICFUZXh0LmlzVGV4dChuKSAmJiBuLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAocGFzcyA9PSBudWxsIHx8IHBhc3MoW24sIHBdKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgICAgdmFyIG5leHRJbmRleCA9IHJldmVyc2UgPyBuLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IocCwgZnJvbSkpIHtcbiAgICAgICAgICAgIG5leHRJbmRleCA9IGZyb21bcC5sZW5ndGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG4gICAgICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIGZvcndhcmQuLi5cbiAgICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLm5leHQocCk7XG4gICAgICAgICAgaWYgKE5vZGUuaGFzKHJvb3QsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICBwID0gbmV3UGF0aDtcbiAgICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuICAgICAgICBpZiAocmV2ZXJzZSAmJiBwW3AubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuICAgICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuICAgICAgICBwID0gUGF0aC5wYXJlbnQocCk7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChyb290LCBwYXRoKSB7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgcCA9IE5vZGUuZ2V0KHJvb3QsIHBhcmVudFBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcobm9kZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKE5vZGUuc3RyaW5nKS5qb2luKCcnKTtcbiAgICB9XG4gIH0sXG4gIHRleHRzOiBmdW5jdGlvbiB0ZXh0cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRsKE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDY7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDYkdmFsdWVbMV07XG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkYyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGMoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRjKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRjKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgT3BlcmF0aW9uID0ge1xuICBpc05vZGVPcGVyYXRpb246IGZ1bmN0aW9uIGlzTm9kZU9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ19ub2RlJyk7XG4gIH0sXG4gIGlzT3BlcmF0aW9uOiBmdW5jdGlvbiBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5uZXdQYXRoKTtcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gdmFsdWUucHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLm5ld1Byb3BlcnRpZXMpIHx8IHZhbHVlLm5ld1Byb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5wcm9wZXJ0aWVzKSB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm5ld1Byb3BlcnRpZXMpO1xuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGlzT3BlcmF0aW9uTGlzdDogZnVuY3Rpb24gaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKTtcbiAgICB9KTtcbiAgfSxcbiAgaXNTZWxlY3Rpb25PcGVyYXRpb246IGZ1bmN0aW9uIGlzU2VsZWN0aW9uT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3NlbGVjdGlvbicpO1xuICB9LFxuICBpc1RleHRPcGVyYXRpb246IGZ1bmN0aW9uIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG4gIGludmVyc2U6IGZ1bmN0aW9uIGludmVyc2Uob3ApIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gb3AubmV3UGF0aCxcbiAgICAgICAgICAgIHBhdGggPSBvcC5wYXRoO1xuICAgICAgICAgIC8vIFBFUkY6IGluIHRoaXMgY2FzZSB0aGUgbW92ZSBvcGVyYXRpb24gaXMgYSBuby1vcCBhbnl3YXlzLlxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgbW92ZSBoYXBwZW5zIGNvbXBsZXRlbHkgd2l0aGluIGEgc2luZ2xlIHBhcmVudCB0aGUgcGF0aCBhbmRcbiAgICAgICAgICAvLyBuZXdQYXRoIGFyZSBzdGFibGUgd2l0aCByZXNwZWN0IHRvIGVhY2ggb3RoZXIuXG4gICAgICAgICAgaWYgKFBhdGguaXNTaWJsaW5nKHBhdGgsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgICAgICBuZXdQYXRoOiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuICAgICAgICAgIHZhciBpbnZlcnNlUGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgICAgICB2YXIgaW52ZXJzZU5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShQYXRoLm5leHQocGF0aCksIG9wKTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcGF0aDogaW52ZXJzZVBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoOiBpbnZlcnNlTmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcHJvcGVydGllczogbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Byb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgX25ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuICAgICAgICAgIGlmIChfcHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIElTX0VESVRPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgaXNFZGl0b3IgPSBmdW5jdGlvbiBpc0VkaXRvcih2YWx1ZSkge1xuICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcbiAgaWYgKGNhY2hlZElzRWRpdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpc0VkaXRvciA9IHR5cGVvZiB2YWx1ZS5hZGRNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5hcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRTb2Z0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRUZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc0VsZW1lbnRSZWFkT25seSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNJbmxpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzU2VsZWN0YWJsZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNWb2lkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5ub3JtYWxpemVOb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUucmVtb3ZlTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZ2V0RGlydHlQYXRocyA9PT0gJ2Z1bmN0aW9uJyAmJiAodmFsdWUubWFya3MgPT09IG51bGwgfHwgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgSVNfRURJVE9SX0NBQ0hFLnNldCh2YWx1ZSwgaXNFZGl0b3IpO1xuICByZXR1cm4gaXNFZGl0b3I7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgRWRpdG9yID0ge1xuICBhYm92ZTogZnVuY3Rpb24gYWJvdmUoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5hYm92ZShvcHRpb25zKTtcbiAgfSxcbiAgYWRkTWFyazogZnVuY3Rpb24gYWRkTWFyayhlZGl0b3IsIGtleSwgdmFsdWUpIHtcbiAgICBlZGl0b3IuYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfSxcbiAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmFmdGVyKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYmVmb3JlKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgZGVsZXRlQmFja3dhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQ7XG4gICAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9LFxuICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdW5pdDIgPSBvcHRpb25zLnVuaXQsXG4gICAgICB1bml0ID0gX29wdGlvbnMkdW5pdDIgPT09IHZvaWQgMCA/ICdjaGFyYWN0ZXInIDogX29wdGlvbnMkdW5pdDI7XG4gICAgZWRpdG9yLmRlbGV0ZUZvcndhcmQodW5pdCk7XG4gIH0sXG4gIGRlbGV0ZUZyYWdtZW50OiBmdW5jdGlvbiBkZWxldGVGcmFnbWVudChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuZGVsZXRlRnJhZ21lbnQob3B0aW9ucyk7XG4gIH0sXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5lZGdlcyhhdCk7XG4gIH0sXG4gIGVsZW1lbnRSZWFkT25seTogZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZWRpdG9yLmVsZW1lbnRSZWFkT25seShvcHRpb25zKTtcbiAgfSxcbiAgZW5kOiBmdW5jdGlvbiBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZW5kKGF0KTtcbiAgfSxcbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmZpcnN0KGF0KTtcbiAgfSxcbiAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmZyYWdtZW50KGF0KTtcbiAgfSxcbiAgaGFzQmxvY2tzOiBmdW5jdGlvbiBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNCbG9ja3MoZWxlbWVudCk7XG4gIH0sXG4gIGhhc0lubGluZXM6IGZ1bmN0aW9uIGhhc0lubGluZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNJbmxpbmVzKGVsZW1lbnQpO1xuICB9LFxuICBoYXNQYXRoOiBmdW5jdGlvbiBoYXNQYXRoKGVkaXRvciwgcGF0aCkge1xuICAgIHJldHVybiBlZGl0b3IuaGFzUGF0aChwYXRoKTtcbiAgfSxcbiAgaGFzVGV4dHM6IGZ1bmN0aW9uIGhhc1RleHRzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaGFzVGV4dHMoZWxlbWVudCk7XG4gIH0sXG4gIGluc2VydEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICB9LFxuICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuICBpbnNlcnRTb2Z0QnJlYWs6IGZ1bmN0aW9uIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG4gIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG4gIGlzQmxvY2s6IGZ1bmN0aW9uIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNCbG9jayh2YWx1ZSk7XG4gIH0sXG4gIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VkZ2UocG9pbnQsIGF0KTtcbiAgfSxcbiAgaXNFZGl0b3I6IGZ1bmN0aW9uIGlzRWRpdG9yJDEodmFsdWUpIHtcbiAgICByZXR1cm4gaXNFZGl0b3IodmFsdWUpO1xuICB9LFxuICBpc0VsZW1lbnRSZWFkT25seTogZnVuY3Rpb24gaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlbGVtZW50KTtcbiAgfSxcbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoZWxlbWVudCk7XG4gIH0sXG4gIGlzRW5kOiBmdW5jdGlvbiBpc0VuZChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFbmQocG9pbnQsIGF0KTtcbiAgfSxcbiAgaXNJbmxpbmU6IGZ1bmN0aW9uIGlzSW5saW5lKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbiAgfSxcbiAgaXNOb3JtYWxpemluZzogZnVuY3Rpb24gaXNOb3JtYWxpemluZyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzTm9ybWFsaXppbmcoKTtcbiAgfSxcbiAgaXNTZWxlY3RhYmxlOiBmdW5jdGlvbiBpc1NlbGVjdGFibGUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNTZWxlY3RhYmxlKHZhbHVlKTtcbiAgfSxcbiAgaXNTdGFydDogZnVuY3Rpb24gaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNTdGFydChwb2ludCwgYXQpO1xuICB9LFxuICBpc1ZvaWQ6IGZ1bmN0aW9uIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1ZvaWQodmFsdWUpO1xuICB9LFxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhc3QoYXQpO1xuICB9LFxuICBsZWFmOiBmdW5jdGlvbiBsZWFmKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxlYWYoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBsZXZlbHM6IGZ1bmN0aW9uIGxldmVscyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxldmVscyhvcHRpb25zKTtcbiAgfSxcbiAgbWFya3M6IGZ1bmN0aW9uIG1hcmtzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuZ2V0TWFya3MoKTtcbiAgfSxcbiAgbmV4dDogZnVuY3Rpb24gbmV4dChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLm5leHQob3B0aW9ucyk7XG4gIH0sXG4gIG5vZGU6IGZ1bmN0aW9uIG5vZGUoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZShhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLm5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iubm9ybWFsaXplKG9wdGlvbnMpO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXJlbnQoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXRoOiBmdW5jdGlvbiBwYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhdGgoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXRoUmVmOiBmdW5jdGlvbiBwYXRoUmVmKGVkaXRvciwgcGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGF0aFJlZihwYXRoLCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aFJlZnM6IGZ1bmN0aW9uIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucGF0aFJlZnMoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uIHBvaW50KGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50KGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgcG9pbnRSZWY6IGZ1bmN0aW9uIHBvaW50UmVmKGVkaXRvciwgcG9pbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50UmVmKHBvaW50LCBvcHRpb25zKTtcbiAgfSxcbiAgcG9pbnRSZWZzOiBmdW5jdGlvbiBwb2ludFJlZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb2ludFJlZnMoKTtcbiAgfSxcbiAgcG9zaXRpb25zOiBmdW5jdGlvbiBwb3NpdGlvbnMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb3NpdGlvbnMob3B0aW9ucyk7XG4gIH0sXG4gIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnByZXZpb3VzKG9wdGlvbnMpO1xuICB9LFxuICByYW5nZTogZnVuY3Rpb24gcmFuZ2UoZWRpdG9yLCBhdCwgdG8pIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlKGF0LCB0byk7XG4gIH0sXG4gIHJhbmdlUmVmOiBmdW5jdGlvbiByYW5nZVJlZihlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZVJlZihyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlUmVmczogZnVuY3Rpb24gcmFuZ2VSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucmFuZ2VSZWZzKCk7XG4gIH0sXG4gIHJlbW92ZU1hcms6IGZ1bmN0aW9uIHJlbW92ZU1hcmsoZWRpdG9yLCBrZXkpIHtcbiAgICBlZGl0b3IucmVtb3ZlTWFyayhrZXkpO1xuICB9LFxuICBzZXROb3JtYWxpemluZzogZnVuY3Rpb24gc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSB7XG4gICAgZWRpdG9yLnNldE5vcm1hbGl6aW5nKGlzTm9ybWFsaXppbmcpO1xuICB9LFxuICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3Iuc3RhcnQoYXQpO1xuICB9LFxuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdHJpbmcoYXQsIG9wdGlvbnMpO1xuICB9LFxuICB1bmhhbmdSYW5nZTogZnVuY3Rpb24gdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IudW5oYW5nUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICB9LFxuICBcInZvaWRcIjogZnVuY3Rpb24gX3ZvaWQoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvcltcInZvaWRcIl0ob3B0aW9ucyk7XG4gIH0sXG4gIHdpdGhvdXROb3JtYWxpemluZzogZnVuY3Rpb24gd2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZm4pIHtcbiAgICBlZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGZuKTtcbiAgfSxcbiAgc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlOiBmdW5jdGlvbiBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUoZWRpdG9yLCBwcmV2Tm9kZSwgY3VyTm9kZSkge1xuICAgIHJldHVybiBlZGl0b3Iuc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlKHByZXZOb2RlLCBjdXJOb2RlKTtcbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIExvY2F0aW9uID0ge1xuICBpc0xvY2F0aW9uOiBmdW5jdGlvbiBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBTcGFuID0ge1xuICBpc1NwYW46IGZ1bmN0aW9uIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRiKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBvaW50ID0ge1xuICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBpc0FmdGVyOiBmdW5jdGlvbiBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuICBpc0JlZm9yZTogZnVuY3Rpb24gaXNCZWZvcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhwb2ludCwgYW5vdGhlcikge1xuICAgIC8vIFBFUkY6IGVuc3VyZSB0aGUgb2Zmc2V0cyBhcmUgZXF1YWwgZmlyc3Qgc2luY2UgdGhleSBhcmUgY2hlYXBlciB0byBjaGVjay5cbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBhbm90aGVyLm9mZnNldCAmJiBQYXRoLmVxdWFscyhwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICB9LFxuICBpc1BvaW50OiBmdW5jdGlvbiBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG4gIH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHBvaW50LCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gaW1tZXIucHJvZHVjZShwb2ludCwgZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7XG4gICAgICB2YXIgcGF0aCA9IHAucGF0aCxcbiAgICAgICAgb2Zmc2V0ID0gcC5vZmZzZXQ7XG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiAob3Aub2Zmc2V0IDwgb2Zmc2V0IHx8IG9wLm9mZnNldCA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgb3Aub2Zmc2V0IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICBwLm9mZnNldCAtPSBNYXRoLm1pbihvZmZzZXQgLSBvcC5vZmZzZXQsIG9wLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBpZiAob3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AucG9zaXRpb24gPCBvZmZzZXQgfHwgb3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgICAgcC5vZmZzZXQgLT0gb3AucG9zaXRpb247XG4gICAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBUaGlzIGludGVyZmFjZSBpbXBsZW1lbnRzIGEgc3RyaW5naWZ5KCkgZnVuY3Rpb24sIHdoaWNoIGlzIHVzZWQgYnkgU2xhdGVcbiAqIGludGVybmFsbHkgd2hlbiBnZW5lcmF0aW5nIGV4Y2VwdGlvbnMgY29udGFpbmluZyBlbmQgdXNlciBkYXRhLiBEZXZlbG9wZXJzXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXG4gKiBzdHJpbmdpZnkoKSBmdW5jdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XG4gKlxuICogICAgaW1wb3J0IHsgU2NydWJiZXIgfSBmcm9tICdzbGF0ZSc7XG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcbiAqICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSByZXR1cm4gJy4uLnNjcnViYmVkLi4uJ1xuICogICAgICByZXR1cm4gdmFsXG4gKiAgICB9KTtcbiAqXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXI6IGZ1bmN0aW9uIHNldFNjcnViYmVyKHNjcnViYmVyKSB7XG4gICAgX3NjcnViYmVyID0gc2NydWJiZXI7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBfc2NydWJiZXIpO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJ0ZXh0XCJdLFxuICBfZXhjbHVkZWQyJDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiLCBcIm1lcmdlXCJdO1xuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkayhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkayhvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGsobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRrKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkayhvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRrKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBvd25LZXlzJGEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRhKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFRleHQgPSB7XG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHRleHQsIGFub3RoZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGxvb3NlID0gb3B0aW9ucy5sb29zZSxcbiAgICAgIGxvb3NlID0gX29wdGlvbnMkbG9vc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkbG9vc2U7XG4gICAgZnVuY3Rpb24gb21pdFRleHQob2JqKSB7XG4gICAgICBvYmoudGV4dDtcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBfZXhjbHVkZWQkMik7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG4gIGlzVGV4dDogZnVuY3Rpb24gaXNUZXh0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc1RleHRMaXN0OiBmdW5jdGlvbiBpc1RleHRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBUZXh0LmlzVGV4dCh2YWwpO1xuICAgIH0pO1xuICB9LFxuICBpc1RleHRQcm9wczogZnVuY3Rpb24gaXNUZXh0UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dCAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKHRleHQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRleHQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0ZXh0W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVjb3JhdGlvbnM6IGZ1bmN0aW9uIGRlY29yYXRpb25zKG5vZGUsIF9kZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbX29iamVjdFNwcmVhZCRhKHt9LCBub2RlKV07XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGsoX2RlY29yYXRpb25zKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgZGVjID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBhbmNob3IgPSBkZWMuYW5jaG9yLFxuICAgICAgICAgIGZvY3VzID0gZGVjLmZvY3VzLFxuICAgICAgICAgIG1lcmdlRGVjb3JhdGlvbiA9IGRlYy5tZXJnZSxcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGRlYywgX2V4Y2x1ZGVkMiQyKTtcbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGRlYyksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICAgIHZhciBsZWFmRW5kID0gMDtcbiAgICAgICAgdmFyIGRlY29yYXRpb25TdGFydCA9IHN0YXJ0Lm9mZnNldDtcbiAgICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuICAgICAgICB2YXIgbWVyZ2UgPSBtZXJnZURlY29yYXRpb24gIT09IG51bGwgJiYgbWVyZ2VEZWNvcmF0aW9uICE9PSB2b2lkIDAgPyBtZXJnZURlY29yYXRpb24gOiBPYmplY3QuYXNzaWduO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGsobGVhdmVzKSxcbiAgICAgICAgICBfc3RlcDI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsZWFmID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxlYWYudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgICAgIGxlYWZFbmQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGVuY29tcGFzc2VzIHRoZSBlbnRpcmUgbGVhZiwgYWRkIHRoZSByYW5nZS5cbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPD0gbGVhZlN0YXJ0ICYmIGxlYWZFbmQgPD0gZGVjb3JhdGlvbkVuZCkge1xuICAgICAgICAgICAgICBtZXJnZShsZWFmLCByZXN0KTtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSByYW5nZSBleHBhbmRlZCBhbmQgbWF0Y2ggdGhlIGxlYWYsIG9yIHN0YXJ0cyBhZnRlciwgb3IgZW5kcyBiZWZvcmUgaXQsIGNvbnRpbnVlLlxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCAhPT0gZGVjb3JhdGlvbkVuZCAmJiAoZGVjb3JhdGlvblN0YXJ0ID09PSBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCkgfHwgZGVjb3JhdGlvblN0YXJ0ID4gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kIDwgbGVhZlN0YXJ0IHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCAmJiBsZWFmU3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBsZWFmLCBhdCB0aGUgc3RhcnQsIGVuZCwgb3IgYm90aCxcbiAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgICAgIC8vIHNwbGl0IGZpcnN0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBvZmZzZXQgdGhhdCB3YXkuXG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gbGVhZjtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvbkVuZCA8IGxlYWZFbmQpIHtcbiAgICAgICAgICAgICAgdmFyIG9mZiA9IGRlY29yYXRpb25FbmQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgICAgIGFmdGVyID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShvZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIG9mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ID4gbGVhZlN0YXJ0KSB7XG4gICAgICAgICAgICAgIHZhciBfb2ZmID0gZGVjb3JhdGlvblN0YXJ0IC0gbGVhZlN0YXJ0O1xuICAgICAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIF9vZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKF9vZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2UobWlkZGxlLCByZXN0KTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcbiAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIHJldHVybiBsZWF2ZXM7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGxvY2F0aW9uIHRvIGluc2VydCBjb250ZW50IGludG8gdGhlIGVkaXRvci5cbiAqIEJ5IGRlZmF1bHQsIHVzZSB0aGUgc2VsZWN0aW9uIGFzIHRoZSB0YXJnZXQgbG9jYXRpb24uIEJ1dCBpZiB0aGVyZSBpc1xuICogbm8gc2VsZWN0aW9uLCBpbnNlcnQgYXQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQgc2luY2UgdGhhdCBpcyBzdWNoIGFcbiAqIGNvbW1vbiB1c2UgY2FzZSB3aGVuIGluc2VydGluZyBmcm9tIGEgbm9uLXNlbGVjdGVkIHN0YXRlLlxuICovXG52YXIgZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uKGVkaXRvcikge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIHJldHVybiBlZGl0b3Iuc2VsZWN0aW9uO1xuICB9IGVsc2UgaWYgKGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFswXTtcbiAgfVxufTtcblxudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgdmFyIF9FZGl0b3Ikbm9kZSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCksXG4gICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF07XG4gIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuID09PSBub2RlO1xuICB9O1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkaihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGoobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRqKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkaihvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRqKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG4vLyBDaGFyYWN0ZXIgKGdyYXBoZW1lIGNsdXN0ZXIpIGJvdW5kYXJpZXMgYXJlIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXG4vLyB0aGUgZGVmYXVsdCBncmFwaGVtZSBjbHVzdGVyIGJvdW5kYXJ5IHNwZWNpZmljYXRpb24sIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzIHZhcmlhbnRbMV0uXG4vL1xuLy8gUmVmZXJlbmNlczpcbi8vXG4vLyBbMV0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNEZWZhdWx0X0dyYXBoZW1lX0NsdXN0ZXJfVGFibGVcbi8vIFsyXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHRcbi8vIFszXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0Lmh0bWxcbi8vIFs0XSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LnR4dFxuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxuICovXG52YXIgZ2V0Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJEaXN0YW5jZShzdHIpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGlzTFRSID0gIWlzUlRMO1xuICB2YXIgY29kZXBvaW50cyA9IGlzUlRMID8gY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikgOiBzdHI7XG4gIHZhciBsZWZ0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgcmlnaHQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciBkaXN0YW5jZSA9IDA7XG4gIC8vIEV2YWx1YXRpb24gb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgZGVmZXJyZWQuXG4gIHZhciBnYjExID0gbnVsbDsgLy8gSXMgR0IxMSBhcHBsaWNhYmxlP1xuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGooY29kZXBvaW50cyksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfY2hhciA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIGNvZGUgPSBfY2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIGlmICghY29kZSkgYnJlYWs7XG4gICAgICB2YXIgdHlwZSA9IGdldENvZGVwb2ludFR5cGUoX2NoYXIsIGNvZGUpO1xuICAgICAgdmFyIF9yZWYgPSBpc0xUUiA/IFtyaWdodCwgdHlwZV0gOiBbdHlwZSwgbGVmdF07XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcbiAgICAgIGxlZnQgPSBfcmVmMlswXTtcbiAgICAgIHJpZ2h0ID0gX3JlZjJbMV07XG4gICAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlpXSikgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5FeHRQaWN0KSkge1xuICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIGRpc3RhbmNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdiMTEpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5SSSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5SSSkpIHtcbiAgICAgICAgaWYgKGdiMTJPcjEzICE9PSBudWxsKSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSAhZ2IxMk9yMTM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgICAgICBnYjEyT3IxMyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdiMTJPcjEzID0gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdiMTJPcjEzKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgcmlnaHQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkaXN0YW5jZSArPSBfY2hhci5sZW5ndGg7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbiAgcmV0dXJuIGRpc3RhbmNlIHx8IDE7XG59O1xudmFyIFNQQUNFID0gL1xccy87XG52YXIgUFVOQ1RVQVRJT04gPSAvW1xcdTAwMkJcXHUwMDIxLVxcdTAwMjNcXHUwMDI1LVxcdTAwMkFcXHUwMDJDLVxcdTAwMkZcXHUwMDNBXFx1MDAzQlxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVEXFx1MDA1RlxcdTAwN0JcXHUwMDdEXFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTNCXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS87XG52YXIgQ0hBTUVMRU9OID0gL1snXFx1MjAxOFxcdTIwMTldLztcbi8qKlxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgc3RyaW5nIG9mIHRleHQuXG4gKi9cbnZhciBnZXRXb3JkRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRXb3JkRGlzdGFuY2UodGV4dCkge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgZGlzdCA9IDA7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG4gIHdoaWxlICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBpc1JUTCk7XG4gICAgdmFyIF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpLFxuICAgICAgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MiA9IF9zbGljZWRUb0FycmF5KF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdCwgMiksXG4gICAgICBfY2hhcjIgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3QyWzBdLFxuICAgICAgcmVtYWluaW5nID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MlsxXTtcbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKF9jaGFyMiwgcmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydGVkKSB7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGV4dCA9IHJlbWFpbmluZztcbiAgfVxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcbiAqIFNwbGl0IGEgc3RyaW5nIGluIHR3byBwYXJ0cyBhdCBhIGdpdmVuIGRpc3RhbmNlIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCB3aGVuXG4gKiBgaXNSVExgIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbnZhciBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2Uoc3RyLCBkaXN0LCBpc1JUTCkge1xuICBpZiAoaXNSVEwpIHtcbiAgICB2YXIgYXQgPSBzdHIubGVuZ3RoIC0gZGlzdDtcbiAgICByZXR1cm4gW3N0ci5zbGljZShhdCwgc3RyLmxlbmd0aCksIHN0ci5zbGljZSgwLCBhdCldO1xuICB9XG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGRpc3QpLCBzdHIuc2xpY2UoZGlzdCldO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcbiAqIGJlY2F1c2Ugc29tZXRpbWVzIHlvdSBtdXN0IHJlYWQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzIHRvIHRydWx5IGRldGVybWluZSBpdC5cbiAqL1xudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihfY2hhcjMsIHJlbWFpbmluZykge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBpZiAoU1BBQ0UudGVzdChfY2hhcjMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENoYW1lbGVvbnMgY291bnQgYXMgd29yZCBjaGFyYWN0ZXJzIGFzIGxvbmcgYXMgdGhleSdyZSBpbiBhIHdvcmQsIHNvXG4gIC8vIHJlY3Vyc2UgdG8gc2VlIGlmIHRoZSBuZXh0IG9uZSBpcyBhIHdvcmQgY2hhcmFjdGVyIG9yIG5vdC5cbiAgaWYgKENIQU1FTEVPTi50ZXN0KF9jaGFyMykpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcbiAgICB2YXIgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MyA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGNoYXJEaXN0LCBpc1JUTCksXG4gICAgICBfc3BsaXRCeUNoYXJhY3RlckRpc3Q0ID0gX3NsaWNlZFRvQXJyYXkoX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MywgMiksXG4gICAgICBuZXh0Q2hhciA9IF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDRbMF0sXG4gICAgICBuZXh0UmVtYWluaW5nID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0NFsxXTtcbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKG5leHRDaGFyLCBuZXh0UmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoUFVOQ1RVQVRJT04udGVzdChfY2hhcjMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogSXRlcmF0ZSBvbiBjb2RlcG9pbnRzIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqL1xudmFyIGNvZGVwb2ludHNJdGVyYXRvclJUTCA9IGZ1bmN0aW9uKiBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSB7XG4gIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcjEgPSBzdHIuY2hhckF0KGVuZCAtIGkpO1xuICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShjaGFyMS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdmFyIGNoYXIyID0gc3RyLmNoYXJBdChlbmQgLSBpIC0gMSk7XG4gICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXIyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHlpZWxkIGNoYXIyICsgY2hhcjE7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIHlpZWxkIGNoYXIxO1xuICB9XG59O1xuLyoqXG4gKiBJcyBgY2hhckNvZGVgIGEgaGlnaCBzdXJyb2dhdGUuXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG4gKi9cbnZhciBpc0hpZ2hTdXJyb2dhdGUgPSBmdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZDgwMCAmJiBjaGFyQ29kZSA8PSAweGRiZmY7XG59O1xuLyoqXG4gKiBJcyBgY2hhckNvZGVgIGEgbG93IHN1cnJvZ2F0ZS5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAqL1xudmFyIGlzTG93U3Vycm9nYXRlID0gZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZGMwMCAmJiBjaGFyQ29kZSA8PSAweGRmZmY7XG59O1xudmFyIENvZGVwb2ludFR5cGU7XG4oZnVuY3Rpb24gKENvZGVwb2ludFR5cGUpIHtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dGVuZFwiXSA9IDFdID0gXCJFeHRlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiWldKXCJdID0gMl0gPSBcIlpXSlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJSSVwiXSA9IDRdID0gXCJSSVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJQcmVwZW5kXCJdID0gOF0gPSBcIlByZXBlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiU3BhY2luZ01hcmtcIl0gPSAxNl0gPSBcIlNwYWNpbmdNYXJrXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxcIl0gPSAzMl0gPSBcIkxcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVlwiXSA9IDY0XSA9IFwiVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJUXCJdID0gMTI4XSA9IFwiVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlwiXSA9IDI1Nl0gPSBcIkxWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWVFwiXSA9IDUxMl0gPSBcIkxWVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRQaWN0XCJdID0gMTAyNF0gPSBcIkV4dFBpY3RcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiQW55XCJdID0gMjA0OF0gPSBcIkFueVwiO1xufSkoQ29kZXBvaW50VHlwZSB8fCAoQ29kZXBvaW50VHlwZSA9IHt9KSk7XG52YXIgcmVFeHRlbmQgPSAvXig/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4OTgtXFx1MDg5RlxcdTA4Q0EtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNDXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRVxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyXFx1MTczM1xcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTgwRlxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQ0VcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURFRkQtXFx1REVGRlxcdURGNDYtXFx1REY1MFxcdURGODItXFx1REY4NV18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3MFxcdURDNzNcXHVEQzc0XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVEQ0MyXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERTQxXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNFxcdURGMDBcXHVERjAxXFx1REYzNi1cXHVERjNBXFx1REY0MFxcdURGNDJdfFxcdUQ4MERbXFx1REM0MFxcdURDNDctXFx1REM1NV18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzNbXFx1REYwMC1cXHVERjJEXFx1REYzMC1cXHVERjQ2XXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVEQzhGXFx1REQzMC1cXHVERDM2XFx1REVBRVxcdURFRUMtXFx1REVFRl18XFx1RDgzOVtcXHVEQ0VDLVxcdURDRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSQvO1xudmFyIHJlUHJlcGVuZCA9IC9eKD86W1xcdTA2MDAtXFx1MDYwNVxcdTA2RERcXHUwNzBGXFx1MDg5MFxcdTA4OTFcXHUwOEUyXFx1MEQ0RV18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRFxcdUREQzJcXHVEREMzXXxcXHVEODA2W1xcdUREM0ZcXHVERDQxXFx1REUzQVxcdURFODQtXFx1REU4OV18XFx1RDgwN1xcdURENDYpJC87XG52YXIgcmVTcGFjaW5nTWFyayA9IC9eKD86W1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkZcXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzBcXHUwQ0MxXFx1MENDM1xcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MEQwMlxcdTBEMDNcXHUwRDNGXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBEODJcXHUwRDgzXFx1MEREMFxcdTBERDFcXHUwREQ4LVxcdTBEREVcXHUwREYyXFx1MERGM1xcdTBFMzNcXHUwRUIzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAzMVxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDg0XFx1MTcxNVxcdTE3MzRcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGN1xcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkUtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUNdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ0NVxcdURENDZcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERENFXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQzM1LVxcdURDMzdcXHVEQzQwXFx1REM0MVxcdURDNDVcXHVEQ0IxXFx1RENCMlxcdURDQjlcXHVEQ0JCXFx1RENCQ1xcdURDQkVcXHVEQ0MxXFx1RERCMFxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjZdfFxcdUQ4MDZbXFx1REMyQy1cXHVEQzJFXFx1REMzOFxcdUREMzEtXFx1REQzNVxcdUREMzdcXHVERDM4XFx1REQzRFxcdURENDBcXHVERDQyXFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERGXFx1RERFNFxcdURFMzlcXHVERTU3XFx1REU1OFxcdURFOTddfFxcdUQ4MDdbXFx1REMyRlxcdURDM0VcXHVEQ0E5XFx1RENCMVxcdURDQjRcXHVERDhBLVxcdUREOEVcXHVERDkzXFx1REQ5NFxcdUREOTZcXHVERUY1XFx1REVGNl18XFx1RDgxQltcXHVERjUxLVxcdURGODdcXHVERkYwXFx1REZGMV18XFx1RDgzNFtcXHVERDY2XFx1REQ2RF0pJC87XG52YXIgcmVMID0gL15bXFx1MTEwMC1cXHUxMTVGXFx1QTk2MC1cXHVBOTdDXSQvO1xudmFyIHJlViA9IC9eW1xcdTExNjAtXFx1MTFBN1xcdUQ3QjAtXFx1RDdDNl0kLztcbnZhciByZVQgPSAvXltcXHUxMUE4LVxcdTExRkZcXHVEN0NCLVxcdUQ3RkJdJC87XG52YXIgcmVMViA9IC9eW1xcdUFDMDBcXHVBQzFDXFx1QUMzOFxcdUFDNTRcXHVBQzcwXFx1QUM4Q1xcdUFDQThcXHVBQ0M0XFx1QUNFMFxcdUFDRkNcXHVBRDE4XFx1QUQzNFxcdUFENTBcXHVBRDZDXFx1QUQ4OFxcdUFEQTRcXHVBREMwXFx1QUREQ1xcdUFERjhcXHVBRTE0XFx1QUUzMFxcdUFFNENcXHVBRTY4XFx1QUU4NFxcdUFFQTBcXHVBRUJDXFx1QUVEOFxcdUFFRjRcXHVBRjEwXFx1QUYyQ1xcdUFGNDhcXHVBRjY0XFx1QUY4MFxcdUFGOUNcXHVBRkI4XFx1QUZENFxcdUFGRjBcXHVCMDBDXFx1QjAyOFxcdUIwNDRcXHVCMDYwXFx1QjA3Q1xcdUIwOThcXHVCMEI0XFx1QjBEMFxcdUIwRUNcXHVCMTA4XFx1QjEyNFxcdUIxNDBcXHVCMTVDXFx1QjE3OFxcdUIxOTRcXHVCMUIwXFx1QjFDQ1xcdUIxRThcXHVCMjA0XFx1QjIyMFxcdUIyM0NcXHVCMjU4XFx1QjI3NFxcdUIyOTBcXHVCMkFDXFx1QjJDOFxcdUIyRTRcXHVCMzAwXFx1QjMxQ1xcdUIzMzhcXHVCMzU0XFx1QjM3MFxcdUIzOENcXHVCM0E4XFx1QjNDNFxcdUIzRTBcXHVCM0ZDXFx1QjQxOFxcdUI0MzRcXHVCNDUwXFx1QjQ2Q1xcdUI0ODhcXHVCNEE0XFx1QjRDMFxcdUI0RENcXHVCNEY4XFx1QjUxNFxcdUI1MzBcXHVCNTRDXFx1QjU2OFxcdUI1ODRcXHVCNUEwXFx1QjVCQ1xcdUI1RDhcXHVCNUY0XFx1QjYxMFxcdUI2MkNcXHVCNjQ4XFx1QjY2NFxcdUI2ODBcXHVCNjlDXFx1QjZCOFxcdUI2RDRcXHVCNkYwXFx1QjcwQ1xcdUI3MjhcXHVCNzQ0XFx1Qjc2MFxcdUI3N0NcXHVCNzk4XFx1QjdCNFxcdUI3RDBcXHVCN0VDXFx1QjgwOFxcdUI4MjRcXHVCODQwXFx1Qjg1Q1xcdUI4NzhcXHVCODk0XFx1QjhCMFxcdUI4Q0NcXHVCOEU4XFx1QjkwNFxcdUI5MjBcXHVCOTNDXFx1Qjk1OFxcdUI5NzRcXHVCOTkwXFx1QjlBQ1xcdUI5QzhcXHVCOUU0XFx1QkEwMFxcdUJBMUNcXHVCQTM4XFx1QkE1NFxcdUJBNzBcXHVCQThDXFx1QkFBOFxcdUJBQzRcXHVCQUUwXFx1QkFGQ1xcdUJCMThcXHVCQjM0XFx1QkI1MFxcdUJCNkNcXHVCQjg4XFx1QkJBNFxcdUJCQzBcXHVCQkRDXFx1QkJGOFxcdUJDMTRcXHVCQzMwXFx1QkM0Q1xcdUJDNjhcXHVCQzg0XFx1QkNBMFxcdUJDQkNcXHVCQ0Q4XFx1QkNGNFxcdUJEMTBcXHVCRDJDXFx1QkQ0OFxcdUJENjRcXHVCRDgwXFx1QkQ5Q1xcdUJEQjhcXHVCREQ0XFx1QkRGMFxcdUJFMENcXHVCRTI4XFx1QkU0NFxcdUJFNjBcXHVCRTdDXFx1QkU5OFxcdUJFQjRcXHVCRUQwXFx1QkVFQ1xcdUJGMDhcXHVCRjI0XFx1QkY0MFxcdUJGNUNcXHVCRjc4XFx1QkY5NFxcdUJGQjBcXHVCRkNDXFx1QkZFOFxcdUMwMDRcXHVDMDIwXFx1QzAzQ1xcdUMwNThcXHVDMDc0XFx1QzA5MFxcdUMwQUNcXHVDMEM4XFx1QzBFNFxcdUMxMDBcXHVDMTFDXFx1QzEzOFxcdUMxNTRcXHVDMTcwXFx1QzE4Q1xcdUMxQThcXHVDMUM0XFx1QzFFMFxcdUMxRkNcXHVDMjE4XFx1QzIzNFxcdUMyNTBcXHVDMjZDXFx1QzI4OFxcdUMyQTRcXHVDMkMwXFx1QzJEQ1xcdUMyRjhcXHVDMzE0XFx1QzMzMFxcdUMzNENcXHVDMzY4XFx1QzM4NFxcdUMzQTBcXHVDM0JDXFx1QzNEOFxcdUMzRjRcXHVDNDEwXFx1QzQyQ1xcdUM0NDhcXHVDNDY0XFx1QzQ4MFxcdUM0OUNcXHVDNEI4XFx1QzRENFxcdUM0RjBcXHVDNTBDXFx1QzUyOFxcdUM1NDRcXHVDNTYwXFx1QzU3Q1xcdUM1OThcXHVDNUI0XFx1QzVEMFxcdUM1RUNcXHVDNjA4XFx1QzYyNFxcdUM2NDBcXHVDNjVDXFx1QzY3OFxcdUM2OTRcXHVDNkIwXFx1QzZDQ1xcdUM2RThcXHVDNzA0XFx1QzcyMFxcdUM3M0NcXHVDNzU4XFx1Qzc3NFxcdUM3OTBcXHVDN0FDXFx1QzdDOFxcdUM3RTRcXHVDODAwXFx1QzgxQ1xcdUM4MzhcXHVDODU0XFx1Qzg3MFxcdUM4OENcXHVDOEE4XFx1QzhDNFxcdUM4RTBcXHVDOEZDXFx1QzkxOFxcdUM5MzRcXHVDOTUwXFx1Qzk2Q1xcdUM5ODhcXHVDOUE0XFx1QzlDMFxcdUM5RENcXHVDOUY4XFx1Q0ExNFxcdUNBMzBcXHVDQTRDXFx1Q0E2OFxcdUNBODRcXHVDQUEwXFx1Q0FCQ1xcdUNBRDhcXHVDQUY0XFx1Q0IxMFxcdUNCMkNcXHVDQjQ4XFx1Q0I2NFxcdUNCODBcXHVDQjlDXFx1Q0JCOFxcdUNCRDRcXHVDQkYwXFx1Q0MwQ1xcdUNDMjhcXHVDQzQ0XFx1Q0M2MFxcdUNDN0NcXHVDQzk4XFx1Q0NCNFxcdUNDRDBcXHVDQ0VDXFx1Q0QwOFxcdUNEMjRcXHVDRDQwXFx1Q0Q1Q1xcdUNENzhcXHVDRDk0XFx1Q0RCMFxcdUNEQ0NcXHVDREU4XFx1Q0UwNFxcdUNFMjBcXHVDRTNDXFx1Q0U1OFxcdUNFNzRcXHVDRTkwXFx1Q0VBQ1xcdUNFQzhcXHVDRUU0XFx1Q0YwMFxcdUNGMUNcXHVDRjM4XFx1Q0Y1NFxcdUNGNzBcXHVDRjhDXFx1Q0ZBOFxcdUNGQzRcXHVDRkUwXFx1Q0ZGQ1xcdUQwMThcXHVEMDM0XFx1RDA1MFxcdUQwNkNcXHVEMDg4XFx1RDBBNFxcdUQwQzBcXHVEMERDXFx1RDBGOFxcdUQxMTRcXHVEMTMwXFx1RDE0Q1xcdUQxNjhcXHVEMTg0XFx1RDFBMFxcdUQxQkNcXHVEMUQ4XFx1RDFGNFxcdUQyMTBcXHVEMjJDXFx1RDI0OFxcdUQyNjRcXHVEMjgwXFx1RDI5Q1xcdUQyQjhcXHVEMkQ0XFx1RDJGMFxcdUQzMENcXHVEMzI4XFx1RDM0NFxcdUQzNjBcXHVEMzdDXFx1RDM5OFxcdUQzQjRcXHVEM0QwXFx1RDNFQ1xcdUQ0MDhcXHVENDI0XFx1RDQ0MFxcdUQ0NUNcXHVENDc4XFx1RDQ5NFxcdUQ0QjBcXHVENENDXFx1RDRFOFxcdUQ1MDRcXHVENTIwXFx1RDUzQ1xcdUQ1NThcXHVENTc0XFx1RDU5MFxcdUQ1QUNcXHVENUM4XFx1RDVFNFxcdUQ2MDBcXHVENjFDXFx1RDYzOFxcdUQ2NTRcXHVENjcwXFx1RDY4Q1xcdUQ2QThcXHVENkM0XFx1RDZFMFxcdUQ2RkNcXHVENzE4XFx1RDczNFxcdUQ3NTBcXHVENzZDXFx1RDc4OF0kLztcbnZhciByZUxWVCA9IC9eW1xcdUFDMDEtXFx1QUMxQlxcdUFDMUQtXFx1QUMzN1xcdUFDMzktXFx1QUM1M1xcdUFDNTUtXFx1QUM2RlxcdUFDNzEtXFx1QUM4QlxcdUFDOEQtXFx1QUNBN1xcdUFDQTktXFx1QUNDM1xcdUFDQzUtXFx1QUNERlxcdUFDRTEtXFx1QUNGQlxcdUFDRkQtXFx1QUQxN1xcdUFEMTktXFx1QUQzM1xcdUFEMzUtXFx1QUQ0RlxcdUFENTEtXFx1QUQ2QlxcdUFENkQtXFx1QUQ4N1xcdUFEODktXFx1QURBM1xcdUFEQTUtXFx1QURCRlxcdUFEQzEtXFx1QUREQlxcdUFEREQtXFx1QURGN1xcdUFERjktXFx1QUUxM1xcdUFFMTUtXFx1QUUyRlxcdUFFMzEtXFx1QUU0QlxcdUFFNEQtXFx1QUU2N1xcdUFFNjktXFx1QUU4M1xcdUFFODUtXFx1QUU5RlxcdUFFQTEtXFx1QUVCQlxcdUFFQkQtXFx1QUVEN1xcdUFFRDktXFx1QUVGM1xcdUFFRjUtXFx1QUYwRlxcdUFGMTEtXFx1QUYyQlxcdUFGMkQtXFx1QUY0N1xcdUFGNDktXFx1QUY2M1xcdUFGNjUtXFx1QUY3RlxcdUFGODEtXFx1QUY5QlxcdUFGOUQtXFx1QUZCN1xcdUFGQjktXFx1QUZEM1xcdUFGRDUtXFx1QUZFRlxcdUFGRjEtXFx1QjAwQlxcdUIwMEQtXFx1QjAyN1xcdUIwMjktXFx1QjA0M1xcdUIwNDUtXFx1QjA1RlxcdUIwNjEtXFx1QjA3QlxcdUIwN0QtXFx1QjA5N1xcdUIwOTktXFx1QjBCM1xcdUIwQjUtXFx1QjBDRlxcdUIwRDEtXFx1QjBFQlxcdUIwRUQtXFx1QjEwN1xcdUIxMDktXFx1QjEyM1xcdUIxMjUtXFx1QjEzRlxcdUIxNDEtXFx1QjE1QlxcdUIxNUQtXFx1QjE3N1xcdUIxNzktXFx1QjE5M1xcdUIxOTUtXFx1QjFBRlxcdUIxQjEtXFx1QjFDQlxcdUIxQ0QtXFx1QjFFN1xcdUIxRTktXFx1QjIwM1xcdUIyMDUtXFx1QjIxRlxcdUIyMjEtXFx1QjIzQlxcdUIyM0QtXFx1QjI1N1xcdUIyNTktXFx1QjI3M1xcdUIyNzUtXFx1QjI4RlxcdUIyOTEtXFx1QjJBQlxcdUIyQUQtXFx1QjJDN1xcdUIyQzktXFx1QjJFM1xcdUIyRTUtXFx1QjJGRlxcdUIzMDEtXFx1QjMxQlxcdUIzMUQtXFx1QjMzN1xcdUIzMzktXFx1QjM1M1xcdUIzNTUtXFx1QjM2RlxcdUIzNzEtXFx1QjM4QlxcdUIzOEQtXFx1QjNBN1xcdUIzQTktXFx1QjNDM1xcdUIzQzUtXFx1QjNERlxcdUIzRTEtXFx1QjNGQlxcdUIzRkQtXFx1QjQxN1xcdUI0MTktXFx1QjQzM1xcdUI0MzUtXFx1QjQ0RlxcdUI0NTEtXFx1QjQ2QlxcdUI0NkQtXFx1QjQ4N1xcdUI0ODktXFx1QjRBM1xcdUI0QTUtXFx1QjRCRlxcdUI0QzEtXFx1QjREQlxcdUI0REQtXFx1QjRGN1xcdUI0RjktXFx1QjUxM1xcdUI1MTUtXFx1QjUyRlxcdUI1MzEtXFx1QjU0QlxcdUI1NEQtXFx1QjU2N1xcdUI1NjktXFx1QjU4M1xcdUI1ODUtXFx1QjU5RlxcdUI1QTEtXFx1QjVCQlxcdUI1QkQtXFx1QjVEN1xcdUI1RDktXFx1QjVGM1xcdUI1RjUtXFx1QjYwRlxcdUI2MTEtXFx1QjYyQlxcdUI2MkQtXFx1QjY0N1xcdUI2NDktXFx1QjY2M1xcdUI2NjUtXFx1QjY3RlxcdUI2ODEtXFx1QjY5QlxcdUI2OUQtXFx1QjZCN1xcdUI2QjktXFx1QjZEM1xcdUI2RDUtXFx1QjZFRlxcdUI2RjEtXFx1QjcwQlxcdUI3MEQtXFx1QjcyN1xcdUI3MjktXFx1Qjc0M1xcdUI3NDUtXFx1Qjc1RlxcdUI3NjEtXFx1Qjc3QlxcdUI3N0QtXFx1Qjc5N1xcdUI3OTktXFx1QjdCM1xcdUI3QjUtXFx1QjdDRlxcdUI3RDEtXFx1QjdFQlxcdUI3RUQtXFx1QjgwN1xcdUI4MDktXFx1QjgyM1xcdUI4MjUtXFx1QjgzRlxcdUI4NDEtXFx1Qjg1QlxcdUI4NUQtXFx1Qjg3N1xcdUI4NzktXFx1Qjg5M1xcdUI4OTUtXFx1QjhBRlxcdUI4QjEtXFx1QjhDQlxcdUI4Q0QtXFx1QjhFN1xcdUI4RTktXFx1QjkwM1xcdUI5MDUtXFx1QjkxRlxcdUI5MjEtXFx1QjkzQlxcdUI5M0QtXFx1Qjk1N1xcdUI5NTktXFx1Qjk3M1xcdUI5NzUtXFx1Qjk4RlxcdUI5OTEtXFx1QjlBQlxcdUI5QUQtXFx1QjlDN1xcdUI5QzktXFx1QjlFM1xcdUI5RTUtXFx1QjlGRlxcdUJBMDEtXFx1QkExQlxcdUJBMUQtXFx1QkEzN1xcdUJBMzktXFx1QkE1M1xcdUJBNTUtXFx1QkE2RlxcdUJBNzEtXFx1QkE4QlxcdUJBOEQtXFx1QkFBN1xcdUJBQTktXFx1QkFDM1xcdUJBQzUtXFx1QkFERlxcdUJBRTEtXFx1QkFGQlxcdUJBRkQtXFx1QkIxN1xcdUJCMTktXFx1QkIzM1xcdUJCMzUtXFx1QkI0RlxcdUJCNTEtXFx1QkI2QlxcdUJCNkQtXFx1QkI4N1xcdUJCODktXFx1QkJBM1xcdUJCQTUtXFx1QkJCRlxcdUJCQzEtXFx1QkJEQlxcdUJCREQtXFx1QkJGN1xcdUJCRjktXFx1QkMxM1xcdUJDMTUtXFx1QkMyRlxcdUJDMzEtXFx1QkM0QlxcdUJDNEQtXFx1QkM2N1xcdUJDNjktXFx1QkM4M1xcdUJDODUtXFx1QkM5RlxcdUJDQTEtXFx1QkNCQlxcdUJDQkQtXFx1QkNEN1xcdUJDRDktXFx1QkNGM1xcdUJDRjUtXFx1QkQwRlxcdUJEMTEtXFx1QkQyQlxcdUJEMkQtXFx1QkQ0N1xcdUJENDktXFx1QkQ2M1xcdUJENjUtXFx1QkQ3RlxcdUJEODEtXFx1QkQ5QlxcdUJEOUQtXFx1QkRCN1xcdUJEQjktXFx1QkREM1xcdUJERDUtXFx1QkRFRlxcdUJERjEtXFx1QkUwQlxcdUJFMEQtXFx1QkUyN1xcdUJFMjktXFx1QkU0M1xcdUJFNDUtXFx1QkU1RlxcdUJFNjEtXFx1QkU3QlxcdUJFN0QtXFx1QkU5N1xcdUJFOTktXFx1QkVCM1xcdUJFQjUtXFx1QkVDRlxcdUJFRDEtXFx1QkVFQlxcdUJFRUQtXFx1QkYwN1xcdUJGMDktXFx1QkYyM1xcdUJGMjUtXFx1QkYzRlxcdUJGNDEtXFx1QkY1QlxcdUJGNUQtXFx1QkY3N1xcdUJGNzktXFx1QkY5M1xcdUJGOTUtXFx1QkZBRlxcdUJGQjEtXFx1QkZDQlxcdUJGQ0QtXFx1QkZFN1xcdUJGRTktXFx1QzAwM1xcdUMwMDUtXFx1QzAxRlxcdUMwMjEtXFx1QzAzQlxcdUMwM0QtXFx1QzA1N1xcdUMwNTktXFx1QzA3M1xcdUMwNzUtXFx1QzA4RlxcdUMwOTEtXFx1QzBBQlxcdUMwQUQtXFx1QzBDN1xcdUMwQzktXFx1QzBFM1xcdUMwRTUtXFx1QzBGRlxcdUMxMDEtXFx1QzExQlxcdUMxMUQtXFx1QzEzN1xcdUMxMzktXFx1QzE1M1xcdUMxNTUtXFx1QzE2RlxcdUMxNzEtXFx1QzE4QlxcdUMxOEQtXFx1QzFBN1xcdUMxQTktXFx1QzFDM1xcdUMxQzUtXFx1QzFERlxcdUMxRTEtXFx1QzFGQlxcdUMxRkQtXFx1QzIxN1xcdUMyMTktXFx1QzIzM1xcdUMyMzUtXFx1QzI0RlxcdUMyNTEtXFx1QzI2QlxcdUMyNkQtXFx1QzI4N1xcdUMyODktXFx1QzJBM1xcdUMyQTUtXFx1QzJCRlxcdUMyQzEtXFx1QzJEQlxcdUMyREQtXFx1QzJGN1xcdUMyRjktXFx1QzMxM1xcdUMzMTUtXFx1QzMyRlxcdUMzMzEtXFx1QzM0QlxcdUMzNEQtXFx1QzM2N1xcdUMzNjktXFx1QzM4M1xcdUMzODUtXFx1QzM5RlxcdUMzQTEtXFx1QzNCQlxcdUMzQkQtXFx1QzNEN1xcdUMzRDktXFx1QzNGM1xcdUMzRjUtXFx1QzQwRlxcdUM0MTEtXFx1QzQyQlxcdUM0MkQtXFx1QzQ0N1xcdUM0NDktXFx1QzQ2M1xcdUM0NjUtXFx1QzQ3RlxcdUM0ODEtXFx1QzQ5QlxcdUM0OUQtXFx1QzRCN1xcdUM0QjktXFx1QzREM1xcdUM0RDUtXFx1QzRFRlxcdUM0RjEtXFx1QzUwQlxcdUM1MEQtXFx1QzUyN1xcdUM1MjktXFx1QzU0M1xcdUM1NDUtXFx1QzU1RlxcdUM1NjEtXFx1QzU3QlxcdUM1N0QtXFx1QzU5N1xcdUM1OTktXFx1QzVCM1xcdUM1QjUtXFx1QzVDRlxcdUM1RDEtXFx1QzVFQlxcdUM1RUQtXFx1QzYwN1xcdUM2MDktXFx1QzYyM1xcdUM2MjUtXFx1QzYzRlxcdUM2NDEtXFx1QzY1QlxcdUM2NUQtXFx1QzY3N1xcdUM2NzktXFx1QzY5M1xcdUM2OTUtXFx1QzZBRlxcdUM2QjEtXFx1QzZDQlxcdUM2Q0QtXFx1QzZFN1xcdUM2RTktXFx1QzcwM1xcdUM3MDUtXFx1QzcxRlxcdUM3MjEtXFx1QzczQlxcdUM3M0QtXFx1Qzc1N1xcdUM3NTktXFx1Qzc3M1xcdUM3NzUtXFx1Qzc4RlxcdUM3OTEtXFx1QzdBQlxcdUM3QUQtXFx1QzdDN1xcdUM3QzktXFx1QzdFM1xcdUM3RTUtXFx1QzdGRlxcdUM4MDEtXFx1QzgxQlxcdUM4MUQtXFx1QzgzN1xcdUM4MzktXFx1Qzg1M1xcdUM4NTUtXFx1Qzg2RlxcdUM4NzEtXFx1Qzg4QlxcdUM4OEQtXFx1QzhBN1xcdUM4QTktXFx1QzhDM1xcdUM4QzUtXFx1QzhERlxcdUM4RTEtXFx1QzhGQlxcdUM4RkQtXFx1QzkxN1xcdUM5MTktXFx1QzkzM1xcdUM5MzUtXFx1Qzk0RlxcdUM5NTEtXFx1Qzk2QlxcdUM5NkQtXFx1Qzk4N1xcdUM5ODktXFx1QzlBM1xcdUM5QTUtXFx1QzlCRlxcdUM5QzEtXFx1QzlEQlxcdUM5REQtXFx1QzlGN1xcdUM5RjktXFx1Q0ExM1xcdUNBMTUtXFx1Q0EyRlxcdUNBMzEtXFx1Q0E0QlxcdUNBNEQtXFx1Q0E2N1xcdUNBNjktXFx1Q0E4M1xcdUNBODUtXFx1Q0E5RlxcdUNBQTEtXFx1Q0FCQlxcdUNBQkQtXFx1Q0FEN1xcdUNBRDktXFx1Q0FGM1xcdUNBRjUtXFx1Q0IwRlxcdUNCMTEtXFx1Q0IyQlxcdUNCMkQtXFx1Q0I0N1xcdUNCNDktXFx1Q0I2M1xcdUNCNjUtXFx1Q0I3RlxcdUNCODEtXFx1Q0I5QlxcdUNCOUQtXFx1Q0JCN1xcdUNCQjktXFx1Q0JEM1xcdUNCRDUtXFx1Q0JFRlxcdUNCRjEtXFx1Q0MwQlxcdUNDMEQtXFx1Q0MyN1xcdUNDMjktXFx1Q0M0M1xcdUNDNDUtXFx1Q0M1RlxcdUNDNjEtXFx1Q0M3QlxcdUNDN0QtXFx1Q0M5N1xcdUNDOTktXFx1Q0NCM1xcdUNDQjUtXFx1Q0NDRlxcdUNDRDEtXFx1Q0NFQlxcdUNDRUQtXFx1Q0QwN1xcdUNEMDktXFx1Q0QyM1xcdUNEMjUtXFx1Q0QzRlxcdUNENDEtXFx1Q0Q1QlxcdUNENUQtXFx1Q0Q3N1xcdUNENzktXFx1Q0Q5M1xcdUNEOTUtXFx1Q0RBRlxcdUNEQjEtXFx1Q0RDQlxcdUNEQ0QtXFx1Q0RFN1xcdUNERTktXFx1Q0UwM1xcdUNFMDUtXFx1Q0UxRlxcdUNFMjEtXFx1Q0UzQlxcdUNFM0QtXFx1Q0U1N1xcdUNFNTktXFx1Q0U3M1xcdUNFNzUtXFx1Q0U4RlxcdUNFOTEtXFx1Q0VBQlxcdUNFQUQtXFx1Q0VDN1xcdUNFQzktXFx1Q0VFM1xcdUNFRTUtXFx1Q0VGRlxcdUNGMDEtXFx1Q0YxQlxcdUNGMUQtXFx1Q0YzN1xcdUNGMzktXFx1Q0Y1M1xcdUNGNTUtXFx1Q0Y2RlxcdUNGNzEtXFx1Q0Y4QlxcdUNGOEQtXFx1Q0ZBN1xcdUNGQTktXFx1Q0ZDM1xcdUNGQzUtXFx1Q0ZERlxcdUNGRTEtXFx1Q0ZGQlxcdUNGRkQtXFx1RDAxN1xcdUQwMTktXFx1RDAzM1xcdUQwMzUtXFx1RDA0RlxcdUQwNTEtXFx1RDA2QlxcdUQwNkQtXFx1RDA4N1xcdUQwODktXFx1RDBBM1xcdUQwQTUtXFx1RDBCRlxcdUQwQzEtXFx1RDBEQlxcdUQwREQtXFx1RDBGN1xcdUQwRjktXFx1RDExM1xcdUQxMTUtXFx1RDEyRlxcdUQxMzEtXFx1RDE0QlxcdUQxNEQtXFx1RDE2N1xcdUQxNjktXFx1RDE4M1xcdUQxODUtXFx1RDE5RlxcdUQxQTEtXFx1RDFCQlxcdUQxQkQtXFx1RDFEN1xcdUQxRDktXFx1RDFGM1xcdUQxRjUtXFx1RDIwRlxcdUQyMTEtXFx1RDIyQlxcdUQyMkQtXFx1RDI0N1xcdUQyNDktXFx1RDI2M1xcdUQyNjUtXFx1RDI3RlxcdUQyODEtXFx1RDI5QlxcdUQyOUQtXFx1RDJCN1xcdUQyQjktXFx1RDJEM1xcdUQyRDUtXFx1RDJFRlxcdUQyRjEtXFx1RDMwQlxcdUQzMEQtXFx1RDMyN1xcdUQzMjktXFx1RDM0M1xcdUQzNDUtXFx1RDM1RlxcdUQzNjEtXFx1RDM3QlxcdUQzN0QtXFx1RDM5N1xcdUQzOTktXFx1RDNCM1xcdUQzQjUtXFx1RDNDRlxcdUQzRDEtXFx1RDNFQlxcdUQzRUQtXFx1RDQwN1xcdUQ0MDktXFx1RDQyM1xcdUQ0MjUtXFx1RDQzRlxcdUQ0NDEtXFx1RDQ1QlxcdUQ0NUQtXFx1RDQ3N1xcdUQ0NzktXFx1RDQ5M1xcdUQ0OTUtXFx1RDRBRlxcdUQ0QjEtXFx1RDRDQlxcdUQ0Q0QtXFx1RDRFN1xcdUQ0RTktXFx1RDUwM1xcdUQ1MDUtXFx1RDUxRlxcdUQ1MjEtXFx1RDUzQlxcdUQ1M0QtXFx1RDU1N1xcdUQ1NTktXFx1RDU3M1xcdUQ1NzUtXFx1RDU4RlxcdUQ1OTEtXFx1RDVBQlxcdUQ1QUQtXFx1RDVDN1xcdUQ1QzktXFx1RDVFM1xcdUQ1RTUtXFx1RDVGRlxcdUQ2MDEtXFx1RDYxQlxcdUQ2MUQtXFx1RDYzN1xcdUQ2MzktXFx1RDY1M1xcdUQ2NTUtXFx1RDY2RlxcdUQ2NzEtXFx1RDY4QlxcdUQ2OEQtXFx1RDZBN1xcdUQ2QTktXFx1RDZDM1xcdUQ2QzUtXFx1RDZERlxcdUQ2RTEtXFx1RDZGQlxcdUQ2RkQtXFx1RDcxN1xcdUQ3MTktXFx1RDczM1xcdUQ3MzUtXFx1RDc0RlxcdUQ3NTEtXFx1RDc2QlxcdUQ3NkQtXFx1RDc4N1xcdUQ3ODktXFx1RDdBM10kLztcbnZhciByZUV4dFBpY3QgPSAvXig/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkkLztcbnZhciBnZXRDb2RlcG9pbnRUeXBlID0gZnVuY3Rpb24gZ2V0Q29kZXBvaW50VHlwZShfY2hhcjQsIGNvZGUpIHtcbiAgdmFyIHR5cGUgPSBDb2RlcG9pbnRUeXBlLkFueTtcbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVFeHRlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRlbmQ7XG4gIH1cbiAgaWYgKGNvZGUgPT09IDB4MjAwZCkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5aV0o7XG4gIH1cbiAgaWYgKGNvZGUgPj0gMHgxZjFlNiAmJiBjb2RlIDw9IDB4MWYxZmYpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUkk7XG4gIH1cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVQcmVwZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUHJlcGVuZDtcbiAgfVxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVNwYWNpbmdNYXJrKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuU3BhY2luZ01hcms7XG4gIH1cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVMKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTDtcbiAgfVxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5WO1xuICB9XG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlQ7XG4gIH1cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVMVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWO1xuICB9XG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlTFZUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFZUO1xuICB9XG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlRXh0UGljdCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dFBpY3Q7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59O1xuZnVuY3Rpb24gaW50ZXJzZWN0cyh4LCB5KSB7XG4gIHJldHVybiAoeCAmIHkpICE9PSAwO1xufVxudmFyIE5vbkJvdW5kYXJ5UGFpcnMgPSBbXG4vLyBHQjZcbltDb2RlcG9pbnRUeXBlLkwsIENvZGVwb2ludFR5cGUuTCB8IENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLkxWVF0sXG4vLyBHQjdcbltDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5WLCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLlRdLFxuLy8gR0I4XG5bQ29kZXBvaW50VHlwZS5MVlQgfCBDb2RlcG9pbnRUeXBlLlQsIENvZGVwb2ludFR5cGUuVF0sXG4vLyBHQjlcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5FeHRlbmQgfCBDb2RlcG9pbnRUeXBlLlpXSl0sXG4vLyBHQjlhXG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuU3BhY2luZ01hcmtdLFxuLy8gR0I5YlxuW0NvZGVwb2ludFR5cGUuUHJlcGVuZCwgQ29kZXBvaW50VHlwZS5BbnldLFxuLy8gR0IxMVxuW0NvZGVwb2ludFR5cGUuWldKLCBDb2RlcG9pbnRUeXBlLkV4dFBpY3RdLFxuLy8gR0IxMiBhbmQgR0IxM1xuW0NvZGVwb2ludFR5cGUuUkksIENvZGVwb2ludFR5cGUuUkldXTtcbmZ1bmN0aW9uIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBOb25Cb3VuZGFyeVBhaXJzLmZpbmRJbmRleChmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBpbnRlcnNlY3RzKGxlZnQsIHJbMF0pICYmIGludGVyc2VjdHMocmlnaHQsIHJbMV0pO1xuICB9KSA9PT0gLTE7XG59XG52YXIgZW5kaW5nRW1vamlaV0ogPSAvKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSg/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4OTgtXFx1MDg5RlxcdTA4Q0EtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNDXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRVxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyXFx1MTczM1xcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTgwRlxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQ0VcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURFRkQtXFx1REVGRlxcdURGNDYtXFx1REY1MFxcdURGODItXFx1REY4NV18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3MFxcdURDNzNcXHVEQzc0XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVEQ0MyXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERTQxXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNFxcdURGMDBcXHVERjAxXFx1REYzNi1cXHVERjNBXFx1REY0MFxcdURGNDJdfFxcdUQ4MERbXFx1REM0MFxcdURDNDctXFx1REM1NV18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzNbXFx1REYwMC1cXHVERjJEXFx1REYzMC1cXHVERjQ2XXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVEQzhGXFx1REQzMC1cXHVERDM2XFx1REVBRVxcdURFRUMtXFx1REVFRl18XFx1RDgzOVtcXHVEQ0VDLVxcdURDRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSpcXHUyMDBEJC87XG52YXIgZW5kc1dpdGhFbW9qaVpXSiA9IGZ1bmN0aW9uIGVuZHNXaXRoRW1vamlaV0ooc3RyKSB7XG4gIHJldHVybiBzdHIuc2VhcmNoKGVuZGluZ0Vtb2ppWldKKSAhPT0gLTE7XG59O1xudmFyIGVuZGluZ1JJcyA9IC8oPzpcXHVEODNDW1xcdURERTYtXFx1RERGRl0pKyQvZztcbnZhciBlbmRzV2l0aE9kZE51bWJlck9mUklzID0gZnVuY3Rpb24gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIpIHtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKGVuZGluZ1JJcyk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBIFJJIGlzIHJlcHJlc2VudGVkIGJ5IGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgdmFyIG51bVJJcyA9IG1hdGNoWzBdLmxlbmd0aCAvIDI7XG4gICAgcmV0dXJuIG51bVJJcyAlIDIgPT09IDE7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgXCJkZWxldGVcIjogZnVuY3Rpb24gX2RlbGV0ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3JbXCJkZWxldGVcIl0ob3B0aW9ucyk7XG4gIH0sXG4gIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zKTtcbiAgfSxcbiAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKSA6IF9vcHRpb25zJGF0O1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFJhbmdlLmVuZChhdCk7XG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBlbmRSZWYudW5yZWYoKTtcbiAgICAgICAgICBhdCA9IHN0YXJ0UG9pbnQgfHwgZW5kUG9pbnQ7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgICAgZm9jdXM6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0XG4gICAgICB9KSB8fCBFZGl0b3IuZWxlbWVudFJlYWRPbmx5KGVkaXRvciwge1xuICAgICAgICBhdDogYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfYXQgPSBhdCxcbiAgICAgICAgcGF0aCA9IF9hdC5wYXRoLFxuICAgICAgICBvZmZzZXQgPSBfYXQub2Zmc2V0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0JyxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDkoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ5KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkOShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkOShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoe30sIEdlbmVyYWxUcmFuc2Zvcm1zKSwgTm9kZVRyYW5zZm9ybXMpLCBTZWxlY3Rpb25UcmFuc2Zvcm1zKSwgVGV4dFRyYW5zZm9ybXMpO1xuXG4vLyBwZXJmXG52YXIgQkFUQ0hJTkdfRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIGlzQmF0Y2hpbmdEaXJ0eVBhdGhzID0gZnVuY3Rpb24gaXNCYXRjaGluZ0RpcnR5UGF0aHMoZWRpdG9yKSB7XG4gIHJldHVybiBCQVRDSElOR19ESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBmYWxzZTtcbn07XG52YXIgYmF0Y2hEaXJ0eVBhdGhzID0gZnVuY3Rpb24gYmF0Y2hEaXJ0eVBhdGhzKGVkaXRvciwgZm4sIHVwZGF0ZSkge1xuICB2YXIgdmFsdWUgPSBCQVRDSElOR19ESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBmYWxzZTtcbiAgQkFUQ0hJTkdfRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgICB1cGRhdGUoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBCQVRDSElOR19ESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCB2YWx1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGkobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRpKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkaShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkaShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiB1cGRhdGUgZWRpdG9yIGRpcnR5IHBhdGhzXG4gKlxuICogQHBhcmFtIG5ld0RpcnR5UGF0aHM6IFBhdGhbXTsgbmV3IGRpcnR5IHBhdGhzXG4gKiBAcGFyYW0gdHJhbnNmb3JtOiAocDogUGF0aCkgPT4gUGF0aCB8IG51bGw7IGhvdyB0byB0cmFuc2Zvcm0gZXhpc3RpbmcgZGlydHkgcGF0aHNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGlydHlQYXRocyhlZGl0b3IsIG5ld0RpcnR5UGF0aHMsIHRyYW5zZm9ybSkge1xuICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICB2YXIgb2xkRGlydHlQYXRoS2V5cyA9IERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gIHZhciBkaXJ0eVBhdGhzO1xuICB2YXIgZGlydHlQYXRoS2V5cztcbiAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChwYXRoKSB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICAgIGlmICghZGlydHlQYXRoS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBkaXJ0eVBhdGhLZXlzLmFkZChrZXkpO1xuICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgZGlydHlQYXRocyA9IFtdO1xuICAgIGRpcnR5UGF0aEtleXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGkob2xkRGlydHlQYXRocyksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHBhdGggPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0cmFuc2Zvcm0ocGF0aCk7XG4gICAgICAgIGFkZChuZXdQYXRoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpcnR5UGF0aHMgPSBvbGREaXJ0eVBhdGhzO1xuICAgIGRpcnR5UGF0aEtleXMgPSBvbGREaXJ0eVBhdGhLZXlzO1xuICB9XG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaShuZXdEaXJ0eVBhdGhzKSxcbiAgICBfc3RlcDI7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfcGF0aCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIGFkZChfcGF0aCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhzKTtcbiAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGRpcnR5UGF0aEtleXMpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRoKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRoKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkaChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGgobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRoKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGgoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGVkaXRvciwgb3ApIHtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGgoRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcmVmID0gX3N0ZXAudmFsdWU7XG4gICAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGgoRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSxcbiAgICBfc3RlcDI7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfcmVmID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG4gIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkaChFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcikpLFxuICAgIF9zdGVwMztcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgdmFyIF9yZWYyID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgUmFuZ2VSZWYudHJhbnNmb3JtKF9yZWYyLCBvcCk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBkaXJ0eSBwYXRoc1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IzLmYoKTtcbiAgfVxuICBpZiAoIWlzQmF0Y2hpbmdEaXJ0eVBhdGhzKGVkaXRvcikpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSA/IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gUGF0aC50cmFuc2Zvcm0ocCwgb3ApO1xuICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgdXBkYXRlRGlydHlQYXRocyhlZGl0b3IsIGVkaXRvci5nZXREaXJ0eVBhdGhzKG9wKSwgdHJhbnNmb3JtKTtcbiAgfVxuICBUcmFuc2Zvcm1zLnRyYW5zZm9ybShlZGl0b3IsIG9wKTtcbiAgZWRpdG9yLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yLCB7XG4gICAgb3BlcmF0aW9uOiBvcFxuICB9KTtcbiAgLy8gQ2xlYXIgYW55IGZvcm1hdHMgYXBwbGllZCB0byB0aGUgY3Vyc29yIGlmIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gIH1cbiAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgIEZMVVNISU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgZWRpdG9yLm9uQ2hhbmdlKHtcbiAgICAgICAgb3BlcmF0aW9uOiBvcFxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucyA9IFtdO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRnKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRnKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkZyhvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGcobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRnKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGcoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbi8qKlxuICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxuICovXG52YXIgZ2V0RGlydHlQYXRocyA9IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMoZWRpdG9yLCBvcCkge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBhdGggPSBvcC5wYXRoO1xuICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICB9XG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgbm9kZSA9IG9wLm5vZGUsXG4gICAgICAgICAgX3BhdGggPSBvcC5wYXRoO1xuICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgpO1xuICAgICAgICB2YXIgZGVzY2VuZGFudHMgPSBUZXh0LmlzVGV4dChub2RlKSA/IFtdIDogQXJyYXkuZnJvbShOb2RlLm5vZGVzKG5vZGUpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgICAgIHJldHVybiBfcGF0aC5jb25jYXQocCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsZXZlbHMpLCBfdG9Db25zdW1hYmxlQXJyYXkoZGVzY2VuZGFudHMpKTtcbiAgICAgIH1cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoMiA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbmNlc3RvcnMpLCBbcHJldmlvdXNQYXRoXSk7XG4gICAgICB9XG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoMyA9IG9wLnBhdGgsXG4gICAgICAgICAgbmV3UGF0aCA9IG9wLm5ld1BhdGg7XG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDMsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0FuY2VzdG9ycyA9IFtdO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkZyhQYXRoLmFuY2VzdG9ycyhfcGF0aDMpKSxcbiAgICAgICAgICBfc3RlcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgcCA9IFBhdGgudHJhbnNmb3JtKGFuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgICBvbGRBbmNlc3RvcnMucHVzaChwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGcoUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpLFxuICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9hbmNlc3RvciA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBfcCA9IFBhdGgudHJhbnNmb3JtKF9hbmNlc3Rvciwgb3ApO1xuICAgICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ld0FuY2VzdG9yc1tuZXdBbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlc3VsdFBhdGggPSBuZXdQYXJlbnQuY29uY2F0KG5ld0luZGV4KTtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChvbGRBbmNlc3RvcnMsIG5ld0FuY2VzdG9ycywgW3Jlc3VsdFBhdGhdKTtcbiAgICAgIH1cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDQgPSBvcC5wYXRoO1xuICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNCk7XG4gICAgICAgIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoX2FuY2VzdG9ycyk7XG4gICAgICB9XG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDUgPSBvcC5wYXRoO1xuICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNSk7XG4gICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDUpO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfbGV2ZWxzKSwgW25leHRQYXRoXSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiBnZXRGcmFnbWVudChlZGl0b3IpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcblxudmFyIG5vcm1hbGl6ZU5vZGUgPSBmdW5jdGlvbiBub3JtYWxpemVOb2RlKGVkaXRvciwgZW50cnkpIHtcbiAgdmFyIF9lbnRyeSA9IF9zbGljZWRUb0FycmF5KGVudHJ5LCAyKSxcbiAgICBub2RlID0gX2VudHJ5WzBdLFxuICAgIHBhdGggPSBfZW50cnlbMV07XG4gIC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRW5zdXJlIHRoYXQgYmxvY2sgYW5kIGlubGluZSBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSB0ZXh0IGNoaWxkLlxuICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgY2hpbGQgPSB7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH07XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICBhdDogcGF0aC5jb25jYXQoMCksXG4gICAgICB2b2lkczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgaGF2ZSBibG9jayBvciBpbmxpbmUgY2hpbGRyZW4uXG4gIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpO1xuICAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cbiAgdmFyIG4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KGN1cnJlbnROb2RlKSkgY29udGludWU7XG4gICAgdmFyIF9jaGlsZCA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW25dO1xuICAgIHZhciBwcmV2ID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbiAtIDFdO1xuICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpO1xuICAgIC8vIE9ubHkgYWxsb3cgYmxvY2sgbm9kZXMgaW4gdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBhbmQgcGFyZW50IGJsb2Nrc1xuICAgIC8vIHRoYXQgb25seSBjb250YWluIGJsb2NrIG5vZGVzLiBTaW1pbGFybHksIG9ubHkgYWxsb3cgaW5saW5lIG5vZGVzIGluXG4gICAgLy8gb3RoZXIgaW5saW5lIG5vZGVzLCBvciBwYXJlbnQgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGlubGluZXMgYW5kXG4gICAgLy8gdGV4dC5cbiAgICBpZiAoaXNJbmxpbmVPclRleHQgIT09IHNob3VsZEhhdmVJbmxpbmVzKSB7XG4gICAgICBpZiAoaXNJbmxpbmVPclRleHQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSwgYW5kIGRvZXNuJ3QgaGF2ZSBhIGBjaGlsZHJlbmAgZmllbGQsXG4gICAgICAvLyB0aGVuIHdlIGhhdmUgYW4gaW52YWxpZCBub2RlIHRoYXQgd2lsbCB1cHNldCBzbGF0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBlZzogYHsgdHlwZTogJ3NvbWVfbm9kZScgfWAuXG4gICAgICAvL1xuICAgICAgLy8gVG8gcHJldmVudCBzbGF0ZSBmcm9tIGJyZWFraW5nLCB3ZSBjYW4gYWRkIHRoZSBgY2hpbGRyZW5gIGZpZWxkLFxuICAgICAgLy8gYW5kIG5vdyB0aGF0IGl0IGlzIHZhbGlkLCB3ZSBjYW4gdG8gbWFueSBtb3JlIG9wZXJhdGlvbnMgZWFzaWx5LFxuICAgICAgLy8gc3VjaCBhcyBleHRlbmQgbm9ybWFsaXplcnMgdG8gZml4IGVycm9ub3VzIHN0cnVjdHVyZS5cbiAgICAgIGlmICghVGV4dC5pc1RleHQoX2NoaWxkKSAmJiAhKCdjaGlsZHJlbicgaW4gX2NoaWxkKSkge1xuICAgICAgICB2YXIgZWxlbWVudENoaWxkID0gX2NoaWxkO1xuICAgICAgICBlbGVtZW50Q2hpbGQuY2hpbGRyZW4gPSBbXTtcbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgdGhhdCBhcmUgZW1wdHkgb3IgbWF0Y2guXG4gICAgICBpZiAocHJldiAhPSBudWxsICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgIGlmIChUZXh0LmVxdWFscyhfY2hpbGQsIHByZXYsIHtcbiAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXYudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gLSAxKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKF9jaGlsZC50ZXh0ID09PSAnJykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNob3VsZE5vcm1hbGl6ZSA9IGZ1bmN0aW9uIHNob3VsZE5vcm1hbGl6ZShlZGl0b3IsIF9yZWYpIHtcbiAgdmFyIGl0ZXJhdGlvbiA9IF9yZWYuaXRlcmF0aW9uLFxuICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoID0gX3JlZi5pbml0aWFsRGlydHlQYXRoc0xlbmd0aDtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuICBpZiAoaXRlcmF0aW9uID4gbWF4SXRlcmF0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXhJdGVyYXRpb25zLCBcIiBpdGVyYXRpb25zISBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGluY29ycmVjdCBub3JtYWxpemF0aW9uIGxvZ2ljIHRoYXQgbGVhdmVzIGEgbm9kZSBpbiBhbiBpbnZhbGlkIHN0YXRlLlwiKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRmKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRmKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkZihvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGYobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRmKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGYoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBhYm92ZSA9IGZ1bmN0aW9uIGFib3ZlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcyxcbiAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgdmFyIHJldmVyc2UgPSBtb2RlID09PSAnbG93ZXN0JztcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGYoRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgcmV2ZXJzZTogcmV2ZXJzZVxuICAgIH0pKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICBuID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgIHAgPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSkgY29udGludWU7XG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBhdC5hbmNob3IucGF0aCkgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmZvY3VzLnBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhwYXRoLCBwKSkge1xuICAgICAgICAgIHJldHVybiBbbiwgcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ4KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDgoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDgoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBhZGRNYXJrID0gZnVuY3Rpb24gYWRkTWFyayhlZGl0b3IsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChub2RlLCBwYXRoKSB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICB9XG5cbiAgICAgIHZhciBfRWRpdG9yJHBhcmVudCA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDIpLFxuICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQyWzBdO1xuICAgICAgICBfRWRpdG9yJHBhcmVudDJbMV07XG4gICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBfRWRpdG9yJG5vZGUgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiksXG4gICAgICAgIF9FZGl0b3Ikbm9kZTIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUsIDIpLFxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdLFxuICAgICAgICBzZWxlY3RlZFBhdGggPSBfRWRpdG9yJG5vZGUyWzFdO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50MyA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpLFxuICAgICAgICAgIF9FZGl0b3IkcGFyZW50NCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50MywgMSksXG4gICAgICAgICAgcGFyZW50Tm9kZSA9IF9FZGl0b3IkcGFyZW50NFswXTtcbiAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpLCB7XG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKSk7XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDcoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkZShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGUobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRlKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkZShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRlKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGFuY2hvciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG4gIHZhciBmb2N1cyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIHZhciByYW5nZSA9IHtcbiAgICBhbmNob3I6IGFuY2hvcixcbiAgICBmb2N1czogZm9jdXNcbiAgfTtcbiAgdmFyIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2U7XG4gIHZhciBkID0gMDtcbiAgdmFyIHRhcmdldDtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGUoRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgYXQ6IHJhbmdlXG4gICAgfSkpKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuICAgICAgZCsrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDYoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ2KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkZChvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkZChvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGQobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRkKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkZChvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRkKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgYW5jaG9yID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICB2YXIgZm9jdXMgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdzdGFydCdcbiAgfSk7XG4gIHZhciByYW5nZSA9IHtcbiAgICBhbmNob3I6IGFuY2hvcixcbiAgICBmb2N1czogZm9jdXNcbiAgfTtcbiAgdmFyIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2U7XG4gIHZhciBkID0gMDtcbiAgdmFyIHRhcmdldDtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGQoRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQkNihfb2JqZWN0U3ByZWFkJDYoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgYXQ6IHJhbmdlLFxuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pKSksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgdGFyZ2V0ID0gcDtcbiAgICAgIH1cbiAgICAgIGQrKztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGRlbGV0ZUJhY2t3YXJkID0gZnVuY3Rpb24gZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB1bml0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgdW5pdDogdW5pdCxcbiAgICAgIHJldmVyc2U6IHRydWVcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGRlbGV0ZUZvcndhcmQgPSBmdW5jdGlvbiBkZWxldGVGb3J3YXJkKGVkaXRvciwgdW5pdCkge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgIHVuaXQ6IHVuaXRcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGRlbGV0ZUZyYWdtZW50ID0gZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICBfcmVmJGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgIGRpcmVjdGlvbiA9IF9yZWYkZGlyZWN0aW9uID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfcmVmJGRpcmVjdGlvbjtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZWRnZXMgPSBmdW5jdGlvbiBlZGdlcyhlZGl0b3IsIGF0KSB7XG4gIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ1KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ1KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZWxlbWVudFJlYWRPbmx5ID0gZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDUoX29iamVjdFNwcmVhZCQ1KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIG4pO1xuICAgIH1cbiAgfSkpO1xufTtcblxudmFyIGVuZCA9IGZ1bmN0aW9uIGVuZChlZGl0b3IsIGF0KSB7XG4gIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xufTtcblxudmFyIGZpcnN0ID0gZnVuY3Rpb24gZmlyc3QoZWRpdG9yLCBhdCkge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnc3RhcnQnXG4gIH0pO1xuICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbn07XG5cbnZhciBmcmFnbWVudCA9IGZ1bmN0aW9uIGZyYWdtZW50KGVkaXRvciwgYXQpIHtcbiAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHJhbmdlKTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ0KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ0KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZ2V0Vm9pZCA9IGZ1bmN0aW9uIGdldFZvaWQoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pO1xuICAgIH1cbiAgfSkpO1xufTtcblxudmFyIGhhc0Jsb2NrcyA9IGZ1bmN0aW9uIGhhc0Jsb2NrcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICB9KTtcbn07XG5cbnZhciBoYXNJbmxpbmVzID0gZnVuY3Rpb24gaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgfSk7XG59O1xuXG52YXIgaGFzUGF0aCA9IGZ1bmN0aW9uIGhhc1BhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIHJldHVybiBOb2RlLmhhcyhlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGhhc1RleHRzID0gZnVuY3Rpb24gaGFzVGV4dHMoZWRpdG9yLCBlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pO1xuICB9KTtcbn07XG5cbnZhciBpbnNlcnRCcmVhayA9IGZ1bmN0aW9uIGluc2VydEJyZWFrKGVkaXRvcikge1xuICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgYWx3YXlzOiB0cnVlXG4gIH0pO1xufTtcblxudmFyIGluc2VydE5vZGUgPSBmdW5jdGlvbiBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSwgb3B0aW9ucykge1xuICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwgb3B0aW9ucyk7XG59O1xuXG52YXIgaW5zZXJ0U29mdEJyZWFrID0gZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrKGVkaXRvcikge1xuICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgYWx3YXlzOiB0cnVlXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBpbnNlcnRUZXh0ID0gZnVuY3Rpb24gaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXJrcyA9IGVkaXRvci5tYXJrcztcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGlmIChtYXJrcykge1xuICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDMoe1xuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9LCBtYXJrcyk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwge1xuICAgICAgICBhdDogb3B0aW9ucy5hdCxcbiAgICAgICAgdm9pZHM6IG9wdGlvbnMudm9pZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgfVxufTtcblxudmFyIGlzQmxvY2sgPSBmdW5jdGlvbiBpc0Jsb2NrKGVkaXRvciwgdmFsdWUpIHtcbiAgcmV0dXJuICFlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xufTtcblxudmFyIGlzRWRnZSA9IGZ1bmN0aW9uIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICByZXR1cm4gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHx8IEVkaXRvci5pc0VuZChlZGl0b3IsIHBvaW50LCBhdCk7XG59O1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG4gIHZhciBfY2hpbGRyZW4gPSBfc2xpY2VkVG9BcnJheShjaGlsZHJlbiwgMSksXG4gICAgZmlyc3QgPSBfY2hpbGRyZW5bMF07XG4gIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGZpcnN0KSAmJiBmaXJzdC50ZXh0ID09PSAnJyAmJiAhZWRpdG9yLmlzVm9pZChlbGVtZW50KTtcbn07XG5cbnZhciBpc0VuZCA9IGZ1bmN0aW9uIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBlbmQpO1xufTtcblxudmFyIGlzTm9ybWFsaXppbmcgPSBmdW5jdGlvbiBpc05vcm1hbGl6aW5nKGVkaXRvcikge1xuICB2YXIgaXNOb3JtYWxpemluZyA9IE5PUk1BTElaSU5HLmdldChlZGl0b3IpO1xuICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG59O1xuXG52YXIgaXNTdGFydCA9IGZ1bmN0aW9uIGlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgLy8gUEVSRjogSWYgdGhlIG9mZnNldCBpc24ndCBgMGAgd2Uga25vdyBpdCdzIG5vdCB0aGUgc3RhcnQuXG4gIGlmIChwb2ludC5vZmZzZXQgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBzdGFydCk7XG59O1xuXG52YXIgbGFzdCA9IGZ1bmN0aW9uIGxhc3QoZWRpdG9yLCBhdCkge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgbGVhZiA9IGZ1bmN0aW9uIGxlYWYoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBbbm9kZSwgcGF0aF07XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRjKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRjKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkYyhvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGMobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRjKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGMoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIGxldmVscyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYyhOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgbiA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHAgPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgaWYgKCFtYXRjaChuLCBwKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldmVscy5wdXNoKFtuLCBwXSk7XG4gICAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsZXZlbHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9KCk7XG59XG5cbnZhciBfZXhjbHVkZWQkMSA9IFtcInRleHRcIl0sXG4gIF9leGNsdWRlZDIkMSA9IFtcInRleHRcIl07XG52YXIgbWFya3MgPSBmdW5jdGlvbiBtYXJrcyhlZGl0b3IpIHtcbiAgdmFyIG1hcmtzID0gZWRpdG9yLm1hcmtzLFxuICAgIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGlmIChtYXJrcykge1xuICAgIHJldHVybiBtYXJrcztcbiAgfVxuICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgdmFyIGlzQmFja3dhcmQgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbik7XG4gICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgIHZhciBfcmVmID0gW2FuY2hvciwgZm9jdXNdO1xuICAgICAgZm9jdXMgPSBfcmVmWzBdO1xuICAgICAgYW5jaG9yID0gX3JlZlsxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ09NUEFUOiBNYWtlIHN1cmUgaGFuZ2luZyByYW5nZXMgKGNhdXNlZCBieSBkb3VibGUgY2xpY2tpbmcgaW4gRmlyZWZveClcbiAgICAgKiBkbyBub3QgYWR2ZXJzZWx5IGFmZmVjdCB0aGUgcmV0dXJuZWQgbWFya3MuXG4gICAgICovXG4gICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYW5jaG9yLCBhbmNob3IucGF0aCk7XG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhbmNob3IpO1xuICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgIGFuY2hvciA9IGFmdGVyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICBhdDoge1xuICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBmb2N1c1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICBtYXRjaCA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIF9tYXRjaCA9IF9zbGljZWRUb0FycmF5KG1hdGNoLCAxKSxcbiAgICAgICAgX25vZGUgPSBfbWF0Y2hbMF07XG4gICAgICBfbm9kZS50ZXh0O1xuICAgICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX25vZGUsIF9leGNsdWRlZCQxKTtcbiAgICAgIHJldHVybiBfcmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuICB2YXIgX2FuY2hvciA9IGFuY2hvcixcbiAgICBwYXRoID0gX2FuY2hvci5wYXRoO1xuICB2YXIgX0VkaXRvciRsZWFmID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKSxcbiAgICBfRWRpdG9yJGxlYWYyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsZWFmLCAxKSxcbiAgICBub2RlID0gX0VkaXRvciRsZWFmMlswXTtcbiAgaWYgKGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgfSk7XG4gICAgdmFyIG1hcmtlZFZvaWQgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFtYXJrZWRWb2lkKSB7XG4gICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXYgJiYgYmxvY2spIHtcbiAgICAgICAgdmFyIF9wcmV2ID0gX3NsaWNlZFRvQXJyYXkocHJldiwgMiksXG4gICAgICAgICAgcHJldk5vZGUgPSBfcHJldlswXSxcbiAgICAgICAgICBwcmV2UGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICB2YXIgX2Jsb2NrID0gX3NsaWNlZFRvQXJyYXkoYmxvY2ssIDIpLFxuICAgICAgICAgIGJsb2NrUGF0aCA9IF9ibG9ja1sxXTtcbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihibG9ja1BhdGgsIHByZXZQYXRoKSkge1xuICAgICAgICAgIG5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgX25vZGUyID0gbm9kZTtcbiAgICBfbm9kZTIudGV4dDtcbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbm9kZTIsIF9leGNsdWRlZDIkMSk7XG4gIHJldHVybiByZXN0O1xufTtcblxudmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDtcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcG9pbnRBZnRlckxvY2F0aW9uID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgYXQsIHtcbiAgICB2b2lkczogdm9pZHNcbiAgfSk7XG4gIGlmICghcG9pbnRBZnRlckxvY2F0aW9uKSByZXR1cm47XG4gIHZhciBfRWRpdG9yJGxhc3QgPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKSxcbiAgICBfRWRpdG9yJGxhc3QyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsYXN0LCAyKSxcbiAgICB0byA9IF9FZGl0b3IkbGFzdDJbMV07XG4gIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG4gIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gIH1cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgX0VkaXRvciRwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpLFxuICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMSksXG4gICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50MlswXTtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBzcGFuLFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pLFxuICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgbmV4dCA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuICByZXR1cm4gbmV4dDtcbn07XG5cbnZhciBub2RlID0gZnVuY3Rpb24gbm9kZShlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICByZXR1cm4gW25vZGUsIHBhdGhdO1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkYihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGIobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRiKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkYihvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRiKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBub2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnYWxsJyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICBfb3B0aW9ucyR1bml2ZXJzYWwgPSBvcHRpb25zLnVuaXZlcnNhbCxcbiAgICAgIHVuaXZlcnNhbCA9IF9vcHRpb25zJHVuaXZlcnNhbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR1bml2ZXJzYWwsXG4gICAgICBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZSxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMsXG4gICAgICBfb3B0aW9ucyRpZ25vcmVOb25TZWwgPSBvcHRpb25zLmlnbm9yZU5vblNlbGVjdGFibGUsXG4gICAgICBpZ25vcmVOb25TZWxlY3RhYmxlID0gX29wdGlvbnMkaWdub3JlTm9uU2VsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGlnbm9yZU5vblNlbDtcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG4gICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IHJldmVyc2UsXG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdG86IHRvLFxuICAgICAgcGFzczogZnVuY3Rpb24gcGFzcyhfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgIG5vZGUgPSBfcmVmMlswXTtcbiAgICAgICAgaWYgKCFFbGVtZW50LmlzRWxlbWVudChub2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXZvaWRzICYmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbm9kZSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGlnbm9yZU5vblNlbGVjdGFibGUgJiYgIUVkaXRvci5pc1NlbGVjdGFibGUoZWRpdG9yLCBub2RlKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBoaXQ7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGIobm9kZUVudHJpZXMpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICBub2RlID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgcGF0aCA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICBpZiAoaWdub3JlTm9uU2VsZWN0YWJsZSAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAhRWRpdG9yLmlzU2VsZWN0YWJsZShlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTG93ZXIgPSBoaXQgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGhpdFsxXSkgPT09IDA7XG4gICAgICAgIC8vIEluIGhpZ2hlc3QgbW9kZSBhbnkgbm9kZSBsb3dlciB0aGFuIHRoZSBsYXN0IGhpdCBpcyBub3QgYSBtYXRjaC5cbiAgICAgICAgaWYgKG1vZGUgPT09ICdoaWdoZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaChub2RlLCBwYXRoKSkge1xuICAgICAgICAgIC8vIElmIHdlJ3ZlIGFycml2ZWQgYXQgYSBsZWFmIHRleHQgbm9kZSB0aGF0IGlzIG5vdCBsb3dlciB0aGFuIHRoZSBsYXN0XG4gICAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgICAgLy8gbWVhbnMgdGhlIG1hdGNoIGlzIG5vdCB1bml2ZXJzYWwuXG4gICAgICAgICAgaWYgKHVuaXZlcnNhbCAmJiAhaXNMb3dlciAmJiBUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIG1hdGNoIGFuZCBpdCdzIGxvd2VyIHRoYW4gdGhlIGxhc3QsIHVwZGF0ZSB0aGUgaGl0LlxuICAgICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuICAgICAgICB2YXIgZW1pdCA9IG1vZGUgPT09ICdsb3dlc3QnID8gaGl0IDogW25vZGUsIHBhdGhdO1xuICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgICAgLy8gU2luY2UgbG93ZXN0IGlzIGFsd2F5cyBlbWl0dGluZyBvbmUgYmVoaW5kLCBjYXRjaCB1cCBhdCB0aGUgZW5kLlxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGhpdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5pdmVyc2FsIGRlZmVycyB0byBlbnN1cmUgdGhhdCB0aGUgbWF0Y2ggb2NjdXJzIGluIGV2ZXJ5IGJyYW5jaCwgc28gd2VcbiAgICAvLyB5aWVsZCBhbGwgb2YgdGhlIG1hdGNoZXMgYWZ0ZXIgaXRlcmF0aW5nLlxuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIHlpZWxkKiBtYXRjaGVzO1xuICAgIH1cbiAgfSgpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRhKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRhKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkYShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGEobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRhKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGEoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJGZvcmNlID0gb3B0aW9ucy5mb3JjZSxcbiAgICBmb3JjZSA9IF9vcHRpb25zJGZvcmNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGZvcmNlLFxuICAgIG9wZXJhdGlvbiA9IG9wdGlvbnMub3BlcmF0aW9uO1xuICB2YXIgZ2V0RGlydHlQYXRocyA9IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICB9O1xuICB2YXIgZ2V0RGlydHlQYXRoS2V5cyA9IGZ1bmN0aW9uIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gIH07XG4gIHZhciBwb3BEaXJ0eVBhdGggPSBmdW5jdGlvbiBwb3BEaXJ0eVBhdGgoZWRpdG9yKSB7XG4gICAgdmFyIHBhdGggPSBnZXREaXJ0eVBhdGhzKGVkaXRvcikucG9wKCk7XG4gICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuICAgIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKVtcImRlbGV0ZVwiXShrZXkpO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZvcmNlKSB7XG4gICAgdmFyIGFsbFBhdGhzID0gQXJyYXkuZnJvbShOb2RlLm5vZGVzKGVkaXRvciksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgdmFyIGFsbFBhdGhLZXlzID0gbmV3IFNldChhbGxQYXRocy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwLmpvaW4oJywnKTtcbiAgICB9KSk7XG4gICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgYWxsUGF0aHMpO1xuICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBhbGxQYXRoS2V5cyk7XG4gIH1cbiAgaWYgKGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAvKlxuICAgICAgRml4IGRpcnR5IGVsZW1lbnRzIHdpdGggbm8gY2hpbGRyZW4uXG4gICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZSgpIGRvZXMgZml4IHRoaXMsIGJ1dCBzb21lIG5vcm1hbGl6YXRpb24gZml4ZXMgYWxzbyByZXF1aXJlIGl0IHRvIHdvcmsuXG4gICAgICBSdW5uaW5nIGFuIGluaXRpYWwgcGFzcyBhdm9pZHMgdGhlIGNhdGNoLTIyIHJhY2UgY29uZGl0aW9uLlxuICAgICovXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGEoZ2V0RGlydHlQYXRocyhlZGl0b3IpKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX2RpcnR5UGF0aCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBfZGlydHlQYXRoKSkge1xuICAgICAgICAgIHZhciBfZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIF9kaXJ0eVBhdGgpO1xuICAgICAgICAgIHZhciBfZW50cnkyID0gX3NsaWNlZFRvQXJyYXkoX2VudHJ5LCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfZW50cnkyWzBdLFxuICAgICAgICAgICAgXyA9IF9lbnRyeTJbMV07XG4gICAgICAgICAgLypcbiAgICAgICAgICAgIFRoZSBkZWZhdWx0IG5vcm1hbGl6ZXIgaW5zZXJ0cyBhbiBlbXB0eSB0ZXh0IG5vZGUgaW4gdGhpcyBzY2VuYXJpbywgYnV0IGl0IGNhbiBiZSBjdXN0b21pc2VkLlxuICAgICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICBBcyBsb25nIGFzIHRoZSBub3JtYWxpemVyIG9ubHkgaW5zZXJ0cyBjaGlsZCBub2RlcyBmb3IgdGhpcyBjYXNlIGl0IGlzIHNhZmUgdG8gZG8gaW4gYW55IG9yZGVyO1xuICAgICAgICAgICAgYnkgZGVmaW5pdGlvbiBhZGRpbmcgY2hpbGRyZW4gdG8gYW4gZW1wdHkgbm9kZSBjYW4ndCBjYXVzZSBvdGhlciBwYXRocyB0byBjaGFuZ2UuXG4gICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKF9lbnRyeSwge1xuICAgICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgICB2YXIgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICB2YXIgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggPSBkaXJ0eVBhdGhzLmxlbmd0aDtcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICB3aGlsZSAoZGlydHlQYXRocy5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmICghZWRpdG9yLnNob3VsZE5vcm1hbGl6ZSh7XG4gICAgICAgIGRpcnR5UGF0aHM6IGRpcnR5UGF0aHMsXG4gICAgICAgIGl0ZXJhdGlvbjogaXRlcmF0aW9uLFxuICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aDogaW5pdGlhbERpcnR5UGF0aHNMZW5ndGgsXG4gICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGlydHlQYXRoID0gcG9wRGlydHlQYXRoKGVkaXRvcik7XG4gICAgICAvLyBJZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQuXG4gICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBkaXJ0eVBhdGgpKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZGlydHlQYXRoKTtcbiAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoZW50cnksIHtcbiAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHBhcmVudCA9IGZ1bmN0aW9uIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcblxudmFyIHBhdGhSZWYgPSBmdW5jdGlvbiBwYXRoUmVmKGVkaXRvciwgcGF0aCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcGF0aCxcbiAgICBhZmZpbml0eTogYWZmaW5pdHksXG4gICAgdW5yZWY6IGZ1bmN0aW9uIHVucmVmKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgICAgcGF0aFJlZnNbXCJkZWxldGVcIl0ocmVmKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciBwYXRoUmVmcyA9IGZ1bmN0aW9uIHBhdGhSZWZzKGVkaXRvcikge1xuICB2YXIgcmVmcyA9IFBBVEhfUkVGUy5nZXQoZWRpdG9yKTtcbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gIH1cbiAgcmV0dXJuIHJlZnM7XG59O1xuXG52YXIgcGF0aCA9IGZ1bmN0aW9uIHBhdGgoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBkZXB0aCA9IG9wdGlvbnMuZGVwdGgsXG4gICAgZWRnZSA9IG9wdGlvbnMuZWRnZTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICB2YXIgX05vZGUkZmlyc3QgPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpLFxuICAgICAgICBfTm9kZSRmaXJzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRmaXJzdCwgMiksXG4gICAgICAgIGZpcnN0UGF0aCA9IF9Ob2RlJGZpcnN0MlsxXTtcbiAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBfTm9kZSRsYXN0ID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpLFxuICAgICAgICBfTm9kZSRsYXN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGxhc3QsIDIpLFxuICAgICAgICBsYXN0UGF0aCA9IF9Ob2RlJGxhc3QyWzFdO1xuICAgICAgYXQgPSBsYXN0UGF0aDtcbiAgICB9XG4gIH1cbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGF0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXQgPSBQYXRoLmNvbW1vbihhdC5hbmNob3IucGF0aCwgYXQuZm9jdXMucGF0aCk7XG4gICAgfVxuICB9XG4gIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgIGF0ID0gYXQucGF0aDtcbiAgfVxuICBpZiAoZGVwdGggIT0gbnVsbCkge1xuICAgIGF0ID0gYXQuc2xpY2UoMCwgZGVwdGgpO1xuICB9XG4gIHJldHVybiBhdDtcbn07XG5cbnZhciBwb2ludFJlZiA9IGZ1bmN0aW9uIHBvaW50UmVmKGVkaXRvciwgcG9pbnQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IHBvaW50LFxuICAgIGFmZmluaXR5OiBhZmZpbml0eSxcbiAgICB1bnJlZjogZnVuY3Rpb24gdW5yZWYoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgdmFyIHBvaW50UmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgICAgIHBvaW50UmVmc1tcImRlbGV0ZVwiXShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgcmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciBwb2ludFJlZnMgPSBmdW5jdGlvbiBwb2ludFJlZnMoZWRpdG9yKSB7XG4gIHZhciByZWZzID0gUE9JTlRfUkVGUy5nZXQoZWRpdG9yKTtcbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHBvaW50ID0gZnVuY3Rpb24gcG9pbnQoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBfb3B0aW9ucyRlZGdlID0gb3B0aW9ucy5lZGdlLFxuICAgIGVkZ2UgPSBfb3B0aW9ucyRlZGdlID09PSB2b2lkIDAgPyAnc3RhcnQnIDogX29wdGlvbnMkZWRnZTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgIHZhciBwYXRoO1xuICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIF9Ob2RlJGxhc3QgPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCksXG4gICAgICAgIF9Ob2RlJGxhc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkbGFzdCwgMiksXG4gICAgICAgIGxhc3RQYXRoID0gX05vZGUkbGFzdDJbMV07XG4gICAgICBwYXRoID0gbGFzdFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfTm9kZSRmaXJzdCA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCksXG4gICAgICAgIF9Ob2RlJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0LCAyKSxcbiAgICAgICAgZmlyc3RQYXRoID0gX05vZGUkZmlyc3QyWzFdO1xuICAgICAgcGF0aCA9IGZpcnN0UGF0aDtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIFwiLmNvbmNhdChlZGdlLCBcIiBwb2ludCBpbiB0aGUgbm9kZSBhdCBwYXRoIFtcIikuY29uY2F0KGF0LCBcIl0gYmVjYXVzZSBpdCBoYXMgbm8gXCIpLmNvbmNhdChlZGdlLCBcIiB0ZXh0IG5vZGUuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBvZmZzZXQ6IGVkZ2UgPT09ICdlbmQnID8gbm9kZS50ZXh0Lmxlbmd0aCA6IDBcbiAgICB9O1xuICB9XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgfVxuICByZXR1cm4gYXQ7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ5KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIHBvc2l0aW9ucyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnb2Zmc2V0JyA6IF9vcHRpb25zJHVuaXQsXG4gICAgICBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZSxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMsXG4gICAgICBfb3B0aW9ucyRpZ25vcmVOb25TZWwgPSBvcHRpb25zLmlnbm9yZU5vblNlbGVjdGFibGUsXG4gICAgICBpZ25vcmVOb25TZWxlY3RhYmxlID0gX29wdGlvbnMkaWdub3JlTm9uU2VsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGlnbm9yZU5vblNlbDtcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRobSBub3RlczpcbiAgICAgKlxuICAgICAqIEVhY2ggc3RlcCBgZGlzdGFuY2VgIGlzIGR5bmFtaWMgZGVwZW5kaW5nIG9uIHRoZSB1bmRlcmx5aW5nIHRleHRcbiAgICAgKiBhbmQgdGhlIGB1bml0YCBzcGVjaWZpZWQuICBFYWNoIHN0ZXAsIGUuZy4sIGEgbGluZSBvciB3b3JkLCBtYXlcbiAgICAgKiBzcGFuIG11bHRpcGxlIHRleHQgbm9kZXMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGV4dCBib3RoIG9uXG4gICAgICogdHdvIGxldmVscyBpbiBzdGVwLXN5bmM6XG4gICAgICpcbiAgICAgKiBgbGVhZlRleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIHRleHQgbGVhZiBsZXZlbCwgYW5kIGlzIGFkdmFuY2VkXG4gICAgICogdGhyb3VnaCB1c2luZyB0aGUgY291bnRlcnMgYGxlYWZUZXh0T2Zmc2V0YCBhbmQgYGxlYWZUZXh0UmVtYWluaW5nYC5cbiAgICAgKlxuICAgICAqIGBibG9ja1RleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIGJsb2NrIGxldmVsLCBhbmQgaXMgc2hvcnRlbmVkXG4gICAgICogYnkgYGRpc3RhbmNlYCBldmVyeSB0aW1lIGl0IGlzIGFkdmFuY2VkLlxuICAgICAqXG4gICAgICogV2Ugb25seSBtYWludGFpbiBhIHdpbmRvdyBvZiBvbmUgYmxvY2tUZXh0IGFuZCBvbmUgbGVhZlRleHQgYmVjYXVzZVxuICAgICAqIGEgYmxvY2sgbm9kZSBhbHdheXMgYXBwZWFycyBiZWZvcmUgYWxsIG9mIGl0cyBsZWFmIG5vZGVzLlxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICAgIHZhciBmaXJzdCA9IHJldmVyc2UgPyBlbmQgOiBzdGFydDtcbiAgICB2YXIgaXNOZXdCbG9jayA9IGZhbHNlO1xuICAgIHZhciBibG9ja1RleHQgPSAnJztcbiAgICB2YXIgZGlzdGFuY2UgPSAwOyAvLyBEaXN0YW5jZSBmb3IgbGVhZlRleHQgdG8gY2F0Y2ggdXAgdG8gYmxvY2tUZXh0LlxuICAgIHZhciBsZWFmVGV4dFJlbWFpbmluZyA9IDA7XG4gICAgdmFyIGxlYWZUZXh0T2Zmc2V0ID0gMDtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vZGVzIGluIHJhbmdlLCBncmFiYmluZyBlbnRpcmUgdGV4dHVhbCBjb250ZW50XG4gICAgLy8gb2YgYmxvY2sgbm9kZXMgaW4gYmxvY2tUZXh0LCBhbmQgdGV4dCBub2RlcyBpbiBsZWFmVGV4dC5cbiAgICAvLyBFeHBsb2l0cyB0aGUgZmFjdCB0aGF0IG5vZGVzIGFyZSBzZXF1ZW5jZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIGZpcnN0XG4gICAgLy8gZW5jb3VudGVyIHRoZSBibG9jayBub2RlLCB0aGVuIGFsbCBvZiBpdHMgdGV4dCBub2Rlcywgc28gd2hlbiBpdGVyYXRpbmdcbiAgICAvLyB0aHJvdWdoIHRoZSBibG9ja1RleHQgYW5kIGxlYWZUZXh0IHdlIGp1c3QgbmVlZCB0byByZW1lbWJlciBhIHdpbmRvdyBvZlxuICAgIC8vIG9uZSBibG9jayBub2RlIGFuZCBsZWFmIG5vZGUsIHJlc3BlY3RpdmVseS5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICBpZ25vcmVOb25TZWxlY3RhYmxlOiBpZ25vcmVOb25TZWxlY3RhYmxlXG4gICAgICB9KSksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgIG5vZGUgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICBwYXRoID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgIC8qXG4gICAgICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgLy8gVm9pZCBub2RlcyBhcmUgYSBzcGVjaWFsIGNhc2UsIHNvIGJ5IGRlZmF1bHQgd2Ugd2lsbCBhbHdheXNcbiAgICAgICAgICAvLyB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC4gSWYgdGhlIGB2b2lkc2Agb3B0aW9uIGlzIHNldCB0byB0cnVlLFxuICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBpdGVyYXRlIG92ZXIgdGhlaXIgY29udGVudC5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIChlZGl0b3IuaXNWb2lkKG5vZGUpIHx8IGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShub2RlKSkpIHtcbiAgICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElubGluZSBlbGVtZW50IG5vZGVzIGFyZSBpZ25vcmVkIGFzIHRoZXkgZG9uJ3QgdGhlbXNlbHZlc1xuICAgICAgICAgIC8vIGNvbnRyaWJ1dGUgdG8gYGJsb2NrVGV4dGAgb3IgYGxlYWZUZXh0YCAtIHRoZWlyIHBhcmVudCBhbmRcbiAgICAgICAgICAvLyBjaGlsZHJlbiBkby5cbiAgICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSBjb250aW51ZTtcbiAgICAgICAgICAvLyBCbG9jayBlbGVtZW50IG5vZGUgLSBzZXQgYGJsb2NrVGV4dGAgdG8gaXRzIHRleHQgY29udGVudC5cbiAgICAgICAgICBpZiAoRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIGV4aGF1c3QgYmxvY2sgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsXG4gICAgICAgICAgICAvLyAgICAgYGJsb2NrVGV4dD0nJHtibG9ja1RleHR9JyAtIGArXG4gICAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBibG9jayBub2RlYCwgcGF0aClcbiAgICAgICAgICAgIC8vIEVuc3VyZSByYW5nZSBjb25zaWRlcmVkIGlzIGNhcHBlZCB0byBgcmFuZ2VgLCBpbiB0aGVcbiAgICAgICAgICAgIC8vIHN0YXJ0L2VuZCBlZGdlIGNhc2VzIHdoZXJlIGJsb2NrIGV4dGVuZHMgYmV5b25kIHJhbmdlLlxuICAgICAgICAgICAgLy8gRXF1aXZhbGVudCB0byB0aGlzLCBidXQgcHJlc3VtYWJseSBtb3JlIHBlcmZvcm1hbnQ6XG4gICAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCAuLi5FZGl0b3IuZWRnZXMoZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgYmxvY2tSYW5nZSkgLy8gaW50ZXJzZWN0XG4gICAgICAgICAgICAvLyAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1JhbmdlLCB7IHZvaWRzIH0pXG4gICAgICAgICAgICB2YXIgZSA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBlbmQucGF0aCkgPyBlbmQgOiBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgICB2YXIgcyA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBzdGFydC5wYXRoKSA/IHN0YXJ0IDogRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgICBhbmNob3I6IHMsXG4gICAgICAgICAgICAgIGZvY3VzOiBlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpc05ld0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogVEVYVCBMRUFGIE5PREUgLSBJdGVyYXRlIHRocm91Z2ggdGV4dCBjb250ZW50LCB5aWVsZGluZ1xuICAgICAgICAgKiBwb3NpdGlvbnMgZXZlcnkgYGRpc3RhbmNlYCBvZmZzZXQgYWNjb3JkaW5nIHRvIGB1bml0YC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgIHZhciBpc0ZpcnN0ID0gUGF0aC5lcXVhbHMocGF0aCwgZmlyc3QucGF0aCk7XG4gICAgICAgICAgLy8gUHJvb2YgdGhhdCB3ZSBhbHdheXMgZXhoYXVzdCB0ZXh0IG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCxcbiAgICAgICAgICAvLyAgICAgYGxlYWZUZXh0UmVtYWluaW5nPSR7bGVhZlRleHRSZW1haW5pbmd9IC0gYCtcbiAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBsZWFmIHRleHQgbm9kZWAsIHBhdGgpXG4gICAgICAgICAgLy8gUmVzZXQgYGxlYWZUZXh0YCBjb3VudGVycyBmb3IgbmV3IHRleHQgbm9kZS5cbiAgICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSByZXZlcnNlID8gZmlyc3Qub2Zmc2V0IDogbm9kZS50ZXh0Lmxlbmd0aCAtIGZpcnN0Lm9mZnNldDtcbiAgICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gWWllbGQgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIG5vZGUgKHBvdGVudGlhbGx5KS5cbiAgICAgICAgICBpZiAoaXNGaXJzdCB8fCBpc05ld0Jsb2NrIHx8IHVuaXQgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFlpZWxkIHBvc2l0aW9ucyBldmVyeSAoZHluYW1pY2FsbHkgY2FsY3VsYXRlZCkgYGRpc3RhbmNlYCBvZmZzZXQuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIElmIGBsZWFmVGV4dGAgaGFzIGNhdWdodCB1cCB3aXRoIGBibG9ja1RleHRgIChkaXN0YW5jZT0wKSxcbiAgICAgICAgICAgIC8vIGFuZCBpZiBibG9ja1RleHQgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYW5vdGhlciBibG9jayBub2RlLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFkdmFuY2UgYmxvY2tUZXh0IGZvcndhcmQgYnkgdGhlIG5ldyBgZGlzdGFuY2VgLlxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChibG9ja1RleHQgPT09ICcnKSBicmVhaztcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoYmxvY2tUZXh0LCB1bml0LCByZXZlcnNlKTtcbiAgICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHN0cmluZyBhdCB0aGUgcHJldmlvdXNseSBmb3VuZCBkaXN0YW5jZSBhbmQgdXNlIHRoZVxuICAgICAgICAgICAgICAvLyByZW1haW5pbmcgc3RyaW5nIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgIGJsb2NrVGV4dCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShibG9ja1RleHQsIGRpc3RhbmNlLCByZXZlcnNlKVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkdmFuY2UgYGxlYWZUZXh0YCBieSB0aGUgY3VycmVudCBgZGlzdGFuY2VgLlxuICAgICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRPZmZzZXQgLSBkaXN0YW5jZSA6IGxlYWZUZXh0T2Zmc2V0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IGxlYWZUZXh0UmVtYWluaW5nIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAvLyBJZiBgbGVhZlRleHRgIGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGEgbmV3IGxlYWYgbm9kZVxuICAgICAgICAgICAgLy8gYW5kIHNldCBkaXN0YW5jZSB0byB0aGUgb3ZlcmZsb3cgYW1vdW50LCBzbyB3ZSdsbCAobWF5YmUpXG4gICAgICAgICAgICAvLyBjYXRjaCB1cCB0byBibG9ja1RleHQgaW4gdGhlIG5leHQgbGVhZiB0ZXh0IG5vZGUuXG4gICAgICAgICAgICBpZiAobGVhZlRleHRSZW1haW5pbmcgPCAwKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gLWxlYWZUZXh0UmVtYWluaW5nO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSB3YWxrZWQgYGRpc3RhbmNlYCBvZmZzZXRzIHRocm91Z2ggYGxlYWZUZXh0YFxuICAgICAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgICAgIC8vIGFuZCB5aWVsZCB0aGlzIHBvc2l0aW9uIGluIHRoaXMgbm9kZS5cbiAgICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAgICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLCBcImxlYWZUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJywgXCJibG9ja1RleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgICAgLy8gSGVscGVyOlxuICAgICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBvZmZzZXRzIGZvciBhIHN0ZXAgb2Ygc2l6ZSBgdW5pdGAgb24gZ2l2ZW4gc3RyaW5nLlxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0oKTtcbn1cblxudmFyIHByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZSxcbiAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0O1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwb2ludEJlZm9yZUxvY2F0aW9uID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCB7XG4gICAgdm9pZHM6IHZvaWRzXG4gIH0pO1xuICBpZiAoIXBvaW50QmVmb3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIF9FZGl0b3IkZmlyc3QgPSBFZGl0b3IuZmlyc3QoZWRpdG9yLCBbXSksXG4gICAgX0VkaXRvciRmaXJzdDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGZpcnN0LCAyKSxcbiAgICB0byA9IF9FZGl0b3IkZmlyc3QyWzFdO1xuICAvLyBUaGUgc2VhcmNoIGxvY2F0aW9uIGlzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB0byB0aGUgcGF0aCBvZlxuICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cbiAgdmFyIHNwYW4gPSBbcG9pbnRCZWZvcmVMb2NhdGlvbi5wYXRoLCB0b107XG4gIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICB9XG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KSxcbiAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDEpLFxuICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDJbMF07XG4gICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdmFyIF9FZGl0b3Ikbm9kZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSksXG4gICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICBwcmV2aW91cyA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG52YXIgcmFuZ2VSZWYgPSBmdW5jdGlvbiByYW5nZVJlZihlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiByYW5nZSxcbiAgICBhZmZpbml0eTogYWZmaW5pdHksXG4gICAgdW5yZWY6IGZ1bmN0aW9uIHVucmVmKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICByYW5nZVJlZnNbXCJkZWxldGVcIl0ocmVmKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gIHJlZnMuYWRkKHJlZik7XG4gIHJldHVybiByZWY7XG59O1xuXG52YXIgcmFuZ2VSZWZzID0gZnVuY3Rpb24gcmFuZ2VSZWZzKGVkaXRvcikge1xuICB2YXIgcmVmcyA9IFJBTkdFX1JFRlMuZ2V0KGVkaXRvcik7XG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciByYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICByZXR1cm4gYXQ7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHN0YXJ0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQyKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQyKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgcmVtb3ZlTWFyayA9IGZ1bmN0aW9uIHJlbW92ZU1hcmsoZWRpdG9yLCBrZXkpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChub2RlLCBwYXRoKSB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICB9XG5cbiAgICAgIHZhciBfRWRpdG9yJHBhcmVudCA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDIpLFxuICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQyWzBdO1xuICAgICAgICBfRWRpdG9yJHBhcmVudDJbMV07XG4gICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBfRWRpdG9yJG5vZGUgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiksXG4gICAgICAgIF9FZGl0b3Ikbm9kZTIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUsIDIpLFxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdLFxuICAgICAgICBzZWxlY3RlZFBhdGggPSBfRWRpdG9yJG5vZGUyWzFdO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50MyA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpLFxuICAgICAgICAgIF9FZGl0b3IkcGFyZW50NCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50MywgMSksXG4gICAgICAgICAgcGFyZW50Tm9kZSA9IF9FZGl0b3IkcGFyZW50NFswXTtcbiAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIGtleSwge1xuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkMih7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pO1xuICAgICAgZGVsZXRlIG1hcmtzW2tleV07XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2V0Tm9ybWFsaXppbmcgPSBmdW5jdGlvbiBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgTk9STUFMSVpJTkcuc2V0KGVkaXRvciwgaXNOb3JtYWxpemluZyk7XG59O1xuXG52YXIgc3RhcnQgPSBmdW5jdGlvbiBzdGFydChlZGl0b3IsIGF0KSB7XG4gIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdzdGFydCdcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ4KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDgobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ4KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDgoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICB2YXIgdGV4dCA9ICcnO1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOChFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgbm9kZSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICBwYXRoID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICB2YXIgdCA9IG5vZGUudGV4dDtcbiAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgdCA9IHQuc2xpY2UoMCwgZW5kLm9mZnNldCk7XG4gICAgICB9XG4gICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgdCA9IHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHRleHQgKz0gdDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4gdGV4dDtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIHVuaGFuZ1JhbmdlID0gZnVuY3Rpb24gdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgLy8gUEVSRjogZXhpdCBlYXJseSBpZiB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlIGlzbid0IGhhbmdpbmcuXG4gIGlmIChzdGFydC5vZmZzZXQgIT09IDAgfHwgZW5kLm9mZnNldCAhPT0gMCB8fCBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgfHwgUGF0aC5oYXNQcmV2aW91cyhlbmQucGF0aCkpIHtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIGF0OiBlbmQsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH0sXG4gICAgdm9pZHM6IHZvaWRzXG4gIH0pO1xuICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICB2YXIgZmlyc3QgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBzdGFydCk7XG4gIHZhciBiZWZvcmUgPSB7XG4gICAgYW5jaG9yOiBmaXJzdCxcbiAgICBmb2N1czogZW5kXG4gIH07XG4gIHZhciBza2lwID0gdHJ1ZTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGJlZm9yZSxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgbm9kZSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICBwYXRoID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICBpZiAoc2tpcCkge1xuICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUudGV4dCAhPT0gJycgfHwgUGF0aC5pc0JlZm9yZShwYXRoLCBibG9ja1BhdGgpKSB7XG4gICAgICAgIGVuZCA9IHtcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIG9mZnNldDogbm9kZS50ZXh0Lmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuY2hvcjogc3RhcnQsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xufTtcblxudmFyIHdpdGhvdXROb3JtYWxpemluZyA9IGZ1bmN0aW9uIHdpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZuKSB7XG4gIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIGZhbHNlKTtcbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgfVxuICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG59O1xuXG52YXIgc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlID0gZnVuY3Rpb24gc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlKGVkaXRvciwgX3JlZiwgX3JlZjIpIHtcbiAgdmFyIF9yZWYzID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgcHJldk5vZGUgPSBfcmVmM1swXSxcbiAgICBwcmV2UGF0aCA9IF9yZWYzWzFdO1xuICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMik7XG4gICAgX3JlZjRbMF07XG4gICAgX3JlZjRbMV07XG4gIC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgLy8gb2YgbWVyZ2luZyB0aGUgdHdvLiBUaGlzIGlzIGEgY29tbW9uIHJpY2ggdGV4dCBlZGl0b3IgYmVoYXZpb3IgdG9cbiAgLy8gcHJldmVudCBsb3NpbmcgZm9ybWF0dGluZyB3aGVuIGRlbGV0aW5nIGVudGlyZSBub2RlcyB3aGVuIHlvdSBoYXZlIGFcbiAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4gIC8vIGlmIHByZXZOb2RlIGlzIGZpcnN0IGNoaWxkIGluIHBhcmVudCxkb24ndCByZW1vdmUgaXQuXG4gIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnICYmIHByZXZQYXRoW3ByZXZQYXRoLmxlbmd0aCAtIDFdICE9PSAwO1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ2KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgZGVsZXRlVGV4dCA9IGZ1bmN0aW9uIGRlbGV0ZVRleHQoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX0VkaXRvciR2b2lkLCBfRWRpdG9yJHZvaWQyO1xuICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZSxcbiAgICAgIF9vcHRpb25zJHVuaXQgPSBvcHRpb25zLnVuaXQsXG4gICAgICB1bml0ID0gX29wdGlvbnMkdW5pdCA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0LFxuICAgICAgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgICAgZGlzdGFuY2UgPSBfb3B0aW9ucyRkaXN0YW5jZSA9PT0gdm9pZCAwID8gMSA6IF9vcHRpb25zJGRpc3RhbmNlLFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgX29wdGlvbnMkaGFuZ2luZyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmc7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICB9XG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICB2YXIgZnVydGhlc3RWb2lkID0gRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgaWYgKCF2b2lkcyAmJiBmdXJ0aGVzdFZvaWQpIHtcbiAgICAgICAgdmFyIF9mdXJ0aGVzdFZvaWQgPSBfc2xpY2VkVG9BcnJheShmdXJ0aGVzdFZvaWQsIDIpLFxuICAgICAgICAgIHZvaWRQYXRoID0gX2Z1cnRoZXN0Vm9pZFsxXTtcbiAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXJnZXQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSkgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgYXQgPSB7XG4gICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICBmb2N1czogdGFyZ2V0XG4gICAgICAgIH07XG4gICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgX2VuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgICB2YXIgZW5kT2ZEb2MgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgaWYgKCFQb2ludC5lcXVhbHMoX2VuZCwgZW5kT2ZEb2MpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM0WzBdLFxuICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNFsxXTtcbiAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIGF0OiBzdGFydCxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIGF0OiBlbmQsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgaXNBY3Jvc3NCbG9ja3MgPSBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSk7XG4gICAgdmFyIGlzU2luZ2xlVGV4dCA9IFBhdGguZXF1YWxzKHN0YXJ0LnBhdGgsIGVuZC5wYXRoKTtcbiAgICB2YXIgc3RhcnROb25FZGl0YWJsZSA9IHZvaWRzID8gbnVsbCA6IChfRWRpdG9yJHZvaWQgPSBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpICE9PSBudWxsICYmIF9FZGl0b3Ikdm9pZCAhPT0gdm9pZCAwID8gX0VkaXRvciR2b2lkIDogRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgIGF0OiBzdGFydCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pO1xuICAgIHZhciBlbmROb25FZGl0YWJsZSA9IHZvaWRzID8gbnVsbCA6IChfRWRpdG9yJHZvaWQyID0gRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkgIT09IG51bGwgJiYgX0VkaXRvciR2b2lkMiAhPT0gdm9pZCAwID8gX0VkaXRvciR2b2lkMiA6IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICBhdDogZW5kLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSk7XG4gICAgLy8gSWYgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludHMgYXJlIGluc2lkZSBhbiBpbmxpbmUgdm9pZCwgbnVkZ2UgdGhlbSBvdXQuXG4gICAgaWYgKHN0YXJ0Tm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuICAgICAgaWYgKGJlZm9yZSAmJiBzdGFydEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihzdGFydEJsb2NrWzFdLCBiZWZvcmUucGF0aCkpIHtcbiAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcbiAgICAgIGlmIChhZnRlciAmJiBlbmRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3IoZW5kQmxvY2tbMV0sIGFmdGVyLnBhdGgpKSB7XG4gICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIGhpZ2hlc3Qgbm9kZXMgdGhhdCBhcmUgY29tcGxldGVseSBpbnNpZGUgdGhlIHJhbmdlLCBhcyB3ZWxsIGFzXG4gICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMuXG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgbGFzdFBhdGg7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSkpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgX2VudHJ5ID0gX3NsaWNlZFRvQXJyYXkoZW50cnksIDIpLFxuICAgICAgICAgIF9ub2RlMiA9IF9lbnRyeVswXSxcbiAgICAgICAgICBfcGF0aDIgPSBfZW50cnlbMV07XG4gICAgICAgIGlmIChsYXN0UGF0aCAmJiBQYXRoLmNvbXBhcmUoX3BhdGgyLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KF9ub2RlMikgJiYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBfbm9kZTIpIHx8IEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIF9ub2RlMikpIHx8ICFQYXRoLmlzQ29tbW9uKF9wYXRoMiwgc3RhcnQucGF0aCkgJiYgIVBhdGguaXNDb21tb24oX3BhdGgyLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICAgIGxhc3RQYXRoID0gX3BhdGgyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuICAgIGlmICghaXNTaW5nbGVUZXh0ICYmICFzdGFydE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgX3BvaW50ID0gc3RhcnRSZWYuY3VycmVudDtcbiAgICAgIHZhciBfRWRpdG9yJGxlYWYgPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludCksXG4gICAgICAgIF9FZGl0b3IkbGVhZjIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGxlYWYsIDEpLFxuICAgICAgICBub2RlID0gX0VkaXRvciRsZWFmMlswXTtcbiAgICAgIHZhciBwYXRoID0gX3BvaW50LnBhdGg7XG4gICAgICB2YXIgX3N0YXJ0ID0gc3RhcnQsXG4gICAgICAgIG9mZnNldCA9IF9zdGFydC5vZmZzZXQ7XG4gICAgICB2YXIgdGV4dCA9IG5vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByLnVucmVmKCk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gciAhPT0gbnVsbDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHAsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFlbmROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIF9wb2ludDIgPSBlbmRSZWYuY3VycmVudDtcbiAgICAgIHZhciBfRWRpdG9yJGxlYWYzID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQyKSxcbiAgICAgICAgX0VkaXRvciRsZWFmNCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZjMsIDEpLFxuICAgICAgICBfbm9kZSA9IF9FZGl0b3IkbGVhZjRbMF07XG4gICAgICB2YXIgX3BhdGggPSBfcG9pbnQyLnBhdGg7XG4gICAgICB2YXIgX29mZnNldCA9IGlzU2luZ2xlVGV4dCA/IHN0YXJ0Lm9mZnNldCA6IDA7XG4gICAgICB2YXIgX3RleHQgPSBfbm9kZS50ZXh0LnNsaWNlKF9vZmZzZXQsIGVuZC5vZmZzZXQpO1xuICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSBfdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgaXNBY3Jvc3NCbG9ja3MgJiYgZW5kUmVmLmN1cnJlbnQgJiYgc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIGhhbmdpbmc6IHRydWUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvciBUaGFpIHNjcmlwdCwgZGVsZXRpbmcgTiBjaGFyYWN0ZXIocykgYmFja3dhcmQgc2hvdWxkIGRlbGV0ZVxuICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgIC8vIFRoZXJlZm9yZSwgdGhlIHJlbWFpbmluZyBjb2RlIHBvaW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgYmFjay5cbiAgICBpZiAoaXNDb2xsYXBzZWQgJiYgcmV2ZXJzZSAmJiB1bml0ID09PSAnY2hhcmFjdGVyJyAmJiByZW1vdmVkVGV4dC5sZW5ndGggPiAxICYmIHJlbW92ZWRUZXh0Lm1hdGNoKC9bXFx1MEUwMC1cXHUwRTdGXSsvKSkge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgcmVtb3ZlZFRleHQuc2xpY2UoMCwgcmVtb3ZlZFRleHQubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0VW5yZWYgPSBzdGFydFJlZi51bnJlZigpO1xuICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBzdGFydFVucmVmIHx8IGVuZFVucmVmIDogZW5kVW5yZWYgfHwgc3RhcnRVbnJlZjtcbiAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ1KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgaW5zZXJ0RnJhZ21lbnQgPSBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdGlvbnMkaGFuZ2luZyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmcsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKSA6IF9vcHRpb25zJGF0LFxuICAgICAgX29wdGlvbnMkYmF0Y2hEaXJ0eSA9IG9wdGlvbnMuYmF0Y2hEaXJ0eSxcbiAgICAgIGJhdGNoRGlydHkgPSBfb3B0aW9ucyRiYXRjaERpcnR5ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYmF0Y2hEaXJ0eTtcbiAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgfVxuICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiBhdFxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHRoZSBpbnNlcnQgcG9pbnQgaXMgYXQgdGhlIGVkZ2Ugb2YgYW4gaW5saW5lIG5vZGUsIG1vdmUgaXQgb3V0c2lkZVxuICAgIC8vIGluc3RlYWQgc2luY2UgaXQgd2lsbCBuZWVkIHRvIGJlIHNwbGl0IG90aGVyd2lzZS5cbiAgICB2YXIgaW5saW5lRWxlbWVudE1hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IGF0LFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIGlmIChpbmxpbmVFbGVtZW50TWF0Y2gpIHtcbiAgICAgIHZhciBfaW5saW5lRWxlbWVudE1hdGNoID0gX3NsaWNlZFRvQXJyYXkoaW5saW5lRWxlbWVudE1hdGNoLCAyKSxcbiAgICAgICAgX2lubGluZVBhdGggPSBfaW5saW5lRWxlbWVudE1hdGNoWzFdO1xuICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgIGF0ID0gYmVmb3JlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIGF0OiBhdCxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBfYmxvY2tNYXRjaCA9IF9zbGljZWRUb0FycmF5KGJsb2NrTWF0Y2gsIDIpLFxuICAgICAgYmxvY2tQYXRoID0gX2Jsb2NrTWF0Y2hbMV07XG4gICAgdmFyIGlzQmxvY2tTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgdmFyIGlzQmxvY2tFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICB2YXIgaXNCbG9ja0VtcHR5ID0gaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgdmFyIG1lcmdlU3RhcnQgPSAhaXNCbG9ja1N0YXJ0IHx8IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgIHZhciBtZXJnZUVuZCA9ICFpc0Jsb2NrRW5kO1xuICAgIHZhciBfTm9kZSRmaXJzdCA9IE5vZGUuZmlyc3Qoe1xuICAgICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICAgIH0sIFtdKSxcbiAgICAgIF9Ob2RlJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0LCAyKSxcbiAgICAgIGZpcnN0UGF0aCA9IF9Ob2RlJGZpcnN0MlsxXTtcbiAgICB2YXIgX05vZGUkbGFzdCA9IE5vZGUubGFzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pLFxuICAgICAgX05vZGUkbGFzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRsYXN0LCAyKSxcbiAgICAgIGxhc3RQYXRoID0gX05vZGUkbGFzdDJbMV07XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgbWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoZXIoX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIG4gPSBfcmVmMlswXSxcbiAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNCbG9ja0VtcHR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1lcmdlU3RhcnQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGZpcnN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobWVyZ2VFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoTm9kZS5ub2Rlcyh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwge1xuICAgICAgICBwYXNzOiBtYXRjaGVyXG4gICAgICB9KSksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmIChtYXRjaGVyKGVudHJ5KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICB2YXIgbWlkZGxlcyA9IFtdO1xuICAgIHZhciBlbmRzID0gW107XG4gICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICB2YXIgaGFzQmxvY2tzID0gZmFsc2U7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfbWF0Y2hlcyA9IG1hdGNoZXM7IF9pIDwgX21hdGNoZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX21hdGNoZXMkX2kgPSBfc2xpY2VkVG9BcnJheShfbWF0Y2hlc1tfaV0sIDEpLFxuICAgICAgICBub2RlID0gX21hdGNoZXMkX2lbMF07XG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICBoYXNCbG9ja3MgPSB0cnVlO1xuICAgICAgICBtaWRkbGVzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgIHN0YXJ0cy5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pLFxuICAgICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICAgIGlubGluZU1hdGNoID0gX0VkaXRvciRub2RlczJbMF07XG4gICAgdmFyIF9pbmxpbmVNYXRjaCA9IF9zbGljZWRUb0FycmF5KGlubGluZU1hdGNoLCAyKSxcbiAgICAgIGlubGluZVBhdGggPSBfaW5saW5lTWF0Y2hbMV07XG4gICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYXQsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gaGFzQmxvY2tzID8gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgYWx3YXlzOiBoYXNCbG9ja3MgJiYgKCFpc0Jsb2NrU3RhcnQgfHwgc3RhcnRzLmxlbmd0aCA+IDApICYmICghaXNCbG9ja0VuZCB8fCBlbmRzLmxlbmd0aCA+IDApLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCAhaXNJbmxpbmVTdGFydCB8fCBpc0lubGluZVN0YXJ0ICYmIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHN0YXJ0cywge1xuICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgYmF0Y2hEaXJ0eTogYmF0Y2hEaXJ0eVxuICAgIH0pO1xuICAgIGlmIChpc0Jsb2NrRW1wdHkgJiYgIXN0YXJ0cy5sZW5ndGggJiYgbWlkZGxlcy5sZW5ndGggJiYgIWVuZHMubGVuZ3RoKSB7XG4gICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogYmxvY2tQYXRoLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWlkZGxlcywge1xuICAgICAgYXQ6IG1pZGRsZVJlZi5jdXJyZW50LFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICB2b2lkczogdm9pZHMsXG4gICAgICBiYXRjaERpcnR5OiBiYXRjaERpcnR5XG4gICAgfSk7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVuZHMsIHtcbiAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgIH0sXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkczogdm9pZHMsXG4gICAgICBiYXRjaERpcnR5OiBiYXRjaERpcnR5XG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLmF0KSB7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDAgJiYgZW5kUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChtaWRkbGVzLmxlbmd0aCA+IDAgJiYgbWlkZGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMobWlkZGxlUmVmLmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKHN0YXJ0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIF9lbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgbWlkZGxlUmVmLnVucmVmKCk7XG4gICAgZW5kUmVmLnVucmVmKCk7XG4gIH0pO1xufTtcblxudmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJGVkZ2UgPSBvcHRpb25zLmVkZ2UsXG4gICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UgPT09IHZvaWQgMCA/ICdhbmNob3InIDogX29wdGlvbnMkZWRnZTtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKSxcbiAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDEpLFxuICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLFxuICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNFsxXTtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGVuZCk7XG4gIH1cbn07XG5cbnZhciBkZXNlbGVjdCA9IGZ1bmN0aW9uIGRlc2VsZWN0KGVkaXRvcikge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtb3ZlID0gZnVuY3Rpb24gbW92ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgdmFyIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2UsXG4gICAgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICB1bml0ID0gX29wdGlvbnMkdW5pdCA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0LFxuICAgIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgdmFyIF9vcHRpb25zJGVkZ2UgPSBvcHRpb25zLmVkZ2UsXG4gICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9ucyRlZGdlO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gIH1cbiAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgfVxuICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcixcbiAgICBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgdmFyIG9wdHMgPSB7XG4gICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgIHVuaXQ6IHVuaXQsXG4gICAgaWdub3JlTm9uU2VsZWN0YWJsZTogdHJ1ZVxuICB9O1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYW5jaG9yLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvciwgb3B0cyk7XG4gICAgaWYgKHBvaW50KSB7XG4gICAgICBwcm9wcy5hbmNob3IgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuICAgIGlmIChfcG9pbnQpIHtcbiAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgIH1cbiAgfVxuICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKTtcbn07XG5cbnZhciBzZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gIHRhcmdldCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHRhcmdldCk7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHRhcmdldCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gYW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBgbnVsbGAgeW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdCBhbiBgYW5jaG9yYCBhbmQgYGZvY3VzYCwgYnV0IHlvdSBwYXNzZWQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkodGFyZ2V0KSkpO1xuICB9XG4gIGVkaXRvci5hcHBseSh7XG4gICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICBuZXdQcm9wZXJ0aWVzOiB0YXJnZXRcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIHNldFBvaW50ID0gZnVuY3Rpb24gc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICB2YXIgX29wdGlvbnMkZWRnZSA9IG9wdGlvbnMuZWRnZSxcbiAgICBlZGdlID0gX29wdGlvbnMkZWRnZSA9PT0gdm9pZCAwID8gJ2JvdGgnIDogX29wdGlvbnMkZWRnZTtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICB9XG4gIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gIH1cbiAgdmFyIGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgX2RlZmluZVByb3BlcnR5KHt9LCBlZGdlID09PSAnYW5jaG9yJyA/ICdhbmNob3InIDogJ2ZvY3VzJywgX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9pbnQpLCBwcm9wcykpKTtcbn07XG5cbnZhciBzZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcykge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgdmFyIG9sZFByb3BzID0ge307XG4gIHZhciBuZXdQcm9wcyA9IHt9O1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgIG9sZFByb3BzW2tdID0gc2VsZWN0aW9uW2tdO1xuICAgICAgbmV3UHJvcHNba10gPSBwcm9wc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKG9sZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IG9sZFByb3BzLFxuICAgICAgbmV3UHJvcGVydGllczogbmV3UHJvcHNcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ0KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgaW5zZXJ0Tm9kZXMgPSBmdW5jdGlvbiBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdGlvbnMkaGFuZ2luZyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmcsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzLFxuICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICBfb3B0aW9ucyRiYXRjaERpcnR5ID0gb3B0aW9ucy5iYXRjaERpcnR5LFxuICAgICAgYmF0Y2hEaXJ0eSA9IF9vcHRpb25zJGJhdGNoRGlydHkgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRiYXRjaERpcnR5O1xuICAgIHZhciBhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICBzZWxlY3QgPSBvcHRpb25zLnNlbGVjdDtcbiAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgfVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIF9ub2RlcyA9IG5vZGVzLFxuICAgICAgX25vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9ub2RlcywgMSksXG4gICAgICBub2RlID0gX25vZGVzMlswXTtcbiAgICBpZiAoIWF0KSB7XG4gICAgICBhdCA9IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpO1xuICAgICAgaWYgKHNlbGVjdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2VsZWN0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdCA9PSBudWxsKSB7XG4gICAgICBzZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIF9FZGl0b3Ikbm9kZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LnBhdGgsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pLFxuICAgICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgICBlbnRyeSA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHZhciBfZW50cnkgPSBfc2xpY2VkVG9BcnJheShlbnRyeSwgMiksXG4gICAgICAgICAgbWF0Y2hQYXRoID0gX2VudHJ5WzFdO1xuICAgICAgICB2YXIgcGF0aFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgbWF0Y2hQYXRoKTtcbiAgICAgICAgdmFyIGlzQXRFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgbWF0Y2hQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICBhdCA9IGlzQXRFbmQgPyBQYXRoLm5leHQocGF0aCkgOiBwYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KGF0KTtcbiAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcbiAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICBhdDogcGFyZW50UGF0aFxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChiYXRjaERpcnR5KSB7XG4gICAgICAvLyBQRVJGOiBiYXRjaCB1cGRhdGUgZGlydHkgcGF0aHNcbiAgICAgIC8vIGJhdGNoZWQgb3BzIHVzZWQgdG8gdHJhbnNmb3JtIGV4aXN0aW5nIGRpcnR5IHBhdGhzXG4gICAgICB2YXIgYmF0Y2hlZE9wcyA9IFtdO1xuICAgICAgdmFyIG5ld0RpcnR5UGF0aHMgPSBQYXRoLmxldmVscyhwYXJlbnRQYXRoKTtcbiAgICAgIGJhdGNoRGlydHlQYXRocyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobm9kZXMpLFxuICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgICBhdCA9IFBhdGgubmV4dChhdCk7XG4gICAgICAgICAgICBiYXRjaGVkT3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dCkge1xuICAgICAgICAgICAgICBuZXdEaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdEaXJ0eVBhdGhzLnB1c2guYXBwbHkobmV3RGlydHlQYXRocywgX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5LmZyb20oTm9kZS5ub2Rlcyhub2RlKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgICAgICAgIHAgPSBfcmVmMlsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5jb25jYXQocCk7XG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB1cGRhdGVEaXJ0eVBhdGhzKGVkaXRvciwgbmV3RGlydHlQYXRocywgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IHA7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYmF0Y2hlZE9wcyA9IGJhdGNoZWRPcHM7IF9pIDwgX2JhdGNoZWRPcHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3AgPSBfYmF0Y2hlZE9wc1tfaV07XG4gICAgICAgICAgICBpZiAoUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSkge1xuICAgICAgICAgICAgICBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0obmV3UGF0aCwgb3ApO1xuICAgICAgICAgICAgICBpZiAoIW5ld1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3UGF0aDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KG5vZGVzKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX25vZGUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgIG5vZGU6IF9ub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXQgPSBQYXRoLnByZXZpb3VzKGF0KTtcbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgbGlmdE5vZGVzID0gZnVuY3Rpb24gbGlmdE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBhdCxcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfcGF0aFJlZnMgPSBwYXRoUmVmczsgX2kgPCBfcGF0aFJlZnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgcGF0aFJlZiA9IF9wYXRoUmVmc1tfaV07XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGxpZnQgbm9kZSBhdCBhIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBoYXMgYSBkZXB0aCBvZiBsZXNzIHRoYW4gYDJgLlwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50Tm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBQYXRoLnBhcmVudChwYXRoKSk7XG4gICAgICB2YXIgX3BhcmVudE5vZGVFbnRyeSA9IF9zbGljZWRUb0FycmF5KHBhcmVudE5vZGVFbnRyeSwgMiksXG4gICAgICAgIHBhcmVudCA9IF9wYXJlbnROb2RlRW50cnlbMF0sXG4gICAgICAgIHBhcmVudFBhdGggPSBfcGFyZW50Tm9kZUVudHJ5WzFdO1xuICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxlbmd0aCA9IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXJlbnRQYXRoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICB2YXIgX3RvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aCA9IFBhdGgubmV4dChwYXRoKTtcbiAgICAgICAgdmFyIF90b1BhdGgyID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHNwbGl0UGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBfdG9QYXRoMixcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0ZXh0XCJdLFxuICBfZXhjbHVkZWQyID0gW1wiY2hpbGRyZW5cIl07XG52YXIgaGFzU2luZ2xlQ2hpbGROZXN0ID0gZnVuY3Rpb24gaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbm9kZSkge1xuICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBtZXJnZU5vZGVzID0gZnVuY3Rpb24gbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ7XG4gICAgdmFyIF9vcHRpb25zJGhhbmdpbmcgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nLFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcyxcbiAgICAgIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KSxcbiAgICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMSksXG4gICAgICAgICAgcGFyZW50ID0gX0VkaXRvciRwYXJlbnQyWzBdO1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSksXG4gICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgY3VycmVudCA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgYXQ6IGF0LFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgbW9kZTogbW9kZVxuICAgIH0pO1xuICAgIGlmICghY3VycmVudCB8fCAhcHJldikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX2N1cnJlbnQgPSBfc2xpY2VkVG9BcnJheShjdXJyZW50LCAyKSxcbiAgICAgIG5vZGUgPSBfY3VycmVudFswXSxcbiAgICAgIHBhdGggPSBfY3VycmVudFsxXTtcbiAgICB2YXIgX3ByZXYgPSBfc2xpY2VkVG9BcnJheShwcmV2LCAyKSxcbiAgICAgIHByZXZOb2RlID0gX3ByZXZbMF0sXG4gICAgICBwcmV2UGF0aCA9IF9wcmV2WzFdO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld1BhdGggPSBQYXRoLm5leHQocHJldlBhdGgpO1xuICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24ocGF0aCwgcHJldlBhdGgpO1xuICAgIHZhciBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKTtcbiAgICB2YXIgbGV2ZWxzID0gQXJyYXkuZnJvbShFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICBuID0gX3JlZjJbMF07XG4gICAgICByZXR1cm4gbjtcbiAgICB9KS5zbGljZShjb21tb25QYXRoLmxlbmd0aCkuc2xpY2UoMCwgLTEpO1xuICAgIC8vIERldGVybWluZSBpZiB0aGUgbWVyZ2Ugd2lsbCBsZWF2ZSBhbiBhbmNlc3RvciBvZiB0aGUgcGF0aCBlbXB0eSBhcyBhXG4gICAgLy8gcmVzdWx0LCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gcmVtb3ZlIGl0IGFmdGVyIG1lcmdpbmcuXG4gICAgdmFyIGVtcHR5QW5jZXN0b3IgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBsZXZlbHMuaW5jbHVkZXMobikgJiYgaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGVtcHR5UmVmID0gZW1wdHlBbmNlc3RvciAmJiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGVtcHR5QW5jZXN0b3JbMV0pO1xuICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgIHZhciBwb3NpdGlvbjtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgLy8gYW5kIGV4dHJhIHByb3BlcnRpZXMgb2YgdGhlIG1lcmdlIHdpbGwgYmUuXG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuICAgICAgbm9kZS50ZXh0O1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpKSB7XG4gICAgICBub2RlLmNoaWxkcmVuO1xuICAgICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG4gICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHByb3BlcnRpZXMgPSBfcmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHRoZSBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldk5vZGUpKSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgIC8vIGl0IHNvIHRoYXQgaXQgaXMgYmVmb3JlIG1lcmdpbmcuXG4gICAgaWYgKCFpc1ByZXZpb3VzU2libGluZykge1xuICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoLFxuICAgICAgICB0bzogbmV3UGF0aCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgd2FzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IGFuY2VzdG9yIG9mIHRoZSBub2RlIHRoYXQgd2FzIG1lcmdlZCxcbiAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cbiAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbXB0eVJlZi5jdXJyZW50LFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoRWRpdG9yLnNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZShlZGl0b3IsIHByZXYsIGN1cnJlbnQpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcHJldlBhdGgsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICBlbXB0eVJlZi51bnJlZigpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgbW92ZU5vZGVzID0gZnVuY3Rpb24gbW92ZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0byA9IG9wdGlvbnMudG8sXG4gICAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZSxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgdmFyIHRhcmdldHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYXQsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbSh0YXJnZXRzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIHAgPSBfcmVmMlsxXTtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pID0gMCwgX3BhdGhSZWZzID0gcGF0aFJlZnM7IF9pIDwgX3BhdGhSZWZzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHBhdGhSZWYgPSBfcGF0aFJlZnNbX2ldO1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICB2YXIgbmV3UGF0aCA9IHRvUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIG5ld1BhdGg6IG5ld1BhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodG9SZWYuY3VycmVudCAmJiBQYXRoLmlzU2libGluZyhuZXdQYXRoLCBwYXRoKSAmJiBQYXRoLmlzQWZ0ZXIobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgIC8vIHRvIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIHBvaW50IGluc3RlYWQgb2YgYWZ0ZXIuIFRvIGVuc3VyZSBvdXIgZ3JvdXAgb2Ygbm9kZXMgYXJlIGluc2VydGVkXG4gICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIHdlIGluY3JlbWVudCB0b1JlZiB0byBhY2NvdW50IGZvciB0aGF0XG4gICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRvUmVmLnVucmVmKCk7XG4gIH0pO1xufTtcblxudmFyIHJlbW92ZU5vZGVzID0gZnVuY3Rpb24gcmVtb3ZlTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdGlvbnMkaGFuZ2luZyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmcsXG4gICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzLFxuICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU7XG4gICAgdmFyIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYXQsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfcGF0aFJlZnMgPSBwYXRoUmVmczsgX2kgPCBfcGF0aFJlZnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgcGF0aFJlZiA9IF9wYXRoUmVmc1tfaV07XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBfRWRpdG9yJG5vZGUgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgIF9FZGl0b3Ikbm9kZTIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUsIDEpLFxuICAgICAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdO1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDMoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBzZXROb2RlcyA9IGZ1bmN0aW9uIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICBjb21wYXJlID0gb3B0aW9ucy5jb21wYXJlLFxuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1lcmdlO1xuICAgIHZhciBfb3B0aW9ucyRoYW5naW5nID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZyxcbiAgICAgIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgX29wdGlvbnMkc3BsaXQgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgc3BsaXQgPSBfb3B0aW9ucyRzcGxpdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzcGxpdCxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkgJiYgRWRpdG9yLmxlYWYoZWRpdG9yLCBhdC5hbmNob3IpWzBdLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkIGluIGEgbm9uLWVtcHR5IG5vZGUgYW5kICdzcGxpdCcgaXMgdHJ1ZSwgdGhlcmUncyBub3RoaW5nIHRvXG4gICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG4gICAgICB2YXIgc3BsaXRNb2RlID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JztcbiAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICBhbHdheXM6ICFlbmRBdEVuZE9mTm9kZVxuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRBdFN0YXJ0T2ZOb2RlID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBzdGFydCwgc3RhcnQucGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29tcGFyZSkge1xuICAgICAgY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUocHJvcCwgbm9kZVByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AgIT09IG5vZGVQcm9wO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KSksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgIG5vZGUgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICBwYXRoID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgIC8vIEZJWE1FOiBpcyB0aGlzIGNvcnJlY3Q/XG4gICAgICAgIHZhciBuZXdQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIC8vIFlvdSBjYW4ndCBzZXQgcHJvcGVydGllcyBvbiB0aGUgZWRpdG9yIG5vZGUuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgICAgICBpZiAoayA9PT0gJ2NoaWxkcmVuJyB8fCBrID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcGFyZShwcm9wc1trXSwgbm9kZVtrXSkpIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrKSkgcHJvcGVydGllc1trXSA9IG5vZGVba107XG4gICAgICAgICAgICAvLyBPbWl0IHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBuZXcgcHJvcGVydGllcyBsaXN0XG4gICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ2hhbmdlcykge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnc2V0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMihhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cbiAqL1xudmFyIGRlbGV0ZVJhbmdlID0gZnVuY3Rpb24gZGVsZXRlUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHJhbmdlLmFuY2hvcjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xudmFyIHNwbGl0Tm9kZXMgPSBmdW5jdGlvbiBzcGxpdE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgX29wdGlvbnMkaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsXG4gICAgICBoZWlnaHQgPSBfb3B0aW9ucyRoZWlnaHQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRoZWlnaHQsXG4gICAgICBfb3B0aW9ucyRhbHdheXMgPSBvcHRpb25zLmFsd2F5cyxcbiAgICAgIGFsd2F5cyA9IF9vcHRpb25zJGFsd2F5cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHdheXM7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBkZWxldGVSYW5nZShlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHBhdGgsIHRoZSBkZWZhdWx0IGhlaWdodC1za2lwcGluZyBhbmQgcG9zaXRpb25cbiAgICAvLyBjb3VudGVycyBuZWVkIHRvIGFjY291bnQgZm9yIHVzIHBvdGVudGlhbGx5IHNwbGl0dGluZyBhdCBhIG5vbi1sZWFmLlxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICB2YXIgcG9pbnQgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHZhciBfRWRpdG9yJHBhcmVudCA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDEpLFxuICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDJbMF07XG4gICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT09IHBhcmVudDtcbiAgICAgIH07XG4gICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgIGF0ID0gcG9pbnQ7XG4gICAgICBhbHdheXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgICB2YXIgYWZ0ZXJSZWY7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSksXG4gICAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICAgIGhpZ2hlc3QgPSBfRWRpdG9yJG5vZGVzMlswXTtcbiAgICAgIGlmICghaGlnaGVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIG51ZGdlID0gMDtcbiAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgIHZhciBfdm9pZE1hdGNoID0gX3NsaWNlZFRvQXJyYXkodm9pZE1hdGNoLCAyKSxcbiAgICAgICAgICB2b2lkTm9kZSA9IF92b2lkTWF0Y2hbMF0sXG4gICAgICAgICAgdm9pZFBhdGggPSBfdm9pZE1hdGNoWzFdO1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQodm9pZE5vZGUpICYmIGVkaXRvci5pc0lubGluZSh2b2lkTm9kZSkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG4gICAgICAgICAgaWYgKCFhZnRlcikge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgdGV4dCwge1xuICAgICAgICAgICAgICBhdDogYWZ0ZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpYmxpbmdIZWlnaHQgPSBhdC5wYXRoLmxlbmd0aCAtIHZvaWRQYXRoLmxlbmd0aDtcbiAgICAgICAgaGVpZ2h0ID0gc2libGluZ0hlaWdodCArIDE7XG4gICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgIHZhciBkZXB0aCA9IGF0LnBhdGgubGVuZ3RoIC0gaGVpZ2h0O1xuICAgICAgdmFyIF9oaWdoZXN0ID0gX3NsaWNlZFRvQXJyYXkoaGlnaGVzdCwgMiksXG4gICAgICAgIGhpZ2hlc3RQYXRoID0gX2hpZ2hlc3RbMV07XG4gICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gaGVpZ2h0ID09PSAwID8gYXQub2Zmc2V0IDogYXQucGF0aFtkZXB0aF0gKyBudWRnZTtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSkpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgX3BhdGggPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoX3BhdGgubGVuZ3RoIDwgaGlnaGVzdFBhdGgubGVuZ3RoIHx8IF9wYXRoLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9wb2ludDIgPSBiZWZvcmVSZWYuY3VycmVudDtcbiAgICAgICAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBfcG9pbnQyLCBfcGF0aCk7XG4gICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50MiwgX3BhdGgpKSB7XG4gICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IE5vZGUuZXh0cmFjdFByb3BzKG5vZGUpO1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zaXRpb24gPSBfcGF0aFtfcGF0aC5sZW5ndGggLSAxXSArIChzcGxpdCB8fCBpc0VuZCA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3BvaW50ID0gYWZ0ZXJSZWYuY3VycmVudCB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9wb2ludCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHZhciBfYWZ0ZXJSZWY7XG4gICAgICBiZWZvcmVSZWYudW5yZWYoKTtcbiAgICAgIChfYWZ0ZXJSZWYgPSBhZnRlclJlZikgPT09IG51bGwgfHwgX2FmdGVyUmVmID09PSB2b2lkIDAgfHwgX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIHVuc2V0Tm9kZXMgPSBmdW5jdGlvbiB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgcHJvcHMgPSBbcHJvcHNdO1xuICB9XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEocHJvcHMpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICBvYmpba2V5XSA9IG51bGw7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbiAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIG9iaiwgb3B0aW9ucyk7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciB1bndyYXBOb2RlcyA9IGZ1bmN0aW9uIHVud3JhcE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgX29wdGlvbnMkc3BsaXQgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgc3BsaXQgPSBfb3B0aW9ucyRzcGxpdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzcGxpdCxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgdmFyIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgfVxuICAgIHZhciByYW5nZVJlZiA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQpIDogbnVsbDtcbiAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBhdCxcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcCA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfVxuICAgIC8vIHVud3JhcE5vZGUgd2lsbCBjYWxsIGxpZnROb2RlIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgc3BsaXR0aW5nIHRoZSBub2RlIHdoZW4gbmVzdGVkLlxuICAgIC8vIElmIHdlIGRvIG5vdCByZXZlcnNlIHRoZSBvcmRlciBhbmQgY2FsbCBpdCBmcm9tIHRvcCB0byB0aGUgYm90dG9tLCBpdCB3aWxsIHJlbW92ZSBhbGwgYmxvY2tzXG4gICAgLy8gdGhhdCB3cmFwIHRhcmdldCBub2RlLiBTbyB3ZSByZXZlcnNlIHRoZSBvcmRlci5cbiAgICApLnJldmVyc2UoKTtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGF0aFJlZnMpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgcGF0aFJlZiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgICAgICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF07XG4gICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICBpZiAoc3BsaXQgJiYgcmFuZ2VSZWYpIHtcbiAgICAgICAgICByYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZVJlZi5jdXJyZW50LCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpICYmIG5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIGlmIChyYW5nZVJlZikge1xuICAgICAgcmFuZ2VSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgd3JhcE5vZGVzID0gZnVuY3Rpb24gd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgX29wdGlvbnMkc3BsaXQgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgc3BsaXQgPSBfb3B0aW9ucyRzcGxpdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzcGxpdCxcbiAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDtcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIG1hdGNoID0gbWF0Y2hQYXRoKGVkaXRvciwgYXQpO1xuICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkpIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcm9vdHMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBhdCxcbiAgICAgIG1hdGNoOiBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gRWRpdG9yLmlzRWRpdG9yKG4pO1xuICAgICAgfSxcbiAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSkpO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgX3Jvb3RzJF9pID0gX3NsaWNlZFRvQXJyYXkoX3Jvb3RzW19pXSwgMiksXG4gICAgICAgICAgcm9vdFBhdGggPSBfcm9vdHMkX2lbMV07XG4gICAgICAgIHZhciBhID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBSYW5nZS5pbnRlcnNlY3Rpb24oYXQsIEVkaXRvci5yYW5nZShlZGl0b3IsIHJvb3RQYXRoKSkgOiBhdDtcbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGZpcnN0ID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgX2ZpcnN0ID0gX3NsaWNlZFRvQXJyYXkoZmlyc3QsIDIpLFxuICAgICAgICAgICAgZmlyc3RQYXRoID0gX2ZpcnN0WzFdO1xuICAgICAgICAgIHZhciBfbGFzdCA9IF9zbGljZWRUb0FycmF5KGxhc3QsIDIpLFxuICAgICAgICAgICAgbGFzdFBhdGggPSBfbGFzdFsxXTtcbiAgICAgICAgICBpZiAoZmlyc3RQYXRoLmxlbmd0aCA9PT0gMCAmJiBsYXN0UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5lcXVhbHMoZmlyc3RQYXRoLCBsYXN0UGF0aCkgPyBQYXRoLnBhcmVudChmaXJzdFBhdGgpIDogUGF0aC5jb21tb24oZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgdmFyIGNvbW1vbk5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgY29tbW9uUGF0aCk7XG4gICAgICAgICAgdmFyIF9jb21tb25Ob2RlRW50cnkgPSBfc2xpY2VkVG9BcnJheShjb21tb25Ob2RlRW50cnksIDEpLFxuICAgICAgICAgICAgY29tbW9uTm9kZSA9IF9jb21tb25Ob2RlRW50cnlbMF07XG4gICAgICAgICAgdmFyIGRlcHRoID0gY29tbW9uUGF0aC5sZW5ndGggKyAxO1xuICAgICAgICAgIHZhciB3cmFwcGVyUGF0aCA9IFBhdGgubmV4dChsYXN0UGF0aC5zbGljZSgwLCBkZXB0aCkpO1xuICAgICAgICAgIHZhciB3cmFwcGVyID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB3cmFwcGVyLCB7XG4gICAgICAgICAgICBhdDogd3JhcHBlclBhdGgsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0bzogd3JhcHBlclBhdGguY29uY2F0KDApLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfcmV0O1xuICAgIGZvciAodmFyIF9pID0gMCwgX3Jvb3RzID0gcm9vdHM7IF9pIDwgX3Jvb3RzLmxlbmd0aDsgX2krKykge1xuICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cbiAqL1xudmFyIGNyZWF0ZUVkaXRvciA9IGZ1bmN0aW9uIGNyZWF0ZUVkaXRvcigpIHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzRWxlbWVudFJlYWRPbmx5OiBmdW5jdGlvbiBpc0VsZW1lbnRSZWFkT25seSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzSW5saW5lOiBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzU2VsZWN0YWJsZTogZnVuY3Rpb24gaXNTZWxlY3RhYmxlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpc1ZvaWQ6IGZ1bmN0aW9uIGlzVm9pZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG1hcmthYmxlVm9pZDogZnVuY3Rpb24gbWFya2FibGVWb2lkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge30sXG4gICAgLy8gQ29yZVxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXBwbHkuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgLy8gRWRpdG9yXG4gICAgYWRkTWFyazogZnVuY3Rpb24gYWRkTWFyayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRNYXJrLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGRlbGV0ZUJhY2t3YXJkOiBmdW5jdGlvbiBkZWxldGVCYWNrd2FyZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVCYWNrd2FyZC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUZvcndhcmQuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgZGVsZXRlRnJhZ21lbnQ6IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUZyYWdtZW50LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbiBnZXRGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGcmFnbWVudC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0QnJlYWskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0QnJlYWsuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgaW5zZXJ0U29mdEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRTb2Z0QnJlYWskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW44ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0U29mdEJyZWFrLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRGcmFnbWVudC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTBdID0gYXJndW1lbnRzW19rZXkxMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0Tm9kZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMSksIF9rZXkxMSA9IDA7IF9rZXkxMSA8IF9sZW4xMTsgX2tleTExKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTFdID0gYXJndW1lbnRzW19rZXkxMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0VGV4dC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBub3JtYWxpemVOb2RlOiBmdW5jdGlvbiBub3JtYWxpemVOb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMiksIF9rZXkxMiA9IDA7IF9rZXkxMiA8IF9sZW4xMjsgX2tleTEyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTJdID0gYXJndW1lbnRzW19rZXkxMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplTm9kZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBmdW5jdGlvbiByZW1vdmVNYXJrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMyksIF9rZXkxMyA9IDA7IF9rZXkxMyA8IF9sZW4xMzsgX2tleTEzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTNdID0gYXJndW1lbnRzW19rZXkxM107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlTWFyay5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBnZXREaXJ0eVBhdGhzOiBmdW5jdGlvbiBnZXREaXJ0eVBhdGhzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNCksIF9rZXkxNCA9IDA7IF9rZXkxNCA8IF9sZW4xNDsgX2tleTE0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTRdID0gYXJndW1lbnRzW19rZXkxNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RGlydHlQYXRocy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzaG91bGROb3JtYWxpemU6IGZ1bmN0aW9uIHNob3VsZE5vcm1hbGl6ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTUpLCBfa2V5MTUgPSAwOyBfa2V5MTUgPCBfbGVuMTU7IF9rZXkxNSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE1XSA9IGFyZ3VtZW50c1tfa2V5MTVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZE5vcm1hbGl6ZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICAvLyBFZGl0b3IgaW50ZXJmYWNlXG4gICAgYWJvdmU6IGZ1bmN0aW9uIGFib3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNiksIF9rZXkxNiA9IDA7IF9rZXkxNiA8IF9sZW4xNjsgX2tleTE2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTZdID0gYXJndW1lbnRzW19rZXkxNl07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWJvdmUuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNyksIF9rZXkxNyA9IDA7IF9rZXkxNyA8IF9sZW4xNzsgX2tleTE3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTddID0gYXJndW1lbnRzW19rZXkxN107XG4gICAgICB9XG4gICAgICByZXR1cm4gYWZ0ZXIuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE4KSwgX2tleTE4ID0gMDsgX2tleTE4IDwgX2xlbjE4OyBfa2V5MTgrKykge1xuICAgICAgICBhcmdzW19rZXkxOF0gPSBhcmd1bWVudHNbX2tleTE4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiZWZvcmUuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOSksIF9rZXkxOSA9IDA7IF9rZXkxOSA8IF9sZW4xOTsgX2tleTE5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTldID0gYXJndW1lbnRzW19rZXkxOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGFwc2UuYXBwbHkodm9pZCAwLCBbZWRpdG9yXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG4gICAgXCJkZWxldGVcIjogZnVuY3Rpb24gX2RlbGV0ZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIwKSwgX2tleTIwID0gMDsgX2tleTIwIDwgX2xlbjIwOyBfa2V5MjArKykge1xuICAgICAgICBhcmdzW19rZXkyMF0gPSBhcmd1bWVudHNbX2tleTIwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVUZXh0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjEpLCBfa2V5MjEgPSAwOyBfa2V5MjEgPCBfbGVuMjE7IF9rZXkyMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIxXSA9IGFyZ3VtZW50c1tfa2V5MjFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2VsZWN0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjIpLCBfa2V5MjIgPSAwOyBfa2V5MjIgPCBfbGVuMjI7IF9rZXkyMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIyXSA9IGFyZ3VtZW50c1tfa2V5MjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVkZ2VzLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGVsZW1lbnRSZWFkT25seTogZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMyksIF9rZXkyMyA9IDA7IF9rZXkyMyA8IF9sZW4yMzsgX2tleTIzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjNdID0gYXJndW1lbnRzW19rZXkyM107XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFJlYWRPbmx5LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24gZW5kJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNCksIF9rZXkyNCA9IDA7IF9rZXkyNCA8IF9sZW4yNDsgX2tleTI0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjRdID0gYXJndW1lbnRzW19rZXkyNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5kLmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjUpLCBfa2V5MjUgPSAwOyBfa2V5MjUgPCBfbGVuMjU7IF9rZXkyNSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI1XSA9IGFyZ3VtZW50c1tfa2V5MjVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjYpLCBfa2V5MjYgPSAwOyBfa2V5MjYgPCBfbGVuMjY7IF9rZXkyNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI2XSA9IGFyZ3VtZW50c1tfa2V5MjZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LmFwcGx5KHZvaWQgMCwgW2VkaXRvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIGdldE1hcmtzOiBmdW5jdGlvbiBnZXRNYXJrcygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI3KSwgX2tleTI3ID0gMDsgX2tleTI3IDwgX2xlbjI3OyBfa2V5MjcrKykge1xuICAgICAgICBhcmdzW19rZXkyN10gPSBhcmd1bWVudHNbX2tleTI3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXJrcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBoYXNCbG9ja3M6IGZ1bmN0aW9uIGhhc0Jsb2NrcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjgpLCBfa2V5MjggPSAwOyBfa2V5MjggPCBfbGVuMjg7IF9rZXkyOCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI4XSA9IGFyZ3VtZW50c1tfa2V5MjhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0Jsb2Nrcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBoYXNJbmxpbmVzOiBmdW5jdGlvbiBoYXNJbmxpbmVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOSksIF9rZXkyOSA9IDA7IF9rZXkyOSA8IF9sZW4yOTsgX2tleTI5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjldID0gYXJndW1lbnRzW19rZXkyOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzSW5saW5lcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBoYXNQYXRoOiBmdW5jdGlvbiBoYXNQYXRoJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMCksIF9rZXkzMCA9IDA7IF9rZXkzMCA8IF9sZW4zMDsgX2tleTMwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzBdID0gYXJndW1lbnRzW19rZXkzMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzUGF0aC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBoYXNUZXh0czogZnVuY3Rpb24gaGFzVGV4dHMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMxKSwgX2tleTMxID0gMDsgX2tleTMxIDwgX2xlbjMxOyBfa2V5MzErKykge1xuICAgICAgICBhcmdzW19rZXkzMV0gPSBhcmd1bWVudHNbX2tleTMxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNUZXh0cy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlczogZnVuY3Rpb24gaW5zZXJ0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMyKSwgX2tleTMyID0gMDsgX2tleTMyIDwgX2xlbjMyOyBfa2V5MzIrKykge1xuICAgICAgICBhcmdzW19rZXkzMl0gPSBhcmd1bWVudHNbX2tleTMyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnROb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpc0Jsb2NrOiBmdW5jdGlvbiBpc0Jsb2NrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMyksIF9rZXkzMyA9IDA7IF9rZXkzMyA8IF9sZW4zMzsgX2tleTMzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzNdID0gYXJndW1lbnRzW19rZXkzM107XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNCbG9jay5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzQpLCBfa2V5MzQgPSAwOyBfa2V5MzQgPCBfbGVuMzQ7IF9rZXkzNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM0XSA9IGFyZ3VtZW50c1tfa2V5MzRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRWRnZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNSksIF9rZXkzNSA9IDA7IF9rZXkzNSA8IF9sZW4zNTsgX2tleTM1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzVdID0gYXJndW1lbnRzW19rZXkzNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbXB0eS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpc0VuZDogZnVuY3Rpb24gaXNFbmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM2KSwgX2tleTM2ID0gMDsgX2tleTM2IDwgX2xlbjM2OyBfa2V5MzYrKykge1xuICAgICAgICBhcmdzW19rZXkzNl0gPSBhcmd1bWVudHNbX2tleTM2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VuZC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpc05vcm1hbGl6aW5nOiBmdW5jdGlvbiBpc05vcm1hbGl6aW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNyksIF9rZXkzNyA9IDA7IF9rZXkzNyA8IF9sZW4zNzsgX2tleTM3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzddID0gYXJndW1lbnRzW19rZXkzN107XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNOb3JtYWxpemluZy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBpc1N0YXJ0OiBmdW5jdGlvbiBpc1N0YXJ0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zOCksIF9rZXkzOCA9IDA7IF9rZXkzOCA8IF9sZW4zODsgX2tleTM4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzhdID0gYXJndW1lbnRzW19rZXkzOF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdGFydC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zOSksIF9rZXkzOSA9IDA7IF9rZXkzOSA8IF9sZW4zOTsgX2tleTM5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzldID0gYXJndW1lbnRzW19rZXkzOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBsZWFmOiBmdW5jdGlvbiBsZWFmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MCksIF9rZXk0MCA9IDA7IF9rZXk0MCA8IF9sZW40MDsgX2tleTQwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDBdID0gYXJndW1lbnRzW19rZXk0MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVhZi5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBsZXZlbHM6IGZ1bmN0aW9uIGxldmVscyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDEpLCBfa2V5NDEgPSAwOyBfa2V5NDEgPCBfbGVuNDE7IF9rZXk0MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQxXSA9IGFyZ3VtZW50c1tfa2V5NDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVscy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBsaWZ0Tm9kZXM6IGZ1bmN0aW9uIGxpZnROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDIpLCBfa2V5NDIgPSAwOyBfa2V5NDIgPCBfbGVuNDI7IF9rZXk0MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQyXSA9IGFyZ3VtZW50c1tfa2V5NDJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpZnROb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBtZXJnZU5vZGVzOiBmdW5jdGlvbiBtZXJnZU5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MyksIF9rZXk0MyA9IDA7IF9rZXk0MyA8IF9sZW40MzsgX2tleTQzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDNdID0gYXJndW1lbnRzW19rZXk0M107XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VOb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NCksIF9rZXk0NCA9IDA7IF9rZXk0NCA8IF9sZW40NDsgX2tleTQ0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDRdID0gYXJndW1lbnRzW19rZXk0NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbW92ZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBtb3ZlTm9kZXM6IGZ1bmN0aW9uIG1vdmVOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDUpLCBfa2V5NDUgPSAwOyBfa2V5NDUgPCBfbGVuNDU7IF9rZXk0NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ1XSA9IGFyZ3VtZW50c1tfa2V5NDVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdmVOb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NiksIF9rZXk0NiA9IDA7IF9rZXk0NiA8IF9sZW40NjsgX2tleTQ2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDZdID0gYXJndW1lbnRzW19rZXk0Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBub2RlOiBmdW5jdGlvbiBub2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NyksIF9rZXk0NyA9IDA7IF9rZXk0NyA8IF9sZW40NzsgX2tleTQ3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDddID0gYXJndW1lbnRzW19rZXk0N107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBub2RlczogZnVuY3Rpb24gbm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ4KSwgX2tleTQ4ID0gMDsgX2tleTQ4IDwgX2xlbjQ4OyBfa2V5NDgrKykge1xuICAgICAgICBhcmdzW19rZXk0OF0gPSBhcmd1bWVudHNbX2tleTQ4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDkpLCBfa2V5NDkgPSAwOyBfa2V5NDkgPCBfbGVuNDk7IF9rZXk0OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ5XSA9IGFyZ3VtZW50c1tfa2V5NDldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTApLCBfa2V5NTAgPSAwOyBfa2V5NTAgPCBfbGVuNTA7IF9rZXk1MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUwXSA9IGFyZ3VtZW50c1tfa2V5NTBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwYXRoOiBmdW5jdGlvbiBwYXRoJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MSksIF9rZXk1MSA9IDA7IF9rZXk1MSA8IF9sZW41MTsgX2tleTUxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTFdID0gYXJndW1lbnRzW19rZXk1MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwYXRoUmVmOiBmdW5jdGlvbiBwYXRoUmVmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MiksIF9rZXk1MiA9IDA7IF9rZXk1MiA8IF9sZW41MjsgX2tleTUyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTJdID0gYXJndW1lbnRzW19rZXk1Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aFJlZi5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwYXRoUmVmczogZnVuY3Rpb24gcGF0aFJlZnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUzKSwgX2tleTUzID0gMDsgX2tleTUzIDwgX2xlbjUzOyBfa2V5NTMrKykge1xuICAgICAgICBhcmdzW19rZXk1M10gPSBhcmd1bWVudHNbX2tleTUzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoUmVmcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24gcG9pbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU0KSwgX2tleTU0ID0gMDsgX2tleTU0IDwgX2xlbjU0OyBfa2V5NTQrKykge1xuICAgICAgICBhcmdzW19rZXk1NF0gPSBhcmd1bWVudHNbX2tleTU0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwb2ludFJlZjogZnVuY3Rpb24gcG9pbnRSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU1KSwgX2tleTU1ID0gMDsgX2tleTU1IDwgX2xlbjU1OyBfa2V5NTUrKykge1xuICAgICAgICBhcmdzW19rZXk1NV0gPSBhcmd1bWVudHNbX2tleTU1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludFJlZi5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwb2ludFJlZnM6IGZ1bmN0aW9uIHBvaW50UmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTYpLCBfa2V5NTYgPSAwOyBfa2V5NTYgPCBfbGVuNTY7IF9rZXk1NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU2XSA9IGFyZ3VtZW50c1tfa2V5NTZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50UmVmcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTcpLCBfa2V5NTcgPSAwOyBfa2V5NTcgPCBfbGVuNTc7IF9rZXk1NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU3XSA9IGFyZ3VtZW50c1tfa2V5NTddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc2l0aW9ucy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU4KSwgX2tleTU4ID0gMDsgX2tleTU4IDwgX2xlbjU4OyBfa2V5NTgrKykge1xuICAgICAgICBhcmdzW19rZXk1OF0gPSBhcmd1bWVudHNbX2tleTU4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91cy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICByYW5nZTogZnVuY3Rpb24gcmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU5KSwgX2tleTU5ID0gMDsgX2tleTU5IDwgX2xlbjU5OyBfa2V5NTkrKykge1xuICAgICAgICBhcmdzW19rZXk1OV0gPSBhcmd1bWVudHNbX2tleTU5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICByYW5nZVJlZjogZnVuY3Rpb24gcmFuZ2VSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYwKSwgX2tleTYwID0gMDsgX2tleTYwIDwgX2xlbjYwOyBfa2V5NjArKykge1xuICAgICAgICBhcmdzW19rZXk2MF0gPSBhcmd1bWVudHNbX2tleTYwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZVJlZi5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICByYW5nZVJlZnM6IGZ1bmN0aW9uIHJhbmdlUmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjEpLCBfa2V5NjEgPSAwOyBfa2V5NjEgPCBfbGVuNjE7IF9rZXk2MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYxXSA9IGFyZ3VtZW50c1tfa2V5NjFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlUmVmcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICByZW1vdmVOb2RlczogZnVuY3Rpb24gcmVtb3ZlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYyKSwgX2tleTYyID0gMDsgX2tleTYyIDwgX2xlbjYyOyBfa2V5NjIrKykge1xuICAgICAgICBhcmdzW19rZXk2Ml0gPSBhcmd1bWVudHNbX2tleTYyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVOb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjMpLCBfa2V5NjMgPSAwOyBfa2V5NjMgPCBfbGVuNjM7IF9rZXk2MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYzXSA9IGFyZ3VtZW50c1tfa2V5NjNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzZXROb2RlczogZnVuY3Rpb24gc2V0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY0KSwgX2tleTY0ID0gMDsgX2tleTY0IDwgX2xlbjY0OyBfa2V5NjQrKykge1xuICAgICAgICBhcmdzW19rZXk2NF0gPSBhcmd1bWVudHNbX2tleTY0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXROb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzZXROb3JtYWxpemluZzogZnVuY3Rpb24gc2V0Tm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY1KSwgX2tleTY1ID0gMDsgX2tleTY1IDwgX2xlbjY1OyBfa2V5NjUrKykge1xuICAgICAgICBhcmdzW19rZXk2NV0gPSBhcmd1bWVudHNbX2tleTY1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXROb3JtYWxpemluZy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzZXRQb2ludDogZnVuY3Rpb24gc2V0UG9pbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY2KSwgX2tleTY2ID0gMDsgX2tleTY2IDwgX2xlbjY2OyBfa2V5NjYrKykge1xuICAgICAgICBhcmdzW19rZXk2Nl0gPSBhcmd1bWVudHNbX2tleTY2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRQb2ludC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjcpLCBfa2V5NjcgPSAwOyBfa2V5NjcgPCBfbGVuNjc7IF9rZXk2NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY3XSA9IGFyZ3VtZW50c1tfa2V5NjddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFNlbGVjdGlvbi5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzcGxpdE5vZGVzOiBmdW5jdGlvbiBzcGxpdE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42OCksIF9rZXk2OCA9IDA7IF9rZXk2OCA8IF9sZW42ODsgX2tleTY4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjhdID0gYXJndW1lbnRzW19rZXk2OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BsaXROb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY5KSwgX2tleTY5ID0gMDsgX2tleTY5IDwgX2xlbjY5OyBfa2V5NjkrKykge1xuICAgICAgICBhcmdzW19rZXk2OV0gPSBhcmd1bWVudHNbX2tleTY5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzApLCBfa2V5NzAgPSAwOyBfa2V5NzAgPCBfbGVuNzA7IF9rZXk3MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcwXSA9IGFyZ3VtZW50c1tfa2V5NzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICB1bmhhbmdSYW5nZTogZnVuY3Rpb24gdW5oYW5nUmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcxKSwgX2tleTcxID0gMDsgX2tleTcxIDwgX2xlbjcxOyBfa2V5NzErKykge1xuICAgICAgICBhcmdzW19rZXk3MV0gPSBhcmd1bWVudHNbX2tleTcxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmhhbmdSYW5nZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICB1bnNldE5vZGVzOiBmdW5jdGlvbiB1bnNldE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MiksIF9rZXk3MiA9IDA7IF9rZXk3MiA8IF9sZW43MjsgX2tleTcyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzJdID0gYXJndW1lbnRzW19rZXk3Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5zZXROb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICB1bndyYXBOb2RlczogZnVuY3Rpb24gdW53cmFwTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjczKSwgX2tleTczID0gMDsgX2tleTczIDwgX2xlbjczOyBfa2V5NzMrKykge1xuICAgICAgICBhcmdzW19rZXk3M10gPSBhcmd1bWVudHNbX2tleTczXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bndyYXBOb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBcInZvaWRcIjogZnVuY3Rpb24gX3ZvaWQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NCksIF9rZXk3NCA9IDA7IF9rZXk3NCA8IF9sZW43NDsgX2tleTc0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzRdID0gYXJndW1lbnRzW19rZXk3NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0Vm9pZC5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICB3aXRob3V0Tm9ybWFsaXppbmc6IGZ1bmN0aW9uIHdpdGhvdXROb3JtYWxpemluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzUpLCBfa2V5NzUgPSAwOyBfa2V5NzUgPCBfbGVuNzU7IF9rZXk3NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc1XSA9IGFyZ3VtZW50c1tfa2V5NzVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhvdXROb3JtYWxpemluZy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICB3cmFwTm9kZXM6IGZ1bmN0aW9uIHdyYXBOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzYpLCBfa2V5NzYgPSAwOyBfa2V5NzYgPCBfbGVuNzY7IF9rZXk3NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc2XSA9IGFyZ3VtZW50c1tfa2V5NzZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBOb2Rlcy5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSxcbiAgICBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGU6IGZ1bmN0aW9uIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzcpLCBfa2V5NzcgPSAwOyBfa2V5NzcgPCBfbGVuNzc7IF9rZXk3NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc3XSA9IGFyZ3VtZW50c1tfa2V5NzddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZS5hcHBseSh2b2lkIDAsIFtlZGl0b3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufTtcblxuZXhwb3J0cy5FZGl0b3IgPSBFZGl0b3I7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Mb2NhdGlvbiA9IExvY2F0aW9uO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuT3BlcmF0aW9uID0gT3BlcmF0aW9uO1xuZXhwb3J0cy5QYXRoID0gUGF0aDtcbmV4cG9ydHMuUGF0aFJlZiA9IFBhdGhSZWY7XG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLlBvaW50UmVmID0gUG9pbnRSZWY7XG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5leHBvcnRzLlJhbmdlUmVmID0gUmFuZ2VSZWY7XG5leHBvcnRzLlNjcnViYmVyID0gU2NydWJiZXI7XG5leHBvcnRzLlNwYW4gPSBTcGFuO1xuZXhwb3J0cy5UZXh0ID0gVGV4dDtcbmV4cG9ydHMuVHJhbnNmb3JtcyA9IFRyYW5zZm9ybXM7XG5leHBvcnRzLmFib3ZlID0gYWJvdmU7XG5leHBvcnRzLmFkZE1hcmsgPSBhZGRNYXJrO1xuZXhwb3J0cy5hZnRlciA9IGFmdGVyO1xuZXhwb3J0cy5hcHBseSA9IGFwcGx5O1xuZXhwb3J0cy5iZWZvcmUgPSBiZWZvcmU7XG5leHBvcnRzLmNvbGxhcHNlID0gY29sbGFwc2U7XG5leHBvcnRzLmNyZWF0ZUVkaXRvciA9IGNyZWF0ZUVkaXRvcjtcbmV4cG9ydHMuZGVsZXRlQmFja3dhcmQgPSBkZWxldGVCYWNrd2FyZDtcbmV4cG9ydHMuZGVsZXRlRm9yd2FyZCA9IGRlbGV0ZUZvcndhcmQ7XG5leHBvcnRzLmRlbGV0ZUZyYWdtZW50ID0gZGVsZXRlRnJhZ21lbnQ7XG5leHBvcnRzLmRlbGV0ZVRleHQgPSBkZWxldGVUZXh0O1xuZXhwb3J0cy5kZXNlbGVjdCA9IGRlc2VsZWN0O1xuZXhwb3J0cy5lZGdlcyA9IGVkZ2VzO1xuZXhwb3J0cy5lbGVtZW50UmVhZE9ubHkgPSBlbGVtZW50UmVhZE9ubHk7XG5leHBvcnRzLmVuZCA9IGVuZDtcbmV4cG9ydHMuZmlyc3QgPSBmaXJzdDtcbmV4cG9ydHMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbmV4cG9ydHMuZ2V0RGlydHlQYXRocyA9IGdldERpcnR5UGF0aHM7XG5leHBvcnRzLmdldEZyYWdtZW50ID0gZ2V0RnJhZ21lbnQ7XG5leHBvcnRzLmdldFZvaWQgPSBnZXRWb2lkO1xuZXhwb3J0cy5oYXNCbG9ja3MgPSBoYXNCbG9ja3M7XG5leHBvcnRzLmhhc0lubGluZXMgPSBoYXNJbmxpbmVzO1xuZXhwb3J0cy5oYXNQYXRoID0gaGFzUGF0aDtcbmV4cG9ydHMuaGFzVGV4dHMgPSBoYXNUZXh0cztcbmV4cG9ydHMuaW5zZXJ0QnJlYWsgPSBpbnNlcnRCcmVhaztcbmV4cG9ydHMuaW5zZXJ0RnJhZ21lbnQgPSBpbnNlcnRGcmFnbWVudDtcbmV4cG9ydHMuaW5zZXJ0Tm9kZSA9IGluc2VydE5vZGU7XG5leHBvcnRzLmluc2VydE5vZGVzID0gaW5zZXJ0Tm9kZXM7XG5leHBvcnRzLmluc2VydFNvZnRCcmVhayA9IGluc2VydFNvZnRCcmVhaztcbmV4cG9ydHMuaW5zZXJ0VGV4dCA9IGluc2VydFRleHQ7XG5leHBvcnRzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuZXhwb3J0cy5pc0VkZ2UgPSBpc0VkZ2U7XG5leHBvcnRzLmlzRWRpdG9yID0gaXNFZGl0b3I7XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xuZXhwb3J0cy5pc0VuZCA9IGlzRW5kO1xuZXhwb3J0cy5pc05vcm1hbGl6aW5nID0gaXNOb3JtYWxpemluZztcbmV4cG9ydHMuaXNTdGFydCA9IGlzU3RhcnQ7XG5leHBvcnRzLmxhc3QgPSBsYXN0O1xuZXhwb3J0cy5sZWFmID0gbGVhZjtcbmV4cG9ydHMubGV2ZWxzID0gbGV2ZWxzO1xuZXhwb3J0cy5saWZ0Tm9kZXMgPSBsaWZ0Tm9kZXM7XG5leHBvcnRzLm1hcmtzID0gbWFya3M7XG5leHBvcnRzLm1lcmdlTm9kZXMgPSBtZXJnZU5vZGVzO1xuZXhwb3J0cy5tb3ZlID0gbW92ZTtcbmV4cG9ydHMubW92ZU5vZGVzID0gbW92ZU5vZGVzO1xuZXhwb3J0cy5uZXh0ID0gbmV4dDtcbmV4cG9ydHMubm9kZSA9IG5vZGU7XG5leHBvcnRzLm5vZGVzID0gbm9kZXM7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMubm9ybWFsaXplTm9kZSA9IG5vcm1hbGl6ZU5vZGU7XG5leHBvcnRzLnBhcmVudCA9IHBhcmVudDtcbmV4cG9ydHMucGF0aCA9IHBhdGg7XG5leHBvcnRzLnBhdGhSZWYgPSBwYXRoUmVmO1xuZXhwb3J0cy5wYXRoUmVmcyA9IHBhdGhSZWZzO1xuZXhwb3J0cy5wb2ludCA9IHBvaW50O1xuZXhwb3J0cy5wb2ludFJlZiA9IHBvaW50UmVmO1xuZXhwb3J0cy5wb2ludFJlZnMgPSBwb2ludFJlZnM7XG5leHBvcnRzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbmV4cG9ydHMucHJldmlvdXMgPSBwcmV2aW91cztcbmV4cG9ydHMucmFuZ2UgPSByYW5nZTtcbmV4cG9ydHMucmFuZ2VSZWYgPSByYW5nZVJlZjtcbmV4cG9ydHMucmFuZ2VSZWZzID0gcmFuZ2VSZWZzO1xuZXhwb3J0cy5yZW1vdmVNYXJrID0gcmVtb3ZlTWFyaztcbmV4cG9ydHMucmVtb3ZlTm9kZXMgPSByZW1vdmVOb2RlcztcbmV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xuZXhwb3J0cy5zZXROb2RlcyA9IHNldE5vZGVzO1xuZXhwb3J0cy5zZXROb3JtYWxpemluZyA9IHNldE5vcm1hbGl6aW5nO1xuZXhwb3J0cy5zZXRQb2ludCA9IHNldFBvaW50O1xuZXhwb3J0cy5zZXRTZWxlY3Rpb24gPSBzZXRTZWxlY3Rpb247XG5leHBvcnRzLnNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZSA9IHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZTtcbmV4cG9ydHMuc2hvdWxkTm9ybWFsaXplID0gc2hvdWxkTm9ybWFsaXplO1xuZXhwb3J0cy5zcGxpdE5vZGVzID0gc3BsaXROb2RlcztcbmV4cG9ydHMuc3RhcnQgPSBzdGFydDtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZXhwb3J0cy51bmhhbmdSYW5nZSA9IHVuaGFuZ1JhbmdlO1xuZXhwb3J0cy51bnNldE5vZGVzID0gdW5zZXROb2RlcztcbmV4cG9ydHMudW53cmFwTm9kZXMgPSB1bndyYXBOb2RlcztcbmV4cG9ydHMud2l0aG91dE5vcm1hbGl6aW5nID0gd2l0aG91dE5vcm1hbGl6aW5nO1xuZXhwb3J0cy53cmFwTm9kZXMgPSB3cmFwTm9kZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js\n");

/***/ })

};
;