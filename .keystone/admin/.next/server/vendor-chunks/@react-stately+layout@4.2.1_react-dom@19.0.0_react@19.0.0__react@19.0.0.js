"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0";
exports.ids = ["vendor-chunks/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs":
/*!*********************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs ***!
  \*********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayout: () => (/* binding */ $a58592d295a170a4$export$7d2b12578154a735)\n/* harmony export */ });\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/virtualizer */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n\n\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $a58592d295a170a4$var$DEFAULT_OPTIONS = {\n    minItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(200, 200),\n    maxItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(Infinity, Infinity),\n    preserveAspectRatio: false,\n    minSpace: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(18, 18),\n    maxColumns: Infinity,\n    dropIndicatorThickness: 2\n};\nclass $a58592d295a170a4$export$7d2b12578154a735 extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Layout) {\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.maxColumns !== oldOptions.maxColumns || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness || newOptions.preserveAspectRatio !== oldOptions.preserveAspectRatio || !(newOptions.minItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.minItemSize).equals(oldOptions.minItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.minItemSize) || !(newOptions.maxItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.maxItemSize).equals(oldOptions.maxItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.maxItemSize) || !(newOptions.minSpace || $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace).equals(oldOptions.minSpace || $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace);\n    }\n    update(invalidationContext) {\n        let { minItemSize: minItemSize = $a58592d295a170a4$var$DEFAULT_OPTIONS.minItemSize, maxItemSize: maxItemSize = $a58592d295a170a4$var$DEFAULT_OPTIONS.maxItemSize, preserveAspectRatio: preserveAspectRatio = $a58592d295a170a4$var$DEFAULT_OPTIONS.preserveAspectRatio, minSpace: minSpace = $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace, maxColumns: maxColumns = $a58592d295a170a4$var$DEFAULT_OPTIONS.maxColumns, dropIndicatorThickness: dropIndicatorThickness = $a58592d295a170a4$var$DEFAULT_OPTIONS.dropIndicatorThickness } = invalidationContext.layoutOptions || {};\n        this.dropIndicatorThickness = dropIndicatorThickness;\n        let visibleWidth = this.virtualizer.visibleRect.width;\n        // The max item width is always the entire viewport.\n        // If the max item height is infinity, scale in proportion to the max width.\n        let maxItemWidth = Math.min(maxItemSize.width, visibleWidth);\n        let maxItemHeight = Number.isFinite(maxItemSize.height) ? maxItemSize.height : Math.floor(minItemSize.height / minItemSize.width * maxItemWidth);\n        // Compute the number of rows and columns needed to display the content\n        let columns = Math.floor(visibleWidth / (minItemSize.width + minSpace.width));\n        let numColumns = Math.max(1, Math.min(maxColumns, columns));\n        this.numColumns = numColumns;\n        // Compute the available width (minus the space between items)\n        let width = visibleWidth - minSpace.width * Math.max(0, numColumns);\n        // Compute the item width based on the space available\n        let itemWidth = Math.floor(width / numColumns);\n        itemWidth = Math.max(minItemSize.width, Math.min(maxItemWidth, itemWidth));\n        // Compute the item height, which is proportional to the item width\n        let t = (itemWidth - minItemSize.width) / Math.max(1, maxItemWidth - minItemSize.width);\n        let itemHeight = minItemSize.height + Math.floor((maxItemHeight - minItemSize.height) * t);\n        itemHeight = Math.max(minItemSize.height, Math.min(maxItemHeight, itemHeight));\n        // Compute the horizontal spacing and content height\n        let horizontalSpacing = Math.floor((visibleWidth - numColumns * itemWidth) / (numColumns + 1));\n        this.gap = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(horizontalSpacing, minSpace.height);\n        let rows = Math.ceil(this.virtualizer.collection.size / numColumns);\n        let iterator = this.virtualizer.collection[Symbol.iterator]();\n        let y = rows > 0 ? minSpace.height : 0;\n        let newLayoutInfos = new Map();\n        let skeleton = null;\n        let skeletonCount = 0;\n        for(let row = 0; row < rows; row++){\n            let maxHeight = 0;\n            let rowLayoutInfos = [];\n            for(let col = 0; col < numColumns; col++){\n                // Repeat skeleton until the end of the current row.\n                let node = skeleton || iterator.next().value;\n                if (!node) break;\n                if (node.type === 'skeleton') skeleton = node;\n                let key = skeleton ? `${skeleton.key}-${skeletonCount++}` : node.key;\n                let oldLayoutInfo = this.layoutInfos.get(key);\n                let content = node;\n                if (skeleton) content = oldLayoutInfo && oldLayoutInfo.content.key === key ? oldLayoutInfo.content : {\n                    ...skeleton,\n                    key: key\n                };\n                let x = horizontalSpacing + col * (itemWidth + horizontalSpacing);\n                let height = itemHeight;\n                let estimatedSize = !preserveAspectRatio;\n                if (oldLayoutInfo && estimatedSize) {\n                    height = oldLayoutInfo.rect.height;\n                    estimatedSize = invalidationContext.layoutOptionsChanged || invalidationContext.sizeChanged || oldLayoutInfo.estimatedSize || oldLayoutInfo.content !== content;\n                }\n                let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, itemWidth, height);\n                let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, key, rect);\n                layoutInfo.estimatedSize = estimatedSize;\n                layoutInfo.allowOverflow = true;\n                layoutInfo.content = content;\n                newLayoutInfos.set(key, layoutInfo);\n                rowLayoutInfos.push(layoutInfo);\n                maxHeight = Math.max(maxHeight, layoutInfo.rect.height);\n            }\n            for (let layoutInfo of rowLayoutInfos)layoutInfo.rect.height = maxHeight;\n            y += maxHeight + minSpace.height;\n            // Keep adding skeleton rows until we fill the viewport\n            if (skeleton && row === rows - 1 && y < this.virtualizer.visibleRect.height) rows++;\n        }\n        this.layoutInfos = newLayoutInfos;\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(this.virtualizer.visibleRect.width, y);\n    }\n    getLayoutInfo(key) {\n        return this.layoutInfos.get(key);\n    }\n    getContentSize() {\n        return this.contentSize;\n    }\n    getVisibleLayoutInfos(rect) {\n        let layoutInfos = [];\n        for (let layoutInfo of this.layoutInfos.values())if (layoutInfo.rect.intersects(rect) || this.virtualizer.isPersistedKey(layoutInfo.key)) layoutInfos.push(layoutInfo);\n        return layoutInfos;\n    }\n    updateItemSize(key, size) {\n        let layoutInfo = this.layoutInfos.get(key);\n        if (!size || !layoutInfo) return false;\n        if (size.height !== layoutInfo.rect.height) {\n            let newLayoutInfo = layoutInfo.copy();\n            newLayoutInfo.rect.height = size.height;\n            newLayoutInfo.estimatedSize = false;\n            this.layoutInfos.set(key, newLayoutInfo);\n            return true;\n        }\n        return false;\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        if (this.layoutInfos.size === 0) return {\n            type: 'root'\n        };\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        // Find the closest item within on either side of the point using the gap width.\n        let key = null;\n        if (this.numColumns === 1) {\n            let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, Math.max(0, y - this.gap.height), 1, this.gap.height * 2);\n            let candidates = this.getVisibleLayoutInfos(searchRect);\n            let minDistance = Infinity;\n            for (let candidate of candidates){\n                // Ignore items outside the search rect, e.g. persisted keys.\n                if (!candidate.rect.intersects(searchRect)) continue;\n                let yDist = Math.abs(candidate.rect.y - y);\n                let maxYDist = Math.abs(candidate.rect.maxY - y);\n                let dist = Math.min(yDist, maxYDist);\n                if (dist < minDistance) {\n                    minDistance = dist;\n                    key = candidate.key;\n                }\n            }\n        } else {\n            let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(Math.max(0, x - this.gap.width), y, this.gap.width * 2, 1);\n            let candidates = this.getVisibleLayoutInfos(searchRect);\n            let minDistance = Infinity;\n            for (let candidate of candidates){\n                // Ignore items outside the search rect, e.g. persisted keys.\n                if (!candidate.rect.intersects(searchRect)) continue;\n                let xDist = Math.abs(candidate.rect.x - x);\n                let maxXDist = Math.abs(candidate.rect.maxX - x);\n                let dist = Math.min(xDist, maxXDist);\n                if (dist < minDistance) {\n                    minDistance = dist;\n                    key = candidate.key;\n                }\n            }\n        }\n        let layoutInfo = key != null ? this.getLayoutInfo(key) : null;\n        if (!layoutInfo) return {\n            type: 'root'\n        };\n        let target = {\n            type: 'item',\n            key: layoutInfo.key,\n            dropPosition: 'on'\n        };\n        let pos = this.numColumns === 1 ? y : x;\n        let layoutInfoPos = this.numColumns === 1 ? layoutInfo.rect.y : layoutInfo.rect.x;\n        let size = this.numColumns === 1 ? layoutInfo.rect.height : layoutInfo.rect.width;\n        if (isValidDropTarget(target)) {\n            // If dropping on the item is accepted, try the before/after positions\n            // if within 5px of the start or end of the item.\n            if (pos < layoutInfoPos + 5) target.dropPosition = 'before';\n            else if (pos > layoutInfoPos + size - 5) target.dropPosition = 'after';\n        } else {\n            // If dropping on the item isn't accepted, try the target before or after depending on the position.\n            let mid = layoutInfoPos + size / 2;\n            if (pos <= mid && isValidDropTarget({\n                ...target,\n                dropPosition: 'before'\n            })) target.dropPosition = 'before';\n            else if (pos >= mid && isValidDropTarget({\n                ...target,\n                dropPosition: 'after'\n            })) target.dropPosition = 'after';\n        }\n        return target;\n    }\n    getDropTargetLayoutInfo(target) {\n        let layoutInfo = this.getLayoutInfo(target.key);\n        let rect;\n        if (this.numColumns === 1) // Flip from vertical to horizontal if only one column is visible.\n        rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.x, target.dropPosition === 'before' ? layoutInfo.rect.y - this.gap.height / 2 - this.dropIndicatorThickness / 2 : layoutInfo.rect.maxY + this.gap.height / 2 - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n        else rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(target.dropPosition === 'before' ? layoutInfo.rect.x - this.gap.width / 2 - this.dropIndicatorThickness / 2 : layoutInfo.rect.maxX + this.gap.width / 2 - this.dropIndicatorThickness / 2, layoutInfo.rect.y, this.dropIndicatorThickness, layoutInfo.rect.height);\n        return new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('dropIndicator', target.key + ':' + target.dropPosition, rect);\n    }\n    constructor(...args){\n        super(...args), this.gap = $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace, this.dropIndicatorThickness = 2, this.numColumns = 0, this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(), this.layoutInfos = new Map();\n    }\n}\n\n\n\n//# sourceMappingURL=GridLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L0dyaWRMYXlvdXQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThJOztBQUU5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQVc7QUFDcEMseUJBQXlCLDREQUFXO0FBQ3BDO0FBQ0Esc0JBQXNCLDREQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw4REFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa2dCQUFrZ0I7QUFDaGhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLEdBQUcsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFXO0FBQzlDLHlDQUF5QyxrRUFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNERBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDREQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHFDQUFxQyw0REFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBVztBQUNsQyw0QkFBNEIsNERBQVc7QUFDdkMsdUJBQXVCLGtFQUFpQjtBQUN4QztBQUNBO0FBQ0Esb0tBQW9LLDREQUFXO0FBQy9LO0FBQ0E7OztBQUdpRTtBQUNqRSIsInNvdXJjZXMiOlsiL1VzZXJzL2phaW1laXNyYWVsY2FtcGVhcy9rZXlzdG9uZS9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L0dyaWRMYXlvdXQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2l6ZSBhcyAkaXBnS0YkU2l6ZSwgUmVjdCBhcyAkaXBnS0YkUmVjdCwgTGF5b3V0SW5mbyBhcyAkaXBnS0YkTGF5b3V0SW5mbywgTGF5b3V0IGFzICRpcGdLRiRMYXlvdXR9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplclwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjQgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jb25zdCAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TID0ge1xuICAgIG1pbkl0ZW1TaXplOiBuZXcgKDAsICRpcGdLRiRTaXplKSgyMDAsIDIwMCksXG4gICAgbWF4SXRlbVNpemU6IG5ldyAoMCwgJGlwZ0tGJFNpemUpKEluZmluaXR5LCBJbmZpbml0eSksXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgbWluU3BhY2U6IG5ldyAoMCwgJGlwZ0tGJFNpemUpKDE4LCAxOCksXG4gICAgbWF4Q29sdW1uczogSW5maW5pdHksXG4gICAgZHJvcEluZGljYXRvclRoaWNrbmVzczogMlxufTtcbmNsYXNzICRhNTg1OTJkMjk1YTE3MGE0JGV4cG9ydCQ3ZDJiMTI1NzgxNTRhNzM1IGV4dGVuZHMgKDAsICRpcGdLRiRMYXlvdXQpIHtcbiAgICBzaG91bGRJbnZhbGlkYXRlTGF5b3V0T3B0aW9ucyhuZXdPcHRpb25zLCBvbGRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zLm1heENvbHVtbnMgIT09IG9sZE9wdGlvbnMubWF4Q29sdW1ucyB8fCBuZXdPcHRpb25zLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgIT09IG9sZE9wdGlvbnMuZHJvcEluZGljYXRvclRoaWNrbmVzcyB8fCBuZXdPcHRpb25zLnByZXNlcnZlQXNwZWN0UmF0aW8gIT09IG9sZE9wdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbyB8fCAhKG5ld09wdGlvbnMubWluSXRlbVNpemUgfHwgJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5JdGVtU2l6ZSkuZXF1YWxzKG9sZE9wdGlvbnMubWluSXRlbVNpemUgfHwgJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5JdGVtU2l6ZSkgfHwgIShuZXdPcHRpb25zLm1heEl0ZW1TaXplIHx8ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWF4SXRlbVNpemUpLmVxdWFscyhvbGRPcHRpb25zLm1heEl0ZW1TaXplIHx8ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWF4SXRlbVNpemUpIHx8ICEobmV3T3B0aW9ucy5taW5TcGFjZSB8fCAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLm1pblNwYWNlKS5lcXVhbHMob2xkT3B0aW9ucy5taW5TcGFjZSB8fCAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLm1pblNwYWNlKTtcbiAgICB9XG4gICAgdXBkYXRlKGludmFsaWRhdGlvbkNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgbWluSXRlbVNpemU6IG1pbkl0ZW1TaXplID0gJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5JdGVtU2l6ZSwgbWF4SXRlbVNpemU6IG1heEl0ZW1TaXplID0gJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5tYXhJdGVtU2l6ZSwgcHJlc2VydmVBc3BlY3RSYXRpbzogcHJlc2VydmVBc3BlY3RSYXRpbyA9ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMucHJlc2VydmVBc3BlY3RSYXRpbywgbWluU3BhY2U6IG1pblNwYWNlID0gJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5TcGFjZSwgbWF4Q29sdW1uczogbWF4Q29sdW1ucyA9ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWF4Q29sdW1ucywgZHJvcEluZGljYXRvclRoaWNrbmVzczogZHJvcEluZGljYXRvclRoaWNrbmVzcyA9ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMuZHJvcEluZGljYXRvclRoaWNrbmVzcyB9ID0gaW52YWxpZGF0aW9uQ29udGV4dC5sYXlvdXRPcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgPSBkcm9wSW5kaWNhdG9yVGhpY2tuZXNzO1xuICAgICAgICBsZXQgdmlzaWJsZVdpZHRoID0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aDtcbiAgICAgICAgLy8gVGhlIG1heCBpdGVtIHdpZHRoIGlzIGFsd2F5cyB0aGUgZW50aXJlIHZpZXdwb3J0LlxuICAgICAgICAvLyBJZiB0aGUgbWF4IGl0ZW0gaGVpZ2h0IGlzIGluZmluaXR5LCBzY2FsZSBpbiBwcm9wb3J0aW9uIHRvIHRoZSBtYXggd2lkdGguXG4gICAgICAgIGxldCBtYXhJdGVtV2lkdGggPSBNYXRoLm1pbihtYXhJdGVtU2l6ZS53aWR0aCwgdmlzaWJsZVdpZHRoKTtcbiAgICAgICAgbGV0IG1heEl0ZW1IZWlnaHQgPSBOdW1iZXIuaXNGaW5pdGUobWF4SXRlbVNpemUuaGVpZ2h0KSA/IG1heEl0ZW1TaXplLmhlaWdodCA6IE1hdGguZmxvb3IobWluSXRlbVNpemUuaGVpZ2h0IC8gbWluSXRlbVNpemUud2lkdGggKiBtYXhJdGVtV2lkdGgpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBuZWVkZWQgdG8gZGlzcGxheSB0aGUgY29udGVudFxuICAgICAgICBsZXQgY29sdW1ucyA9IE1hdGguZmxvb3IodmlzaWJsZVdpZHRoIC8gKG1pbkl0ZW1TaXplLndpZHRoICsgbWluU3BhY2Uud2lkdGgpKTtcbiAgICAgICAgbGV0IG51bUNvbHVtbnMgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihtYXhDb2x1bW5zLCBjb2x1bW5zKSk7XG4gICAgICAgIHRoaXMubnVtQ29sdW1ucyA9IG51bUNvbHVtbnM7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGF2YWlsYWJsZSB3aWR0aCAobWludXMgdGhlIHNwYWNlIGJldHdlZW4gaXRlbXMpXG4gICAgICAgIGxldCB3aWR0aCA9IHZpc2libGVXaWR0aCAtIG1pblNwYWNlLndpZHRoICogTWF0aC5tYXgoMCwgbnVtQ29sdW1ucyk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGl0ZW0gd2lkdGggYmFzZWQgb24gdGhlIHNwYWNlIGF2YWlsYWJsZVxuICAgICAgICBsZXQgaXRlbVdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIG51bUNvbHVtbnMpO1xuICAgICAgICBpdGVtV2lkdGggPSBNYXRoLm1heChtaW5JdGVtU2l6ZS53aWR0aCwgTWF0aC5taW4obWF4SXRlbVdpZHRoLCBpdGVtV2lkdGgpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaXRlbSBoZWlnaHQsIHdoaWNoIGlzIHByb3BvcnRpb25hbCB0byB0aGUgaXRlbSB3aWR0aFxuICAgICAgICBsZXQgdCA9IChpdGVtV2lkdGggLSBtaW5JdGVtU2l6ZS53aWR0aCkgLyBNYXRoLm1heCgxLCBtYXhJdGVtV2lkdGggLSBtaW5JdGVtU2l6ZS53aWR0aCk7XG4gICAgICAgIGxldCBpdGVtSGVpZ2h0ID0gbWluSXRlbVNpemUuaGVpZ2h0ICsgTWF0aC5mbG9vcigobWF4SXRlbUhlaWdodCAtIG1pbkl0ZW1TaXplLmhlaWdodCkgKiB0KTtcbiAgICAgICAgaXRlbUhlaWdodCA9IE1hdGgubWF4KG1pbkl0ZW1TaXplLmhlaWdodCwgTWF0aC5taW4obWF4SXRlbUhlaWdodCwgaXRlbUhlaWdodCkpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBob3Jpem9udGFsIHNwYWNpbmcgYW5kIGNvbnRlbnQgaGVpZ2h0XG4gICAgICAgIGxldCBob3Jpem9udGFsU3BhY2luZyA9IE1hdGguZmxvb3IoKHZpc2libGVXaWR0aCAtIG51bUNvbHVtbnMgKiBpdGVtV2lkdGgpIC8gKG51bUNvbHVtbnMgKyAxKSk7XG4gICAgICAgIHRoaXMuZ2FwID0gbmV3ICgwLCAkaXBnS0YkU2l6ZSkoaG9yaXpvbnRhbFNwYWNpbmcsIG1pblNwYWNlLmhlaWdodCk7XG4gICAgICAgIGxldCByb3dzID0gTWF0aC5jZWlsKHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbi5zaXplIC8gbnVtQ29sdW1ucyk7XG4gICAgICAgIGxldCBpdGVyYXRvciA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGxldCB5ID0gcm93cyA+IDAgPyBtaW5TcGFjZS5oZWlnaHQgOiAwO1xuICAgICAgICBsZXQgbmV3TGF5b3V0SW5mb3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBza2VsZXRvbiA9IG51bGw7XG4gICAgICAgIGxldCBza2VsZXRvbkNvdW50ID0gMDtcbiAgICAgICAgZm9yKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKyl7XG4gICAgICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCByb3dMYXlvdXRJbmZvcyA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBjb2wgPSAwOyBjb2wgPCBudW1Db2x1bW5zOyBjb2wrKyl7XG4gICAgICAgICAgICAgICAgLy8gUmVwZWF0IHNrZWxldG9uIHVudGlsIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcm93LlxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gc2tlbGV0b24gfHwgaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3NrZWxldG9uJykgc2tlbGV0b24gPSBub2RlO1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBza2VsZXRvbiA/IGAke3NrZWxldG9uLmtleX0tJHtza2VsZXRvbkNvdW50Kyt9YCA6IG5vZGUua2V5O1xuICAgICAgICAgICAgICAgIGxldCBvbGRMYXlvdXRJbmZvID0gdGhpcy5sYXlvdXRJbmZvcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uKSBjb250ZW50ID0gb2xkTGF5b3V0SW5mbyAmJiBvbGRMYXlvdXRJbmZvLmNvbnRlbnQua2V5ID09PSBrZXkgPyBvbGRMYXlvdXRJbmZvLmNvbnRlbnQgOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNrZWxldG9uLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IHggPSBob3Jpem9udGFsU3BhY2luZyArIGNvbCAqIChpdGVtV2lkdGggKyBob3Jpem9udGFsU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IGl0ZW1IZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IGVzdGltYXRlZFNpemUgPSAhcHJlc2VydmVBc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBpZiAob2xkTGF5b3V0SW5mbyAmJiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IG9sZExheW91dEluZm8ucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZFNpemUgPSBpbnZhbGlkYXRpb25Db250ZXh0LmxheW91dE9wdGlvbnNDaGFuZ2VkIHx8IGludmFsaWRhdGlvbkNvbnRleHQuc2l6ZUNoYW5nZWQgfHwgb2xkTGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplIHx8IG9sZExheW91dEluZm8uY29udGVudCAhPT0gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRpcGdLRiRSZWN0KSh4LCB5LCBpdGVtV2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSBuZXcgKDAsICRpcGdLRiRMYXlvdXRJbmZvKShub2RlLnR5cGUsIGtleSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVkU2l6ZTtcbiAgICAgICAgICAgICAgICBsYXlvdXRJbmZvLmFsbG93T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxheW91dEluZm8uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgbmV3TGF5b3V0SW5mb3Muc2V0KGtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgcm93TGF5b3V0SW5mb3MucHVzaChsYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIGxheW91dEluZm8ucmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgbGF5b3V0SW5mbyBvZiByb3dMYXlvdXRJbmZvcylsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgICAgICAgICAgeSArPSBtYXhIZWlnaHQgKyBtaW5TcGFjZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBLZWVwIGFkZGluZyBza2VsZXRvbiByb3dzIHVudGlsIHdlIGZpbGwgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICBpZiAoc2tlbGV0b24gJiYgcm93ID09PSByb3dzIC0gMSAmJiB5IDwgdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC5oZWlnaHQpIHJvd3MrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxheW91dEluZm9zID0gbmV3TGF5b3V0SW5mb3M7XG4gICAgICAgIHRoaXMuY29udGVudFNpemUgPSBuZXcgKDAsICRpcGdLRiRTaXplKSh0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoLCB5KTtcbiAgICB9XG4gICAgZ2V0TGF5b3V0SW5mbyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgfVxuICAgIGdldENvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2l6ZTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gW107XG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgdGhpcy5sYXlvdXRJbmZvcy52YWx1ZXMoKSlpZiAobGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHMocmVjdCkgfHwgdGhpcy52aXJ0dWFsaXplci5pc1BlcnNpc3RlZEtleShsYXlvdXRJbmZvLmtleSkpIGxheW91dEluZm9zLnB1c2gobGF5b3V0SW5mbyk7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvcztcbiAgICB9XG4gICAgdXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXRJbmZvcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFzaXplIHx8ICFsYXlvdXRJbmZvKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzaXplLmhlaWdodCAhPT0gbGF5b3V0SW5mby5yZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgbGV0IG5ld0xheW91dEluZm8gPSBsYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIG5ld0xheW91dEluZm8ucmVjdC5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIG5ld0xheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRJbmZvcy5zZXQoa2V5LCBuZXdMYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0RHJvcFRhcmdldEZyb21Qb2ludCh4LCB5LCBpc1ZhbGlkRHJvcFRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5sYXlvdXRJbmZvcy5zaXplID09PSAwKSByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3Jvb3QnXG4gICAgICAgIH07XG4gICAgICAgIHggKz0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC54O1xuICAgICAgICB5ICs9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QueTtcbiAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBpdGVtIHdpdGhpbiBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgcG9pbnQgdXNpbmcgdGhlIGdhcCB3aWR0aC5cbiAgICAgICAgbGV0IGtleSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm51bUNvbHVtbnMgPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBzZWFyY2hSZWN0ID0gbmV3ICgwLCAkaXBnS0YkUmVjdCkoeCwgTWF0aC5tYXgoMCwgeSAtIHRoaXMuZ2FwLmhlaWdodCksIDEsIHRoaXMuZ2FwLmhlaWdodCAqIDIpO1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSB0aGlzLmdldFZpc2libGVMYXlvdXRJbmZvcyhzZWFyY2hSZWN0KTtcbiAgICAgICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yIChsZXQgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpe1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpdGVtcyBvdXRzaWRlIHRoZSBzZWFyY2ggcmVjdCwgZS5nLiBwZXJzaXN0ZWQga2V5cy5cbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZS5yZWN0LmludGVyc2VjdHMoc2VhcmNoUmVjdCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCB5RGlzdCA9IE1hdGguYWJzKGNhbmRpZGF0ZS5yZWN0LnkgLSB5KTtcbiAgICAgICAgICAgICAgICBsZXQgbWF4WURpc3QgPSBNYXRoLmFicyhjYW5kaWRhdGUucmVjdC5tYXhZIC0geSk7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSBNYXRoLm1pbih5RGlzdCwgbWF4WURpc3QpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGUua2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWFyY2hSZWN0ID0gbmV3ICgwLCAkaXBnS0YkUmVjdCkoTWF0aC5tYXgoMCwgeCAtIHRoaXMuZ2FwLndpZHRoKSwgeSwgdGhpcy5nYXAud2lkdGggKiAyLCAxKTtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGVzID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3Moc2VhcmNoUmVjdCk7XG4gICAgICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKXtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaXRlbXMgb3V0c2lkZSB0aGUgc2VhcmNoIHJlY3QsIGUuZy4gcGVyc2lzdGVkIGtleXMuXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUucmVjdC5pbnRlcnNlY3RzKHNlYXJjaFJlY3QpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgeERpc3QgPSBNYXRoLmFicyhjYW5kaWRhdGUucmVjdC54IC0geCk7XG4gICAgICAgICAgICAgICAgbGV0IG1heFhEaXN0ID0gTWF0aC5hYnMoY2FuZGlkYXRlLnJlY3QubWF4WCAtIHgpO1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5taW4oeERpc3QsIG1heFhEaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlLmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxheW91dEluZm8gPSBrZXkgIT0gbnVsbCA/IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXkpIDogbnVsbDtcbiAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3Jvb3QnXG4gICAgICAgIH07XG4gICAgICAgIGxldCB0YXJnZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiAnaXRlbScsXG4gICAgICAgICAgICBrZXk6IGxheW91dEluZm8ua2V5LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnb24nXG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLm51bUNvbHVtbnMgPT09IDEgPyB5IDogeDtcbiAgICAgICAgbGV0IGxheW91dEluZm9Qb3MgPSB0aGlzLm51bUNvbHVtbnMgPT09IDEgPyBsYXlvdXRJbmZvLnJlY3QueSA6IGxheW91dEluZm8ucmVjdC54O1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMubnVtQ29sdW1ucyA9PT0gMSA/IGxheW91dEluZm8ucmVjdC5oZWlnaHQgOiBsYXlvdXRJbmZvLnJlY3Qud2lkdGg7XG4gICAgICAgIGlmIChpc1ZhbGlkRHJvcFRhcmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAvLyBJZiBkcm9wcGluZyBvbiB0aGUgaXRlbSBpcyBhY2NlcHRlZCwgdHJ5IHRoZSBiZWZvcmUvYWZ0ZXIgcG9zaXRpb25zXG4gICAgICAgICAgICAvLyBpZiB3aXRoaW4gNXB4IG9mIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGl0ZW0uXG4gICAgICAgICAgICBpZiAocG9zIDwgbGF5b3V0SW5mb1BvcyArIDUpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYmVmb3JlJztcbiAgICAgICAgICAgIGVsc2UgaWYgKHBvcyA+IGxheW91dEluZm9Qb3MgKyBzaXplIC0gNSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBkcm9wcGluZyBvbiB0aGUgaXRlbSBpc24ndCBhY2NlcHRlZCwgdHJ5IHRoZSB0YXJnZXQgYmVmb3JlIG9yIGFmdGVyIGRlcGVuZGluZyBvbiB0aGUgcG9zaXRpb24uXG4gICAgICAgICAgICBsZXQgbWlkID0gbGF5b3V0SW5mb1BvcyArIHNpemUgLyAyO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBtaWQgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICBkcm9wUG9zaXRpb246ICdiZWZvcmUnXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9ICdiZWZvcmUnO1xuICAgICAgICAgICAgZWxzZSBpZiAocG9zID49IG1pZCAmJiBpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ2FmdGVyJ1xuICAgICAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYWZ0ZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGdldERyb3BUYXJnZXRMYXlvdXRJbmZvKHRhcmdldCkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyh0YXJnZXQua2V5KTtcbiAgICAgICAgbGV0IHJlY3Q7XG4gICAgICAgIGlmICh0aGlzLm51bUNvbHVtbnMgPT09IDEpIC8vIEZsaXAgZnJvbSB2ZXJ0aWNhbCB0byBob3Jpem9udGFsIGlmIG9ubHkgb25lIGNvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAgICByZWN0ID0gbmV3ICgwLCAkaXBnS0YkUmVjdCkobGF5b3V0SW5mby5yZWN0LngsIHRhcmdldC5kcm9wUG9zaXRpb24gPT09ICdiZWZvcmUnID8gbGF5b3V0SW5mby5yZWN0LnkgLSB0aGlzLmdhcC5oZWlnaHQgLyAyIC0gdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIC8gMiA6IGxheW91dEluZm8ucmVjdC5tYXhZICsgdGhpcy5nYXAuaGVpZ2h0IC8gMiAtIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyAvIDIsIGxheW91dEluZm8ucmVjdC53aWR0aCwgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzKTtcbiAgICAgICAgZWxzZSByZWN0ID0gbmV3ICgwLCAkaXBnS0YkUmVjdCkodGFyZ2V0LmRyb3BQb3NpdGlvbiA9PT0gJ2JlZm9yZScgPyBsYXlvdXRJbmZvLnJlY3QueCAtIHRoaXMuZ2FwLndpZHRoIC8gMiAtIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyAvIDIgOiBsYXlvdXRJbmZvLnJlY3QubWF4WCArIHRoaXMuZ2FwLndpZHRoIC8gMiAtIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyAvIDIsIGxheW91dEluZm8ucmVjdC55LCB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MsIGxheW91dEluZm8ucmVjdC5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkaXBnS0YkTGF5b3V0SW5mbykoJ2Ryb3BJbmRpY2F0b3InLCB0YXJnZXQua2V5ICsgJzonICsgdGFyZ2V0LmRyb3BQb3NpdGlvbiwgcmVjdCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKSwgdGhpcy5nYXAgPSAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLm1pblNwYWNlLCB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgPSAyLCB0aGlzLm51bUNvbHVtbnMgPSAwLCB0aGlzLmNvbnRlbnRTaXplID0gbmV3ICgwLCAkaXBnS0YkU2l6ZSkoKSwgdGhpcy5sYXlvdXRJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICB9XG59XG5cblxuZXhwb3J0IHskYTU4NTkyZDI5NWExNzBhNCRleHBvcnQkN2QyYjEyNTc4MTU0YTczNSBhcyBHcmlkTGF5b3V0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyaWRMYXlvdXQubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs\n");

/***/ }),

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs":
/*!*********************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs ***!
  \*********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListLayout: () => (/* binding */ $61ef60fc9b1041f4$export$cacbb3924155d68e)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/collections */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+collections@3.12.2_react@19.0.0/node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/virtualizer */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;\nclass $61ef60fc9b1041f4$export$cacbb3924155d68e extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Layout) {\n    // Backward compatibility for subclassing.\n    get collection() {\n        return this.virtualizer.collection;\n    }\n    getLayoutInfo(key) {\n        var _this_layoutNodes_get;\n        this.ensureLayoutInfo(key);\n        return ((_this_layoutNodes_get = this.layoutNodes.get(key)) === null || _this_layoutNodes_get === void 0 ? void 0 : _this_layoutNodes_get.layoutInfo) || null;\n    }\n    getVisibleLayoutInfos(rect) {\n        // Adjust rect to keep number of visible rows consistent.\n        // (only if height > 1 for getDropTargetFromPoint)\n        if (rect.height > 1) {\n            var _this_rowHeight, _ref;\n            let rowHeight = ((_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT) + this.gap;\n            rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n            rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n        }\n        // If layout hasn't yet been done for the requested rect, union the\n        // new rect with the existing valid rect, and recompute.\n        this.layoutIfNeeded(rect);\n        let res = [];\n        let addNodes = (nodes)=>{\n            for (let node of nodes)if (this.isVisible(node, rect)) {\n                res.push(node.layoutInfo);\n                if (node.children) addNodes(node.children);\n            }\n        };\n        addNodes(this.rootNodes);\n        return res;\n    }\n    layoutIfNeeded(rect) {\n        if (!this.lastCollection) return;\n        if (!this.requestedRect.containsRect(rect)) {\n            this.requestedRect = this.requestedRect.union(rect);\n            this.rootNodes = this.buildCollection();\n        }\n        // Ensure all of the persisted keys are available.\n        for (let key of this.virtualizer.persistedKeys){\n            if (this.ensureLayoutInfo(key)) return;\n        }\n    }\n    ensureLayoutInfo(key) {\n        // If the layout info wasn't found, it might be outside the bounds of the area that we've\n        // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n        // Compute the full layout and try again.\n        if (!this.layoutNodes.has(key) && this.requestedRect.area < this.contentSize.area && this.lastCollection) {\n            this.requestedRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, 0, Infinity, Infinity);\n            this.rootNodes = this.buildCollection();\n            this.requestedRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, 0, this.contentSize.width, this.contentSize.height);\n            return true;\n        }\n        return false;\n    }\n    isVisible(node, rect) {\n        return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || node.layoutInfo.type === 'header' || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n    }\n    shouldInvalidateEverything(invalidationContext) {\n        // Invalidate cache if the size of the collection changed.\n        // In this case, we need to recalculate the entire layout.\n        // Also invalidate if fixed sizes/gaps change.\n        let options = invalidationContext.layoutOptions;\n        var _options_rowHeight, _options_headingHeight, _options_loaderHeight, _options_gap, _options_padding;\n        return invalidationContext.sizeChanged || this.rowHeight !== ((_options_rowHeight = options === null || options === void 0 ? void 0 : options.rowHeight) !== null && _options_rowHeight !== void 0 ? _options_rowHeight : this.rowHeight) || this.headingHeight !== ((_options_headingHeight = options === null || options === void 0 ? void 0 : options.headingHeight) !== null && _options_headingHeight !== void 0 ? _options_headingHeight : this.headingHeight) || this.loaderHeight !== ((_options_loaderHeight = options === null || options === void 0 ? void 0 : options.loaderHeight) !== null && _options_loaderHeight !== void 0 ? _options_loaderHeight : this.loaderHeight) || this.gap !== ((_options_gap = options === null || options === void 0 ? void 0 : options.gap) !== null && _options_gap !== void 0 ? _options_gap : this.gap) || this.padding !== ((_options_padding = options === null || options === void 0 ? void 0 : options.padding) !== null && _options_padding !== void 0 ? _options_padding : this.padding);\n    }\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.rowHeight !== oldOptions.rowHeight || newOptions.estimatedRowHeight !== oldOptions.estimatedRowHeight || newOptions.headingHeight !== oldOptions.headingHeight || newOptions.estimatedHeadingHeight !== oldOptions.estimatedHeadingHeight || newOptions.loaderHeight !== oldOptions.loaderHeight || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness || newOptions.gap !== oldOptions.gap || newOptions.padding !== oldOptions.padding;\n    }\n    update(invalidationContext) {\n        let collection = this.virtualizer.collection;\n        // Reset valid rect if we will have to invalidate everything.\n        // Otherwise we can reuse cached layout infos outside the current visible rect.\n        this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n        if (this.invalidateEverything) {\n            this.requestedRect = this.virtualizer.visibleRect.copy();\n            this.layoutNodes.clear();\n        }\n        let options = invalidationContext.layoutOptions;\n        var _options_rowHeight;\n        this.rowHeight = (_options_rowHeight = options === null || options === void 0 ? void 0 : options.rowHeight) !== null && _options_rowHeight !== void 0 ? _options_rowHeight : this.rowHeight;\n        var _options_estimatedRowHeight;\n        this.estimatedRowHeight = (_options_estimatedRowHeight = options === null || options === void 0 ? void 0 : options.estimatedRowHeight) !== null && _options_estimatedRowHeight !== void 0 ? _options_estimatedRowHeight : this.estimatedRowHeight;\n        var _options_headingHeight;\n        this.headingHeight = (_options_headingHeight = options === null || options === void 0 ? void 0 : options.headingHeight) !== null && _options_headingHeight !== void 0 ? _options_headingHeight : this.headingHeight;\n        var _options_estimatedHeadingHeight;\n        this.estimatedHeadingHeight = (_options_estimatedHeadingHeight = options === null || options === void 0 ? void 0 : options.estimatedHeadingHeight) !== null && _options_estimatedHeadingHeight !== void 0 ? _options_estimatedHeadingHeight : this.estimatedHeadingHeight;\n        var _options_loaderHeight;\n        this.loaderHeight = (_options_loaderHeight = options === null || options === void 0 ? void 0 : options.loaderHeight) !== null && _options_loaderHeight !== void 0 ? _options_loaderHeight : this.loaderHeight;\n        var _options_dropIndicatorThickness;\n        this.dropIndicatorThickness = (_options_dropIndicatorThickness = options === null || options === void 0 ? void 0 : options.dropIndicatorThickness) !== null && _options_dropIndicatorThickness !== void 0 ? _options_dropIndicatorThickness : this.dropIndicatorThickness;\n        var _options_gap;\n        this.gap = (_options_gap = options === null || options === void 0 ? void 0 : options.gap) !== null && _options_gap !== void 0 ? _options_gap : this.gap;\n        var _options_padding;\n        this.padding = (_options_padding = options === null || options === void 0 ? void 0 : options.padding) !== null && _options_padding !== void 0 ? _options_padding : this.padding;\n        this.rootNodes = this.buildCollection();\n        // Remove deleted layout nodes\n        if (this.lastCollection && collection !== this.lastCollection) {\n            for (let key of this.lastCollection.getKeys())if (!collection.getItem(key)) {\n                let layoutNode = this.layoutNodes.get(key);\n                if (layoutNode) this.layoutNodes.delete(key);\n            }\n        }\n        this.lastCollection = collection;\n        this.invalidateEverything = false;\n        this.validRect = this.requestedRect.copy();\n    }\n    buildCollection(y = this.padding) {\n        let collection = this.virtualizer.collection;\n        let skipped = 0;\n        let nodes = [];\n        for (let node of collection){\n            var _this_rowHeight, _ref;\n            let rowHeight = ((_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT) + this.gap;\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (node.type === 'item' && y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(node, this.padding, y, null);\n            y = layoutNode.layoutInfo.rect.maxY + this.gap;\n            nodes.push(layoutNode);\n            if (node.type === 'item' && y > this.requestedRect.maxY) {\n                y += (collection.size - (nodes.length + skipped)) * rowHeight;\n                break;\n            }\n        }\n        y -= this.gap;\n        y += this.padding;\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(this.virtualizer.visibleRect.width, y);\n        return nodes;\n    }\n    isValid(node, y) {\n        let cached = this.layoutNodes.get(node.key);\n        return !this.invalidateEverything && cached && cached.node === node && y === cached.layoutInfo.rect.y && cached.layoutInfo.rect.intersects(this.validRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.requestedRect));\n    }\n    buildChild(node, x, y, parentKey) {\n        if (this.isValid(node, y)) return this.layoutNodes.get(node.key);\n        let layoutNode = this.buildNode(node, x, y);\n        layoutNode.layoutInfo.parentKey = parentKey !== null && parentKey !== void 0 ? parentKey : null;\n        this.layoutNodes.set(node.key, layoutNode);\n        return layoutNode;\n    }\n    buildNode(node, x, y) {\n        switch(node.type){\n            case 'section':\n                return this.buildSection(node, x, y);\n            case 'item':\n                return this.buildItem(node, x, y);\n            case 'header':\n                return this.buildSectionHeader(node, x, y);\n            case 'loader':\n                return this.buildLoader(node, x, y);\n            default:\n                throw new Error('Unsupported node type: ' + node.type);\n        }\n    }\n    buildLoader(node, x, y) {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, this.padding, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('loader', node.key, rect);\n        rect.width = this.virtualizer.contentSize.width - this.padding - x;\n        rect.height = this.loaderHeight || this.rowHeight || this.estimatedRowHeight || $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        return {\n            layoutInfo: layoutInfo,\n            validRect: rect.intersection(this.requestedRect)\n        };\n    }\n    buildSection(node, x, y) {\n        let collection = this.virtualizer.collection;\n        let width = this.virtualizer.visibleRect.width - this.padding;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width - x, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        let startY = y;\n        let skipped = 0;\n        let children = [];\n        for (let child of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(node, collection)){\n            var _this_rowHeight, _ref;\n            let rowHeight = ((_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT) + this.gap;\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n            y = layoutNode.layoutInfo.rect.maxY + this.gap;\n            children.push(layoutNode);\n            if (y > this.requestedRect.maxY) {\n                // Estimate the remaining height for rows that we don't need to layout right now.\n                y += ([\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(node, collection)\n                ].length - (children.length + skipped)) * rowHeight;\n                break;\n            }\n        }\n        y -= this.gap;\n        rect.height = y - startY;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect.intersection(this.requestedRect),\n            node: node\n        };\n    }\n    buildSectionHeader(node, x, y) {\n        let width = this.virtualizer.visibleRect.width - this.padding;\n        let rectHeight = this.headingHeight;\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (rectHeight == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall virtualizer changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            let previousLayoutInfo = previousLayoutNode === null || previousLayoutNode === void 0 ? void 0 : previousLayoutNode.layoutInfo;\n            if (previousLayoutInfo) {\n                let curNode = this.virtualizer.collection.getItem(node.key);\n                let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n                rectHeight = previousLayoutInfo.rect.height;\n                isEstimated = width !== previousLayoutInfo.rect.width || curNode !== lastNode || previousLayoutInfo.estimatedSize;\n            } else {\n                rectHeight = node.rendered ? this.estimatedHeadingHeight : 0;\n                isEstimated = true;\n            }\n        }\n        if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        let headerRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width - x, rectHeight);\n        let header = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('header', node.key, headerRect);\n        header.estimatedSize = isEstimated;\n        return {\n            layoutInfo: header,\n            children: [],\n            validRect: header.rect.intersection(this.requestedRect),\n            node: node\n        };\n    }\n    buildItem(node, x, y) {\n        let width = this.virtualizer.visibleRect.width - this.padding - x;\n        let rectHeight = this.rowHeight;\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (rectHeight == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall virtualizer changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            if (previousLayoutNode) {\n                rectHeight = previousLayoutNode.layoutInfo.rect.height;\n                isEstimated = width !== previousLayoutNode.layoutInfo.rect.width || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n            } else {\n                rectHeight = this.estimatedRowHeight;\n                isEstimated = true;\n            }\n        }\n        if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width, rectHeight);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            children: [],\n            validRect: layoutInfo.rect,\n            node: node\n        };\n    }\n    updateItemSize(key, size) {\n        let layoutNode = this.layoutNodes.get(key);\n        // If no layoutInfo, item has been deleted/removed.\n        if (!layoutNode) return false;\n        let collection = this.virtualizer.collection;\n        let layoutInfo = layoutNode.layoutInfo;\n        layoutInfo.estimatedSize = false;\n        if (layoutInfo.rect.height !== size.height) {\n            // Copy layout info rather than mutating so that later caches are invalidated.\n            let newLayoutInfo = layoutInfo.copy();\n            newLayoutInfo.rect.height = size.height;\n            layoutNode.layoutInfo = newLayoutInfo;\n            // Items after this layoutInfo will need to be repositioned to account for the new height.\n            // Adjust the validRect so that only items above remain valid.\n            this.validRect.height = Math.min(this.validRect.height, layoutInfo.rect.y - this.validRect.y);\n            // The requestedRect also needs to be adjusted to account for the height difference.\n            this.requestedRect.height += newLayoutInfo.rect.height - layoutInfo.rect.height;\n            // Invalidate layout for this layout node and all parents\n            this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n            let node = layoutInfo.parentKey != null ? collection.getItem(layoutInfo.parentKey) : null;\n            while(node){\n                this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n                node = node.parentKey != null ? collection.getItem(node.parentKey) : null;\n            }\n            return true;\n        }\n        return false;\n    }\n    updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {\n        let n = this.layoutNodes.get(key);\n        if (n) {\n            // Invalidate by intersecting the validRect of this node with the overall validRect.\n            n.validRect = n.validRect.intersection(this.validRect);\n            // Replace layout info in LayoutNode\n            if (n.layoutInfo === oldLayoutInfo) n.layoutInfo = newLayoutInfo;\n        }\n    }\n    getContentSize() {\n        return this.contentSize;\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        // Find the closest item within on either side of the point using the gap width.\n        let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, Math.max(0, y - this.gap), 1, this.gap * 2);\n        let candidates = this.getVisibleLayoutInfos(searchRect);\n        let key = null;\n        let minDistance = Infinity;\n        for (let candidate of candidates){\n            // Ignore items outside the search rect, e.g. persisted keys.\n            if (!candidate.rect.intersects(searchRect)) continue;\n            let yDist = Math.abs(candidate.rect.y - y);\n            let maxYDist = Math.abs(candidate.rect.maxY - y);\n            let dist = Math.min(yDist, maxYDist);\n            if (dist < minDistance) {\n                minDistance = dist;\n                key = candidate.key;\n            }\n        }\n        if (key == null || this.virtualizer.collection.size === 0) return {\n            type: 'root'\n        };\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = layoutInfo.rect;\n        let target = {\n            type: 'item',\n            key: layoutInfo.key,\n            dropPosition: 'on'\n        };\n        // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n        // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n        // of the top or bottom of the item.\n        if (!isValidDropTarget(target)) {\n            if (y <= rect.y + rect.height / 2 && isValidDropTarget({\n                ...target,\n                dropPosition: 'before'\n            })) target.dropPosition = 'before';\n            else if (isValidDropTarget({\n                ...target,\n                dropPosition: 'after'\n            })) target.dropPosition = 'after';\n        } else if (y <= rect.y + 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'before'\n        })) target.dropPosition = 'before';\n        else if (y >= rect.maxY - 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'after'\n        })) target.dropPosition = 'after';\n        return target;\n    }\n    getDropTargetLayoutInfo(target) {\n        let layoutInfo = this.getLayoutInfo(target.key);\n        let rect;\n        if (target.dropPosition === 'before') rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.x, layoutInfo.rect.y - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n        else if (target.dropPosition === 'after') rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.x, layoutInfo.rect.maxY - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n        else rect = layoutInfo.rect;\n        return new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('dropIndicator', target.key + ':' + target.dropPosition, rect);\n    }\n    /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */ constructor(options = {}){\n        super();\n        var _options_rowHeight;\n        this.rowHeight = (_options_rowHeight = options.rowHeight) !== null && _options_rowHeight !== void 0 ? _options_rowHeight : null;\n        var _options_estimatedRowHeight;\n        this.estimatedRowHeight = (_options_estimatedRowHeight = options.estimatedRowHeight) !== null && _options_estimatedRowHeight !== void 0 ? _options_estimatedRowHeight : null;\n        var _options_headingHeight;\n        this.headingHeight = (_options_headingHeight = options.headingHeight) !== null && _options_headingHeight !== void 0 ? _options_headingHeight : null;\n        var _options_estimatedHeadingHeight;\n        this.estimatedHeadingHeight = (_options_estimatedHeadingHeight = options.estimatedHeadingHeight) !== null && _options_estimatedHeadingHeight !== void 0 ? _options_estimatedHeadingHeight : null;\n        var _options_loaderHeight;\n        this.loaderHeight = (_options_loaderHeight = options.loaderHeight) !== null && _options_loaderHeight !== void 0 ? _options_loaderHeight : null;\n        this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n        this.gap = options.gap || 0;\n        this.padding = options.padding || 0;\n        this.layoutNodes = new Map();\n        this.rootNodes = [];\n        this.lastCollection = null;\n        this.invalidateEverything = false;\n        this.validRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)();\n        this.requestedRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)();\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)();\n    }\n}\n\n\n\n//# sourceMappingURL=ListLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L0xpc3RMYXlvdXQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRjtBQUM2RDs7QUFFOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCw4REFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDREQUFXO0FBQ3BEO0FBQ0EseUNBQXlDLDREQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDLGlDQUFpQyxrRUFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVc7QUFDdEMsaUNBQWlDLGtFQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUVBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0REFBVztBQUM1Qyw2QkFBNkIsa0VBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDLGlDQUFpQyxrRUFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNERBQVc7QUFDeEUsaUVBQWlFLDREQUFXO0FBQzVFO0FBQ0EsdUJBQXVCLGtFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQVc7QUFDNUMscUNBQXFDLDREQUFXO0FBQ2hELG1DQUFtQyw0REFBVztBQUM5QztBQUNBOzs7QUFHaUU7QUFDakUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9MaXN0TGF5b3V0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldENoaWxkTm9kZXMgYXMgJGltZzI2JGdldENoaWxkTm9kZXN9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHtSZWN0IGFzICRpbWcyNiRSZWN0LCBTaXplIGFzICRpbWcyNiRTaXplLCBMYXlvdXRJbmZvIGFzICRpbWcyNiRMYXlvdXRJbmZvLCBMYXlvdXQgYXMgJGltZzI2JExheW91dH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3ZpcnR1YWxpemVyXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY29uc3QgJDYxZWY2MGZjOWIxMDQxZjQkdmFyJERFRkFVTFRfSEVJR0hUID0gNDg7XG5jbGFzcyAkNjFlZjYwZmM5YjEwNDFmNCRleHBvcnQkY2FjYmIzOTI0MTU1ZDY4ZSBleHRlbmRzICgwLCAkaW1nMjYkTGF5b3V0KSB7XG4gICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3Igc3ViY2xhc3NpbmcuXG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgfVxuICAgIGdldExheW91dEluZm8oa2V5KSB7XG4gICAgICAgIHZhciBfdGhpc19sYXlvdXROb2Rlc19nZXQ7XG4gICAgICAgIHRoaXMuZW5zdXJlTGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICByZXR1cm4gKChfdGhpc19sYXlvdXROb2Rlc19nZXQgPSB0aGlzLmxheW91dE5vZGVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfdGhpc19sYXlvdXROb2Rlc19nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2xheW91dE5vZGVzX2dldC5sYXlvdXRJbmZvKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCkge1xuICAgICAgICAvLyBBZGp1c3QgcmVjdCB0byBrZWVwIG51bWJlciBvZiB2aXNpYmxlIHJvd3MgY29uc2lzdGVudC5cbiAgICAgICAgLy8gKG9ubHkgaWYgaGVpZ2h0ID4gMSBmb3IgZ2V0RHJvcFRhcmdldEZyb21Qb2ludClcbiAgICAgICAgaWYgKHJlY3QuaGVpZ2h0ID4gMSkge1xuICAgICAgICAgICAgdmFyIF90aGlzX3Jvd0hlaWdodCwgX3JlZjtcbiAgICAgICAgICAgIGxldCByb3dIZWlnaHQgPSAoKF9yZWYgPSAoX3RoaXNfcm93SGVpZ2h0ID0gdGhpcy5yb3dIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX3Jvd0hlaWdodCAhPT0gdm9pZCAwID8gX3RoaXNfcm93SGVpZ2h0IDogdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiAkNjFlZjYwZmM5YjEwNDFmNCR2YXIkREVGQVVMVF9IRUlHSFQpICsgdGhpcy5nYXA7XG4gICAgICAgICAgICByZWN0LnkgPSBNYXRoLmZsb29yKHJlY3QueSAvIHJvd0hlaWdodCkgKiByb3dIZWlnaHQ7XG4gICAgICAgICAgICByZWN0LmhlaWdodCA9IE1hdGguY2VpbChyZWN0LmhlaWdodCAvIHJvd0hlaWdodCkgKiByb3dIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbGF5b3V0IGhhc24ndCB5ZXQgYmVlbiBkb25lIGZvciB0aGUgcmVxdWVzdGVkIHJlY3QsIHVuaW9uIHRoZVxuICAgICAgICAvLyBuZXcgcmVjdCB3aXRoIHRoZSBleGlzdGluZyB2YWxpZCByZWN0LCBhbmQgcmVjb21wdXRlLlxuICAgICAgICB0aGlzLmxheW91dElmTmVlZGVkKHJlY3QpO1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGxldCBhZGROb2RlcyA9IChub2Rlcyk9PntcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpaWYgKHRoaXMuaXNWaXNpYmxlKG5vZGUsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikgYWRkTm9kZXMobm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZE5vZGVzKHRoaXMucm9vdE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgbGF5b3V0SWZOZWVkZWQocmVjdCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdENvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RlZFJlY3QuY29udGFpbnNSZWN0KHJlY3QpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlZFJlY3QgPSB0aGlzLnJlcXVlc3RlZFJlY3QudW5pb24ocmVjdCk7XG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHRoaXMuYnVpbGRDb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIGFsbCBvZiB0aGUgcGVyc2lzdGVkIGtleXMgYXJlIGF2YWlsYWJsZS5cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMudmlydHVhbGl6ZXIucGVyc2lzdGVkS2V5cyl7XG4gICAgICAgICAgICBpZiAodGhpcy5lbnN1cmVMYXlvdXRJbmZvKGtleSkpIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnN1cmVMYXlvdXRJbmZvKGtleSkge1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGluZm8gd2Fzbid0IGZvdW5kLCBpdCBtaWdodCBiZSBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGFyZWEgdGhhdCB3ZSd2ZVxuICAgICAgICAvLyBjb21wdXRlZCBsYXlvdXQgZm9yIHNvIGZhci4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYWNjZXNzaW5nIGEgcmFuZG9tIGtleSwgZS5nIHByZXNzaW5nIEhvbWUvRW5kLlxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmdWxsIGxheW91dCBhbmQgdHJ5IGFnYWluLlxuICAgICAgICBpZiAoIXRoaXMubGF5b3V0Tm9kZXMuaGFzKGtleSkgJiYgdGhpcy5yZXF1ZXN0ZWRSZWN0LmFyZWEgPCB0aGlzLmNvbnRlbnRTaXplLmFyZWEgJiYgdGhpcy5sYXN0Q29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkoMCwgMCwgSW5maW5pdHksIEluZmluaXR5KTtcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGVzID0gdGhpcy5idWlsZENvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVkUmVjdCA9IG5ldyAoMCwgJGltZzI2JFJlY3QpKDAsIDAsIHRoaXMuY29udGVudFNpemUud2lkdGgsIHRoaXMuY29udGVudFNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNWaXNpYmxlKG5vZGUsIHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHMocmVjdCkgfHwgbm9kZS5sYXlvdXRJbmZvLmlzU3RpY2t5IHx8IG5vZGUubGF5b3V0SW5mby50eXBlID09PSAnaGVhZGVyJyB8fCB0aGlzLnZpcnR1YWxpemVyLmlzUGVyc2lzdGVkS2V5KG5vZGUubGF5b3V0SW5mby5rZXkpO1xuICAgIH1cbiAgICBzaG91bGRJbnZhbGlkYXRlRXZlcnl0aGluZyhpbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgaWYgdGhlIHNpemUgb2YgdGhlIGNvbGxlY3Rpb24gY2hhbmdlZC5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBlbnRpcmUgbGF5b3V0LlxuICAgICAgICAvLyBBbHNvIGludmFsaWRhdGUgaWYgZml4ZWQgc2l6ZXMvZ2FwcyBjaGFuZ2UuXG4gICAgICAgIGxldCBvcHRpb25zID0gaW52YWxpZGF0aW9uQ29udGV4dC5sYXlvdXRPcHRpb25zO1xuICAgICAgICB2YXIgX29wdGlvbnNfcm93SGVpZ2h0LCBfb3B0aW9uc19oZWFkaW5nSGVpZ2h0LCBfb3B0aW9uc19sb2FkZXJIZWlnaHQsIF9vcHRpb25zX2dhcCwgX29wdGlvbnNfcGFkZGluZztcbiAgICAgICAgcmV0dXJuIGludmFsaWRhdGlvbkNvbnRleHQuc2l6ZUNoYW5nZWQgfHwgdGhpcy5yb3dIZWlnaHQgIT09ICgoX29wdGlvbnNfcm93SGVpZ2h0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvd0hlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfcm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19yb3dIZWlnaHQgOiB0aGlzLnJvd0hlaWdodCkgfHwgdGhpcy5oZWFkaW5nSGVpZ2h0ICE9PSAoKF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGluZ0hlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfaGVhZGluZ0hlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfaGVhZGluZ0hlaWdodCA6IHRoaXMuaGVhZGluZ0hlaWdodCkgfHwgdGhpcy5sb2FkZXJIZWlnaHQgIT09ICgoX29wdGlvbnNfbG9hZGVySGVpZ2h0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvYWRlckhlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfbG9hZGVySGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19sb2FkZXJIZWlnaHQgOiB0aGlzLmxvYWRlckhlaWdodCkgfHwgdGhpcy5nYXAgIT09ICgoX29wdGlvbnNfZ2FwID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdhcCkgIT09IG51bGwgJiYgX29wdGlvbnNfZ2FwICE9PSB2b2lkIDAgPyBfb3B0aW9uc19nYXAgOiB0aGlzLmdhcCkgfHwgdGhpcy5wYWRkaW5nICE9PSAoKF9vcHRpb25zX3BhZGRpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFkZGluZykgIT09IG51bGwgJiYgX29wdGlvbnNfcGFkZGluZyAhPT0gdm9pZCAwID8gX29wdGlvbnNfcGFkZGluZyA6IHRoaXMucGFkZGluZyk7XG4gICAgfVxuICAgIHNob3VsZEludmFsaWRhdGVMYXlvdXRPcHRpb25zKG5ld09wdGlvbnMsIG9sZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnMucm93SGVpZ2h0ICE9PSBvbGRPcHRpb25zLnJvd0hlaWdodCB8fCBuZXdPcHRpb25zLmVzdGltYXRlZFJvd0hlaWdodCAhPT0gb2xkT3B0aW9ucy5lc3RpbWF0ZWRSb3dIZWlnaHQgfHwgbmV3T3B0aW9ucy5oZWFkaW5nSGVpZ2h0ICE9PSBvbGRPcHRpb25zLmhlYWRpbmdIZWlnaHQgfHwgbmV3T3B0aW9ucy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ICE9PSBvbGRPcHRpb25zLmVzdGltYXRlZEhlYWRpbmdIZWlnaHQgfHwgbmV3T3B0aW9ucy5sb2FkZXJIZWlnaHQgIT09IG9sZE9wdGlvbnMubG9hZGVySGVpZ2h0IHx8IG5ld09wdGlvbnMuZHJvcEluZGljYXRvclRoaWNrbmVzcyAhPT0gb2xkT3B0aW9ucy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIHx8IG5ld09wdGlvbnMuZ2FwICE9PSBvbGRPcHRpb25zLmdhcCB8fCBuZXdPcHRpb25zLnBhZGRpbmcgIT09IG9sZE9wdGlvbnMucGFkZGluZztcbiAgICB9XG4gICAgdXBkYXRlKGludmFsaWRhdGlvbkNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgICAgIC8vIFJlc2V0IHZhbGlkIHJlY3QgaWYgd2Ugd2lsbCBoYXZlIHRvIGludmFsaWRhdGUgZXZlcnl0aGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiByZXVzZSBjYWNoZWQgbGF5b3V0IGluZm9zIG91dHNpZGUgdGhlIGN1cnJlbnQgdmlzaWJsZSByZWN0LlxuICAgICAgICB0aGlzLmludmFsaWRhdGVFdmVyeXRoaW5nID0gdGhpcy5zaG91bGRJbnZhbGlkYXRlRXZlcnl0aGluZyhpbnZhbGlkYXRpb25Db250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuaW52YWxpZGF0ZUV2ZXJ5dGhpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVkUmVjdCA9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QuY29weSgpO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXROb2Rlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcHRpb25zID0gaW52YWxpZGF0aW9uQ29udGV4dC5sYXlvdXRPcHRpb25zO1xuICAgICAgICB2YXIgX29wdGlvbnNfcm93SGVpZ2h0O1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IChfb3B0aW9uc19yb3dIZWlnaHQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfb3B0aW9uc19yb3dIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX3Jvd0hlaWdodCA6IHRoaXMucm93SGVpZ2h0O1xuICAgICAgICB2YXIgX29wdGlvbnNfZXN0aW1hdGVkUm93SGVpZ2h0O1xuICAgICAgICB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCA9IChfb3B0aW9uc19lc3RpbWF0ZWRSb3dIZWlnaHQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXN0aW1hdGVkUm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfb3B0aW9uc19lc3RpbWF0ZWRSb3dIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX2VzdGltYXRlZFJvd0hlaWdodCA6IHRoaXMuZXN0aW1hdGVkUm93SGVpZ2h0O1xuICAgICAgICB2YXIgX29wdGlvbnNfaGVhZGluZ0hlaWdodDtcbiAgICAgICAgdGhpcy5oZWFkaW5nSGVpZ2h0ID0gKF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGluZ0hlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfaGVhZGluZ0hlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfaGVhZGluZ0hlaWdodCA6IHRoaXMuaGVhZGluZ0hlaWdodDtcbiAgICAgICAgdmFyIF9vcHRpb25zX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuZXN0aW1hdGVkSGVhZGluZ0hlaWdodCA9IChfb3B0aW9uc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVzdGltYXRlZEhlYWRpbmdIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgOiB0aGlzLmVzdGltYXRlZEhlYWRpbmdIZWlnaHQ7XG4gICAgICAgIHZhciBfb3B0aW9uc19sb2FkZXJIZWlnaHQ7XG4gICAgICAgIHRoaXMubG9hZGVySGVpZ2h0ID0gKF9vcHRpb25zX2xvYWRlckhlaWdodCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2FkZXJIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2xvYWRlckhlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfbG9hZGVySGVpZ2h0IDogdGhpcy5sb2FkZXJIZWlnaHQ7XG4gICAgICAgIHZhciBfb3B0aW9uc19kcm9wSW5kaWNhdG9yVGhpY2tuZXNzO1xuICAgICAgICB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgPSAoX29wdGlvbnNfZHJvcEluZGljYXRvclRoaWNrbmVzcyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19kcm9wSW5kaWNhdG9yVGhpY2tuZXNzICE9PSB2b2lkIDAgPyBfb3B0aW9uc19kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIDogdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2FwO1xuICAgICAgICB0aGlzLmdhcCA9IChfb3B0aW9uc19nYXAgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2FwKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nYXAgIT09IHZvaWQgMCA/IF9vcHRpb25zX2dhcCA6IHRoaXMuZ2FwO1xuICAgICAgICB2YXIgX29wdGlvbnNfcGFkZGluZztcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gKF9vcHRpb25zX3BhZGRpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFkZGluZykgIT09IG51bGwgJiYgX29wdGlvbnNfcGFkZGluZyAhPT0gdm9pZCAwID8gX29wdGlvbnNfcGFkZGluZyA6IHRoaXMucGFkZGluZztcbiAgICAgICAgdGhpcy5yb290Tm9kZXMgPSB0aGlzLmJ1aWxkQ29sbGVjdGlvbigpO1xuICAgICAgICAvLyBSZW1vdmUgZGVsZXRlZCBsYXlvdXQgbm9kZXNcbiAgICAgICAgaWYgKHRoaXMubGFzdENvbGxlY3Rpb24gJiYgY29sbGVjdGlvbiAhPT0gdGhpcy5sYXN0Q29sbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMubGFzdENvbGxlY3Rpb24uZ2V0S2V5cygpKWlmICghY29sbGVjdGlvbi5nZXRJdGVtKGtleSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dE5vZGUpIHRoaXMubGF5b3V0Tm9kZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Q29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUV2ZXJ5dGhpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWxpZFJlY3QgPSB0aGlzLnJlcXVlc3RlZFJlY3QuY29weSgpO1xuICAgIH1cbiAgICBidWlsZENvbGxlY3Rpb24oeSA9IHRoaXMucGFkZGluZykge1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IHNraXBwZWQgPSAwO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjb2xsZWN0aW9uKXtcbiAgICAgICAgICAgIHZhciBfdGhpc19yb3dIZWlnaHQsIF9yZWY7XG4gICAgICAgICAgICBsZXQgcm93SGVpZ2h0ID0gKChfcmVmID0gKF90aGlzX3Jvd0hlaWdodCA9IHRoaXMucm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpc19yb3dIZWlnaHQgIT09IHZvaWQgMCA/IF90aGlzX3Jvd0hlaWdodCA6IHRoaXMuZXN0aW1hdGVkUm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogJDYxZWY2MGZjOWIxMDQxZjQkdmFyJERFRkFVTFRfSEVJR0hUKSArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJlZm9yZSB0aGUgdmFsaWQgcmVjdGFuZ2xlIHVubGVzcyB0aGV5IGFyZSBhbHJlYWR5IGNhY2hlZC5cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdpdGVtJyAmJiB5ICsgcm93SGVpZ2h0IDwgdGhpcy5yZXF1ZXN0ZWRSZWN0LnkgJiYgIXRoaXMuaXNWYWxpZChub2RlLCB5KSkge1xuICAgICAgICAgICAgICAgIHkgKz0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZENoaWxkKG5vZGUsIHRoaXMucGFkZGluZywgeSwgbnVsbCk7XG4gICAgICAgICAgICB5ID0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QubWF4WSArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgbm9kZXMucHVzaChsYXlvdXROb2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdpdGVtJyAmJiB5ID4gdGhpcy5yZXF1ZXN0ZWRSZWN0Lm1heFkpIHtcbiAgICAgICAgICAgICAgICB5ICs9IChjb2xsZWN0aW9uLnNpemUgLSAobm9kZXMubGVuZ3RoICsgc2tpcHBlZCkpICogcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHkgLT0gdGhpcy5nYXA7XG4gICAgICAgIHkgKz0gdGhpcy5wYWRkaW5nO1xuICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gbmV3ICgwLCAkaW1nMjYkU2l6ZSkodGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCwgeSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgaXNWYWxpZChub2RlLCB5KSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLmxheW91dE5vZGVzLmdldChub2RlLmtleSk7XG4gICAgICAgIHJldHVybiAhdGhpcy5pbnZhbGlkYXRlRXZlcnl0aGluZyAmJiBjYWNoZWQgJiYgY2FjaGVkLm5vZGUgPT09IG5vZGUgJiYgeSA9PT0gY2FjaGVkLmxheW91dEluZm8ucmVjdC55ICYmIGNhY2hlZC5sYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0cyh0aGlzLnZhbGlkUmVjdCkgJiYgY2FjaGVkLnZhbGlkUmVjdC5jb250YWluc1JlY3QoY2FjaGVkLmxheW91dEluZm8ucmVjdC5pbnRlcnNlY3Rpb24odGhpcy5yZXF1ZXN0ZWRSZWN0KSk7XG4gICAgfVxuICAgIGJ1aWxkQ2hpbGQobm9kZSwgeCwgeSwgcGFyZW50S2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQobm9kZSwgeSkpIHJldHVybiB0aGlzLmxheW91dE5vZGVzLmdldChub2RlLmtleSk7XG4gICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZE5vZGUobm9kZSwgeCwgeSk7XG4gICAgICAgIGxheW91dE5vZGUubGF5b3V0SW5mby5wYXJlbnRLZXkgPSBwYXJlbnRLZXkgIT09IG51bGwgJiYgcGFyZW50S2V5ICE9PSB2b2lkIDAgPyBwYXJlbnRLZXkgOiBudWxsO1xuICAgICAgICB0aGlzLmxheW91dE5vZGVzLnNldChub2RlLmtleSwgbGF5b3V0Tm9kZSk7XG4gICAgICAgIHJldHVybiBsYXlvdXROb2RlO1xuICAgIH1cbiAgICBidWlsZE5vZGUobm9kZSwgeCwgeSkge1xuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkU2VjdGlvbihub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkSXRlbShub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTZWN0aW9uSGVhZGVyKG5vZGUsIHgsIHkpO1xuICAgICAgICAgICAgY2FzZSAnbG9hZGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZExvYWRlcihub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBub2RlIHR5cGU6ICcgKyBub2RlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkTG9hZGVyKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KSh4LCB5LCB0aGlzLnBhZGRpbmcsIDApO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGltZzI2JExheW91dEluZm8pKCdsb2FkZXInLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIHJlY3Qud2lkdGggPSB0aGlzLnZpcnR1YWxpemVyLmNvbnRlbnRTaXplLndpZHRoIC0gdGhpcy5wYWRkaW5nIC0geDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSB0aGlzLmxvYWRlckhlaWdodCB8fCB0aGlzLnJvd0hlaWdodCB8fCB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCB8fCAkNjFlZjYwZmM5YjEwNDFmNCR2YXIkREVGQVVMVF9IRUlHSFQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiByZWN0LmludGVyc2VjdGlvbih0aGlzLnJlcXVlc3RlZFJlY3QpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkU2VjdGlvbihub2RlLCB4LCB5KSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoIC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGltZzI2JFJlY3QpKHgsIHksIHdpZHRoIC0geCwgMCk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkaW1nMjYkTGF5b3V0SW5mbykobm9kZS50eXBlLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIGxldCBzdGFydFkgPSB5O1xuICAgICAgICBsZXQgc2tpcHBlZCA9IDA7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiAoMCwgJGltZzI2JGdldENoaWxkTm9kZXMpKG5vZGUsIGNvbGxlY3Rpb24pKXtcbiAgICAgICAgICAgIHZhciBfdGhpc19yb3dIZWlnaHQsIF9yZWY7XG4gICAgICAgICAgICBsZXQgcm93SGVpZ2h0ID0gKChfcmVmID0gKF90aGlzX3Jvd0hlaWdodCA9IHRoaXMucm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpc19yb3dIZWlnaHQgIT09IHZvaWQgMCA/IF90aGlzX3Jvd0hlaWdodCA6IHRoaXMuZXN0aW1hdGVkUm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogJDYxZWY2MGZjOWIxMDQxZjQkdmFyJERFRkFVTFRfSEVJR0hUKSArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJlZm9yZSB0aGUgdmFsaWQgcmVjdGFuZ2xlIHVubGVzcyB0aGV5IGFyZSBhbHJlYWR5IGNhY2hlZC5cbiAgICAgICAgICAgIGlmICh5ICsgcm93SGVpZ2h0IDwgdGhpcy5yZXF1ZXN0ZWRSZWN0LnkgJiYgIXRoaXMuaXNWYWxpZChub2RlLCB5KSkge1xuICAgICAgICAgICAgICAgIHkgKz0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZENoaWxkKGNoaWxkLCB4LCB5LCBsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICB5ID0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QubWF4WSArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsYXlvdXROb2RlKTtcbiAgICAgICAgICAgIGlmICh5ID4gdGhpcy5yZXF1ZXN0ZWRSZWN0Lm1heFkpIHtcbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSB0aGUgcmVtYWluaW5nIGhlaWdodCBmb3Igcm93cyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbGF5b3V0IHJpZ2h0IG5vdy5cbiAgICAgICAgICAgICAgICB5ICs9IChbXG4gICAgICAgICAgICAgICAgICAgIC4uLigwLCAkaW1nMjYkZ2V0Q2hpbGROb2Rlcykobm9kZSwgY29sbGVjdGlvbilcbiAgICAgICAgICAgICAgICBdLmxlbmd0aCAtIChjaGlsZHJlbi5sZW5ndGggKyBza2lwcGVkKSkgKiByb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeSAtPSB0aGlzLmdhcDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSB5IC0gc3RhcnRZO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgIHZhbGlkUmVjdDogbGF5b3V0SW5mby5yZWN0LmludGVyc2VjdGlvbih0aGlzLnJlcXVlc3RlZFJlY3QpLFxuICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZFNlY3Rpb25IZWFkZXIobm9kZSwgeCwgeSkge1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoIC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBsZXQgcmVjdEhlaWdodCA9IHRoaXMuaGVhZGluZ0hlaWdodDtcbiAgICAgICAgbGV0IGlzRXN0aW1hdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGhlaWdodCBpcyBhdmFpbGFibGUsIHVzZSBhbiBlc3RpbWF0ZWQgaGVpZ2h0LlxuICAgICAgICBpZiAocmVjdEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBsYXlvdXQgaW5mbyBleGlzdHMsIHJldXNlIGl0cyBoZWlnaHQuXG4gICAgICAgICAgICAvLyBNYXJrIGFzIGVzdGltYXRlZCBpZiB0aGUgc2l6ZSBvZiB0aGUgb3ZlcmFsbCB2aXJ0dWFsaXplciBjaGFuZ2VkLFxuICAgICAgICAgICAgLy8gb3IgdGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0gY2hhbmdlZC5cbiAgICAgICAgICAgIGxldCBwcmV2aW91c0xheW91dE5vZGUgPSB0aGlzLmxheW91dE5vZGVzLmdldChub2RlLmtleSk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNMYXlvdXRJbmZvID0gcHJldmlvdXNMYXlvdXROb2RlID09PSBudWxsIHx8IHByZXZpb3VzTGF5b3V0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm87XG4gICAgICAgICAgICBpZiAocHJldmlvdXNMYXlvdXRJbmZvKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1ck5vZGUgPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb24uZ2V0SXRlbShub2RlLmtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3ROb2RlID0gdGhpcy5sYXN0Q29sbGVjdGlvbiA/IHRoaXMubGFzdENvbGxlY3Rpb24uZ2V0SXRlbShub2RlLmtleSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHJlY3RIZWlnaHQgPSBwcmV2aW91c0xheW91dEluZm8ucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSB3aWR0aCAhPT0gcHJldmlvdXNMYXlvdXRJbmZvLnJlY3Qud2lkdGggfHwgY3VyTm9kZSAhPT0gbGFzdE5vZGUgfHwgcHJldmlvdXNMYXlvdXRJbmZvLmVzdGltYXRlZFNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY3RIZWlnaHQgPSBub2RlLnJlbmRlcmVkID8gdGhpcy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpc0VzdGltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY3RIZWlnaHQgPT0gbnVsbCkgcmVjdEhlaWdodCA9ICQ2MWVmNjBmYzliMTA0MWY0JHZhciRERUZBVUxUX0hFSUdIVDtcbiAgICAgICAgbGV0IGhlYWRlclJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KSh4LCB5LCB3aWR0aCAtIHgsIHJlY3RIZWlnaHQpO1xuICAgICAgICBsZXQgaGVhZGVyID0gbmV3ICgwLCAkaW1nMjYkTGF5b3V0SW5mbykoJ2hlYWRlcicsIG5vZGUua2V5LCBoZWFkZXJSZWN0KTtcbiAgICAgICAgaGVhZGVyLmVzdGltYXRlZFNpemUgPSBpc0VzdGltYXRlZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGhlYWRlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHZhbGlkUmVjdDogaGVhZGVyLnJlY3QuaW50ZXJzZWN0aW9uKHRoaXMucmVxdWVzdGVkUmVjdCksXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkSXRlbShub2RlLCB4LCB5KSB7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGggLSB0aGlzLnBhZGRpbmcgLSB4O1xuICAgICAgICBsZXQgcmVjdEhlaWdodCA9IHRoaXMucm93SGVpZ2h0O1xuICAgICAgICBsZXQgaXNFc3RpbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgaGVpZ2h0IGlzIGF2YWlsYWJsZSwgdXNlIGFuIGVzdGltYXRlZCBoZWlnaHQuXG4gICAgICAgIGlmIChyZWN0SGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIGxheW91dCBpbmZvIGV4aXN0cywgcmV1c2UgaXRzIGhlaWdodC5cbiAgICAgICAgICAgIC8vIE1hcmsgYXMgZXN0aW1hdGVkIGlmIHRoZSBzaXplIG9mIHRoZSBvdmVyYWxsIHZpcnR1YWxpemVyIGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBvciB0aGUgY29udGVudCBvZiB0aGUgaXRlbSBjaGFuZ2VkLlxuICAgICAgICAgICAgbGV0IHByZXZpb3VzTGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xheW91dE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZWN0SGVpZ2h0ID0gcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSB3aWR0aCAhPT0gcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC53aWR0aCB8fCBub2RlICE9PSBwcmV2aW91c0xheW91dE5vZGUubm9kZSB8fCBwcmV2aW91c0xheW91dE5vZGUubGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWN0SGVpZ2h0ID0gdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN0SGVpZ2h0ID09IG51bGwpIHJlY3RIZWlnaHQgPSAkNjFlZjYwZmM5YjEwNDFmNCR2YXIkREVGQVVMVF9IRUlHSFQ7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkoeCwgeSwgd2lkdGgsIHJlY3RIZWlnaHQpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGltZzI2JExheW91dEluZm8pKG5vZGUudHlwZSwgbm9kZS5rZXksIHJlY3QpO1xuICAgICAgICBsYXlvdXRJbmZvLmVzdGltYXRlZFNpemUgPSBpc0VzdGltYXRlZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IGxheW91dEluZm8ucmVjdCxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKSB7XG4gICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQoa2V5KTtcbiAgICAgICAgLy8gSWYgbm8gbGF5b3V0SW5mbywgaXRlbSBoYXMgYmVlbiBkZWxldGVkL3JlbW92ZWQuXG4gICAgICAgIGlmICghbGF5b3V0Tm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSBsYXlvdXROb2RlLmxheW91dEluZm87XG4gICAgICAgIGxheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICBpZiAobGF5b3V0SW5mby5yZWN0LmhlaWdodCAhPT0gc2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbGF5b3V0IGluZm8gcmF0aGVyIHRoYW4gbXV0YXRpbmcgc28gdGhhdCBsYXRlciBjYWNoZXMgYXJlIGludmFsaWRhdGVkLlxuICAgICAgICAgICAgbGV0IG5ld0xheW91dEluZm8gPSBsYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIG5ld0xheW91dEluZm8ucmVjdC5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIGxheW91dE5vZGUubGF5b3V0SW5mbyA9IG5ld0xheW91dEluZm87XG4gICAgICAgICAgICAvLyBJdGVtcyBhZnRlciB0aGlzIGxheW91dEluZm8gd2lsbCBuZWVkIHRvIGJlIHJlcG9zaXRpb25lZCB0byBhY2NvdW50IGZvciB0aGUgbmV3IGhlaWdodC5cbiAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgdmFsaWRSZWN0IHNvIHRoYXQgb25seSBpdGVtcyBhYm92ZSByZW1haW4gdmFsaWQuXG4gICAgICAgICAgICB0aGlzLnZhbGlkUmVjdC5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLnZhbGlkUmVjdC5oZWlnaHQsIGxheW91dEluZm8ucmVjdC55IC0gdGhpcy52YWxpZFJlY3QueSk7XG4gICAgICAgICAgICAvLyBUaGUgcmVxdWVzdGVkUmVjdCBhbHNvIG5lZWRzIHRvIGJlIGFkanVzdGVkIHRvIGFjY291bnQgZm9yIHRoZSBoZWlnaHQgZGlmZmVyZW5jZS5cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVkUmVjdC5oZWlnaHQgKz0gbmV3TGF5b3V0SW5mby5yZWN0LmhlaWdodCAtIGxheW91dEluZm8ucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGxheW91dCBmb3IgdGhpcyBsYXlvdXQgbm9kZSBhbmQgYWxsIHBhcmVudHNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGF5b3V0Tm9kZShrZXksIGxheW91dEluZm8sIG5ld0xheW91dEluZm8pO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsYXlvdXRJbmZvLnBhcmVudEtleSAhPSBudWxsID8gY29sbGVjdGlvbi5nZXRJdGVtKGxheW91dEluZm8ucGFyZW50S2V5KSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZShub2RlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxheW91dE5vZGUobm9kZS5rZXksIGxheW91dEluZm8sIG5ld0xheW91dEluZm8pO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEtleSAhPSBudWxsID8gY29sbGVjdGlvbi5nZXRJdGVtKG5vZGUucGFyZW50S2V5KSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZUxheW91dE5vZGUoa2V5LCBvbGRMYXlvdXRJbmZvLCBuZXdMYXlvdXRJbmZvKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgYnkgaW50ZXJzZWN0aW5nIHRoZSB2YWxpZFJlY3Qgb2YgdGhpcyBub2RlIHdpdGggdGhlIG92ZXJhbGwgdmFsaWRSZWN0LlxuICAgICAgICAgICAgbi52YWxpZFJlY3QgPSBuLnZhbGlkUmVjdC5pbnRlcnNlY3Rpb24odGhpcy52YWxpZFJlY3QpO1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBsYXlvdXQgaW5mbyBpbiBMYXlvdXROb2RlXG4gICAgICAgICAgICBpZiAobi5sYXlvdXRJbmZvID09PSBvbGRMYXlvdXRJbmZvKSBuLmxheW91dEluZm8gPSBuZXdMYXlvdXRJbmZvO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2l6ZTtcbiAgICB9XG4gICAgZ2V0RHJvcFRhcmdldEZyb21Qb2ludCh4LCB5LCBpc1ZhbGlkRHJvcFRhcmdldCkge1xuICAgICAgICB4ICs9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QueDtcbiAgICAgICAgeSArPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lnk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaXRlbSB3aXRoaW4gb24gZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW50IHVzaW5nIHRoZSBnYXAgd2lkdGguXG4gICAgICAgIGxldCBzZWFyY2hSZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkoeCwgTWF0aC5tYXgoMCwgeSAtIHRoaXMuZ2FwKSwgMSwgdGhpcy5nYXAgKiAyKTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSB0aGlzLmdldFZpc2libGVMYXlvdXRJbmZvcyhzZWFyY2hSZWN0KTtcbiAgICAgICAgbGV0IGtleSA9IG51bGw7XG4gICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcyl7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaXRlbXMgb3V0c2lkZSB0aGUgc2VhcmNoIHJlY3QsIGUuZy4gcGVyc2lzdGVkIGtleXMuXG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZS5yZWN0LmludGVyc2VjdHMoc2VhcmNoUmVjdCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHlEaXN0ID0gTWF0aC5hYnMoY2FuZGlkYXRlLnJlY3QueSAtIHkpO1xuICAgICAgICAgICAgbGV0IG1heFlEaXN0ID0gTWF0aC5hYnMoY2FuZGlkYXRlLnJlY3QubWF4WSAtIHkpO1xuICAgICAgICAgICAgbGV0IGRpc3QgPSBNYXRoLm1pbih5RGlzdCwgbWF4WURpc3QpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGUua2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb24uc2l6ZSA9PT0gMCkgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdyb290J1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICBpZiAoIWxheW91dEluZm8pIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdCA9IGxheW91dEluZm8ucmVjdDtcbiAgICAgICAgbGV0IHRhcmdldCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdpdGVtJyxcbiAgICAgICAgICAgIGtleTogbGF5b3V0SW5mby5rZXksXG4gICAgICAgICAgICBkcm9wUG9zaXRpb246ICdvbidcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgZHJvcHBpbmcgb24gdGhlIGl0ZW0gaXNuJ3QgYWNjZXB0ZWQsIHRyeSB0aGUgdGFyZ2V0IGJlZm9yZSBvciBhZnRlciBkZXBlbmRpbmcgb24gdGhlIHkgcG9zaXRpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgZHJvcHBpbmcgb24gdGhlIGl0ZW0gaXMgYWNjZXB0ZWQsIHN0aWxsIHRyeSB0aGUgYmVmb3JlL2FmdGVyIHBvc2l0aW9ucyBpZiB3aXRoaW4gMTBweFxuICAgICAgICAvLyBvZiB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgaXRlbS5cbiAgICAgICAgaWYgKCFpc1ZhbGlkRHJvcFRhcmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBpZiAoeSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDIgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICBkcm9wUG9zaXRpb246ICdiZWZvcmUnXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9ICdiZWZvcmUnO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICBkcm9wUG9zaXRpb246ICdhZnRlcidcbiAgICAgICAgICAgIH0pKSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgfSBlbHNlIGlmICh5IDw9IHJlY3QueSArIDEwICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ2JlZm9yZSdcbiAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYmVmb3JlJztcbiAgICAgICAgZWxzZSBpZiAoeSA+PSByZWN0Lm1heFkgLSAxMCAmJiBpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICBkcm9wUG9zaXRpb246ICdhZnRlcidcbiAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYWZ0ZXInO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBnZXREcm9wVGFyZ2V0TGF5b3V0SW5mbyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8odGFyZ2V0LmtleSk7XG4gICAgICAgIGxldCByZWN0O1xuICAgICAgICBpZiAodGFyZ2V0LmRyb3BQb3NpdGlvbiA9PT0gJ2JlZm9yZScpIHJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KShsYXlvdXRJbmZvLnJlY3QueCwgbGF5b3V0SW5mby5yZWN0LnkgLSB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgLyAyLCBsYXlvdXRJbmZvLnJlY3Qud2lkdGgsIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyk7XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldC5kcm9wUG9zaXRpb24gPT09ICdhZnRlcicpIHJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KShsYXlvdXRJbmZvLnJlY3QueCwgbGF5b3V0SW5mby5yZWN0Lm1heFkgLSB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgLyAyLCBsYXlvdXRJbmZvLnJlY3Qud2lkdGgsIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyk7XG4gICAgICAgIGVsc2UgcmVjdCA9IGxheW91dEluZm8ucmVjdDtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGltZzI2JExheW91dEluZm8pKCdkcm9wSW5kaWNhdG9yJywgdGFyZ2V0LmtleSArICc6JyArIHRhcmdldC5kcm9wUG9zaXRpb24sIHJlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBMaXN0TGF5b3V0IHdpdGggb3B0aW9ucy4gU2VlIHRoZSBsaXN0IG9mIHByb3BlcnRpZXMgYmVsb3cgZm9yIGEgZGVzY3JpcHRpb25cbiAgICogb2YgdGhlIG9wdGlvbnMgdGhhdCBjYW4gYmUgcHJvdmlkZWQuXG4gICAqLyBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB2YXIgX29wdGlvbnNfcm93SGVpZ2h0O1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IChfb3B0aW9uc19yb3dIZWlnaHQgPSBvcHRpb25zLnJvd0hlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfcm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19yb3dIZWlnaHQgOiBudWxsO1xuICAgICAgICB2YXIgX29wdGlvbnNfZXN0aW1hdGVkUm93SGVpZ2h0O1xuICAgICAgICB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCA9IChfb3B0aW9uc19lc3RpbWF0ZWRSb3dIZWlnaHQgPSBvcHRpb25zLmVzdGltYXRlZFJvd0hlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfZXN0aW1hdGVkUm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19lc3RpbWF0ZWRSb3dIZWlnaHQgOiBudWxsO1xuICAgICAgICB2YXIgX29wdGlvbnNfaGVhZGluZ0hlaWdodDtcbiAgICAgICAgdGhpcy5oZWFkaW5nSGVpZ2h0ID0gKF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgPSBvcHRpb25zLmhlYWRpbmdIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgOiBudWxsO1xuICAgICAgICB2YXIgX29wdGlvbnNfZXN0aW1hdGVkSGVhZGluZ0hlaWdodDtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ID0gKF9vcHRpb25zX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgPSBvcHRpb25zLmVzdGltYXRlZEhlYWRpbmdIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgOiBudWxsO1xuICAgICAgICB2YXIgX29wdGlvbnNfbG9hZGVySGVpZ2h0O1xuICAgICAgICB0aGlzLmxvYWRlckhlaWdodCA9IChfb3B0aW9uc19sb2FkZXJIZWlnaHQgPSBvcHRpb25zLmxvYWRlckhlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfbG9hZGVySGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19sb2FkZXJIZWlnaHQgOiBudWxsO1xuICAgICAgICB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgPSBvcHRpb25zLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgfHwgMjtcbiAgICAgICAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgfHwgMDtcbiAgICAgICAgdGhpcy5sYXlvdXROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yb290Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0Q29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUV2ZXJ5dGhpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWxpZFJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KSgpO1xuICAgICAgICB0aGlzLnJlcXVlc3RlZFJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KSgpO1xuICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gbmV3ICgwLCAkaW1nMjYkU2l6ZSkoKTtcbiAgICB9XG59XG5cblxuZXhwb3J0IHskNjFlZjYwZmM5YjEwNDFmNCRleHBvcnQkY2FjYmIzOTI0MTU1ZDY4ZSBhcyBMaXN0TGF5b3V0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3RMYXlvdXQubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs\n");

/***/ }),

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs":
/*!**********************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs ***!
  \**********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableLayout: () => (/* binding */ $a152112e902709bf$export$62444c3c724b1b20)\n/* harmony export */ });\n/* harmony import */ var _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ListLayout.mjs */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+collections@3.12.2_react@19.0.0/node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/virtualizer */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n/* harmony import */ var _react_stately_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/table */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+table@3.14.0_react@19.0.0/node_modules/@react-stately/table/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\nconst $a152112e902709bf$var$DEFAULT_ROW_HEIGHT = 48;\nclass $a152112e902709bf$export$62444c3c724b1b20 extends (0, _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_0__.ListLayout) {\n    // Backward compatibility for subclassing.\n    get collection() {\n        return this.virtualizer.collection;\n    }\n    columnsChanged(newCollection, oldCollection) {\n        return !oldCollection || newCollection.columns !== oldCollection.columns && newCollection.columns.length !== oldCollection.columns.length || newCollection.columns.some((c, i)=>c.key !== oldCollection.columns[i].key || c.props.width !== oldCollection.columns[i].props.width || c.props.minWidth !== oldCollection.columns[i].props.minWidth || c.props.maxWidth !== oldCollection.columns[i].props.maxWidth);\n    }\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.columnWidths !== oldOptions.columnWidths || super.shouldInvalidateLayoutOptions(newOptions, oldOptions);\n    }\n    update(invalidationContext) {\n        var _invalidationContext_layoutOptions;\n        let newCollection = this.virtualizer.collection;\n        // If columnWidths were provided via layoutOptions, update those.\n        // Otherwise, calculate column widths ourselves.\n        if ((_invalidationContext_layoutOptions = invalidationContext.layoutOptions) === null || _invalidationContext_layoutOptions === void 0 ? void 0 : _invalidationContext_layoutOptions.columnWidths) {\n            if (invalidationContext.layoutOptions.columnWidths !== this.columnWidths) {\n                this.columnWidths = invalidationContext.layoutOptions.columnWidths;\n                invalidationContext.sizeChanged = true;\n            }\n        } else if (invalidationContext.sizeChanged || this.columnsChanged(newCollection, this.lastCollection)) {\n            let columnLayout = new (0, _react_stately_table__WEBPACK_IMPORTED_MODULE_1__.TableColumnLayout)({});\n            this.columnWidths = columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width - this.padding * 2, newCollection, new Map());\n            invalidationContext.sizeChanged = true;\n        }\n        super.update(invalidationContext);\n    }\n    buildCollection() {\n        this.stickyColumnIndices = [];\n        let collection = this.virtualizer.collection;\n        for (let column of collection.columns)// The selection cell and any other sticky columns always need to be visible.\n        // In addition, row headers need to be in the DOM for accessibility labeling.\n        if (this.isStickyColumn(column) || collection.rowHeaderColumnKeys.has(column.key)) this.stickyColumnIndices.push(column.index);\n        let header = this.buildTableHeader();\n        this.layoutNodes.set(header.layoutInfo.key, header);\n        let body = this.buildBody(header.layoutInfo.rect.maxY + this.gap);\n        this.lastPersistedKeys = null;\n        body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Size)(body.layoutInfo.rect.width + this.padding * 2, body.layoutInfo.rect.maxY + this.padding);\n        return [\n            header,\n            body\n        ];\n    }\n    buildTableHeader() {\n        var _collection_head;\n        let collection = this.virtualizer.collection;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(this.padding, this.padding, 0, 0);\n        var _collection_head_key;\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('header', (_collection_head_key = (_collection_head = collection.head) === null || _collection_head === void 0 ? void 0 : _collection_head.key) !== null && _collection_head_key !== void 0 ? _collection_head_key : 'header', rect);\n        layoutInfo.isSticky = true;\n        layoutInfo.zIndex = 1;\n        let y = this.padding;\n        let width = 0;\n        let children = [];\n        for (let headerRow of collection.headerRows){\n            let layoutNode = this.buildChild(headerRow, this.padding, y, layoutInfo.key);\n            layoutNode.layoutInfo.parentKey = layoutInfo.key;\n            y = layoutNode.layoutInfo.rect.maxY;\n            width = Math.max(width, layoutNode.layoutInfo.rect.width);\n            layoutNode.index = children.length;\n            children.push(layoutNode);\n        }\n        rect.width = width;\n        rect.height = y - this.padding;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect,\n            node: collection.head\n        };\n    }\n    buildHeaderRow(headerRow, x, y) {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, 0, 0);\n        let row = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('headerrow', headerRow.key, rect);\n        let height = 0;\n        let columns = [];\n        for (let cell of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.getChildNodes)(headerRow, this.virtualizer.collection)){\n            let layoutNode = this.buildChild(cell, x, y, row.key);\n            layoutNode.layoutInfo.parentKey = row.key;\n            x = layoutNode.layoutInfo.rect.maxX;\n            height = Math.max(height, layoutNode.layoutInfo.rect.height);\n            layoutNode.index = columns.length;\n            columns.push(layoutNode);\n        }\n        for (let [i, layout] of columns.entries())layout.layoutInfo.zIndex = columns.length - i + 1;\n        this.setChildHeights(columns, height);\n        rect.height = height;\n        rect.width = x - rect.x;\n        return {\n            layoutInfo: row,\n            children: columns,\n            validRect: rect,\n            node: headerRow\n        };\n    }\n    setChildHeights(children, height) {\n        for (let child of children)if (child.layoutInfo.rect.height !== height) {\n            // Need to copy the layout info before we mutate it.\n            child.layoutInfo = child.layoutInfo.copy();\n            child.layoutInfo.rect.height = height;\n        }\n    }\n    // used to get the column widths when rendering to the DOM\n    getRenderedColumnWidth(node) {\n        let collection = this.virtualizer.collection;\n        var _node_colSpan;\n        let colSpan = (_node_colSpan = node.colSpan) !== null && _node_colSpan !== void 0 ? _node_colSpan : 1;\n        var _node_colIndex;\n        let colIndex = (_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index;\n        let width = 0;\n        for(let i = colIndex; i < colIndex + colSpan; i++){\n            let column = collection.columns[i];\n            var _this_columnWidths_get;\n            if ((column === null || column === void 0 ? void 0 : column.key) != null) width += (_this_columnWidths_get = this.columnWidths.get(column.key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n        }\n        return width;\n    }\n    getEstimatedHeight(node, width, height, estimatedHeight) {\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (height == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall collection view changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            if (previousLayoutNode) {\n                height = previousLayoutNode.layoutInfo.rect.height;\n                isEstimated = node !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n            } else {\n                height = estimatedHeight !== null && estimatedHeight !== void 0 ? estimatedHeight : $a152112e902709bf$var$DEFAULT_ROW_HEIGHT;\n                isEstimated = true;\n            }\n        }\n        return {\n            height: height,\n            isEstimated: isEstimated\n        };\n    }\n    getEstimatedRowHeight() {\n        var _this_rowHeight, _ref;\n        return (_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $a152112e902709bf$var$DEFAULT_ROW_HEIGHT;\n    }\n    buildColumn(node, x, y) {\n        let width = this.getRenderedColumnWidth(node);\n        var _this_headingHeight, _this_estimatedHeadingHeight;\n        let { height: height, isEstimated: isEstimated } = this.getEstimatedHeight(node, width, (_this_headingHeight = this.headingHeight) !== null && _this_headingHeight !== void 0 ? _this_headingHeight : this.rowHeight, (_this_estimatedHeadingHeight = this.estimatedHeadingHeight) !== null && _this_estimatedHeadingHeight !== void 0 ? _this_estimatedHeadingHeight : this.estimatedRowHeight);\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, width, height);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.isSticky = this.isStickyColumn(node);\n        layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            children: [],\n            validRect: layoutInfo.rect,\n            node: node\n        };\n    }\n    // For subclasses.\n    // eslint-disable-next-line\n    isStickyColumn(node) {\n        return false;\n    }\n    buildBody(y) {\n        let collection = this.virtualizer.collection;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(this.padding, y, 0, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('rowgroup', collection.body.key, rect);\n        let startY = y;\n        let skipped = 0;\n        let width = 0;\n        let children = [];\n        let rowHeight = this.getEstimatedRowHeight() + this.gap;\n        for (let node of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.getChildNodes)(collection.body, collection)){\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(node, this.padding, y, layoutInfo.key);\n            layoutNode.layoutInfo.parentKey = layoutInfo.key;\n            layoutNode.index = children.length;\n            y = layoutNode.layoutInfo.rect.maxY + this.gap;\n            width = Math.max(width, layoutNode.layoutInfo.rect.width);\n            children.push(layoutNode);\n            if (y > this.requestedRect.maxY) {\n                // Estimate the remaining height for rows that we don't need to layout right now.\n                y += (collection.size - (skipped + children.length)) * rowHeight;\n                break;\n            }\n        }\n        if (children.length === 0) y = this.virtualizer.visibleRect.maxY;\n        else y -= this.gap;\n        rect.width = width;\n        rect.height = y - startY;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect.intersection(this.requestedRect),\n            node: collection.body\n        };\n    }\n    buildNode(node, x, y) {\n        switch(node.type){\n            case 'headerrow':\n                return this.buildHeaderRow(node, x, y);\n            case 'item':\n                return this.buildRow(node, x, y);\n            case 'column':\n            case 'placeholder':\n                return this.buildColumn(node, x, y);\n            case 'cell':\n                return this.buildCell(node, x, y);\n            case 'loader':\n                return this.buildLoader(node, x, y);\n            default:\n                throw new Error('Unknown node type ' + node.type);\n        }\n    }\n    buildRow(node, x, y) {\n        var _collection_head;\n        let collection = this.virtualizer.collection;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, 0, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('row', node.key, rect);\n        let children = [];\n        let height = 0;\n        for (let child of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.getChildNodes)(node, collection))if (child.type === 'cell') {\n            if (x > this.requestedRect.maxX) {\n                // Adjust existing cached layoutInfo to ensure that it is out of view.\n                // This can happen due to column resizing.\n                let layoutNode = this.layoutNodes.get(child.key);\n                if (layoutNode) {\n                    layoutNode.layoutInfo.rect.x = x;\n                    x += layoutNode.layoutInfo.rect.width;\n                } else break;\n            } else {\n                let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n                x = layoutNode.layoutInfo.rect.maxX;\n                height = Math.max(height, layoutNode.layoutInfo.rect.height);\n                layoutNode.index = children.length;\n                children.push(layoutNode);\n            }\n        }\n        this.setChildHeights(children, height);\n        var _collection_head_key;\n        rect.width = this.layoutNodes.get((_collection_head_key = (_collection_head = collection.head) === null || _collection_head === void 0 ? void 0 : _collection_head.key) !== null && _collection_head_key !== void 0 ? _collection_head_key : 'header').layoutInfo.rect.width;\n        rect.height = height;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: rect.intersection(this.requestedRect),\n            node: node\n        };\n    }\n    buildCell(node, x, y) {\n        let width = this.getRenderedColumnWidth(node);\n        let { height: height, isEstimated: isEstimated } = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, width, height);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.isSticky = this.isStickyColumn(node);\n        layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            children: [],\n            validRect: rect,\n            node: node\n        };\n    }\n    getVisibleLayoutInfos(rect) {\n        // Adjust rect to keep number of visible rows consistent.\n        // (only if height > 1 for getDropTargetFromPoint)\n        if (rect.height > 1) {\n            let rowHeight = this.getEstimatedRowHeight();\n            rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n            rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n        }\n        // If layout hasn't yet been done for the requested rect, union the\n        // new rect with the existing valid rect, and recompute.\n        this.layoutIfNeeded(rect);\n        let res = [];\n        this.buildPersistedIndices();\n        for (let node of this.rootNodes){\n            res.push(node.layoutInfo);\n            this.addVisibleLayoutInfos(res, node, rect);\n        }\n        return res;\n    }\n    addVisibleLayoutInfos(res, node, rect) {\n        if (!node.children || node.children.length === 0) return;\n        switch(node.layoutInfo.type){\n            case 'header':\n                for (let child of node.children){\n                    res.push(child.layoutInfo);\n                    this.addVisibleLayoutInfos(res, child, rect);\n                }\n                break;\n            case 'rowgroup':\n                {\n                    let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n                    let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n                    // Add persisted rows before the visible rows.\n                    let persistedRowIndices = this.persistedIndices.get(node.layoutInfo.key);\n                    let persistIndex = 0;\n                    while(persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < firstVisibleRow){\n                        let idx = persistedRowIndices[persistIndex];\n                        if (idx < node.children.length) {\n                            res.push(node.children[idx].layoutInfo);\n                            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n                        }\n                        persistIndex++;\n                    }\n                    for(let i = firstVisibleRow; i <= lastVisibleRow; i++){\n                        // Skip persisted rows that overlap with visible cells.\n                        while(persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i)persistIndex++;\n                        res.push(node.children[i].layoutInfo);\n                        this.addVisibleLayoutInfos(res, node.children[i], rect);\n                    }\n                    // Add persisted rows after the visible rows.\n                    while(persistedRowIndices && persistIndex < persistedRowIndices.length){\n                        let idx = persistedRowIndices[persistIndex++];\n                        if (idx < node.children.length) {\n                            res.push(node.children[idx].layoutInfo);\n                            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n                        }\n                    }\n                    break;\n                }\n            case 'headerrow':\n            case 'row':\n                {\n                    let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n                    let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n                    let stickyIndex = 0;\n                    // Add persisted/sticky cells before the visible cells.\n                    let persistedCellIndices = this.persistedIndices.get(node.layoutInfo.key) || this.stickyColumnIndices;\n                    while(stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell){\n                        let idx = persistedCellIndices[stickyIndex];\n                        if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n                        stickyIndex++;\n                    }\n                    for(let i = firstVisibleCell; i <= lastVisibleCell; i++){\n                        // Skip sticky cells that overlap with visible cells.\n                        while(stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i)stickyIndex++;\n                        res.push(node.children[i].layoutInfo);\n                    }\n                    // Add any remaining sticky cells after the visible cells.\n                    while(stickyIndex < persistedCellIndices.length){\n                        let idx = persistedCellIndices[stickyIndex++];\n                        if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n                    }\n                    break;\n                }\n            default:\n                throw new Error('Unknown node type ' + node.layoutInfo.type);\n        }\n    }\n    binarySearch(items, point, axis) {\n        let low = 0;\n        let high = items.length - 1;\n        while(low <= high){\n            let mid = low + high >> 1;\n            let item = items[mid];\n            if (axis === 'x' && item.layoutInfo.rect.maxX <= point.x || axis === 'y' && item.layoutInfo.rect.maxY <= point.y) low = mid + 1;\n            else if (axis === 'x' && item.layoutInfo.rect.x > point.x || axis === 'y' && item.layoutInfo.rect.y > point.y) high = mid - 1;\n            else return mid;\n        }\n        return Math.max(0, Math.min(items.length - 1, low));\n    }\n    buildPersistedIndices() {\n        if (this.virtualizer.persistedKeys === this.lastPersistedKeys) return;\n        this.lastPersistedKeys = this.virtualizer.persistedKeys;\n        this.persistedIndices.clear();\n        // Build a map of parentKey => indices of children to persist.\n        for (let key of this.virtualizer.persistedKeys){\n            var _this_layoutNodes_get;\n            let layoutInfo = (_this_layoutNodes_get = this.layoutNodes.get(key)) === null || _this_layoutNodes_get === void 0 ? void 0 : _this_layoutNodes_get.layoutInfo;\n            // Walk up ancestors so parents are also persisted if children are.\n            while(layoutInfo && layoutInfo.parentKey){\n                var _this_layoutNodes_get1, _this_layoutNodes_get2;\n                let collectionNode = this.virtualizer.collection.getItem(layoutInfo.key);\n                let indices = this.persistedIndices.get(layoutInfo.parentKey);\n                if (!indices) {\n                    // stickyColumnIndices are always persisted along with any cells from persistedKeys.\n                    indices = (collectionNode === null || collectionNode === void 0 ? void 0 : collectionNode.type) === 'cell' || (collectionNode === null || collectionNode === void 0 ? void 0 : collectionNode.type) === 'column' ? [\n                        ...this.stickyColumnIndices\n                    ] : [];\n                    this.persistedIndices.set(layoutInfo.parentKey, indices);\n                }\n                let index = (_this_layoutNodes_get1 = this.layoutNodes.get(layoutInfo.key)) === null || _this_layoutNodes_get1 === void 0 ? void 0 : _this_layoutNodes_get1.index;\n                if (index != null && !indices.includes(index)) indices.push(index);\n                layoutInfo = (_this_layoutNodes_get2 = this.layoutNodes.get(layoutInfo.parentKey)) === null || _this_layoutNodes_get2 === void 0 ? void 0 : _this_layoutNodes_get2.layoutInfo;\n            }\n        }\n        for (let indices of this.persistedIndices.values())indices.sort((a, b)=>a - b);\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        // Find the closest item within on either side of the point using the gap width.\n        let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, Math.max(0, y - this.gap), 1, this.gap * 2);\n        let candidates = this.getVisibleLayoutInfos(searchRect);\n        let key = null;\n        let minDistance = Infinity;\n        for (let candidate of candidates){\n            // Ignore items outside the search rect, e.g. persisted keys.\n            if (candidate.type !== 'row' || !candidate.rect.intersects(searchRect)) continue;\n            let yDist = Math.abs(candidate.rect.y - y);\n            let maxYDist = Math.abs(candidate.rect.maxY - y);\n            let dist = Math.min(yDist, maxYDist);\n            if (dist < minDistance) {\n                minDistance = dist;\n                key = candidate.key;\n            }\n        }\n        if (key == null || this.virtualizer.collection.size === 0) return {\n            type: 'root'\n        };\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = layoutInfo.rect;\n        let target = {\n            type: 'item',\n            key: layoutInfo.key,\n            dropPosition: 'on'\n        };\n        // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n        // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n        // of the top or bottom of the item.\n        if (!isValidDropTarget(target)) {\n            if (y <= rect.y + rect.height / 2 && isValidDropTarget({\n                ...target,\n                dropPosition: 'before'\n            })) target.dropPosition = 'before';\n            else if (isValidDropTarget({\n                ...target,\n                dropPosition: 'after'\n            })) target.dropPosition = 'after';\n        } else if (y <= rect.y + 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'before'\n        })) target.dropPosition = 'before';\n        else if (y >= rect.maxY - 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'after'\n        })) target.dropPosition = 'after';\n        return target;\n    }\n    getDropTargetLayoutInfo(target) {\n        let layoutInfo = super.getDropTargetLayoutInfo(target);\n        layoutInfo.parentKey = this.virtualizer.collection.body.key;\n        return layoutInfo;\n    }\n    constructor(options){\n        super(options), this.lastCollection = null, this.columnWidths = new Map(), this.lastPersistedKeys = null, this.persistedIndices = new Map();\n        this.stickyColumnIndices = [];\n    }\n}\n\n\n\n//# sourceMappingURL=TableLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L1RhYmxlTGF5b3V0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5RjtBQUNSO0FBQ29DO0FBQ2xDOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSw0REFBNEQsdURBQXlDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdUNBQXVDLG1FQUF3QixJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVc7QUFDdEM7QUFDQSxpQ0FBaUMsa0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVc7QUFDdEMsMEJBQTBCLGtFQUFpQjtBQUMzQztBQUNBO0FBQ0EsNkJBQTZCLHFFQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCwyQkFBMkIsNERBQVc7QUFDdEMsaUNBQWlDLGtFQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDLGlDQUFpQyxrRUFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxRUFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVc7QUFDdEMsaUNBQWlDLGtFQUFpQjtBQUNsRDtBQUNBO0FBQ0EsOEJBQThCLHFFQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pELDJCQUEyQiw0REFBVztBQUN0QyxpQ0FBaUMsa0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0REFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHa0U7QUFDbEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9UYWJsZUxheW91dC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMaXN0TGF5b3V0IGFzICQ2MWVmNjBmYzliMTA0MWY0JGV4cG9ydCRjYWNiYjM5MjQxNTVkNjhlfSBmcm9tIFwiLi9MaXN0TGF5b3V0Lm1qc1wiO1xuaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRibXNKdiRnZXRDaGlsZE5vZGVzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7U2l6ZSBhcyAkYm1zSnYkU2l6ZSwgUmVjdCBhcyAkYm1zSnYkUmVjdCwgTGF5b3V0SW5mbyBhcyAkYm1zSnYkTGF5b3V0SW5mb30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3ZpcnR1YWxpemVyXCI7XG5pbXBvcnQge1RhYmxlQ29sdW1uTGF5b3V0IGFzICRibXNKdiRUYWJsZUNvbHVtbkxheW91dH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3RhYmxlXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cbmNvbnN0ICRhMTUyMTEyZTkwMjcwOWJmJHZhciRERUZBVUxUX1JPV19IRUlHSFQgPSA0ODtcbmNsYXNzICRhMTUyMTEyZTkwMjcwOWJmJGV4cG9ydCQ2MjQ0NGMzYzcyNGIxYjIwIGV4dGVuZHMgKDAsICQ2MWVmNjBmYzliMTA0MWY0JGV4cG9ydCRjYWNiYjM5MjQxNTVkNjhlKSB7XG4gICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3Igc3ViY2xhc3NpbmcuXG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgfVxuICAgIGNvbHVtbnNDaGFuZ2VkKG5ld0NvbGxlY3Rpb24sIG9sZENvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFvbGRDb2xsZWN0aW9uIHx8IG5ld0NvbGxlY3Rpb24uY29sdW1ucyAhPT0gb2xkQ29sbGVjdGlvbi5jb2x1bW5zICYmIG5ld0NvbGxlY3Rpb24uY29sdW1ucy5sZW5ndGggIT09IG9sZENvbGxlY3Rpb24uY29sdW1ucy5sZW5ndGggfHwgbmV3Q29sbGVjdGlvbi5jb2x1bW5zLnNvbWUoKGMsIGkpPT5jLmtleSAhPT0gb2xkQ29sbGVjdGlvbi5jb2x1bW5zW2ldLmtleSB8fCBjLnByb3BzLndpZHRoICE9PSBvbGRDb2xsZWN0aW9uLmNvbHVtbnNbaV0ucHJvcHMud2lkdGggfHwgYy5wcm9wcy5taW5XaWR0aCAhPT0gb2xkQ29sbGVjdGlvbi5jb2x1bW5zW2ldLnByb3BzLm1pbldpZHRoIHx8IGMucHJvcHMubWF4V2lkdGggIT09IG9sZENvbGxlY3Rpb24uY29sdW1uc1tpXS5wcm9wcy5tYXhXaWR0aCk7XG4gICAgfVxuICAgIHNob3VsZEludmFsaWRhdGVMYXlvdXRPcHRpb25zKG5ld09wdGlvbnMsIG9sZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnMuY29sdW1uV2lkdGhzICE9PSBvbGRPcHRpb25zLmNvbHVtbldpZHRocyB8fCBzdXBlci5zaG91bGRJbnZhbGlkYXRlTGF5b3V0T3B0aW9ucyhuZXdPcHRpb25zLCBvbGRPcHRpb25zKTtcbiAgICB9XG4gICAgdXBkYXRlKGludmFsaWRhdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9pbnZhbGlkYXRpb25Db250ZXh0X2xheW91dE9wdGlvbnM7XG4gICAgICAgIGxldCBuZXdDb2xsZWN0aW9uID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgICAgICAvLyBJZiBjb2x1bW5XaWR0aHMgd2VyZSBwcm92aWRlZCB2aWEgbGF5b3V0T3B0aW9ucywgdXBkYXRlIHRob3NlLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGNhbGN1bGF0ZSBjb2x1bW4gd2lkdGhzIG91cnNlbHZlcy5cbiAgICAgICAgaWYgKChfaW52YWxpZGF0aW9uQ29udGV4dF9sYXlvdXRPcHRpb25zID0gaW52YWxpZGF0aW9uQ29udGV4dC5sYXlvdXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfaW52YWxpZGF0aW9uQ29udGV4dF9sYXlvdXRPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW52YWxpZGF0aW9uQ29udGV4dF9sYXlvdXRPcHRpb25zLmNvbHVtbldpZHRocykge1xuICAgICAgICAgICAgaWYgKGludmFsaWRhdGlvbkNvbnRleHQubGF5b3V0T3B0aW9ucy5jb2x1bW5XaWR0aHMgIT09IHRoaXMuY29sdW1uV2lkdGhzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBpbnZhbGlkYXRpb25Db250ZXh0LmxheW91dE9wdGlvbnMuY29sdW1uV2lkdGhzO1xuICAgICAgICAgICAgICAgIGludmFsaWRhdGlvbkNvbnRleHQuc2l6ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGludmFsaWRhdGlvbkNvbnRleHQuc2l6ZUNoYW5nZWQgfHwgdGhpcy5jb2x1bW5zQ2hhbmdlZChuZXdDb2xsZWN0aW9uLCB0aGlzLmxhc3RDb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgbGV0IGNvbHVtbkxheW91dCA9IG5ldyAoMCwgJGJtc0p2JFRhYmxlQ29sdW1uTGF5b3V0KSh7fSk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IGNvbHVtbkxheW91dC5idWlsZENvbHVtbldpZHRocyh0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoIC0gdGhpcy5wYWRkaW5nICogMiwgbmV3Q29sbGVjdGlvbiwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgIGludmFsaWRhdGlvbkNvbnRleHQuc2l6ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnVwZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KTtcbiAgICB9XG4gICAgYnVpbGRDb2xsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0aWNreUNvbHVtbkluZGljZXMgPSBbXTtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2xsZWN0aW9uLmNvbHVtbnMpLy8gVGhlIHNlbGVjdGlvbiBjZWxsIGFuZCBhbnkgb3RoZXIgc3RpY2t5IGNvbHVtbnMgYWx3YXlzIG5lZWQgdG8gYmUgdmlzaWJsZS5cbiAgICAgICAgLy8gSW4gYWRkaXRpb24sIHJvdyBoZWFkZXJzIG5lZWQgdG8gYmUgaW4gdGhlIERPTSBmb3IgYWNjZXNzaWJpbGl0eSBsYWJlbGluZy5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGlja3lDb2x1bW4oY29sdW1uKSB8fCBjb2xsZWN0aW9uLnJvd0hlYWRlckNvbHVtbktleXMuaGFzKGNvbHVtbi5rZXkpKSB0aGlzLnN0aWNreUNvbHVtbkluZGljZXMucHVzaChjb2x1bW4uaW5kZXgpO1xuICAgICAgICBsZXQgaGVhZGVyID0gdGhpcy5idWlsZFRhYmxlSGVhZGVyKCk7XG4gICAgICAgIHRoaXMubGF5b3V0Tm9kZXMuc2V0KGhlYWRlci5sYXlvdXRJbmZvLmtleSwgaGVhZGVyKTtcbiAgICAgICAgbGV0IGJvZHkgPSB0aGlzLmJ1aWxkQm9keShoZWFkZXIubGF5b3V0SW5mby5yZWN0Lm1heFkgKyB0aGlzLmdhcCk7XG4gICAgICAgIHRoaXMubGFzdFBlcnNpc3RlZEtleXMgPSBudWxsO1xuICAgICAgICBib2R5LmxheW91dEluZm8ucmVjdC53aWR0aCA9IE1hdGgubWF4KGhlYWRlci5sYXlvdXRJbmZvLnJlY3Qud2lkdGgsIGJvZHkubGF5b3V0SW5mby5yZWN0LndpZHRoKTtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGJtc0p2JFNpemUpKGJvZHkubGF5b3V0SW5mby5yZWN0LndpZHRoICsgdGhpcy5wYWRkaW5nICogMiwgYm9keS5sYXlvdXRJbmZvLnJlY3QubWF4WSArIHRoaXMucGFkZGluZyk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgIF07XG4gICAgfVxuICAgIGJ1aWxkVGFibGVIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9oZWFkO1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRibXNKdiRSZWN0KSh0aGlzLnBhZGRpbmcsIHRoaXMucGFkZGluZywgMCwgMCk7XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9oZWFkX2tleTtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSBuZXcgKDAsICRibXNKdiRMYXlvdXRJbmZvKSgnaGVhZGVyJywgKF9jb2xsZWN0aW9uX2hlYWRfa2V5ID0gKF9jb2xsZWN0aW9uX2hlYWQgPSBjb2xsZWN0aW9uLmhlYWQpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2hlYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2hlYWQua2V5KSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9oZWFkX2tleSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25faGVhZF9rZXkgOiAnaGVhZGVyJywgcmVjdCk7XG4gICAgICAgIGxheW91dEluZm8uaXNTdGlja3kgPSB0cnVlO1xuICAgICAgICBsYXlvdXRJbmZvLnpJbmRleCA9IDE7XG4gICAgICAgIGxldCB5ID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaGVhZGVyUm93IG9mIGNvbGxlY3Rpb24uaGVhZGVyUm93cyl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGRDaGlsZChoZWFkZXJSb3csIHRoaXMucGFkZGluZywgeSwgbGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnBhcmVudEtleSA9IGxheW91dEluZm8ua2V5O1xuICAgICAgICAgICAgeSA9IGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0Lm1heFk7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC53aWR0aCk7XG4gICAgICAgICAgICBsYXlvdXROb2RlLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsYXlvdXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0geSAtIHRoaXMucGFkZGluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IGxheW91dEluZm8ucmVjdCxcbiAgICAgICAgICAgIG5vZGU6IGNvbGxlY3Rpb24uaGVhZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZEhlYWRlclJvdyhoZWFkZXJSb3csIHgsIHkpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRibXNKdiRSZWN0KSh4LCB5LCAwLCAwKTtcbiAgICAgICAgbGV0IHJvdyA9IG5ldyAoMCwgJGJtc0p2JExheW91dEluZm8pKCdoZWFkZXJyb3cnLCBoZWFkZXJSb3cua2V5LCByZWN0KTtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgKDAsICRibXNKdiRnZXRDaGlsZE5vZGVzKShoZWFkZXJSb3csIHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbikpe1xuICAgICAgICAgICAgbGV0IGxheW91dE5vZGUgPSB0aGlzLmJ1aWxkQ2hpbGQoY2VsbCwgeCwgeSwgcm93LmtleSk7XG4gICAgICAgICAgICBsYXlvdXROb2RlLmxheW91dEluZm8ucGFyZW50S2V5ID0gcm93LmtleTtcbiAgICAgICAgICAgIHggPSBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5tYXhYO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5pbmRleCA9IGNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKGxheW91dE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtpLCBsYXlvdXRdIG9mIGNvbHVtbnMuZW50cmllcygpKWxheW91dC5sYXlvdXRJbmZvLnpJbmRleCA9IGNvbHVtbnMubGVuZ3RoIC0gaSArIDE7XG4gICAgICAgIHRoaXMuc2V0Q2hpbGRIZWlnaHRzKGNvbHVtbnMsIGhlaWdodCk7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZWN0LndpZHRoID0geCAtIHJlY3QueDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IHJvdyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjb2x1bW5zLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiByZWN0LFxuICAgICAgICAgICAgbm9kZTogaGVhZGVyUm93XG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldENoaWxkSGVpZ2h0cyhjaGlsZHJlbiwgaGVpZ2h0KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKWlmIChjaGlsZC5sYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY29weSB0aGUgbGF5b3V0IGluZm8gYmVmb3JlIHdlIG11dGF0ZSBpdC5cbiAgICAgICAgICAgIGNoaWxkLmxheW91dEluZm8gPSBjaGlsZC5sYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIGNoaWxkLmxheW91dEluZm8ucmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCB0byBnZXQgdGhlIGNvbHVtbiB3aWR0aHMgd2hlbiByZW5kZXJpbmcgdG8gdGhlIERPTVxuICAgIGdldFJlbmRlcmVkQ29sdW1uV2lkdGgobm9kZSkge1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgdmFyIF9ub2RlX2NvbFNwYW47XG4gICAgICAgIGxldCBjb2xTcGFuID0gKF9ub2RlX2NvbFNwYW4gPSBub2RlLmNvbFNwYW4pICE9PSBudWxsICYmIF9ub2RlX2NvbFNwYW4gIT09IHZvaWQgMCA/IF9ub2RlX2NvbFNwYW4gOiAxO1xuICAgICAgICB2YXIgX25vZGVfY29sSW5kZXg7XG4gICAgICAgIGxldCBjb2xJbmRleCA9IChfbm9kZV9jb2xJbmRleCA9IG5vZGUuY29sSW5kZXgpICE9PSBudWxsICYmIF9ub2RlX2NvbEluZGV4ICE9PSB2b2lkIDAgPyBfbm9kZV9jb2xJbmRleCA6IG5vZGUuaW5kZXg7XG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IGNvbEluZGV4OyBpIDwgY29sSW5kZXggKyBjb2xTcGFuOyBpKyspe1xuICAgICAgICAgICAgbGV0IGNvbHVtbiA9IGNvbGxlY3Rpb24uY29sdW1uc1tpXTtcbiAgICAgICAgICAgIHZhciBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0O1xuICAgICAgICAgICAgaWYgKChjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4ua2V5KSAhPSBudWxsKSB3aWR0aCArPSAoX3RoaXNfY29sdW1uV2lkdGhzX2dldCA9IHRoaXMuY29sdW1uV2lkdGhzLmdldChjb2x1bW4ua2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uV2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uV2lkdGhzX2dldCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cbiAgICBnZXRFc3RpbWF0ZWRIZWlnaHQobm9kZSwgd2lkdGgsIGhlaWdodCwgZXN0aW1hdGVkSGVpZ2h0KSB7XG4gICAgICAgIGxldCBpc0VzdGltYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiBubyBleHBsaWNpdCBoZWlnaHQgaXMgYXZhaWxhYmxlLCB1c2UgYW4gZXN0aW1hdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBsYXlvdXQgaW5mbyBleGlzdHMsIHJldXNlIGl0cyBoZWlnaHQuXG4gICAgICAgICAgICAvLyBNYXJrIGFzIGVzdGltYXRlZCBpZiB0aGUgc2l6ZSBvZiB0aGUgb3ZlcmFsbCBjb2xsZWN0aW9uIHZpZXcgY2hhbmdlZCxcbiAgICAgICAgICAgIC8vIG9yIHRoZSBjb250ZW50IG9mIHRoZSBpdGVtIGNoYW5nZWQuXG4gICAgICAgICAgICBsZXQgcHJldmlvdXNMYXlvdXROb2RlID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQobm9kZS5rZXkpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzTGF5b3V0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHByZXZpb3VzTGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlzRXN0aW1hdGVkID0gbm9kZSAhPT0gcHJldmlvdXNMYXlvdXROb2RlLm5vZGUgfHwgd2lkdGggIT09IHByZXZpb3VzTGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3Qud2lkdGggfHwgcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8uZXN0aW1hdGVkU2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gZXN0aW1hdGVkSGVpZ2h0ICE9PSBudWxsICYmIGVzdGltYXRlZEhlaWdodCAhPT0gdm9pZCAwID8gZXN0aW1hdGVkSGVpZ2h0IDogJGExNTIxMTJlOTAyNzA5YmYkdmFyJERFRkFVTFRfUk9XX0hFSUdIVDtcbiAgICAgICAgICAgICAgICBpc0VzdGltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgaXNFc3RpbWF0ZWQ6IGlzRXN0aW1hdGVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEVzdGltYXRlZFJvd0hlaWdodCgpIHtcbiAgICAgICAgdmFyIF90aGlzX3Jvd0hlaWdodCwgX3JlZjtcbiAgICAgICAgcmV0dXJuIChfcmVmID0gKF90aGlzX3Jvd0hlaWdodCA9IHRoaXMucm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpc19yb3dIZWlnaHQgIT09IHZvaWQgMCA/IF90aGlzX3Jvd0hlaWdodCA6IHRoaXMuZXN0aW1hdGVkUm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogJGExNTIxMTJlOTAyNzA5YmYkdmFyJERFRkFVTFRfUk9XX0hFSUdIVDtcbiAgICB9XG4gICAgYnVpbGRDb2x1bW4obm9kZSwgeCwgeSkge1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmdldFJlbmRlcmVkQ29sdW1uV2lkdGgobm9kZSk7XG4gICAgICAgIHZhciBfdGhpc19oZWFkaW5nSGVpZ2h0LCBfdGhpc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0O1xuICAgICAgICBsZXQgeyBoZWlnaHQ6IGhlaWdodCwgaXNFc3RpbWF0ZWQ6IGlzRXN0aW1hdGVkIH0gPSB0aGlzLmdldEVzdGltYXRlZEhlaWdodChub2RlLCB3aWR0aCwgKF90aGlzX2hlYWRpbmdIZWlnaHQgPSB0aGlzLmhlYWRpbmdIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX2hlYWRpbmdIZWlnaHQgIT09IHZvaWQgMCA/IF90aGlzX2hlYWRpbmdIZWlnaHQgOiB0aGlzLnJvd0hlaWdodCwgKF90aGlzX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgPSB0aGlzLmVzdGltYXRlZEhlYWRpbmdIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgIT09IHZvaWQgMCA/IF90aGlzX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQgOiB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCk7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkYm1zSnYkUmVjdCkoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkYm1zSnYkTGF5b3V0SW5mbykobm9kZS50eXBlLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIGxheW91dEluZm8uaXNTdGlja3kgPSB0aGlzLmlzU3RpY2t5Q29sdW1uKG5vZGUpO1xuICAgICAgICBsYXlvdXRJbmZvLnpJbmRleCA9IGxheW91dEluZm8uaXNTdGlja3kgPyAyIDogMTtcbiAgICAgICAgbGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplID0gaXNFc3RpbWF0ZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiBsYXlvdXRJbmZvLnJlY3QsXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEZvciBzdWJjbGFzc2VzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlzU3RpY2t5Q29sdW1uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBidWlsZEJvZHkoeSkge1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRibXNKdiRSZWN0KSh0aGlzLnBhZGRpbmcsIHksIDAsIDApO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGJtc0p2JExheW91dEluZm8pKCdyb3dncm91cCcsIGNvbGxlY3Rpb24uYm9keS5rZXksIHJlY3QpO1xuICAgICAgICBsZXQgc3RhcnRZID0geTtcbiAgICAgICAgbGV0IHNraXBwZWQgPSAwO1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgbGV0IHJvd0hlaWdodCA9IHRoaXMuZ2V0RXN0aW1hdGVkUm93SGVpZ2h0KCkgKyB0aGlzLmdhcDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiAoMCwgJGJtc0p2JGdldENoaWxkTm9kZXMpKGNvbGxlY3Rpb24uYm9keSwgY29sbGVjdGlvbikpe1xuICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJlZm9yZSB0aGUgdmFsaWQgcmVjdGFuZ2xlIHVubGVzcyB0aGV5IGFyZSBhbHJlYWR5IGNhY2hlZC5cbiAgICAgICAgICAgIGlmICh5ICsgcm93SGVpZ2h0IDwgdGhpcy5yZXF1ZXN0ZWRSZWN0LnkgJiYgIXRoaXMuaXNWYWxpZChub2RlLCB5KSkge1xuICAgICAgICAgICAgICAgIHkgKz0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZENoaWxkKG5vZGUsIHRoaXMucGFkZGluZywgeSwgbGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnBhcmVudEtleSA9IGxheW91dEluZm8ua2V5O1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHkgPSBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5tYXhZICsgdGhpcy5nYXA7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC53aWR0aCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxheW91dE5vZGUpO1xuICAgICAgICAgICAgaWYgKHkgPiB0aGlzLnJlcXVlc3RlZFJlY3QubWF4WSkge1xuICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIHRoZSByZW1haW5pbmcgaGVpZ2h0IGZvciByb3dzIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBsYXlvdXQgcmlnaHQgbm93LlxuICAgICAgICAgICAgICAgIHkgKz0gKGNvbGxlY3Rpb24uc2l6ZSAtIChza2lwcGVkICsgY2hpbGRyZW4ubGVuZ3RoKSkgKiByb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgeSA9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QubWF4WTtcbiAgICAgICAgZWxzZSB5IC09IHRoaXMuZ2FwO1xuICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0geSAtIHN0YXJ0WTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3Rpb24odGhpcy5yZXF1ZXN0ZWRSZWN0KSxcbiAgICAgICAgICAgIG5vZGU6IGNvbGxlY3Rpb24uYm9keVxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZE5vZGUobm9kZSwgeCwgeSkge1xuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ2hlYWRlcnJvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRIZWFkZXJSb3cobm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFJvdyhub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbHVtbic6XG4gICAgICAgICAgICBjYXNlICdwbGFjZWhvbGRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDb2x1bW4obm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBjYXNlICdjZWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZENlbGwobm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBjYXNlICdsb2FkZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkTG9hZGVyKG5vZGUsIHgsIHkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkUm93KG5vZGUsIHgsIHkpIHtcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2hlYWQ7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGJtc0p2JFJlY3QpKHgsIHksIDAsIDApO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGJtc0p2JExheW91dEluZm8pKCdyb3cnLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgKDAsICRibXNKdiRnZXRDaGlsZE5vZGVzKShub2RlLCBjb2xsZWN0aW9uKSlpZiAoY2hpbGQudHlwZSA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICBpZiAoeCA+IHRoaXMucmVxdWVzdGVkUmVjdC5tYXhYKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IGV4aXN0aW5nIGNhY2hlZCBsYXlvdXRJbmZvIHRvIGVuc3VyZSB0aGF0IGl0IGlzIG91dCBvZiB2aWV3LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBkdWUgdG8gY29sdW1uIHJlc2l6aW5nLlxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQoY2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC54ID0geDtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZENoaWxkKGNoaWxkLCB4LCB5LCBsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgeCA9IGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0Lm1heFg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGUuaW5kZXggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsYXlvdXROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENoaWxkSGVpZ2h0cyhjaGlsZHJlbiwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2hlYWRfa2V5O1xuICAgICAgICByZWN0LndpZHRoID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQoKF9jb2xsZWN0aW9uX2hlYWRfa2V5ID0gKF9jb2xsZWN0aW9uX2hlYWQgPSBjb2xsZWN0aW9uLmhlYWQpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2hlYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2hlYWQua2V5KSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9oZWFkX2tleSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25faGVhZF9rZXkgOiAnaGVhZGVyJykubGF5b3V0SW5mby5yZWN0LndpZHRoO1xuICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IHJlY3QuaW50ZXJzZWN0aW9uKHRoaXMucmVxdWVzdGVkUmVjdCksXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkQ2VsbChub2RlLCB4LCB5KSB7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0UmVuZGVyZWRDb2x1bW5XaWR0aChub2RlKTtcbiAgICAgICAgbGV0IHsgaGVpZ2h0OiBoZWlnaHQsIGlzRXN0aW1hdGVkOiBpc0VzdGltYXRlZCB9ID0gdGhpcy5nZXRFc3RpbWF0ZWRIZWlnaHQobm9kZSwgd2lkdGgsIHRoaXMucm93SGVpZ2h0LCB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCk7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkYm1zSnYkUmVjdCkoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkYm1zSnYkTGF5b3V0SW5mbykobm9kZS50eXBlLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIGxheW91dEluZm8uaXNTdGlja3kgPSB0aGlzLmlzU3RpY2t5Q29sdW1uKG5vZGUpO1xuICAgICAgICBsYXlvdXRJbmZvLnpJbmRleCA9IGxheW91dEluZm8uaXNTdGlja3kgPyAyIDogMTtcbiAgICAgICAgbGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplID0gaXNFc3RpbWF0ZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiByZWN0LFxuICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCkge1xuICAgICAgICAvLyBBZGp1c3QgcmVjdCB0byBrZWVwIG51bWJlciBvZiB2aXNpYmxlIHJvd3MgY29uc2lzdGVudC5cbiAgICAgICAgLy8gKG9ubHkgaWYgaGVpZ2h0ID4gMSBmb3IgZ2V0RHJvcFRhcmdldEZyb21Qb2ludClcbiAgICAgICAgaWYgKHJlY3QuaGVpZ2h0ID4gMSkge1xuICAgICAgICAgICAgbGV0IHJvd0hlaWdodCA9IHRoaXMuZ2V0RXN0aW1hdGVkUm93SGVpZ2h0KCk7XG4gICAgICAgICAgICByZWN0LnkgPSBNYXRoLmZsb29yKHJlY3QueSAvIHJvd0hlaWdodCkgKiByb3dIZWlnaHQ7XG4gICAgICAgICAgICByZWN0LmhlaWdodCA9IE1hdGguY2VpbChyZWN0LmhlaWdodCAvIHJvd0hlaWdodCkgKiByb3dIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbGF5b3V0IGhhc24ndCB5ZXQgYmVlbiBkb25lIGZvciB0aGUgcmVxdWVzdGVkIHJlY3QsIHVuaW9uIHRoZVxuICAgICAgICAvLyBuZXcgcmVjdCB3aXRoIHRoZSBleGlzdGluZyB2YWxpZCByZWN0LCBhbmQgcmVjb21wdXRlLlxuICAgICAgICB0aGlzLmxheW91dElmTmVlZGVkKHJlY3QpO1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIHRoaXMuYnVpbGRQZXJzaXN0ZWRJbmRpY2VzKCk7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5yb290Tm9kZXMpe1xuICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVmlzaWJsZUxheW91dEluZm9zKHJlcywgbm9kZSwgcmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgYWRkVmlzaWJsZUxheW91dEluZm9zKHJlcywgbm9kZSwgcmVjdCkge1xuICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4gfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgc3dpdGNoKG5vZGUubGF5b3V0SW5mby50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbil7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNoaWxkLmxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIGNoaWxkLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb3dncm91cCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RWaXNpYmxlUm93ID0gdGhpcy5iaW5hcnlTZWFyY2gobm9kZS5jaGlsZHJlbiwgcmVjdC50b3BMZWZ0LCAneScpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFZpc2libGVSb3cgPSB0aGlzLmJpbmFyeVNlYXJjaChub2RlLmNoaWxkcmVuLCByZWN0LmJvdHRvbVJpZ2h0LCAneScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcGVyc2lzdGVkIHJvd3MgYmVmb3JlIHRoZSB2aXNpYmxlIHJvd3MuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXJzaXN0ZWRSb3dJbmRpY2VzID0gdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLmdldChub2RlLmxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlcnNpc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHBlcnNpc3RlZFJvd0luZGljZXMgJiYgcGVyc2lzdEluZGV4IDwgcGVyc2lzdGVkUm93SW5kaWNlcy5sZW5ndGggJiYgcGVyc2lzdGVkUm93SW5kaWNlc1twZXJzaXN0SW5kZXhdIDwgZmlyc3RWaXNpYmxlUm93KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSBwZXJzaXN0ZWRSb3dJbmRpY2VzW3BlcnNpc3RJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChub2RlLmNoaWxkcmVuW2lkeF0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWaXNpYmxlTGF5b3V0SW5mb3MocmVzLCBub2RlLmNoaWxkcmVuW2lkeF0sIHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gZmlyc3RWaXNpYmxlUm93OyBpIDw9IGxhc3RWaXNpYmxlUm93OyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwZXJzaXN0ZWQgcm93cyB0aGF0IG92ZXJsYXAgd2l0aCB2aXNpYmxlIGNlbGxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocGVyc2lzdGVkUm93SW5kaWNlcyAmJiBwZXJzaXN0SW5kZXggPCBwZXJzaXN0ZWRSb3dJbmRpY2VzLmxlbmd0aCAmJiBwZXJzaXN0ZWRSb3dJbmRpY2VzW3BlcnNpc3RJbmRleF0gPCBpKXBlcnNpc3RJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5jaGlsZHJlbltpXS5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmlzaWJsZUxheW91dEluZm9zKHJlcywgbm9kZS5jaGlsZHJlbltpXSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHBlcnNpc3RlZCByb3dzIGFmdGVyIHRoZSB2aXNpYmxlIHJvd3MuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHBlcnNpc3RlZFJvd0luZGljZXMgJiYgcGVyc2lzdEluZGV4IDwgcGVyc2lzdGVkUm93SW5kaWNlcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IHBlcnNpc3RlZFJvd0luZGljZXNbcGVyc2lzdEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5jaGlsZHJlbltpZHhdLmxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmlzaWJsZUxheW91dEluZm9zKHJlcywgbm9kZS5jaGlsZHJlbltpZHhdLCByZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdoZWFkZXJyb3cnOlxuICAgICAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdFZpc2libGVDZWxsID0gdGhpcy5iaW5hcnlTZWFyY2gobm9kZS5jaGlsZHJlbiwgcmVjdC50b3BMZWZ0LCAneCcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFZpc2libGVDZWxsID0gdGhpcy5iaW5hcnlTZWFyY2gobm9kZS5jaGlsZHJlbiwgcmVjdC50b3BSaWdodCwgJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0aWNreUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHBlcnNpc3RlZC9zdGlja3kgY2VsbHMgYmVmb3JlIHRoZSB2aXNpYmxlIGNlbGxzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyc2lzdGVkQ2VsbEluZGljZXMgPSB0aGlzLnBlcnNpc3RlZEluZGljZXMuZ2V0KG5vZGUubGF5b3V0SW5mby5rZXkpIHx8IHRoaXMuc3RpY2t5Q29sdW1uSW5kaWNlcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoc3RpY2t5SW5kZXggPCBwZXJzaXN0ZWRDZWxsSW5kaWNlcy5sZW5ndGggJiYgcGVyc2lzdGVkQ2VsbEluZGljZXNbc3RpY2t5SW5kZXhdIDwgZmlyc3RWaXNpYmxlQ2VsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gcGVyc2lzdGVkQ2VsbEluZGljZXNbc3RpY2t5SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSByZXMucHVzaChub2RlLmNoaWxkcmVuW2lkeF0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGlja3lJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGZpcnN0VmlzaWJsZUNlbGw7IGkgPD0gbGFzdFZpc2libGVDZWxsOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzdGlja3kgY2VsbHMgdGhhdCBvdmVybGFwIHdpdGggdmlzaWJsZSBjZWxscy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHN0aWNreUluZGV4IDwgcGVyc2lzdGVkQ2VsbEluZGljZXMubGVuZ3RoICYmIHBlcnNpc3RlZENlbGxJbmRpY2VzW3N0aWNreUluZGV4XSA8IGkpc3RpY2t5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUuY2hpbGRyZW5baV0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFueSByZW1haW5pbmcgc3RpY2t5IGNlbGxzIGFmdGVyIHRoZSB2aXNpYmxlIGNlbGxzLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZShzdGlja3lJbmRleCA8IHBlcnNpc3RlZENlbGxJbmRpY2VzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gcGVyc2lzdGVkQ2VsbEluZGljZXNbc3RpY2t5SW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHJlcy5wdXNoKG5vZGUuY2hpbGRyZW5baWR4XS5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgJyArIG5vZGUubGF5b3V0SW5mby50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5hcnlTZWFyY2goaXRlbXMsIHBvaW50LCBheGlzKSB7XG4gICAgICAgIGxldCBsb3cgPSAwO1xuICAgICAgICBsZXQgaGlnaCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlKGxvdyA8PSBoaWdoKXtcbiAgICAgICAgICAgIGxldCBtaWQgPSBsb3cgKyBoaWdoID4+IDE7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zW21pZF07XG4gICAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnICYmIGl0ZW0ubGF5b3V0SW5mby5yZWN0Lm1heFggPD0gcG9pbnQueCB8fCBheGlzID09PSAneScgJiYgaXRlbS5sYXlvdXRJbmZvLnJlY3QubWF4WSA8PSBwb2ludC55KSBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSBpZiAoYXhpcyA9PT0gJ3gnICYmIGl0ZW0ubGF5b3V0SW5mby5yZWN0LnggPiBwb2ludC54IHx8IGF4aXMgPT09ICd5JyAmJiBpdGVtLmxheW91dEluZm8ucmVjdC55ID4gcG9pbnQueSkgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKGl0ZW1zLmxlbmd0aCAtIDEsIGxvdykpO1xuICAgIH1cbiAgICBidWlsZFBlcnNpc3RlZEluZGljZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxpemVyLnBlcnNpc3RlZEtleXMgPT09IHRoaXMubGFzdFBlcnNpc3RlZEtleXMpIHJldHVybjtcbiAgICAgICAgdGhpcy5sYXN0UGVyc2lzdGVkS2V5cyA9IHRoaXMudmlydHVhbGl6ZXIucGVyc2lzdGVkS2V5cztcbiAgICAgICAgdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLmNsZWFyKCk7XG4gICAgICAgIC8vIEJ1aWxkIGEgbWFwIG9mIHBhcmVudEtleSA9PiBpbmRpY2VzIG9mIGNoaWxkcmVuIHRvIHBlcnNpc3QuXG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnZpcnR1YWxpemVyLnBlcnNpc3RlZEtleXMpe1xuICAgICAgICAgICAgdmFyIF90aGlzX2xheW91dE5vZGVzX2dldDtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gKF90aGlzX2xheW91dE5vZGVzX2dldCA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF90aGlzX2xheW91dE5vZGVzX2dldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0LmxheW91dEluZm87XG4gICAgICAgICAgICAvLyBXYWxrIHVwIGFuY2VzdG9ycyBzbyBwYXJlbnRzIGFyZSBhbHNvIHBlcnNpc3RlZCBpZiBjaGlsZHJlbiBhcmUuXG4gICAgICAgICAgICB3aGlsZShsYXlvdXRJbmZvICYmIGxheW91dEluZm8ucGFyZW50S2V5KXtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0MSwgX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0MjtcbiAgICAgICAgICAgICAgICBsZXQgY29sbGVjdGlvbk5vZGUgPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb24uZ2V0SXRlbShsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSB0aGlzLnBlcnNpc3RlZEluZGljZXMuZ2V0KGxheW91dEluZm8ucGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWluZGljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpY2t5Q29sdW1uSW5kaWNlcyBhcmUgYWx3YXlzIHBlcnNpc3RlZCBhbG9uZyB3aXRoIGFueSBjZWxscyBmcm9tIHBlcnNpc3RlZEtleXMuXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMgPSAoY29sbGVjdGlvbk5vZGUgPT09IG51bGwgfHwgY29sbGVjdGlvbk5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxlY3Rpb25Ob2RlLnR5cGUpID09PSAnY2VsbCcgfHwgKGNvbGxlY3Rpb25Ob2RlID09PSBudWxsIHx8IGNvbGxlY3Rpb25Ob2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xsZWN0aW9uTm9kZS50eXBlKSA9PT0gJ2NvbHVtbicgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLnN0aWNreUNvbHVtbkluZGljZXNcbiAgICAgICAgICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcnNpc3RlZEluZGljZXMuc2V0KGxheW91dEluZm8ucGFyZW50S2V5LCBpbmRpY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gKF90aGlzX2xheW91dE5vZGVzX2dldDEgPSB0aGlzLmxheW91dE5vZGVzLmdldChsYXlvdXRJbmZvLmtleSkpID09PSBudWxsIHx8IF90aGlzX2xheW91dE5vZGVzX2dldDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2xheW91dE5vZGVzX2dldDEuaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwgJiYgIWluZGljZXMuaW5jbHVkZXMoaW5kZXgpKSBpbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIGxheW91dEluZm8gPSAoX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0MiA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGxheW91dEluZm8ucGFyZW50S2V5KSkgPT09IG51bGwgfHwgX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0Mi5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGljZXMgb2YgdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLnZhbHVlcygpKWluZGljZXMuc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICB9XG4gICAgZ2V0RHJvcFRhcmdldEZyb21Qb2ludCh4LCB5LCBpc1ZhbGlkRHJvcFRhcmdldCkge1xuICAgICAgICB4ICs9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QueDtcbiAgICAgICAgeSArPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lnk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaXRlbSB3aXRoaW4gb24gZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW50IHVzaW5nIHRoZSBnYXAgd2lkdGguXG4gICAgICAgIGxldCBzZWFyY2hSZWN0ID0gbmV3ICgwLCAkYm1zSnYkUmVjdCkoeCwgTWF0aC5tYXgoMCwgeSAtIHRoaXMuZ2FwKSwgMSwgdGhpcy5nYXAgKiAyKTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSB0aGlzLmdldFZpc2libGVMYXlvdXRJbmZvcyhzZWFyY2hSZWN0KTtcbiAgICAgICAgbGV0IGtleSA9IG51bGw7XG4gICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcyl7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaXRlbXMgb3V0c2lkZSB0aGUgc2VhcmNoIHJlY3QsIGUuZy4gcGVyc2lzdGVkIGtleXMuXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnR5cGUgIT09ICdyb3cnIHx8ICFjYW5kaWRhdGUucmVjdC5pbnRlcnNlY3RzKHNlYXJjaFJlY3QpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB5RGlzdCA9IE1hdGguYWJzKGNhbmRpZGF0ZS5yZWN0LnkgLSB5KTtcbiAgICAgICAgICAgIGxldCBtYXhZRGlzdCA9IE1hdGguYWJzKGNhbmRpZGF0ZS5yZWN0Lm1heFkgLSB5KTtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5taW4oeURpc3QsIG1heFlEaXN0KTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uLnNpemUgPT09IDApIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncm9vdCdcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlY3QgPSBsYXlvdXRJbmZvLnJlY3Q7XG4gICAgICAgIGxldCB0YXJnZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiAnaXRlbScsXG4gICAgICAgICAgICBrZXk6IGxheW91dEluZm8ua2V5LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnb24nXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzbid0IGFjY2VwdGVkLCB0cnkgdGhlIHRhcmdldCBiZWZvcmUgb3IgYWZ0ZXIgZGVwZW5kaW5nIG9uIHRoZSB5IHBvc2l0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzIGFjY2VwdGVkLCBzdGlsbCB0cnkgdGhlIGJlZm9yZS9hZnRlciBwb3NpdGlvbnMgaWYgd2l0aGluIDEwcHhcbiAgICAgICAgLy8gb2YgdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIGl0ZW0uXG4gICAgICAgIGlmICghaXNWYWxpZERyb3BUYXJnZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYmVmb3JlJ1xuICAgICAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYmVmb3JlJztcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYWZ0ZXInXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8PSByZWN0LnkgKyAxMCAmJiBpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICBkcm9wUG9zaXRpb246ICdiZWZvcmUnXG4gICAgICAgIH0pKSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2JlZm9yZSc7XG4gICAgICAgIGVsc2UgaWYgKHkgPj0gcmVjdC5tYXhZIC0gMTAgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYWZ0ZXInXG4gICAgICAgIH0pKSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZ2V0RHJvcFRhcmdldExheW91dEluZm8odGFyZ2V0KSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gc3VwZXIuZ2V0RHJvcFRhcmdldExheW91dEluZm8odGFyZ2V0KTtcbiAgICAgICAgbGF5b3V0SW5mby5wYXJlbnRLZXkgPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb24uYm9keS5rZXk7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcbiAgICAgICAgc3VwZXIob3B0aW9ucyksIHRoaXMubGFzdENvbGxlY3Rpb24gPSBudWxsLCB0aGlzLmNvbHVtbldpZHRocyA9IG5ldyBNYXAoKSwgdGhpcy5sYXN0UGVyc2lzdGVkS2V5cyA9IG51bGwsIHRoaXMucGVyc2lzdGVkSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGlja3lDb2x1bW5JbmRpY2VzID0gW107XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7JGExNTIxMTJlOTAyNzA5YmYkZXhwb3J0JDYyNDQ0YzNjNzI0YjFiMjAgYXMgVGFibGVMYXlvdXR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFibGVMYXlvdXQubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs\n");

/***/ }),

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs":
/*!**************************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs ***!
  \**************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WaterfallLayout: () => (/* binding */ $f483179558aa907f$export$e9f7cda058ba8df8)\n/* harmony export */ });\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/virtualizer */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n\n\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nclass $f483179558aa907f$var$WaterfallLayoutInfo extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo) {\n    copy() {\n        let res = super.copy();\n        res.column = this.column;\n        return res;\n    }\n    constructor(...args){\n        super(...args), this.column = 0;\n    }\n}\nconst $f483179558aa907f$var$DEFAULT_OPTIONS = {\n    minItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(200, 200),\n    maxItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(Infinity, Infinity),\n    minSpace: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(18, 18),\n    maxColumns: Infinity,\n    dropIndicatorThickness: 2\n};\nclass $f483179558aa907f$export$e9f7cda058ba8df8 extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Layout) {\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.maxColumns !== oldOptions.maxColumns || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness || !(newOptions.minItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.minItemSize).equals(oldOptions.minItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.minItemSize) || !(newOptions.maxItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.maxItemSize).equals(oldOptions.maxItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.maxItemSize) || !(newOptions.minSpace || $f483179558aa907f$var$DEFAULT_OPTIONS.minSpace).equals(oldOptions.minSpace || $f483179558aa907f$var$DEFAULT_OPTIONS.minSpace);\n    }\n    update(invalidationContext) {\n        let { minItemSize: minItemSize = $f483179558aa907f$var$DEFAULT_OPTIONS.minItemSize, maxItemSize: maxItemSize = $f483179558aa907f$var$DEFAULT_OPTIONS.maxItemSize, minSpace: minSpace = $f483179558aa907f$var$DEFAULT_OPTIONS.minSpace, maxColumns: maxColumns = $f483179558aa907f$var$DEFAULT_OPTIONS.maxColumns, dropIndicatorThickness: dropIndicatorThickness = $f483179558aa907f$var$DEFAULT_OPTIONS.dropIndicatorThickness } = invalidationContext.layoutOptions || {};\n        this.dropIndicatorThickness = dropIndicatorThickness;\n        let visibleWidth = this.virtualizer.visibleRect.width;\n        // The max item width is always the entire viewport.\n        // If the max item height is infinity, scale in proportion to the max width.\n        let maxItemWidth = Math.min(maxItemSize.width, visibleWidth);\n        let maxItemHeight = Number.isFinite(maxItemSize.height) ? maxItemSize.height : Math.floor(minItemSize.height / minItemSize.width * maxItemWidth);\n        // Compute the number of rows and columns needed to display the content\n        let columns = Math.floor(visibleWidth / (minItemSize.width + minSpace.width));\n        let numColumns = Math.max(1, Math.min(maxColumns, columns));\n        // Compute the available width (minus the space between items)\n        let width = visibleWidth - minSpace.width * Math.max(0, numColumns);\n        // Compute the item width based on the space available\n        let itemWidth = Math.floor(width / numColumns);\n        itemWidth = Math.max(minItemSize.width, Math.min(maxItemWidth, itemWidth));\n        // Compute the item height, which is proportional to the item width\n        let t = (itemWidth - minItemSize.width) / Math.max(1, maxItemWidth - minItemSize.width);\n        let itemHeight = minItemSize.height + Math.floor((maxItemHeight - minItemSize.height) * t);\n        itemHeight = Math.max(minItemSize.height, Math.min(maxItemHeight, itemHeight));\n        // Compute the horizontal spacing and content height\n        let horizontalSpacing = Math.floor((visibleWidth - numColumns * itemWidth) / (numColumns + 1));\n        // Setup an array of column heights\n        let columnHeights = Array(numColumns).fill(minSpace.height);\n        let newLayoutInfos = new Map();\n        let addNode = (key, node)=>{\n            let oldLayoutInfo = this.layoutInfos.get(key);\n            let height = itemHeight;\n            let estimatedSize = true;\n            if (oldLayoutInfo) {\n                height = oldLayoutInfo.rect.height;\n                estimatedSize = invalidationContext.sizeChanged || oldLayoutInfo.estimatedSize || oldLayoutInfo.content !== node;\n            }\n            // Figure out which column to place the item in, and compute its position.\n            // Preserve the previous column index so items don't jump around during resizing unless the number of columns changed.\n            let prevColumn = numColumns === this.numColumns && oldLayoutInfo && oldLayoutInfo.rect.y < this.virtualizer.visibleRect.maxY ? oldLayoutInfo.column : undefined;\n            let column = prevColumn !== null && prevColumn !== void 0 ? prevColumn : columnHeights.reduce((minIndex, h, i)=>h < columnHeights[minIndex] ? i : minIndex, 0);\n            let x = horizontalSpacing + column * (itemWidth + horizontalSpacing);\n            let y = columnHeights[column];\n            let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, itemWidth, height);\n            let layoutInfo = new $f483179558aa907f$var$WaterfallLayoutInfo(node.type, key, rect);\n            layoutInfo.estimatedSize = estimatedSize;\n            layoutInfo.allowOverflow = true;\n            layoutInfo.content = node;\n            layoutInfo.column = column;\n            newLayoutInfos.set(key, layoutInfo);\n            columnHeights[column] += layoutInfo.rect.height + minSpace.height;\n        };\n        let skeletonCount = 0;\n        for (let node of this.virtualizer.collection)if (node.type === 'skeleton') {\n            // Add skeleton cards until every column has at least one, and we fill the viewport.\n            let startingHeights = [\n                ...columnHeights\n            ];\n            while(!columnHeights.every((h, i)=>h !== startingHeights[i]) || Math.min(...columnHeights) < this.virtualizer.visibleRect.height){\n                var _this_layoutInfos_get;\n                let key = `${node.key}-${skeletonCount++}`;\n                let content = ((_this_layoutInfos_get = this.layoutInfos.get(key)) === null || _this_layoutInfos_get === void 0 ? void 0 : _this_layoutInfos_get.content) || {\n                    ...node\n                };\n                addNode(key, content);\n            }\n            break;\n        } else addNode(node.key, node);\n        // Reset all columns to the maximum for the next section\n        let maxHeight = Math.max(...columnHeights);\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(this.virtualizer.visibleRect.width, maxHeight);\n        this.layoutInfos = newLayoutInfos;\n        this.numColumns = numColumns;\n    }\n    getLayoutInfo(key) {\n        return this.layoutInfos.get(key);\n    }\n    getContentSize() {\n        return this.contentSize;\n    }\n    getVisibleLayoutInfos(rect) {\n        let layoutInfos = [];\n        for (let layoutInfo of this.layoutInfos.values())if (layoutInfo.rect.intersects(rect) || this.virtualizer.isPersistedKey(layoutInfo.key)) layoutInfos.push(layoutInfo);\n        return layoutInfos;\n    }\n    updateItemSize(key, size) {\n        let layoutInfo = this.layoutInfos.get(key);\n        if (!size || !layoutInfo) return false;\n        if (size.height !== layoutInfo.rect.height) {\n            let newLayoutInfo = layoutInfo.copy();\n            newLayoutInfo.rect.height = size.height;\n            newLayoutInfo.estimatedSize = false;\n            this.layoutInfos.set(key, newLayoutInfo);\n            return true;\n        }\n        return false;\n    }\n    // Override keyboard navigation to work spatially.\n    getKeyRightOf(key) {\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.maxX, layoutInfo.rect.y, this.virtualizer.visibleRect.maxX - layoutInfo.rect.maxX, layoutInfo.rect.height);\n        let layoutInfos = this.getVisibleLayoutInfos(rect);\n        let bestKey = null;\n        let bestDistance = Infinity;\n        for (let candidate of layoutInfos){\n            if (candidate.key === key) continue;\n            // Find the closest item in the x direction with the most overlap in the y direction.\n            let deltaX = candidate.rect.x - rect.x;\n            let overlapY = Math.min(candidate.rect.maxY, rect.maxY) - Math.max(candidate.rect.y, rect.y);\n            let distance = deltaX - overlapY;\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestKey = candidate.key;\n            }\n        }\n        return bestKey;\n    }\n    getKeyLeftOf(key) {\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, layoutInfo.rect.y, layoutInfo.rect.x, layoutInfo.rect.height);\n        let layoutInfos = this.getVisibleLayoutInfos(rect);\n        let bestKey = null;\n        let bestDistance = Infinity;\n        for (let candidate of layoutInfos){\n            if (candidate.key === key) continue;\n            // Find the closest item in the x direction with the most overlap in the y direction.\n            let deltaX = rect.maxX - candidate.rect.maxX;\n            let overlapY = Math.min(candidate.rect.maxY, rect.maxY) - Math.max(candidate.rect.y, rect.y);\n            let distance = deltaX - overlapY;\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestKey = candidate.key;\n            }\n        }\n        return bestKey;\n    }\n    // This overrides the default behavior of shift selection to work spatially\n    // rather than following the order of the items in the collection (which may appear unpredictable).\n    getKeyRange(from, to) {\n        let fromLayoutInfo = this.getLayoutInfo(from);\n        let toLayoutInfo = this.getLayoutInfo(to);\n        if (!fromLayoutInfo || !toLayoutInfo) return [];\n        // Find items where half of the area intersects the rectangle\n        // formed from the first item to the last item in the range.\n        let rect = fromLayoutInfo.rect.union(toLayoutInfo.rect);\n        let keys = [];\n        for (let layoutInfo of this.layoutInfos.values())if (rect.intersection(layoutInfo.rect).area > layoutInfo.rect.area / 2) keys.push(layoutInfo.key);\n        return keys;\n    }\n    getDropTargetFromPoint(x, y) {\n        if (this.layoutInfos.size === 0) return {\n            type: 'root'\n        };\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        let key = this.virtualizer.keyAtPoint(new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Point)(x, y));\n        if (key == null) return {\n            type: 'root'\n        };\n        // Only support \"on\" drop position in waterfall layout.\n        // Reordering doesn't make sense because the items don't have a deterministic order.\n        return {\n            type: 'item',\n            key: key,\n            dropPosition: 'on'\n        };\n    }\n    constructor(...args){\n        super(...args), this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(), this.layoutInfos = new Map(), this.numColumns = 0, this.dropIndicatorThickness = 2;\n    }\n}\n\n\n\n//# sourceMappingURL=WaterfallLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L1dhdGVyZmFsbExheW91dC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUs7O0FBRXJLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0VBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFXO0FBQ3BDLHlCQUF5Qiw0REFBVztBQUNwQyxzQkFBc0IsNERBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDhEQUFhO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0WkFBNFo7QUFDMWE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUyxHQUFHLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1DQUFtQyw0REFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2REFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNERBQVc7QUFDOUQ7QUFDQTs7O0FBR3NFO0FBQ3RFIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVhY3Qtc3RhdGVseStsYXlvdXRANC4yLjFfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGF5b3V0L2Rpc3QvV2F0ZXJmYWxsTGF5b3V0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xheW91dEluZm8gYXMgJGxGendJJExheW91dEluZm8sIFNpemUgYXMgJGxGendJJFNpemUsIFJlY3QgYXMgJGxGendJJFJlY3QsIFBvaW50IGFzICRsRnp3SSRQb2ludCwgTGF5b3V0IGFzICRsRnp3SSRMYXlvdXR9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplclwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjQgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jbGFzcyAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkV2F0ZXJmYWxsTGF5b3V0SW5mbyBleHRlbmRzICgwLCAkbEZ6d0kkTGF5b3V0SW5mbykge1xuICAgIGNvcHkoKSB7XG4gICAgICAgIGxldCByZXMgPSBzdXBlci5jb3B5KCk7XG4gICAgICAgIHJlcy5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpLCB0aGlzLmNvbHVtbiA9IDA7XG4gICAgfVxufVxuY29uc3QgJGY0ODMxNzk1NThhYTkwN2YkdmFyJERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBtaW5JdGVtU2l6ZTogbmV3ICgwLCAkbEZ6d0kkU2l6ZSkoMjAwLCAyMDApLFxuICAgIG1heEl0ZW1TaXplOiBuZXcgKDAsICRsRnp3SSRTaXplKShJbmZpbml0eSwgSW5maW5pdHkpLFxuICAgIG1pblNwYWNlOiBuZXcgKDAsICRsRnp3SSRTaXplKSgxOCwgMTgpLFxuICAgIG1heENvbHVtbnM6IEluZmluaXR5LFxuICAgIGRyb3BJbmRpY2F0b3JUaGlja25lc3M6IDJcbn07XG5jbGFzcyAkZjQ4MzE3OTU1OGFhOTA3ZiRleHBvcnQkZTlmN2NkYTA1OGJhOGRmOCBleHRlbmRzICgwLCAkbEZ6d0kkTGF5b3V0KSB7XG4gICAgc2hvdWxkSW52YWxpZGF0ZUxheW91dE9wdGlvbnMobmV3T3B0aW9ucywgb2xkT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3T3B0aW9ucy5tYXhDb2x1bW5zICE9PSBvbGRPcHRpb25zLm1heENvbHVtbnMgfHwgbmV3T3B0aW9ucy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzICE9PSBvbGRPcHRpb25zLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgfHwgIShuZXdPcHRpb25zLm1pbkl0ZW1TaXplIHx8ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMubWluSXRlbVNpemUpLmVxdWFscyhvbGRPcHRpb25zLm1pbkl0ZW1TaXplIHx8ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMubWluSXRlbVNpemUpIHx8ICEobmV3T3B0aW9ucy5tYXhJdGVtU2l6ZSB8fCAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1heEl0ZW1TaXplKS5lcXVhbHMob2xkT3B0aW9ucy5tYXhJdGVtU2l6ZSB8fCAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1heEl0ZW1TaXplKSB8fCAhKG5ld09wdGlvbnMubWluU3BhY2UgfHwgJGY0ODMxNzk1NThhYTkwN2YkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5TcGFjZSkuZXF1YWxzKG9sZE9wdGlvbnMubWluU3BhY2UgfHwgJGY0ODMxNzk1NThhYTkwN2YkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5TcGFjZSk7XG4gICAgfVxuICAgIHVwZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgIGxldCB7IG1pbkl0ZW1TaXplOiBtaW5JdGVtU2l6ZSA9ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMubWluSXRlbVNpemUsIG1heEl0ZW1TaXplOiBtYXhJdGVtU2l6ZSA9ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMubWF4SXRlbVNpemUsIG1pblNwYWNlOiBtaW5TcGFjZSA9ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMubWluU3BhY2UsIG1heENvbHVtbnM6IG1heENvbHVtbnMgPSAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1heENvbHVtbnMsIGRyb3BJbmRpY2F0b3JUaGlja25lc3M6IGRyb3BJbmRpY2F0b3JUaGlja25lc3MgPSAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgfSA9IGludmFsaWRhdGlvbkNvbnRleHQubGF5b3V0T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzID0gZHJvcEluZGljYXRvclRoaWNrbmVzcztcbiAgICAgICAgbGV0IHZpc2libGVXaWR0aCA9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGg7XG4gICAgICAgIC8vIFRoZSBtYXggaXRlbSB3aWR0aCBpcyBhbHdheXMgdGhlIGVudGlyZSB2aWV3cG9ydC5cbiAgICAgICAgLy8gSWYgdGhlIG1heCBpdGVtIGhlaWdodCBpcyBpbmZpbml0eSwgc2NhbGUgaW4gcHJvcG9ydGlvbiB0byB0aGUgbWF4IHdpZHRoLlxuICAgICAgICBsZXQgbWF4SXRlbVdpZHRoID0gTWF0aC5taW4obWF4SXRlbVNpemUud2lkdGgsIHZpc2libGVXaWR0aCk7XG4gICAgICAgIGxldCBtYXhJdGVtSGVpZ2h0ID0gTnVtYmVyLmlzRmluaXRlKG1heEl0ZW1TaXplLmhlaWdodCkgPyBtYXhJdGVtU2l6ZS5oZWlnaHQgOiBNYXRoLmZsb29yKG1pbkl0ZW1TaXplLmhlaWdodCAvIG1pbkl0ZW1TaXplLndpZHRoICogbWF4SXRlbVdpZHRoKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgbmVlZGVkIHRvIGRpc3BsYXkgdGhlIGNvbnRlbnRcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBNYXRoLmZsb29yKHZpc2libGVXaWR0aCAvIChtaW5JdGVtU2l6ZS53aWR0aCArIG1pblNwYWNlLndpZHRoKSk7XG4gICAgICAgIGxldCBudW1Db2x1bW5zID0gTWF0aC5tYXgoMSwgTWF0aC5taW4obWF4Q29sdW1ucywgY29sdW1ucykpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBhdmFpbGFibGUgd2lkdGggKG1pbnVzIHRoZSBzcGFjZSBiZXR3ZWVuIGl0ZW1zKVxuICAgICAgICBsZXQgd2lkdGggPSB2aXNpYmxlV2lkdGggLSBtaW5TcGFjZS53aWR0aCAqIE1hdGgubWF4KDAsIG51bUNvbHVtbnMpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBpdGVtIHdpZHRoIGJhc2VkIG9uIHRoZSBzcGFjZSBhdmFpbGFibGVcbiAgICAgICAgbGV0IGl0ZW1XaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyBudW1Db2x1bW5zKTtcbiAgICAgICAgaXRlbVdpZHRoID0gTWF0aC5tYXgobWluSXRlbVNpemUud2lkdGgsIE1hdGgubWluKG1heEl0ZW1XaWR0aCwgaXRlbVdpZHRoKSk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGl0ZW0gaGVpZ2h0LCB3aGljaCBpcyBwcm9wb3J0aW9uYWwgdG8gdGhlIGl0ZW0gd2lkdGhcbiAgICAgICAgbGV0IHQgPSAoaXRlbVdpZHRoIC0gbWluSXRlbVNpemUud2lkdGgpIC8gTWF0aC5tYXgoMSwgbWF4SXRlbVdpZHRoIC0gbWluSXRlbVNpemUud2lkdGgpO1xuICAgICAgICBsZXQgaXRlbUhlaWdodCA9IG1pbkl0ZW1TaXplLmhlaWdodCArIE1hdGguZmxvb3IoKG1heEl0ZW1IZWlnaHQgLSBtaW5JdGVtU2l6ZS5oZWlnaHQpICogdCk7XG4gICAgICAgIGl0ZW1IZWlnaHQgPSBNYXRoLm1heChtaW5JdGVtU2l6ZS5oZWlnaHQsIE1hdGgubWluKG1heEl0ZW1IZWlnaHQsIGl0ZW1IZWlnaHQpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaG9yaXpvbnRhbCBzcGFjaW5nIGFuZCBjb250ZW50IGhlaWdodFxuICAgICAgICBsZXQgaG9yaXpvbnRhbFNwYWNpbmcgPSBNYXRoLmZsb29yKCh2aXNpYmxlV2lkdGggLSBudW1Db2x1bW5zICogaXRlbVdpZHRoKSAvIChudW1Db2x1bW5zICsgMSkpO1xuICAgICAgICAvLyBTZXR1cCBhbiBhcnJheSBvZiBjb2x1bW4gaGVpZ2h0c1xuICAgICAgICBsZXQgY29sdW1uSGVpZ2h0cyA9IEFycmF5KG51bUNvbHVtbnMpLmZpbGwobWluU3BhY2UuaGVpZ2h0KTtcbiAgICAgICAgbGV0IG5ld0xheW91dEluZm9zID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgYWRkTm9kZSA9IChrZXksIG5vZGUpPT57XG4gICAgICAgICAgICBsZXQgb2xkTGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gaXRlbUhlaWdodDtcbiAgICAgICAgICAgIGxldCBlc3RpbWF0ZWRTaXplID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvbGRMYXlvdXRJbmZvKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gb2xkTGF5b3V0SW5mby5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRTaXplID0gaW52YWxpZGF0aW9uQ29udGV4dC5zaXplQ2hhbmdlZCB8fCBvbGRMYXlvdXRJbmZvLmVzdGltYXRlZFNpemUgfHwgb2xkTGF5b3V0SW5mby5jb250ZW50ICE9PSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBjb2x1bW4gdG8gcGxhY2UgdGhlIGl0ZW0gaW4sIGFuZCBjb21wdXRlIGl0cyBwb3NpdGlvbi5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBwcmV2aW91cyBjb2x1bW4gaW5kZXggc28gaXRlbXMgZG9uJ3QganVtcCBhcm91bmQgZHVyaW5nIHJlc2l6aW5nIHVubGVzcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgY2hhbmdlZC5cbiAgICAgICAgICAgIGxldCBwcmV2Q29sdW1uID0gbnVtQ29sdW1ucyA9PT0gdGhpcy5udW1Db2x1bW5zICYmIG9sZExheW91dEluZm8gJiYgb2xkTGF5b3V0SW5mby5yZWN0LnkgPCB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lm1heFkgPyBvbGRMYXlvdXRJbmZvLmNvbHVtbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSBwcmV2Q29sdW1uICE9PSBudWxsICYmIHByZXZDb2x1bW4gIT09IHZvaWQgMCA/IHByZXZDb2x1bW4gOiBjb2x1bW5IZWlnaHRzLnJlZHVjZSgobWluSW5kZXgsIGgsIGkpPT5oIDwgY29sdW1uSGVpZ2h0c1ttaW5JbmRleF0gPyBpIDogbWluSW5kZXgsIDApO1xuICAgICAgICAgICAgbGV0IHggPSBob3Jpem9udGFsU3BhY2luZyArIGNvbHVtbiAqIChpdGVtV2lkdGggKyBob3Jpem9udGFsU3BhY2luZyk7XG4gICAgICAgICAgICBsZXQgeSA9IGNvbHVtbkhlaWdodHNbY29sdW1uXTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkbEZ6d0kkUmVjdCkoeCwgeSwgaXRlbVdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSBuZXcgJGY0ODMxNzk1NThhYTkwN2YkdmFyJFdhdGVyZmFsbExheW91dEluZm8obm9kZS50eXBlLCBrZXksIHJlY3QpO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVkU2l6ZTtcbiAgICAgICAgICAgIGxheW91dEluZm8uYWxsb3dPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICBsYXlvdXRJbmZvLmNvbnRlbnQgPSBub2RlO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICBuZXdMYXlvdXRJbmZvcy5zZXQoa2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIGNvbHVtbkhlaWdodHNbY29sdW1uXSArPSBsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ICsgbWluU3BhY2UuaGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICBsZXQgc2tlbGV0b25Db3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uKWlmIChub2RlLnR5cGUgPT09ICdza2VsZXRvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCBza2VsZXRvbiBjYXJkcyB1bnRpbCBldmVyeSBjb2x1bW4gaGFzIGF0IGxlYXN0IG9uZSwgYW5kIHdlIGZpbGwgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgICAgbGV0IHN0YXJ0aW5nSGVpZ2h0cyA9IFtcbiAgICAgICAgICAgICAgICAuLi5jb2x1bW5IZWlnaHRzXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgd2hpbGUoIWNvbHVtbkhlaWdodHMuZXZlcnkoKGgsIGkpPT5oICE9PSBzdGFydGluZ0hlaWdodHNbaV0pIHx8IE1hdGgubWluKC4uLmNvbHVtbkhlaWdodHMpIDwgdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC5oZWlnaHQpe1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc19sYXlvdXRJbmZvc19nZXQ7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGAke25vZGUua2V5fS0ke3NrZWxldG9uQ291bnQrK31gO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gKChfdGhpc19sYXlvdXRJbmZvc19nZXQgPSB0aGlzLmxheW91dEluZm9zLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfdGhpc19sYXlvdXRJbmZvc19nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2xheW91dEluZm9zX2dldC5jb250ZW50KSB8fCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZE5vZGUoa2V5LCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgYWRkTm9kZShub2RlLmtleSwgbm9kZSk7XG4gICAgICAgIC8vIFJlc2V0IGFsbCBjb2x1bW5zIHRvIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dCBzZWN0aW9uXG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSBNYXRoLm1heCguLi5jb2x1bW5IZWlnaHRzKTtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGxGendJJFNpemUpKHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGgsIG1heEhlaWdodCk7XG4gICAgICAgIHRoaXMubGF5b3V0SW5mb3MgPSBuZXdMYXlvdXRJbmZvcztcbiAgICAgICAgdGhpcy5udW1Db2x1bW5zID0gbnVtQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0TGF5b3V0SW5mbyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgfVxuICAgIGdldENvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2l6ZTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gW107XG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgdGhpcy5sYXlvdXRJbmZvcy52YWx1ZXMoKSlpZiAobGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHMocmVjdCkgfHwgdGhpcy52aXJ0dWFsaXplci5pc1BlcnNpc3RlZEtleShsYXlvdXRJbmZvLmtleSkpIGxheW91dEluZm9zLnB1c2gobGF5b3V0SW5mbyk7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvcztcbiAgICB9XG4gICAgdXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXRJbmZvcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFzaXplIHx8ICFsYXlvdXRJbmZvKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzaXplLmhlaWdodCAhPT0gbGF5b3V0SW5mby5yZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgbGV0IG5ld0xheW91dEluZm8gPSBsYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIG5ld0xheW91dEluZm8ucmVjdC5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIG5ld0xheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRJbmZvcy5zZXQoa2V5LCBuZXdMYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGUga2V5Ym9hcmQgbmF2aWdhdGlvbiB0byB3b3JrIHNwYXRpYWxseS5cbiAgICBnZXRLZXlSaWdodE9mKGtleSkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICBpZiAoIWxheW91dEluZm8pIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGxGendJJFJlY3QpKGxheW91dEluZm8ucmVjdC5tYXhYLCBsYXlvdXRJbmZvLnJlY3QueSwgdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC5tYXhYIC0gbGF5b3V0SW5mby5yZWN0Lm1heFgsIGxheW91dEluZm8ucmVjdC5oZWlnaHQpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mb3MgPSB0aGlzLmdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KTtcbiAgICAgICAgbGV0IGJlc3RLZXkgPSBudWxsO1xuICAgICAgICBsZXQgYmVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGNhbmRpZGF0ZSBvZiBsYXlvdXRJbmZvcyl7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmtleSA9PT0ga2V5KSBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaXRlbSBpbiB0aGUgeCBkaXJlY3Rpb24gd2l0aCB0aGUgbW9zdCBvdmVybGFwIGluIHRoZSB5IGRpcmVjdGlvbi5cbiAgICAgICAgICAgIGxldCBkZWx0YVggPSBjYW5kaWRhdGUucmVjdC54IC0gcmVjdC54O1xuICAgICAgICAgICAgbGV0IG92ZXJsYXBZID0gTWF0aC5taW4oY2FuZGlkYXRlLnJlY3QubWF4WSwgcmVjdC5tYXhZKSAtIE1hdGgubWF4KGNhbmRpZGF0ZS5yZWN0LnksIHJlY3QueSk7XG4gICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBkZWx0YVggLSBvdmVybGFwWTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGJlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJlc3RLZXkgPSBjYW5kaWRhdGUua2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0S2V5O1xuICAgIH1cbiAgICBnZXRLZXlMZWZ0T2Yoa2V5KSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5nZXRMYXlvdXRJbmZvKGtleSk7XG4gICAgICAgIGlmICghbGF5b3V0SW5mbykgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkbEZ6d0kkUmVjdCkoMCwgbGF5b3V0SW5mby5yZWN0LnksIGxheW91dEluZm8ucmVjdC54LCBsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0KTtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCk7XG4gICAgICAgIGxldCBiZXN0S2V5ID0gbnVsbDtcbiAgICAgICAgbGV0IGJlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBjYW5kaWRhdGUgb2YgbGF5b3V0SW5mb3Mpe1xuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5rZXkgPT09IGtleSkgY29udGludWU7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGl0ZW0gaW4gdGhlIHggZGlyZWN0aW9uIHdpdGggdGhlIG1vc3Qgb3ZlcmxhcCBpbiB0aGUgeSBkaXJlY3Rpb24uXG4gICAgICAgICAgICBsZXQgZGVsdGFYID0gcmVjdC5tYXhYIC0gY2FuZGlkYXRlLnJlY3QubWF4WDtcbiAgICAgICAgICAgIGxldCBvdmVybGFwWSA9IE1hdGgubWluKGNhbmRpZGF0ZS5yZWN0Lm1heFksIHJlY3QubWF4WSkgLSBNYXRoLm1heChjYW5kaWRhdGUucmVjdC55LCByZWN0LnkpO1xuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gZGVsdGFYIC0gb3ZlcmxhcFk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBiZXN0S2V5ID0gY2FuZGlkYXRlLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdEtleTtcbiAgICB9XG4gICAgLy8gVGhpcyBvdmVycmlkZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2Ygc2hpZnQgc2VsZWN0aW9uIHRvIHdvcmsgc3BhdGlhbGx5XG4gICAgLy8gcmF0aGVyIHRoYW4gZm9sbG93aW5nIHRoZSBvcmRlciBvZiB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gKHdoaWNoIG1heSBhcHBlYXIgdW5wcmVkaWN0YWJsZSkuXG4gICAgZ2V0S2V5UmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGZyb21MYXlvdXRJbmZvID0gdGhpcy5nZXRMYXlvdXRJbmZvKGZyb20pO1xuICAgICAgICBsZXQgdG9MYXlvdXRJbmZvID0gdGhpcy5nZXRMYXlvdXRJbmZvKHRvKTtcbiAgICAgICAgaWYgKCFmcm9tTGF5b3V0SW5mbyB8fCAhdG9MYXlvdXRJbmZvKSByZXR1cm4gW107XG4gICAgICAgIC8vIEZpbmQgaXRlbXMgd2hlcmUgaGFsZiBvZiB0aGUgYXJlYSBpbnRlcnNlY3RzIHRoZSByZWN0YW5nbGVcbiAgICAgICAgLy8gZm9ybWVkIGZyb20gdGhlIGZpcnN0IGl0ZW0gdG8gdGhlIGxhc3QgaXRlbSBpbiB0aGUgcmFuZ2UuXG4gICAgICAgIGxldCByZWN0ID0gZnJvbUxheW91dEluZm8ucmVjdC51bmlvbih0b0xheW91dEluZm8ucmVjdCk7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2YgdGhpcy5sYXlvdXRJbmZvcy52YWx1ZXMoKSlpZiAocmVjdC5pbnRlcnNlY3Rpb24obGF5b3V0SW5mby5yZWN0KS5hcmVhID4gbGF5b3V0SW5mby5yZWN0LmFyZWEgLyAyKSBrZXlzLnB1c2gobGF5b3V0SW5mby5rZXkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgZ2V0RHJvcFRhcmdldEZyb21Qb2ludCh4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLmxheW91dEluZm9zLnNpemUgPT09IDApIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncm9vdCdcbiAgICAgICAgfTtcbiAgICAgICAgeCArPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lng7XG4gICAgICAgIHkgKz0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC55O1xuICAgICAgICBsZXQga2V5ID0gdGhpcy52aXJ0dWFsaXplci5rZXlBdFBvaW50KG5ldyAoMCwgJGxGendJJFBvaW50KSh4LCB5KSk7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdyb290J1xuICAgICAgICB9O1xuICAgICAgICAvLyBPbmx5IHN1cHBvcnQgXCJvblwiIGRyb3AgcG9zaXRpb24gaW4gd2F0ZXJmYWxsIGxheW91dC5cbiAgICAgICAgLy8gUmVvcmRlcmluZyBkb2Vzbid0IG1ha2Ugc2Vuc2UgYmVjYXVzZSB0aGUgaXRlbXMgZG9uJ3QgaGF2ZSBhIGRldGVybWluaXN0aWMgb3JkZXIuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaXRlbScsXG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ29uJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyksIHRoaXMuY29udGVudFNpemUgPSBuZXcgKDAsICRsRnp3SSRTaXplKSgpLCB0aGlzLmxheW91dEluZm9zID0gbmV3IE1hcCgpLCB0aGlzLm51bUNvbHVtbnMgPSAwLCB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgPSAyO1xuICAgIH1cbn1cblxuXG5leHBvcnQgeyRmNDgzMTc5NTU4YWE5MDdmJGV4cG9ydCRlOWY3Y2RhMDU4YmE4ZGY4IGFzIFdhdGVyZmFsbExheW91dH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XYXRlcmZhbGxMYXlvdXQubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs\n");

/***/ }),

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/import.mjs":
/*!*****************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/import.mjs ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayout: () => (/* reexport safe */ _GridLayout_mjs__WEBPACK_IMPORTED_MODULE_0__.GridLayout),\n/* harmony export */   ListLayout: () => (/* reexport safe */ _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_1__.ListLayout),\n/* harmony export */   TableLayout: () => (/* reexport safe */ _TableLayout_mjs__WEBPACK_IMPORTED_MODULE_2__.TableLayout),\n/* harmony export */   WaterfallLayout: () => (/* reexport safe */ _WaterfallLayout_mjs__WEBPACK_IMPORTED_MODULE_3__.WaterfallLayout)\n/* harmony export */ });\n/* harmony import */ var _GridLayout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GridLayout.mjs */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs\");\n/* harmony import */ var _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ListLayout.mjs */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs\");\n/* harmony import */ var _TableLayout_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TableLayout.mjs */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs\");\n/* harmony import */ var _WaterfallLayout_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WaterfallLayout.mjs */ \"(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBeUY7QUFDQTtBQUNFO0FBQ1E7O0FBRW5HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1rUDtBQUNsUCIsInNvdXJjZXMiOlsiL1VzZXJzL2phaW1laXNyYWVsY2FtcGVhcy9rZXlzdG9uZS9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L2ltcG9ydC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtHcmlkTGF5b3V0IGFzICRhNTg1OTJkMjk1YTE3MGE0JGV4cG9ydCQ3ZDJiMTI1NzgxNTRhNzM1fSBmcm9tIFwiLi9HcmlkTGF5b3V0Lm1qc1wiO1xuaW1wb3J0IHtMaXN0TGF5b3V0IGFzICQ2MWVmNjBmYzliMTA0MWY0JGV4cG9ydCRjYWNiYjM5MjQxNTVkNjhlfSBmcm9tIFwiLi9MaXN0TGF5b3V0Lm1qc1wiO1xuaW1wb3J0IHtUYWJsZUxheW91dCBhcyAkYTE1MjExMmU5MDI3MDliZiRleHBvcnQkNjI0NDRjM2M3MjRiMWIyMH0gZnJvbSBcIi4vVGFibGVMYXlvdXQubWpzXCI7XG5pbXBvcnQge1dhdGVyZmFsbExheW91dCBhcyAkZjQ4MzE3OTU1OGFhOTA3ZiRleHBvcnQkZTlmN2NkYTA1OGJhOGRmOH0gZnJvbSBcIi4vV2F0ZXJmYWxsTGF5b3V0Lm1qc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cblxuZXhwb3J0IHskYTU4NTkyZDI5NWExNzBhNCRleHBvcnQkN2QyYjEyNTc4MTU0YTczNSBhcyBHcmlkTGF5b3V0LCAkNjFlZjYwZmM5YjEwNDFmNCRleHBvcnQkY2FjYmIzOTI0MTU1ZDY4ZSBhcyBMaXN0TGF5b3V0LCAkYTE1MjExMmU5MDI3MDliZiRleHBvcnQkNjI0NDRjM2M3MjRiMWIyMCBhcyBUYWJsZUxheW91dCwgJGY0ODMxNzk1NThhYTkwN2YkZXhwb3J0JGU5ZjdjZGEwNThiYThkZjggYXMgV2F0ZXJmYWxsTGF5b3V0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/import.mjs\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs":
/*!*********************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs ***!
  \*********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayout: () => (/* binding */ $a58592d295a170a4$export$7d2b12578154a735)\n/* harmony export */ });\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/virtualizer */ \"../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n\n\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $a58592d295a170a4$var$DEFAULT_OPTIONS = {\n    minItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(200, 200),\n    maxItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(Infinity, Infinity),\n    preserveAspectRatio: false,\n    minSpace: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(18, 18),\n    maxColumns: Infinity,\n    dropIndicatorThickness: 2\n};\nclass $a58592d295a170a4$export$7d2b12578154a735 extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Layout) {\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.maxColumns !== oldOptions.maxColumns || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness || newOptions.preserveAspectRatio !== oldOptions.preserveAspectRatio || !(newOptions.minItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.minItemSize).equals(oldOptions.minItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.minItemSize) || !(newOptions.maxItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.maxItemSize).equals(oldOptions.maxItemSize || $a58592d295a170a4$var$DEFAULT_OPTIONS.maxItemSize) || !(newOptions.minSpace || $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace).equals(oldOptions.minSpace || $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace);\n    }\n    update(invalidationContext) {\n        let { minItemSize: minItemSize = $a58592d295a170a4$var$DEFAULT_OPTIONS.minItemSize, maxItemSize: maxItemSize = $a58592d295a170a4$var$DEFAULT_OPTIONS.maxItemSize, preserveAspectRatio: preserveAspectRatio = $a58592d295a170a4$var$DEFAULT_OPTIONS.preserveAspectRatio, minSpace: minSpace = $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace, maxColumns: maxColumns = $a58592d295a170a4$var$DEFAULT_OPTIONS.maxColumns, dropIndicatorThickness: dropIndicatorThickness = $a58592d295a170a4$var$DEFAULT_OPTIONS.dropIndicatorThickness } = invalidationContext.layoutOptions || {};\n        this.dropIndicatorThickness = dropIndicatorThickness;\n        let visibleWidth = this.virtualizer.visibleRect.width;\n        // The max item width is always the entire viewport.\n        // If the max item height is infinity, scale in proportion to the max width.\n        let maxItemWidth = Math.min(maxItemSize.width, visibleWidth);\n        let maxItemHeight = Number.isFinite(maxItemSize.height) ? maxItemSize.height : Math.floor(minItemSize.height / minItemSize.width * maxItemWidth);\n        // Compute the number of rows and columns needed to display the content\n        let columns = Math.floor(visibleWidth / (minItemSize.width + minSpace.width));\n        let numColumns = Math.max(1, Math.min(maxColumns, columns));\n        this.numColumns = numColumns;\n        // Compute the available width (minus the space between items)\n        let width = visibleWidth - minSpace.width * Math.max(0, numColumns);\n        // Compute the item width based on the space available\n        let itemWidth = Math.floor(width / numColumns);\n        itemWidth = Math.max(minItemSize.width, Math.min(maxItemWidth, itemWidth));\n        // Compute the item height, which is proportional to the item width\n        let t = (itemWidth - minItemSize.width) / Math.max(1, maxItemWidth - minItemSize.width);\n        let itemHeight = minItemSize.height + Math.floor((maxItemHeight - minItemSize.height) * t);\n        itemHeight = Math.max(minItemSize.height, Math.min(maxItemHeight, itemHeight));\n        // Compute the horizontal spacing and content height\n        let horizontalSpacing = Math.floor((visibleWidth - numColumns * itemWidth) / (numColumns + 1));\n        this.gap = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(horizontalSpacing, minSpace.height);\n        let rows = Math.ceil(this.virtualizer.collection.size / numColumns);\n        let iterator = this.virtualizer.collection[Symbol.iterator]();\n        let y = rows > 0 ? minSpace.height : 0;\n        let newLayoutInfos = new Map();\n        let skeleton = null;\n        let skeletonCount = 0;\n        for(let row = 0; row < rows; row++){\n            let maxHeight = 0;\n            let rowLayoutInfos = [];\n            for(let col = 0; col < numColumns; col++){\n                // Repeat skeleton until the end of the current row.\n                let node = skeleton || iterator.next().value;\n                if (!node) break;\n                if (node.type === 'skeleton') skeleton = node;\n                let key = skeleton ? `${skeleton.key}-${skeletonCount++}` : node.key;\n                let oldLayoutInfo = this.layoutInfos.get(key);\n                let content = node;\n                if (skeleton) content = oldLayoutInfo && oldLayoutInfo.content.key === key ? oldLayoutInfo.content : {\n                    ...skeleton,\n                    key: key\n                };\n                let x = horizontalSpacing + col * (itemWidth + horizontalSpacing);\n                let height = itemHeight;\n                let estimatedSize = !preserveAspectRatio;\n                if (oldLayoutInfo && estimatedSize) {\n                    height = oldLayoutInfo.rect.height;\n                    estimatedSize = invalidationContext.layoutOptionsChanged || invalidationContext.sizeChanged || oldLayoutInfo.estimatedSize || oldLayoutInfo.content !== content;\n                }\n                let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, itemWidth, height);\n                let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, key, rect);\n                layoutInfo.estimatedSize = estimatedSize;\n                layoutInfo.allowOverflow = true;\n                layoutInfo.content = content;\n                newLayoutInfos.set(key, layoutInfo);\n                rowLayoutInfos.push(layoutInfo);\n                maxHeight = Math.max(maxHeight, layoutInfo.rect.height);\n            }\n            for (let layoutInfo of rowLayoutInfos)layoutInfo.rect.height = maxHeight;\n            y += maxHeight + minSpace.height;\n            // Keep adding skeleton rows until we fill the viewport\n            if (skeleton && row === rows - 1 && y < this.virtualizer.visibleRect.height) rows++;\n        }\n        this.layoutInfos = newLayoutInfos;\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(this.virtualizer.visibleRect.width, y);\n    }\n    getLayoutInfo(key) {\n        return this.layoutInfos.get(key);\n    }\n    getContentSize() {\n        return this.contentSize;\n    }\n    getVisibleLayoutInfos(rect) {\n        let layoutInfos = [];\n        for (let layoutInfo of this.layoutInfos.values())if (layoutInfo.rect.intersects(rect) || this.virtualizer.isPersistedKey(layoutInfo.key)) layoutInfos.push(layoutInfo);\n        return layoutInfos;\n    }\n    updateItemSize(key, size) {\n        let layoutInfo = this.layoutInfos.get(key);\n        if (!size || !layoutInfo) return false;\n        if (size.height !== layoutInfo.rect.height) {\n            let newLayoutInfo = layoutInfo.copy();\n            newLayoutInfo.rect.height = size.height;\n            newLayoutInfo.estimatedSize = false;\n            this.layoutInfos.set(key, newLayoutInfo);\n            return true;\n        }\n        return false;\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        if (this.layoutInfos.size === 0) return {\n            type: 'root'\n        };\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        // Find the closest item within on either side of the point using the gap width.\n        let key = null;\n        if (this.numColumns === 1) {\n            let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, Math.max(0, y - this.gap.height), 1, this.gap.height * 2);\n            let candidates = this.getVisibleLayoutInfos(searchRect);\n            let minDistance = Infinity;\n            for (let candidate of candidates){\n                // Ignore items outside the search rect, e.g. persisted keys.\n                if (!candidate.rect.intersects(searchRect)) continue;\n                let yDist = Math.abs(candidate.rect.y - y);\n                let maxYDist = Math.abs(candidate.rect.maxY - y);\n                let dist = Math.min(yDist, maxYDist);\n                if (dist < minDistance) {\n                    minDistance = dist;\n                    key = candidate.key;\n                }\n            }\n        } else {\n            let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(Math.max(0, x - this.gap.width), y, this.gap.width * 2, 1);\n            let candidates = this.getVisibleLayoutInfos(searchRect);\n            let minDistance = Infinity;\n            for (let candidate of candidates){\n                // Ignore items outside the search rect, e.g. persisted keys.\n                if (!candidate.rect.intersects(searchRect)) continue;\n                let xDist = Math.abs(candidate.rect.x - x);\n                let maxXDist = Math.abs(candidate.rect.maxX - x);\n                let dist = Math.min(xDist, maxXDist);\n                if (dist < minDistance) {\n                    minDistance = dist;\n                    key = candidate.key;\n                }\n            }\n        }\n        let layoutInfo = key != null ? this.getLayoutInfo(key) : null;\n        if (!layoutInfo) return {\n            type: 'root'\n        };\n        let target = {\n            type: 'item',\n            key: layoutInfo.key,\n            dropPosition: 'on'\n        };\n        let pos = this.numColumns === 1 ? y : x;\n        let layoutInfoPos = this.numColumns === 1 ? layoutInfo.rect.y : layoutInfo.rect.x;\n        let size = this.numColumns === 1 ? layoutInfo.rect.height : layoutInfo.rect.width;\n        if (isValidDropTarget(target)) {\n            // If dropping on the item is accepted, try the before/after positions\n            // if within 5px of the start or end of the item.\n            if (pos < layoutInfoPos + 5) target.dropPosition = 'before';\n            else if (pos > layoutInfoPos + size - 5) target.dropPosition = 'after';\n        } else {\n            // If dropping on the item isn't accepted, try the target before or after depending on the position.\n            let mid = layoutInfoPos + size / 2;\n            if (pos <= mid && isValidDropTarget({\n                ...target,\n                dropPosition: 'before'\n            })) target.dropPosition = 'before';\n            else if (pos >= mid && isValidDropTarget({\n                ...target,\n                dropPosition: 'after'\n            })) target.dropPosition = 'after';\n        }\n        return target;\n    }\n    getDropTargetLayoutInfo(target) {\n        let layoutInfo = this.getLayoutInfo(target.key);\n        let rect;\n        if (this.numColumns === 1) // Flip from vertical to horizontal if only one column is visible.\n        rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.x, target.dropPosition === 'before' ? layoutInfo.rect.y - this.gap.height / 2 - this.dropIndicatorThickness / 2 : layoutInfo.rect.maxY + this.gap.height / 2 - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n        else rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(target.dropPosition === 'before' ? layoutInfo.rect.x - this.gap.width / 2 - this.dropIndicatorThickness / 2 : layoutInfo.rect.maxX + this.gap.width / 2 - this.dropIndicatorThickness / 2, layoutInfo.rect.y, this.dropIndicatorThickness, layoutInfo.rect.height);\n        return new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('dropIndicator', target.key + ':' + target.dropPosition, rect);\n    }\n    constructor(...args){\n        super(...args), this.gap = $a58592d295a170a4$var$DEFAULT_OPTIONS.minSpace, this.dropIndicatorThickness = 2, this.numColumns = 0, this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(), this.layoutInfos = new Map();\n    }\n}\n\n\n\n//# sourceMappingURL=GridLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9HcmlkTGF5b3V0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4STs7QUFFOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFXO0FBQ3BDLHlCQUF5Qiw0REFBVztBQUNwQztBQUNBLHNCQUFzQiw0REFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQSw0REFBNEQsOERBQWE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtnQkFBa2dCO0FBQ2hoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYSxHQUFHLGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBVztBQUM5Qyx5Q0FBeUMsa0VBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0REFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQ0FBcUMsNERBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQVc7QUFDbEMsNEJBQTRCLDREQUFXO0FBQ3ZDLHVCQUF1QixrRUFBaUI7QUFDeEM7QUFDQTtBQUNBLG9LQUFvSyw0REFBVztBQUMvSztBQUNBOzs7QUFHaUU7QUFDakUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9HcmlkTGF5b3V0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NpemUgYXMgJGlwZ0tGJFNpemUsIFJlY3QgYXMgJGlwZ0tGJFJlY3QsIExheW91dEluZm8gYXMgJGlwZ0tGJExheW91dEluZm8sIExheW91dCBhcyAkaXBnS0YkTGF5b3V0fSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXJcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDI0IEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBtaW5JdGVtU2l6ZTogbmV3ICgwLCAkaXBnS0YkU2l6ZSkoMjAwLCAyMDApLFxuICAgIG1heEl0ZW1TaXplOiBuZXcgKDAsICRpcGdLRiRTaXplKShJbmZpbml0eSwgSW5maW5pdHkpLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgIG1pblNwYWNlOiBuZXcgKDAsICRpcGdLRiRTaXplKSgxOCwgMTgpLFxuICAgIG1heENvbHVtbnM6IEluZmluaXR5LFxuICAgIGRyb3BJbmRpY2F0b3JUaGlja25lc3M6IDJcbn07XG5jbGFzcyAkYTU4NTkyZDI5NWExNzBhNCRleHBvcnQkN2QyYjEyNTc4MTU0YTczNSBleHRlbmRzICgwLCAkaXBnS0YkTGF5b3V0KSB7XG4gICAgc2hvdWxkSW52YWxpZGF0ZUxheW91dE9wdGlvbnMobmV3T3B0aW9ucywgb2xkT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3T3B0aW9ucy5tYXhDb2x1bW5zICE9PSBvbGRPcHRpb25zLm1heENvbHVtbnMgfHwgbmV3T3B0aW9ucy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzICE9PSBvbGRPcHRpb25zLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgfHwgbmV3T3B0aW9ucy5wcmVzZXJ2ZUFzcGVjdFJhdGlvICE9PSBvbGRPcHRpb25zLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgIShuZXdPcHRpb25zLm1pbkl0ZW1TaXplIHx8ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWluSXRlbVNpemUpLmVxdWFscyhvbGRPcHRpb25zLm1pbkl0ZW1TaXplIHx8ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWluSXRlbVNpemUpIHx8ICEobmV3T3B0aW9ucy5tYXhJdGVtU2l6ZSB8fCAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLm1heEl0ZW1TaXplKS5lcXVhbHMob2xkT3B0aW9ucy5tYXhJdGVtU2l6ZSB8fCAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLm1heEl0ZW1TaXplKSB8fCAhKG5ld09wdGlvbnMubWluU3BhY2UgfHwgJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5TcGFjZSkuZXF1YWxzKG9sZE9wdGlvbnMubWluU3BhY2UgfHwgJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5TcGFjZSk7XG4gICAgfVxuICAgIHVwZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgIGxldCB7IG1pbkl0ZW1TaXplOiBtaW5JdGVtU2l6ZSA9ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWluSXRlbVNpemUsIG1heEl0ZW1TaXplOiBtYXhJdGVtU2l6ZSA9ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWF4SXRlbVNpemUsIHByZXNlcnZlQXNwZWN0UmF0aW86IHByZXNlcnZlQXNwZWN0UmF0aW8gPSAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLnByZXNlcnZlQXNwZWN0UmF0aW8sIG1pblNwYWNlOiBtaW5TcGFjZSA9ICRhNTg1OTJkMjk1YTE3MGE0JHZhciRERUZBVUxUX09QVElPTlMubWluU3BhY2UsIG1heENvbHVtbnM6IG1heENvbHVtbnMgPSAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLm1heENvbHVtbnMsIGRyb3BJbmRpY2F0b3JUaGlja25lc3M6IGRyb3BJbmRpY2F0b3JUaGlja25lc3MgPSAkYTU4NTkyZDI5NWExNzBhNCR2YXIkREVGQVVMVF9PUFRJT05TLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgfSA9IGludmFsaWRhdGlvbkNvbnRleHQubGF5b3V0T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzID0gZHJvcEluZGljYXRvclRoaWNrbmVzcztcbiAgICAgICAgbGV0IHZpc2libGVXaWR0aCA9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGg7XG4gICAgICAgIC8vIFRoZSBtYXggaXRlbSB3aWR0aCBpcyBhbHdheXMgdGhlIGVudGlyZSB2aWV3cG9ydC5cbiAgICAgICAgLy8gSWYgdGhlIG1heCBpdGVtIGhlaWdodCBpcyBpbmZpbml0eSwgc2NhbGUgaW4gcHJvcG9ydGlvbiB0byB0aGUgbWF4IHdpZHRoLlxuICAgICAgICBsZXQgbWF4SXRlbVdpZHRoID0gTWF0aC5taW4obWF4SXRlbVNpemUud2lkdGgsIHZpc2libGVXaWR0aCk7XG4gICAgICAgIGxldCBtYXhJdGVtSGVpZ2h0ID0gTnVtYmVyLmlzRmluaXRlKG1heEl0ZW1TaXplLmhlaWdodCkgPyBtYXhJdGVtU2l6ZS5oZWlnaHQgOiBNYXRoLmZsb29yKG1pbkl0ZW1TaXplLmhlaWdodCAvIG1pbkl0ZW1TaXplLndpZHRoICogbWF4SXRlbVdpZHRoKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgbmVlZGVkIHRvIGRpc3BsYXkgdGhlIGNvbnRlbnRcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBNYXRoLmZsb29yKHZpc2libGVXaWR0aCAvIChtaW5JdGVtU2l6ZS53aWR0aCArIG1pblNwYWNlLndpZHRoKSk7XG4gICAgICAgIGxldCBudW1Db2x1bW5zID0gTWF0aC5tYXgoMSwgTWF0aC5taW4obWF4Q29sdW1ucywgY29sdW1ucykpO1xuICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSBudW1Db2x1bW5zO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBhdmFpbGFibGUgd2lkdGggKG1pbnVzIHRoZSBzcGFjZSBiZXR3ZWVuIGl0ZW1zKVxuICAgICAgICBsZXQgd2lkdGggPSB2aXNpYmxlV2lkdGggLSBtaW5TcGFjZS53aWR0aCAqIE1hdGgubWF4KDAsIG51bUNvbHVtbnMpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBpdGVtIHdpZHRoIGJhc2VkIG9uIHRoZSBzcGFjZSBhdmFpbGFibGVcbiAgICAgICAgbGV0IGl0ZW1XaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyBudW1Db2x1bW5zKTtcbiAgICAgICAgaXRlbVdpZHRoID0gTWF0aC5tYXgobWluSXRlbVNpemUud2lkdGgsIE1hdGgubWluKG1heEl0ZW1XaWR0aCwgaXRlbVdpZHRoKSk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGl0ZW0gaGVpZ2h0LCB3aGljaCBpcyBwcm9wb3J0aW9uYWwgdG8gdGhlIGl0ZW0gd2lkdGhcbiAgICAgICAgbGV0IHQgPSAoaXRlbVdpZHRoIC0gbWluSXRlbVNpemUud2lkdGgpIC8gTWF0aC5tYXgoMSwgbWF4SXRlbVdpZHRoIC0gbWluSXRlbVNpemUud2lkdGgpO1xuICAgICAgICBsZXQgaXRlbUhlaWdodCA9IG1pbkl0ZW1TaXplLmhlaWdodCArIE1hdGguZmxvb3IoKG1heEl0ZW1IZWlnaHQgLSBtaW5JdGVtU2l6ZS5oZWlnaHQpICogdCk7XG4gICAgICAgIGl0ZW1IZWlnaHQgPSBNYXRoLm1heChtaW5JdGVtU2l6ZS5oZWlnaHQsIE1hdGgubWluKG1heEl0ZW1IZWlnaHQsIGl0ZW1IZWlnaHQpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaG9yaXpvbnRhbCBzcGFjaW5nIGFuZCBjb250ZW50IGhlaWdodFxuICAgICAgICBsZXQgaG9yaXpvbnRhbFNwYWNpbmcgPSBNYXRoLmZsb29yKCh2aXNpYmxlV2lkdGggLSBudW1Db2x1bW5zICogaXRlbVdpZHRoKSAvIChudW1Db2x1bW5zICsgMSkpO1xuICAgICAgICB0aGlzLmdhcCA9IG5ldyAoMCwgJGlwZ0tGJFNpemUpKGhvcml6b250YWxTcGFjaW5nLCBtaW5TcGFjZS5oZWlnaHQpO1xuICAgICAgICBsZXQgcm93cyA9IE1hdGguY2VpbCh0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb24uc2l6ZSAvIG51bUNvbHVtbnMpO1xuICAgICAgICBsZXQgaXRlcmF0b3IgPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb25bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBsZXQgeSA9IHJvd3MgPiAwID8gbWluU3BhY2UuaGVpZ2h0IDogMDtcbiAgICAgICAgbGV0IG5ld0xheW91dEluZm9zID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgc2tlbGV0b24gPSBudWxsO1xuICAgICAgICBsZXQgc2tlbGV0b25Db3VudCA9IDA7XG4gICAgICAgIGZvcihsZXQgcm93ID0gMDsgcm93IDwgcm93czsgcm93Kyspe1xuICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgcm93TGF5b3V0SW5mb3MgPSBbXTtcbiAgICAgICAgICAgIGZvcihsZXQgY29sID0gMDsgY29sIDwgbnVtQ29sdW1uczsgY29sKyspe1xuICAgICAgICAgICAgICAgIC8vIFJlcGVhdCBza2VsZXRvbiB1bnRpbCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJvdy5cbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHNrZWxldG9uIHx8IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdza2VsZXRvbicpIHNrZWxldG9uID0gbm9kZTtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gc2tlbGV0b24gPyBgJHtza2VsZXRvbi5rZXl9LSR7c2tlbGV0b25Db3VudCsrfWAgOiBub2RlLmtleTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbikgY29udGVudCA9IG9sZExheW91dEluZm8gJiYgb2xkTGF5b3V0SW5mby5jb250ZW50LmtleSA9PT0ga2V5ID8gb2xkTGF5b3V0SW5mby5jb250ZW50IDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5za2VsZXRvbixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCB4ID0gaG9yaXpvbnRhbFNwYWNpbmcgKyBjb2wgKiAoaXRlbVdpZHRoICsgaG9yaXpvbnRhbFNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBpdGVtSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCBlc3RpbWF0ZWRTaXplID0gIXByZXNlcnZlQXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgaWYgKG9sZExheW91dEluZm8gJiYgZXN0aW1hdGVkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBvbGRMYXlvdXRJbmZvLnJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBlc3RpbWF0ZWRTaXplID0gaW52YWxpZGF0aW9uQ29udGV4dC5sYXlvdXRPcHRpb25zQ2hhbmdlZCB8fCBpbnZhbGlkYXRpb25Db250ZXh0LnNpemVDaGFuZ2VkIHx8IG9sZExheW91dEluZm8uZXN0aW1hdGVkU2l6ZSB8fCBvbGRMYXlvdXRJbmZvLmNvbnRlbnQgIT09IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkaXBnS0YkUmVjdCkoeCwgeSwgaXRlbVdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkaXBnS0YkTGF5b3V0SW5mbykobm9kZS50eXBlLCBrZXksIHJlY3QpO1xuICAgICAgICAgICAgICAgIGxheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlZFNpemU7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mby5hbGxvd092ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsYXlvdXRJbmZvLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIG5ld0xheW91dEluZm9zLnNldChrZXksIGxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgIHJvd0xheW91dEluZm9zLnB1c2gobGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgobWF4SGVpZ2h0LCBsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGxheW91dEluZm8gb2Ygcm93TGF5b3V0SW5mb3MpbGF5b3V0SW5mby5yZWN0LmhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgICAgIHkgKz0gbWF4SGVpZ2h0ICsgbWluU3BhY2UuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gS2VlcCBhZGRpbmcgc2tlbGV0b24gcm93cyB1bnRpbCB3ZSBmaWxsIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgaWYgKHNrZWxldG9uICYmIHJvdyA9PT0gcm93cyAtIDEgJiYgeSA8IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QuaGVpZ2h0KSByb3dzKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXlvdXRJbmZvcyA9IG5ld0xheW91dEluZm9zO1xuICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gbmV3ICgwLCAkaXBnS0YkU2l6ZSkodGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCwgeSk7XG4gICAgfVxuICAgIGdldExheW91dEluZm8oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dEluZm9zLmdldChrZXkpO1xuICAgIH1cbiAgICBnZXRDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNpemU7XG4gICAgfVxuICAgIGdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIHRoaXMubGF5b3V0SW5mb3MudmFsdWVzKCkpaWYgKGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3RzKHJlY3QpIHx8IHRoaXMudmlydHVhbGl6ZXIuaXNQZXJzaXN0ZWRLZXkobGF5b3V0SW5mby5rZXkpKSBsYXlvdXRJbmZvcy5wdXNoKGxheW91dEluZm8pO1xuICAgICAgICByZXR1cm4gbGF5b3V0SW5mb3M7XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgIGlmICghc2l6ZSB8fCAhbGF5b3V0SW5mbykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc2l6ZS5oZWlnaHQgIT09IGxheW91dEluZm8ucmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdMYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBuZXdMYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBuZXdMYXlvdXRJbmZvLmVzdGltYXRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0SW5mb3Muc2V0KGtleSwgbmV3TGF5b3V0SW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldERyb3BUYXJnZXRGcm9tUG9pbnQoeCwgeSwgaXNWYWxpZERyb3BUYXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0SW5mb3Muc2l6ZSA9PT0gMCkgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdyb290J1xuICAgICAgICB9O1xuICAgICAgICB4ICs9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QueDtcbiAgICAgICAgeSArPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lnk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaXRlbSB3aXRoaW4gb24gZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW50IHVzaW5nIHRoZSBnYXAgd2lkdGguXG4gICAgICAgIGxldCBrZXkgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5udW1Db2x1bW5zID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmVjdCA9IG5ldyAoMCwgJGlwZ0tGJFJlY3QpKHgsIE1hdGgubWF4KDAsIHkgLSB0aGlzLmdhcC5oZWlnaHQpLCAxLCB0aGlzLmdhcC5oZWlnaHQgKiAyKTtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGVzID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3Moc2VhcmNoUmVjdCk7XG4gICAgICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKXtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaXRlbXMgb3V0c2lkZSB0aGUgc2VhcmNoIHJlY3QsIGUuZy4gcGVyc2lzdGVkIGtleXMuXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUucmVjdC5pbnRlcnNlY3RzKHNlYXJjaFJlY3QpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgeURpc3QgPSBNYXRoLmFicyhjYW5kaWRhdGUucmVjdC55IC0geSk7XG4gICAgICAgICAgICAgICAgbGV0IG1heFlEaXN0ID0gTWF0aC5hYnMoY2FuZGlkYXRlLnJlY3QubWF4WSAtIHkpO1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5taW4oeURpc3QsIG1heFlEaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlLmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmVjdCA9IG5ldyAoMCwgJGlwZ0tGJFJlY3QpKE1hdGgubWF4KDAsIHggLSB0aGlzLmdhcC53aWR0aCksIHksIHRoaXMuZ2FwLndpZHRoICogMiwgMSk7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlcyA9IHRoaXMuZ2V0VmlzaWJsZUxheW91dEluZm9zKHNlYXJjaFJlY3QpO1xuICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcyl7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGl0ZW1zIG91dHNpZGUgdGhlIHNlYXJjaCByZWN0LCBlLmcuIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlLnJlY3QuaW50ZXJzZWN0cyhzZWFyY2hSZWN0KSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHhEaXN0ID0gTWF0aC5hYnMoY2FuZGlkYXRlLnJlY3QueCAtIHgpO1xuICAgICAgICAgICAgICAgIGxldCBtYXhYRGlzdCA9IE1hdGguYWJzKGNhbmRpZGF0ZS5yZWN0Lm1heFggLSB4KTtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWluKHhEaXN0LCBtYXhYRGlzdCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZS5rZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0ga2V5ICE9IG51bGwgPyB0aGlzLmdldExheW91dEluZm8oa2V5KSA6IG51bGw7XG4gICAgICAgIGlmICghbGF5b3V0SW5mbykgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdyb290J1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdGFyZ2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogJ2l0ZW0nLFxuICAgICAgICAgICAga2V5OiBsYXlvdXRJbmZvLmtleSxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ29uJ1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5udW1Db2x1bW5zID09PSAxID8geSA6IHg7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvUG9zID0gdGhpcy5udW1Db2x1bW5zID09PSAxID8gbGF5b3V0SW5mby5yZWN0LnkgOiBsYXlvdXRJbmZvLnJlY3QueDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm51bUNvbHVtbnMgPT09IDEgPyBsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0IDogbGF5b3V0SW5mby5yZWN0LndpZHRoO1xuICAgICAgICBpZiAoaXNWYWxpZERyb3BUYXJnZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgLy8gSWYgZHJvcHBpbmcgb24gdGhlIGl0ZW0gaXMgYWNjZXB0ZWQsIHRyeSB0aGUgYmVmb3JlL2FmdGVyIHBvc2l0aW9uc1xuICAgICAgICAgICAgLy8gaWYgd2l0aGluIDVweCBvZiB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBpdGVtLlxuICAgICAgICAgICAgaWYgKHBvcyA8IGxheW91dEluZm9Qb3MgKyA1KSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2JlZm9yZSc7XG4gICAgICAgICAgICBlbHNlIGlmIChwb3MgPiBsYXlvdXRJbmZvUG9zICsgc2l6ZSAtIDUpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYWZ0ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgZHJvcHBpbmcgb24gdGhlIGl0ZW0gaXNuJ3QgYWNjZXB0ZWQsIHRyeSB0aGUgdGFyZ2V0IGJlZm9yZSBvciBhZnRlciBkZXBlbmRpbmcgb24gdGhlIHBvc2l0aW9uLlxuICAgICAgICAgICAgbGV0IG1pZCA9IGxheW91dEluZm9Qb3MgKyBzaXplIC8gMjtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gbWlkICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYmVmb3JlJ1xuICAgICAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYmVmb3JlJztcbiAgICAgICAgICAgIGVsc2UgaWYgKHBvcyA+PSBtaWQgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICBkcm9wUG9zaXRpb246ICdhZnRlcidcbiAgICAgICAgICAgIH0pKSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBnZXREcm9wVGFyZ2V0TGF5b3V0SW5mbyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8odGFyZ2V0LmtleSk7XG4gICAgICAgIGxldCByZWN0O1xuICAgICAgICBpZiAodGhpcy5udW1Db2x1bW5zID09PSAxKSAvLyBGbGlwIGZyb20gdmVydGljYWwgdG8gaG9yaXpvbnRhbCBpZiBvbmx5IG9uZSBjb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgICAgcmVjdCA9IG5ldyAoMCwgJGlwZ0tGJFJlY3QpKGxheW91dEluZm8ucmVjdC54LCB0YXJnZXQuZHJvcFBvc2l0aW9uID09PSAnYmVmb3JlJyA/IGxheW91dEluZm8ucmVjdC55IC0gdGhpcy5nYXAuaGVpZ2h0IC8gMiAtIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyAvIDIgOiBsYXlvdXRJbmZvLnJlY3QubWF4WSArIHRoaXMuZ2FwLmhlaWdodCAvIDIgLSB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgLyAyLCBsYXlvdXRJbmZvLnJlY3Qud2lkdGgsIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyk7XG4gICAgICAgIGVsc2UgcmVjdCA9IG5ldyAoMCwgJGlwZ0tGJFJlY3QpKHRhcmdldC5kcm9wUG9zaXRpb24gPT09ICdiZWZvcmUnID8gbGF5b3V0SW5mby5yZWN0LnggLSB0aGlzLmdhcC53aWR0aCAvIDIgLSB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgLyAyIDogbGF5b3V0SW5mby5yZWN0Lm1heFggKyB0aGlzLmdhcC53aWR0aCAvIDIgLSB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgLyAyLCBsYXlvdXRJbmZvLnJlY3QueSwgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzLCBsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGlwZ0tGJExheW91dEluZm8pKCdkcm9wSW5kaWNhdG9yJywgdGFyZ2V0LmtleSArICc6JyArIHRhcmdldC5kcm9wUG9zaXRpb24sIHJlY3QpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyksIHRoaXMuZ2FwID0gJGE1ODU5MmQyOTVhMTcwYTQkdmFyJERFRkFVTFRfT1BUSU9OUy5taW5TcGFjZSwgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzID0gMiwgdGhpcy5udW1Db2x1bW5zID0gMCwgdGhpcy5jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGlwZ0tGJFNpemUpKCksIHRoaXMubGF5b3V0SW5mb3MgPSBuZXcgTWFwKCk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7JGE1ODU5MmQyOTVhMTcwYTQkZXhwb3J0JDdkMmIxMjU3ODE1NGE3MzUgYXMgR3JpZExheW91dH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmlkTGF5b3V0Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs":
/*!*********************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs ***!
  \*********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListLayout: () => (/* binding */ $61ef60fc9b1041f4$export$cacbb3924155d68e)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/collections */ \"../../../../node_modules/.pnpm/@react-stately+collections@3.12.2_react@19.0.0/node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/virtualizer */ \"../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;\nclass $61ef60fc9b1041f4$export$cacbb3924155d68e extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Layout) {\n    // Backward compatibility for subclassing.\n    get collection() {\n        return this.virtualizer.collection;\n    }\n    getLayoutInfo(key) {\n        var _this_layoutNodes_get;\n        this.ensureLayoutInfo(key);\n        return ((_this_layoutNodes_get = this.layoutNodes.get(key)) === null || _this_layoutNodes_get === void 0 ? void 0 : _this_layoutNodes_get.layoutInfo) || null;\n    }\n    getVisibleLayoutInfos(rect) {\n        // Adjust rect to keep number of visible rows consistent.\n        // (only if height > 1 for getDropTargetFromPoint)\n        if (rect.height > 1) {\n            var _this_rowHeight, _ref;\n            let rowHeight = ((_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT) + this.gap;\n            rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n            rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n        }\n        // If layout hasn't yet been done for the requested rect, union the\n        // new rect with the existing valid rect, and recompute.\n        this.layoutIfNeeded(rect);\n        let res = [];\n        let addNodes = (nodes)=>{\n            for (let node of nodes)if (this.isVisible(node, rect)) {\n                res.push(node.layoutInfo);\n                if (node.children) addNodes(node.children);\n            }\n        };\n        addNodes(this.rootNodes);\n        return res;\n    }\n    layoutIfNeeded(rect) {\n        if (!this.lastCollection) return;\n        if (!this.requestedRect.containsRect(rect)) {\n            this.requestedRect = this.requestedRect.union(rect);\n            this.rootNodes = this.buildCollection();\n        }\n        // Ensure all of the persisted keys are available.\n        for (let key of this.virtualizer.persistedKeys){\n            if (this.ensureLayoutInfo(key)) return;\n        }\n    }\n    ensureLayoutInfo(key) {\n        // If the layout info wasn't found, it might be outside the bounds of the area that we've\n        // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n        // Compute the full layout and try again.\n        if (!this.layoutNodes.has(key) && this.requestedRect.area < this.contentSize.area && this.lastCollection) {\n            this.requestedRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, 0, Infinity, Infinity);\n            this.rootNodes = this.buildCollection();\n            this.requestedRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, 0, this.contentSize.width, this.contentSize.height);\n            return true;\n        }\n        return false;\n    }\n    isVisible(node, rect) {\n        return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || node.layoutInfo.type === 'header' || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n    }\n    shouldInvalidateEverything(invalidationContext) {\n        // Invalidate cache if the size of the collection changed.\n        // In this case, we need to recalculate the entire layout.\n        // Also invalidate if fixed sizes/gaps change.\n        let options = invalidationContext.layoutOptions;\n        var _options_rowHeight, _options_headingHeight, _options_loaderHeight, _options_gap, _options_padding;\n        return invalidationContext.sizeChanged || this.rowHeight !== ((_options_rowHeight = options === null || options === void 0 ? void 0 : options.rowHeight) !== null && _options_rowHeight !== void 0 ? _options_rowHeight : this.rowHeight) || this.headingHeight !== ((_options_headingHeight = options === null || options === void 0 ? void 0 : options.headingHeight) !== null && _options_headingHeight !== void 0 ? _options_headingHeight : this.headingHeight) || this.loaderHeight !== ((_options_loaderHeight = options === null || options === void 0 ? void 0 : options.loaderHeight) !== null && _options_loaderHeight !== void 0 ? _options_loaderHeight : this.loaderHeight) || this.gap !== ((_options_gap = options === null || options === void 0 ? void 0 : options.gap) !== null && _options_gap !== void 0 ? _options_gap : this.gap) || this.padding !== ((_options_padding = options === null || options === void 0 ? void 0 : options.padding) !== null && _options_padding !== void 0 ? _options_padding : this.padding);\n    }\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.rowHeight !== oldOptions.rowHeight || newOptions.estimatedRowHeight !== oldOptions.estimatedRowHeight || newOptions.headingHeight !== oldOptions.headingHeight || newOptions.estimatedHeadingHeight !== oldOptions.estimatedHeadingHeight || newOptions.loaderHeight !== oldOptions.loaderHeight || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness || newOptions.gap !== oldOptions.gap || newOptions.padding !== oldOptions.padding;\n    }\n    update(invalidationContext) {\n        let collection = this.virtualizer.collection;\n        // Reset valid rect if we will have to invalidate everything.\n        // Otherwise we can reuse cached layout infos outside the current visible rect.\n        this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n        if (this.invalidateEverything) {\n            this.requestedRect = this.virtualizer.visibleRect.copy();\n            this.layoutNodes.clear();\n        }\n        let options = invalidationContext.layoutOptions;\n        var _options_rowHeight;\n        this.rowHeight = (_options_rowHeight = options === null || options === void 0 ? void 0 : options.rowHeight) !== null && _options_rowHeight !== void 0 ? _options_rowHeight : this.rowHeight;\n        var _options_estimatedRowHeight;\n        this.estimatedRowHeight = (_options_estimatedRowHeight = options === null || options === void 0 ? void 0 : options.estimatedRowHeight) !== null && _options_estimatedRowHeight !== void 0 ? _options_estimatedRowHeight : this.estimatedRowHeight;\n        var _options_headingHeight;\n        this.headingHeight = (_options_headingHeight = options === null || options === void 0 ? void 0 : options.headingHeight) !== null && _options_headingHeight !== void 0 ? _options_headingHeight : this.headingHeight;\n        var _options_estimatedHeadingHeight;\n        this.estimatedHeadingHeight = (_options_estimatedHeadingHeight = options === null || options === void 0 ? void 0 : options.estimatedHeadingHeight) !== null && _options_estimatedHeadingHeight !== void 0 ? _options_estimatedHeadingHeight : this.estimatedHeadingHeight;\n        var _options_loaderHeight;\n        this.loaderHeight = (_options_loaderHeight = options === null || options === void 0 ? void 0 : options.loaderHeight) !== null && _options_loaderHeight !== void 0 ? _options_loaderHeight : this.loaderHeight;\n        var _options_dropIndicatorThickness;\n        this.dropIndicatorThickness = (_options_dropIndicatorThickness = options === null || options === void 0 ? void 0 : options.dropIndicatorThickness) !== null && _options_dropIndicatorThickness !== void 0 ? _options_dropIndicatorThickness : this.dropIndicatorThickness;\n        var _options_gap;\n        this.gap = (_options_gap = options === null || options === void 0 ? void 0 : options.gap) !== null && _options_gap !== void 0 ? _options_gap : this.gap;\n        var _options_padding;\n        this.padding = (_options_padding = options === null || options === void 0 ? void 0 : options.padding) !== null && _options_padding !== void 0 ? _options_padding : this.padding;\n        this.rootNodes = this.buildCollection();\n        // Remove deleted layout nodes\n        if (this.lastCollection && collection !== this.lastCollection) {\n            for (let key of this.lastCollection.getKeys())if (!collection.getItem(key)) {\n                let layoutNode = this.layoutNodes.get(key);\n                if (layoutNode) this.layoutNodes.delete(key);\n            }\n        }\n        this.lastCollection = collection;\n        this.invalidateEverything = false;\n        this.validRect = this.requestedRect.copy();\n    }\n    buildCollection(y = this.padding) {\n        let collection = this.virtualizer.collection;\n        let skipped = 0;\n        let nodes = [];\n        for (let node of collection){\n            var _this_rowHeight, _ref;\n            let rowHeight = ((_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT) + this.gap;\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (node.type === 'item' && y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(node, this.padding, y, null);\n            y = layoutNode.layoutInfo.rect.maxY + this.gap;\n            nodes.push(layoutNode);\n            if (node.type === 'item' && y > this.requestedRect.maxY) {\n                y += (collection.size - (nodes.length + skipped)) * rowHeight;\n                break;\n            }\n        }\n        y -= this.gap;\n        y += this.padding;\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(this.virtualizer.visibleRect.width, y);\n        return nodes;\n    }\n    isValid(node, y) {\n        let cached = this.layoutNodes.get(node.key);\n        return !this.invalidateEverything && cached && cached.node === node && y === cached.layoutInfo.rect.y && cached.layoutInfo.rect.intersects(this.validRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.requestedRect));\n    }\n    buildChild(node, x, y, parentKey) {\n        if (this.isValid(node, y)) return this.layoutNodes.get(node.key);\n        let layoutNode = this.buildNode(node, x, y);\n        layoutNode.layoutInfo.parentKey = parentKey !== null && parentKey !== void 0 ? parentKey : null;\n        this.layoutNodes.set(node.key, layoutNode);\n        return layoutNode;\n    }\n    buildNode(node, x, y) {\n        switch(node.type){\n            case 'section':\n                return this.buildSection(node, x, y);\n            case 'item':\n                return this.buildItem(node, x, y);\n            case 'header':\n                return this.buildSectionHeader(node, x, y);\n            case 'loader':\n                return this.buildLoader(node, x, y);\n            default:\n                throw new Error('Unsupported node type: ' + node.type);\n        }\n    }\n    buildLoader(node, x, y) {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, this.padding, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('loader', node.key, rect);\n        rect.width = this.virtualizer.contentSize.width - this.padding - x;\n        rect.height = this.loaderHeight || this.rowHeight || this.estimatedRowHeight || $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        return {\n            layoutInfo: layoutInfo,\n            validRect: rect.intersection(this.requestedRect)\n        };\n    }\n    buildSection(node, x, y) {\n        let collection = this.virtualizer.collection;\n        let width = this.virtualizer.visibleRect.width - this.padding;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width - x, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        let startY = y;\n        let skipped = 0;\n        let children = [];\n        for (let child of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(node, collection)){\n            var _this_rowHeight, _ref;\n            let rowHeight = ((_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $61ef60fc9b1041f4$var$DEFAULT_HEIGHT) + this.gap;\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n            y = layoutNode.layoutInfo.rect.maxY + this.gap;\n            children.push(layoutNode);\n            if (y > this.requestedRect.maxY) {\n                // Estimate the remaining height for rows that we don't need to layout right now.\n                y += ([\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(node, collection)\n                ].length - (children.length + skipped)) * rowHeight;\n                break;\n            }\n        }\n        y -= this.gap;\n        rect.height = y - startY;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect.intersection(this.requestedRect),\n            node: node\n        };\n    }\n    buildSectionHeader(node, x, y) {\n        let width = this.virtualizer.visibleRect.width - this.padding;\n        let rectHeight = this.headingHeight;\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (rectHeight == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall virtualizer changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            let previousLayoutInfo = previousLayoutNode === null || previousLayoutNode === void 0 ? void 0 : previousLayoutNode.layoutInfo;\n            if (previousLayoutInfo) {\n                let curNode = this.virtualizer.collection.getItem(node.key);\n                let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n                rectHeight = previousLayoutInfo.rect.height;\n                isEstimated = width !== previousLayoutInfo.rect.width || curNode !== lastNode || previousLayoutInfo.estimatedSize;\n            } else {\n                rectHeight = node.rendered ? this.estimatedHeadingHeight : 0;\n                isEstimated = true;\n            }\n        }\n        if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        let headerRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width - x, rectHeight);\n        let header = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('header', node.key, headerRect);\n        header.estimatedSize = isEstimated;\n        return {\n            layoutInfo: header,\n            children: [],\n            validRect: header.rect.intersection(this.requestedRect),\n            node: node\n        };\n    }\n    buildItem(node, x, y) {\n        let width = this.virtualizer.visibleRect.width - this.padding - x;\n        let rectHeight = this.rowHeight;\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (rectHeight == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall virtualizer changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            if (previousLayoutNode) {\n                rectHeight = previousLayoutNode.layoutInfo.rect.height;\n                isEstimated = width !== previousLayoutNode.layoutInfo.rect.width || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n            } else {\n                rectHeight = this.estimatedRowHeight;\n                isEstimated = true;\n            }\n        }\n        if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width, rectHeight);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            children: [],\n            validRect: layoutInfo.rect,\n            node: node\n        };\n    }\n    updateItemSize(key, size) {\n        let layoutNode = this.layoutNodes.get(key);\n        // If no layoutInfo, item has been deleted/removed.\n        if (!layoutNode) return false;\n        let collection = this.virtualizer.collection;\n        let layoutInfo = layoutNode.layoutInfo;\n        layoutInfo.estimatedSize = false;\n        if (layoutInfo.rect.height !== size.height) {\n            // Copy layout info rather than mutating so that later caches are invalidated.\n            let newLayoutInfo = layoutInfo.copy();\n            newLayoutInfo.rect.height = size.height;\n            layoutNode.layoutInfo = newLayoutInfo;\n            // Items after this layoutInfo will need to be repositioned to account for the new height.\n            // Adjust the validRect so that only items above remain valid.\n            this.validRect.height = Math.min(this.validRect.height, layoutInfo.rect.y - this.validRect.y);\n            // The requestedRect also needs to be adjusted to account for the height difference.\n            this.requestedRect.height += newLayoutInfo.rect.height - layoutInfo.rect.height;\n            // Invalidate layout for this layout node and all parents\n            this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n            let node = layoutInfo.parentKey != null ? collection.getItem(layoutInfo.parentKey) : null;\n            while(node){\n                this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n                node = node.parentKey != null ? collection.getItem(node.parentKey) : null;\n            }\n            return true;\n        }\n        return false;\n    }\n    updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {\n        let n = this.layoutNodes.get(key);\n        if (n) {\n            // Invalidate by intersecting the validRect of this node with the overall validRect.\n            n.validRect = n.validRect.intersection(this.validRect);\n            // Replace layout info in LayoutNode\n            if (n.layoutInfo === oldLayoutInfo) n.layoutInfo = newLayoutInfo;\n        }\n    }\n    getContentSize() {\n        return this.contentSize;\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        // Find the closest item within on either side of the point using the gap width.\n        let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, Math.max(0, y - this.gap), 1, this.gap * 2);\n        let candidates = this.getVisibleLayoutInfos(searchRect);\n        let key = null;\n        let minDistance = Infinity;\n        for (let candidate of candidates){\n            // Ignore items outside the search rect, e.g. persisted keys.\n            if (!candidate.rect.intersects(searchRect)) continue;\n            let yDist = Math.abs(candidate.rect.y - y);\n            let maxYDist = Math.abs(candidate.rect.maxY - y);\n            let dist = Math.min(yDist, maxYDist);\n            if (dist < minDistance) {\n                minDistance = dist;\n                key = candidate.key;\n            }\n        }\n        if (key == null || this.virtualizer.collection.size === 0) return {\n            type: 'root'\n        };\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = layoutInfo.rect;\n        let target = {\n            type: 'item',\n            key: layoutInfo.key,\n            dropPosition: 'on'\n        };\n        // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n        // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n        // of the top or bottom of the item.\n        if (!isValidDropTarget(target)) {\n            if (y <= rect.y + rect.height / 2 && isValidDropTarget({\n                ...target,\n                dropPosition: 'before'\n            })) target.dropPosition = 'before';\n            else if (isValidDropTarget({\n                ...target,\n                dropPosition: 'after'\n            })) target.dropPosition = 'after';\n        } else if (y <= rect.y + 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'before'\n        })) target.dropPosition = 'before';\n        else if (y >= rect.maxY - 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'after'\n        })) target.dropPosition = 'after';\n        return target;\n    }\n    getDropTargetLayoutInfo(target) {\n        let layoutInfo = this.getLayoutInfo(target.key);\n        let rect;\n        if (target.dropPosition === 'before') rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.x, layoutInfo.rect.y - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n        else if (target.dropPosition === 'after') rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.x, layoutInfo.rect.maxY - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n        else rect = layoutInfo.rect;\n        return new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)('dropIndicator', target.key + ':' + target.dropPosition, rect);\n    }\n    /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */ constructor(options = {}){\n        super();\n        var _options_rowHeight;\n        this.rowHeight = (_options_rowHeight = options.rowHeight) !== null && _options_rowHeight !== void 0 ? _options_rowHeight : null;\n        var _options_estimatedRowHeight;\n        this.estimatedRowHeight = (_options_estimatedRowHeight = options.estimatedRowHeight) !== null && _options_estimatedRowHeight !== void 0 ? _options_estimatedRowHeight : null;\n        var _options_headingHeight;\n        this.headingHeight = (_options_headingHeight = options.headingHeight) !== null && _options_headingHeight !== void 0 ? _options_headingHeight : null;\n        var _options_estimatedHeadingHeight;\n        this.estimatedHeadingHeight = (_options_estimatedHeadingHeight = options.estimatedHeadingHeight) !== null && _options_estimatedHeadingHeight !== void 0 ? _options_estimatedHeadingHeight : null;\n        var _options_loaderHeight;\n        this.loaderHeight = (_options_loaderHeight = options.loaderHeight) !== null && _options_loaderHeight !== void 0 ? _options_loaderHeight : null;\n        this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n        this.gap = options.gap || 0;\n        this.padding = options.padding || 0;\n        this.layoutNodes = new Map();\n        this.rootNodes = [];\n        this.lastCollection = null;\n        this.invalidateEverything = false;\n        this.validRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)();\n        this.requestedRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)();\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)();\n    }\n}\n\n\n\n//# sourceMappingURL=ListLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9MaXN0TGF5b3V0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUY7QUFDNkQ7O0FBRTlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsOERBQWE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0REFBVztBQUNwRDtBQUNBLHlDQUF5Qyw0REFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBVztBQUN0QyxpQ0FBaUMsa0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDLGlDQUFpQyxrRUFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFFQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQVc7QUFDNUMsNkJBQTZCLGtFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBVztBQUN0QyxpQ0FBaUMsa0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDREQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDREQUFXO0FBQ3hFLGlFQUFpRSw0REFBVztBQUM1RTtBQUNBLHVCQUF1QixrRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDREQUFXO0FBQzVDLHFDQUFxQyw0REFBVztBQUNoRCxtQ0FBbUMsNERBQVc7QUFDOUM7QUFDQTs7O0FBR2lFO0FBQ2pFIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVhY3Qtc3RhdGVseStsYXlvdXRANC4yLjFfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGF5b3V0L2Rpc3QvTGlzdExheW91dC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRpbWcyNiRnZXRDaGlsZE5vZGVzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7UmVjdCBhcyAkaW1nMjYkUmVjdCwgU2l6ZSBhcyAkaW1nMjYkU2l6ZSwgTGF5b3V0SW5mbyBhcyAkaW1nMjYkTGF5b3V0SW5mbywgTGF5b3V0IGFzICRpbWcyNiRMYXlvdXR9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplclwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQ2MWVmNjBmYzliMTA0MWY0JHZhciRERUZBVUxUX0hFSUdIVCA9IDQ4O1xuY2xhc3MgJDYxZWY2MGZjOWIxMDQxZjQkZXhwb3J0JGNhY2JiMzkyNDE1NWQ2OGUgZXh0ZW5kcyAoMCwgJGltZzI2JExheW91dCkge1xuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHN1YmNsYXNzaW5nLlxuICAgIGdldCBjb2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBnZXRMYXlvdXRJbmZvKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0O1xuICAgICAgICB0aGlzLmVuc3VyZUxheW91dEluZm8oa2V5KTtcbiAgICAgICAgcmV0dXJuICgoX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0ID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3RoaXNfbGF5b3V0Tm9kZXNfZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19sYXlvdXROb2Rlc19nZXQubGF5b3V0SW5mbykgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpIHtcbiAgICAgICAgLy8gQWRqdXN0IHJlY3QgdG8ga2VlcCBudW1iZXIgb2YgdmlzaWJsZSByb3dzIGNvbnNpc3RlbnQuXG4gICAgICAgIC8vIChvbmx5IGlmIGhlaWdodCA+IDEgZm9yIGdldERyb3BUYXJnZXRGcm9tUG9pbnQpXG4gICAgICAgIGlmIChyZWN0LmhlaWdodCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBfdGhpc19yb3dIZWlnaHQsIF9yZWY7XG4gICAgICAgICAgICBsZXQgcm93SGVpZ2h0ID0gKChfcmVmID0gKF90aGlzX3Jvd0hlaWdodCA9IHRoaXMucm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpc19yb3dIZWlnaHQgIT09IHZvaWQgMCA/IF90aGlzX3Jvd0hlaWdodCA6IHRoaXMuZXN0aW1hdGVkUm93SGVpZ2h0KSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogJDYxZWY2MGZjOWIxMDQxZjQkdmFyJERFRkFVTFRfSEVJR0hUKSArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgcmVjdC55ID0gTWF0aC5mbG9vcihyZWN0LnkgLyByb3dIZWlnaHQpICogcm93SGVpZ2h0O1xuICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBNYXRoLmNlaWwocmVjdC5oZWlnaHQgLyByb3dIZWlnaHQpICogcm93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGxheW91dCBoYXNuJ3QgeWV0IGJlZW4gZG9uZSBmb3IgdGhlIHJlcXVlc3RlZCByZWN0LCB1bmlvbiB0aGVcbiAgICAgICAgLy8gbmV3IHJlY3Qgd2l0aCB0aGUgZXhpc3RpbmcgdmFsaWQgcmVjdCwgYW5kIHJlY29tcHV0ZS5cbiAgICAgICAgdGhpcy5sYXlvdXRJZk5lZWRlZChyZWN0KTtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBsZXQgYWRkTm9kZXMgPSAobm9kZXMpPT57XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKWlmICh0aGlzLmlzVmlzaWJsZShub2RlLCByZWN0KSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIGFkZE5vZGVzKG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhZGROb2Rlcyh0aGlzLnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGxheW91dElmTmVlZGVkKHJlY3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RDb2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0ZWRSZWN0LmNvbnRhaW5zUmVjdChyZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZWN0ID0gdGhpcy5yZXF1ZXN0ZWRSZWN0LnVuaW9uKHJlY3QpO1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZXMgPSB0aGlzLmJ1aWxkQ29sbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBhbGwgb2YgdGhlIHBlcnNpc3RlZCBrZXlzIGFyZSBhdmFpbGFibGUuXG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnZpcnR1YWxpemVyLnBlcnNpc3RlZEtleXMpe1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5zdXJlTGF5b3V0SW5mbyhrZXkpKSByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5zdXJlTGF5b3V0SW5mbyhrZXkpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxheW91dCBpbmZvIHdhc24ndCBmb3VuZCwgaXQgbWlnaHQgYmUgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSBhcmVhIHRoYXQgd2UndmVcbiAgICAgICAgLy8gY29tcHV0ZWQgbGF5b3V0IGZvciBzbyBmYXIuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGFjY2Vzc2luZyBhIHJhbmRvbSBrZXksIGUuZyBwcmVzc2luZyBIb21lL0VuZC5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZnVsbCBsYXlvdXQgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgaWYgKCF0aGlzLmxheW91dE5vZGVzLmhhcyhrZXkpICYmIHRoaXMucmVxdWVzdGVkUmVjdC5hcmVhIDwgdGhpcy5jb250ZW50U2l6ZS5hcmVhICYmIHRoaXMubGFzdENvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVkUmVjdCA9IG5ldyAoMCwgJGltZzI2JFJlY3QpKDAsIDAsIEluZmluaXR5LCBJbmZpbml0eSk7XG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHRoaXMuYnVpbGRDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlZFJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KSgwLCAwLCB0aGlzLmNvbnRlbnRTaXplLndpZHRoLCB0aGlzLmNvbnRlbnRTaXplLmhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzVmlzaWJsZShub2RlLCByZWN0KSB7XG4gICAgICAgIHJldHVybiBub2RlLmxheW91dEluZm8ucmVjdC5pbnRlcnNlY3RzKHJlY3QpIHx8IG5vZGUubGF5b3V0SW5mby5pc1N0aWNreSB8fCBub2RlLmxheW91dEluZm8udHlwZSA9PT0gJ2hlYWRlcicgfHwgdGhpcy52aXJ0dWFsaXplci5pc1BlcnNpc3RlZEtleShub2RlLmxheW91dEluZm8ua2V5KTtcbiAgICB9XG4gICAgc2hvdWxkSW52YWxpZGF0ZUV2ZXJ5dGhpbmcoaW52YWxpZGF0aW9uQ29udGV4dCkge1xuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIGlmIHRoZSBzaXplIG9mIHRoZSBjb2xsZWN0aW9uIGNoYW5nZWQuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgZW50aXJlIGxheW91dC5cbiAgICAgICAgLy8gQWxzbyBpbnZhbGlkYXRlIGlmIGZpeGVkIHNpemVzL2dhcHMgY2hhbmdlLlxuICAgICAgICBsZXQgb3B0aW9ucyA9IGludmFsaWRhdGlvbkNvbnRleHQubGF5b3V0T3B0aW9ucztcbiAgICAgICAgdmFyIF9vcHRpb25zX3Jvd0hlaWdodCwgX29wdGlvbnNfaGVhZGluZ0hlaWdodCwgX29wdGlvbnNfbG9hZGVySGVpZ2h0LCBfb3B0aW9uc19nYXAsIF9vcHRpb25zX3BhZGRpbmc7XG4gICAgICAgIHJldHVybiBpbnZhbGlkYXRpb25Db250ZXh0LnNpemVDaGFuZ2VkIHx8IHRoaXMucm93SGVpZ2h0ICE9PSAoKF9vcHRpb25zX3Jvd0hlaWdodCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3dIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX3Jvd0hlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfcm93SGVpZ2h0IDogdGhpcy5yb3dIZWlnaHQpIHx8IHRoaXMuaGVhZGluZ0hlaWdodCAhPT0gKChfb3B0aW9uc19oZWFkaW5nSGVpZ2h0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRpbmdIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgOiB0aGlzLmhlYWRpbmdIZWlnaHQpIHx8IHRoaXMubG9hZGVySGVpZ2h0ICE9PSAoKF9vcHRpb25zX2xvYWRlckhlaWdodCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2FkZXJIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2xvYWRlckhlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfbG9hZGVySGVpZ2h0IDogdGhpcy5sb2FkZXJIZWlnaHQpIHx8IHRoaXMuZ2FwICE9PSAoKF9vcHRpb25zX2dhcCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nYXApICE9PSBudWxsICYmIF9vcHRpb25zX2dhcCAhPT0gdm9pZCAwID8gX29wdGlvbnNfZ2FwIDogdGhpcy5nYXApIHx8IHRoaXMucGFkZGluZyAhPT0gKChfb3B0aW9uc19wYWRkaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZGRpbmcpICE9PSBudWxsICYmIF9vcHRpb25zX3BhZGRpbmcgIT09IHZvaWQgMCA/IF9vcHRpb25zX3BhZGRpbmcgOiB0aGlzLnBhZGRpbmcpO1xuICAgIH1cbiAgICBzaG91bGRJbnZhbGlkYXRlTGF5b3V0T3B0aW9ucyhuZXdPcHRpb25zLCBvbGRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zLnJvd0hlaWdodCAhPT0gb2xkT3B0aW9ucy5yb3dIZWlnaHQgfHwgbmV3T3B0aW9ucy5lc3RpbWF0ZWRSb3dIZWlnaHQgIT09IG9sZE9wdGlvbnMuZXN0aW1hdGVkUm93SGVpZ2h0IHx8IG5ld09wdGlvbnMuaGVhZGluZ0hlaWdodCAhPT0gb2xkT3B0aW9ucy5oZWFkaW5nSGVpZ2h0IHx8IG5ld09wdGlvbnMuZXN0aW1hdGVkSGVhZGluZ0hlaWdodCAhPT0gb2xkT3B0aW9ucy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0IHx8IG5ld09wdGlvbnMubG9hZGVySGVpZ2h0ICE9PSBvbGRPcHRpb25zLmxvYWRlckhlaWdodCB8fCBuZXdPcHRpb25zLmRyb3BJbmRpY2F0b3JUaGlja25lc3MgIT09IG9sZE9wdGlvbnMuZHJvcEluZGljYXRvclRoaWNrbmVzcyB8fCBuZXdPcHRpb25zLmdhcCAhPT0gb2xkT3B0aW9ucy5nYXAgfHwgbmV3T3B0aW9ucy5wYWRkaW5nICE9PSBvbGRPcHRpb25zLnBhZGRpbmc7XG4gICAgfVxuICAgIHVwZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgICAgICAvLyBSZXNldCB2YWxpZCByZWN0IGlmIHdlIHdpbGwgaGF2ZSB0byBpbnZhbGlkYXRlIGV2ZXJ5dGhpbmcuXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW4gcmV1c2UgY2FjaGVkIGxheW91dCBpbmZvcyBvdXRzaWRlIHRoZSBjdXJyZW50IHZpc2libGUgcmVjdC5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlRXZlcnl0aGluZyA9IHRoaXMuc2hvdWxkSW52YWxpZGF0ZUV2ZXJ5dGhpbmcoaW52YWxpZGF0aW9uQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmludmFsaWRhdGVFdmVyeXRoaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlZFJlY3QgPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LmNvcHkoKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Tm9kZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW9ucyA9IGludmFsaWRhdGlvbkNvbnRleHQubGF5b3V0T3B0aW9ucztcbiAgICAgICAgdmFyIF9vcHRpb25zX3Jvd0hlaWdodDtcbiAgICAgICAgdGhpcy5yb3dIZWlnaHQgPSAoX29wdGlvbnNfcm93SGVpZ2h0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvd0hlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfcm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19yb3dIZWlnaHQgOiB0aGlzLnJvd0hlaWdodDtcbiAgICAgICAgdmFyIF9vcHRpb25zX2VzdGltYXRlZFJvd0hlaWdodDtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQgPSAoX29wdGlvbnNfZXN0aW1hdGVkUm93SGVpZ2h0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVzdGltYXRlZFJvd0hlaWdodCkgIT09IG51bGwgJiYgX29wdGlvbnNfZXN0aW1hdGVkUm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19lc3RpbWF0ZWRSb3dIZWlnaHQgOiB0aGlzLmVzdGltYXRlZFJvd0hlaWdodDtcbiAgICAgICAgdmFyIF9vcHRpb25zX2hlYWRpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuaGVhZGluZ0hlaWdodCA9IChfb3B0aW9uc19oZWFkaW5nSGVpZ2h0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRpbmdIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX2hlYWRpbmdIZWlnaHQgOiB0aGlzLmhlYWRpbmdIZWlnaHQ7XG4gICAgICAgIHZhciBfb3B0aW9uc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0O1xuICAgICAgICB0aGlzLmVzdGltYXRlZEhlYWRpbmdIZWlnaHQgPSAoX29wdGlvbnNfZXN0aW1hdGVkSGVhZGluZ0hlaWdodCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0KSAhPT0gbnVsbCAmJiBfb3B0aW9uc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0IDogdGhpcy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0O1xuICAgICAgICB2YXIgX29wdGlvbnNfbG9hZGVySGVpZ2h0O1xuICAgICAgICB0aGlzLmxvYWRlckhlaWdodCA9IChfb3B0aW9uc19sb2FkZXJIZWlnaHQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9hZGVySGVpZ2h0KSAhPT0gbnVsbCAmJiBfb3B0aW9uc19sb2FkZXJIZWlnaHQgIT09IHZvaWQgMCA/IF9vcHRpb25zX2xvYWRlckhlaWdodCA6IHRoaXMubG9hZGVySGVpZ2h0O1xuICAgICAgICB2YXIgX29wdGlvbnNfZHJvcEluZGljYXRvclRoaWNrbmVzcztcbiAgICAgICAgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzID0gKF9vcHRpb25zX2Ryb3BJbmRpY2F0b3JUaGlja25lc3MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHJvcEluZGljYXRvclRoaWNrbmVzcykgIT09IG51bGwgJiYgX29wdGlvbnNfZHJvcEluZGljYXRvclRoaWNrbmVzcyAhPT0gdm9pZCAwID8gX29wdGlvbnNfZHJvcEluZGljYXRvclRoaWNrbmVzcyA6IHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcztcbiAgICAgICAgdmFyIF9vcHRpb25zX2dhcDtcbiAgICAgICAgdGhpcy5nYXAgPSAoX29wdGlvbnNfZ2FwID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdhcCkgIT09IG51bGwgJiYgX29wdGlvbnNfZ2FwICE9PSB2b2lkIDAgPyBfb3B0aW9uc19nYXAgOiB0aGlzLmdhcDtcbiAgICAgICAgdmFyIF9vcHRpb25zX3BhZGRpbmc7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IChfb3B0aW9uc19wYWRkaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZGRpbmcpICE9PSBudWxsICYmIF9vcHRpb25zX3BhZGRpbmcgIT09IHZvaWQgMCA/IF9vcHRpb25zX3BhZGRpbmcgOiB0aGlzLnBhZGRpbmc7XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gdGhpcy5idWlsZENvbGxlY3Rpb24oKTtcbiAgICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgbGF5b3V0IG5vZGVzXG4gICAgICAgIGlmICh0aGlzLmxhc3RDb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24gIT09IHRoaXMubGFzdENvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmxhc3RDb2xsZWN0aW9uLmdldEtleXMoKSlpZiAoIWNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dE5vZGUgPSB0aGlzLmxheW91dE5vZGVzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXlvdXROb2RlKSB0aGlzLmxheW91dE5vZGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICB0aGlzLmludmFsaWRhdGVFdmVyeXRoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsaWRSZWN0ID0gdGhpcy5yZXF1ZXN0ZWRSZWN0LmNvcHkoKTtcbiAgICB9XG4gICAgYnVpbGRDb2xsZWN0aW9uKHkgPSB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgICAgIGxldCBza2lwcGVkID0gMDtcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgY29sbGVjdGlvbil7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcm93SGVpZ2h0LCBfcmVmO1xuICAgICAgICAgICAgbGV0IHJvd0hlaWdodCA9ICgoX3JlZiA9IChfdGhpc19yb3dIZWlnaHQgPSB0aGlzLnJvd0hlaWdodCkgIT09IG51bGwgJiYgX3RoaXNfcm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfdGhpc19yb3dIZWlnaHQgOiB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6ICQ2MWVmNjBmYzliMTA0MWY0JHZhciRERUZBVUxUX0hFSUdIVCkgKyB0aGlzLmdhcDtcbiAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZWZvcmUgdGhlIHZhbGlkIHJlY3RhbmdsZSB1bmxlc3MgdGhleSBhcmUgYWxyZWFkeSBjYWNoZWQuXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnaXRlbScgJiYgeSArIHJvd0hlaWdodCA8IHRoaXMucmVxdWVzdGVkUmVjdC55ICYmICF0aGlzLmlzVmFsaWQobm9kZSwgeSkpIHtcbiAgICAgICAgICAgICAgICB5ICs9IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGRDaGlsZChub2RlLCB0aGlzLnBhZGRpbmcsIHksIG51bGwpO1xuICAgICAgICAgICAgeSA9IGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0Lm1heFkgKyB0aGlzLmdhcDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobGF5b3V0Tm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnaXRlbScgJiYgeSA+IHRoaXMucmVxdWVzdGVkUmVjdC5tYXhZKSB7XG4gICAgICAgICAgICAgICAgeSArPSAoY29sbGVjdGlvbi5zaXplIC0gKG5vZGVzLmxlbmd0aCArIHNraXBwZWQpKSAqIHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5IC09IHRoaXMuZ2FwO1xuICAgICAgICB5ICs9IHRoaXMucGFkZGluZztcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGltZzI2JFNpemUpKHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGgsIHkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGlzVmFsaWQobm9kZSwgeSkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQobm9kZS5rZXkpO1xuICAgICAgICByZXR1cm4gIXRoaXMuaW52YWxpZGF0ZUV2ZXJ5dGhpbmcgJiYgY2FjaGVkICYmIGNhY2hlZC5ub2RlID09PSBub2RlICYmIHkgPT09IGNhY2hlZC5sYXlvdXRJbmZvLnJlY3QueSAmJiBjYWNoZWQubGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHModGhpcy52YWxpZFJlY3QpICYmIGNhY2hlZC52YWxpZFJlY3QuY29udGFpbnNSZWN0KGNhY2hlZC5sYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0aW9uKHRoaXMucmVxdWVzdGVkUmVjdCkpO1xuICAgIH1cbiAgICBidWlsZENoaWxkKG5vZGUsIHgsIHksIHBhcmVudEtleSkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKG5vZGUsIHkpKSByZXR1cm4gdGhpcy5sYXlvdXROb2Rlcy5nZXQobm9kZS5rZXkpO1xuICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGROb2RlKG5vZGUsIHgsIHkpO1xuICAgICAgICBsYXlvdXROb2RlLmxheW91dEluZm8ucGFyZW50S2V5ID0gcGFyZW50S2V5ICE9PSBudWxsICYmIHBhcmVudEtleSAhPT0gdm9pZCAwID8gcGFyZW50S2V5IDogbnVsbDtcbiAgICAgICAgdGhpcy5sYXlvdXROb2Rlcy5zZXQobm9kZS5rZXksIGxheW91dE5vZGUpO1xuICAgICAgICByZXR1cm4gbGF5b3V0Tm9kZTtcbiAgICB9XG4gICAgYnVpbGROb2RlKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFNlY3Rpb24obm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEl0ZW0obm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkU2VjdGlvbkhlYWRlcihub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGNhc2UgJ2xvYWRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRMb2FkZXIobm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbm9kZSB0eXBlOiAnICsgbm9kZS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZExvYWRlcihub2RlLCB4LCB5KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkoeCwgeSwgdGhpcy5wYWRkaW5nLCAwKTtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSBuZXcgKDAsICRpbWcyNiRMYXlvdXRJbmZvKSgnbG9hZGVyJywgbm9kZS5rZXksIHJlY3QpO1xuICAgICAgICByZWN0LndpZHRoID0gdGhpcy52aXJ0dWFsaXplci5jb250ZW50U2l6ZS53aWR0aCAtIHRoaXMucGFkZGluZyAtIHg7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gdGhpcy5sb2FkZXJIZWlnaHQgfHwgdGhpcy5yb3dIZWlnaHQgfHwgdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQgfHwgJDYxZWY2MGZjOWIxMDQxZjQkdmFyJERFRkFVTFRfSEVJR0hUO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgIHZhbGlkUmVjdDogcmVjdC5pbnRlcnNlY3Rpb24odGhpcy5yZXF1ZXN0ZWRSZWN0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZFNlY3Rpb24obm9kZSwgeCwgeSkge1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRpbWcyNiRSZWN0KSh4LCB5LCB3aWR0aCAtIHgsIDApO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGltZzI2JExheW91dEluZm8pKG5vZGUudHlwZSwgbm9kZS5rZXksIHJlY3QpO1xuICAgICAgICBsZXQgc3RhcnRZID0geTtcbiAgICAgICAgbGV0IHNraXBwZWQgPSAwO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgKDAsICRpbWcyNiRnZXRDaGlsZE5vZGVzKShub2RlLCBjb2xsZWN0aW9uKSl7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcm93SGVpZ2h0LCBfcmVmO1xuICAgICAgICAgICAgbGV0IHJvd0hlaWdodCA9ICgoX3JlZiA9IChfdGhpc19yb3dIZWlnaHQgPSB0aGlzLnJvd0hlaWdodCkgIT09IG51bGwgJiYgX3RoaXNfcm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfdGhpc19yb3dIZWlnaHQgOiB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6ICQ2MWVmNjBmYzliMTA0MWY0JHZhciRERUZBVUxUX0hFSUdIVCkgKyB0aGlzLmdhcDtcbiAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZWZvcmUgdGhlIHZhbGlkIHJlY3RhbmdsZSB1bmxlc3MgdGhleSBhcmUgYWxyZWFkeSBjYWNoZWQuXG4gICAgICAgICAgICBpZiAoeSArIHJvd0hlaWdodCA8IHRoaXMucmVxdWVzdGVkUmVjdC55ICYmICF0aGlzLmlzVmFsaWQobm9kZSwgeSkpIHtcbiAgICAgICAgICAgICAgICB5ICs9IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGRDaGlsZChjaGlsZCwgeCwgeSwgbGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgeSA9IGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0Lm1heFkgKyB0aGlzLmdhcDtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGF5b3V0Tm9kZSk7XG4gICAgICAgICAgICBpZiAoeSA+IHRoaXMucmVxdWVzdGVkUmVjdC5tYXhZKSB7XG4gICAgICAgICAgICAgICAgLy8gRXN0aW1hdGUgdGhlIHJlbWFpbmluZyBoZWlnaHQgZm9yIHJvd3MgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIGxheW91dCByaWdodCBub3cuXG4gICAgICAgICAgICAgICAgeSArPSAoW1xuICAgICAgICAgICAgICAgICAgICAuLi4oMCwgJGltZzI2JGdldENoaWxkTm9kZXMpKG5vZGUsIGNvbGxlY3Rpb24pXG4gICAgICAgICAgICAgICAgXS5sZW5ndGggLSAoY2hpbGRyZW4ubGVuZ3RoICsgc2tpcHBlZCkpICogcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHkgLT0gdGhpcy5nYXA7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0geSAtIHN0YXJ0WTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3Rpb24odGhpcy5yZXF1ZXN0ZWRSZWN0KSxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRTZWN0aW9uSGVhZGVyKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSB0aGlzLmhlYWRpbmdIZWlnaHQ7XG4gICAgICAgIGxldCBpc0VzdGltYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiBubyBleHBsaWNpdCBoZWlnaHQgaXMgYXZhaWxhYmxlLCB1c2UgYW4gZXN0aW1hdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKHJlY3RIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgYSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgbGF5b3V0IGluZm8gZXhpc3RzLCByZXVzZSBpdHMgaGVpZ2h0LlxuICAgICAgICAgICAgLy8gTWFyayBhcyBlc3RpbWF0ZWQgaWYgdGhlIHNpemUgb2YgdGhlIG92ZXJhbGwgdmlydHVhbGl6ZXIgY2hhbmdlZCxcbiAgICAgICAgICAgIC8vIG9yIHRoZSBjb250ZW50IG9mIHRoZSBpdGVtIGNoYW5nZWQuXG4gICAgICAgICAgICBsZXQgcHJldmlvdXNMYXlvdXROb2RlID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQobm9kZS5rZXkpO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzTGF5b3V0SW5mbyA9IHByZXZpb3VzTGF5b3V0Tm9kZSA9PT0gbnVsbCB8fCBwcmV2aW91c0xheW91dE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZpb3VzTGF5b3V0Tm9kZS5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzTGF5b3V0SW5mbykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJOb2RlID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5rZXkpO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0Tm9kZSA9IHRoaXMubGFzdENvbGxlY3Rpb24gPyB0aGlzLmxhc3RDb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5rZXkpIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZWN0SGVpZ2h0ID0gcHJldmlvdXNMYXlvdXRJbmZvLnJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlzRXN0aW1hdGVkID0gd2lkdGggIT09IHByZXZpb3VzTGF5b3V0SW5mby5yZWN0LndpZHRoIHx8IGN1ck5vZGUgIT09IGxhc3ROb2RlIHx8IHByZXZpb3VzTGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWN0SGVpZ2h0ID0gbm9kZS5yZW5kZXJlZCA/IHRoaXMuZXN0aW1hdGVkSGVhZGluZ0hlaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN0SGVpZ2h0ID09IG51bGwpIHJlY3RIZWlnaHQgPSAkNjFlZjYwZmM5YjEwNDFmNCR2YXIkREVGQVVMVF9IRUlHSFQ7XG4gICAgICAgIGxldCBoZWFkZXJSZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkoeCwgeSwgd2lkdGggLSB4LCByZWN0SGVpZ2h0KTtcbiAgICAgICAgbGV0IGhlYWRlciA9IG5ldyAoMCwgJGltZzI2JExheW91dEluZm8pKCdoZWFkZXInLCBub2RlLmtleSwgaGVhZGVyUmVjdCk7XG4gICAgICAgIGhlYWRlci5lc3RpbWF0ZWRTaXplID0gaXNFc3RpbWF0ZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBoZWFkZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IGhlYWRlci5yZWN0LmludGVyc2VjdGlvbih0aGlzLnJlcXVlc3RlZFJlY3QpLFxuICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZEl0ZW0obm9kZSwgeCwgeSkge1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoIC0gdGhpcy5wYWRkaW5nIC0geDtcbiAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSB0aGlzLnJvd0hlaWdodDtcbiAgICAgICAgbGV0IGlzRXN0aW1hdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGhlaWdodCBpcyBhdmFpbGFibGUsIHVzZSBhbiBlc3RpbWF0ZWQgaGVpZ2h0LlxuICAgICAgICBpZiAocmVjdEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBsYXlvdXQgaW5mbyBleGlzdHMsIHJldXNlIGl0cyBoZWlnaHQuXG4gICAgICAgICAgICAvLyBNYXJrIGFzIGVzdGltYXRlZCBpZiB0aGUgc2l6ZSBvZiB0aGUgb3ZlcmFsbCB2aXJ0dWFsaXplciBjaGFuZ2VkLFxuICAgICAgICAgICAgLy8gb3IgdGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0gY2hhbmdlZC5cbiAgICAgICAgICAgIGxldCBwcmV2aW91c0xheW91dE5vZGUgPSB0aGlzLmxheW91dE5vZGVzLmdldChub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNMYXlvdXROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVjdEhlaWdodCA9IHByZXZpb3VzTGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlzRXN0aW1hdGVkID0gd2lkdGggIT09IHByZXZpb3VzTGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3Qud2lkdGggfHwgbm9kZSAhPT0gcHJldmlvdXNMYXlvdXROb2RlLm5vZGUgfHwgcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8uZXN0aW1hdGVkU2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjdEhlaWdodCA9IHRoaXMuZXN0aW1hdGVkUm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlzRXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdEhlaWdodCA9PSBudWxsKSByZWN0SGVpZ2h0ID0gJDYxZWY2MGZjOWIxMDQxZjQkdmFyJERFRkFVTFRfSEVJR0hUO1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGltZzI2JFJlY3QpKHgsIHksIHdpZHRoLCByZWN0SGVpZ2h0KTtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSBuZXcgKDAsICRpbWcyNiRMYXlvdXRJbmZvKShub2RlLnR5cGUsIG5vZGUua2V5LCByZWN0KTtcbiAgICAgICAgbGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplID0gaXNFc3RpbWF0ZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiBsYXlvdXRJbmZvLnJlY3QsXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSkge1xuICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGtleSk7XG4gICAgICAgIC8vIElmIG5vIGxheW91dEluZm8sIGl0ZW0gaGFzIGJlZW4gZGVsZXRlZC9yZW1vdmVkLlxuICAgICAgICBpZiAoIWxheW91dE5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvO1xuICAgICAgICBsYXlvdXRJbmZvLmVzdGltYXRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxheW91dEluZm8ucmVjdC5oZWlnaHQgIT09IHNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBDb3B5IGxheW91dCBpbmZvIHJhdGhlciB0aGFuIG11dGF0aW5nIHNvIHRoYXQgbGF0ZXIgY2FjaGVzIGFyZSBpbnZhbGlkYXRlZC5cbiAgICAgICAgICAgIGxldCBuZXdMYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBuZXdMYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBsYXlvdXROb2RlLmxheW91dEluZm8gPSBuZXdMYXlvdXRJbmZvO1xuICAgICAgICAgICAgLy8gSXRlbXMgYWZ0ZXIgdGhpcyBsYXlvdXRJbmZvIHdpbGwgbmVlZCB0byBiZSByZXBvc2l0aW9uZWQgdG8gYWNjb3VudCBmb3IgdGhlIG5ldyBoZWlnaHQuXG4gICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHZhbGlkUmVjdCBzbyB0aGF0IG9ubHkgaXRlbXMgYWJvdmUgcmVtYWluIHZhbGlkLlxuICAgICAgICAgICAgdGhpcy52YWxpZFJlY3QuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy52YWxpZFJlY3QuaGVpZ2h0LCBsYXlvdXRJbmZvLnJlY3QueSAtIHRoaXMudmFsaWRSZWN0LnkpO1xuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3RlZFJlY3QgYWxzbyBuZWVkcyB0byBiZSBhZGp1c3RlZCB0byBhY2NvdW50IGZvciB0aGUgaGVpZ2h0IGRpZmZlcmVuY2UuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlZFJlY3QuaGVpZ2h0ICs9IG5ld0xheW91dEluZm8ucmVjdC5oZWlnaHQgLSBsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBsYXlvdXQgZm9yIHRoaXMgbGF5b3V0IG5vZGUgYW5kIGFsbCBwYXJlbnRzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxheW91dE5vZGUoa2V5LCBsYXlvdXRJbmZvLCBuZXdMYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGF5b3V0SW5mby5wYXJlbnRLZXkgIT0gbnVsbCA/IGNvbGxlY3Rpb24uZ2V0SXRlbShsYXlvdXRJbmZvLnBhcmVudEtleSkgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUobm9kZSl7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXROb2RlKG5vZGUua2V5LCBsYXlvdXRJbmZvLCBuZXdMYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRLZXkgIT0gbnVsbCA/IGNvbGxlY3Rpb24uZ2V0SXRlbShub2RlLnBhcmVudEtleSkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGVMYXlvdXROb2RlKGtleSwgb2xkTGF5b3V0SW5mbywgbmV3TGF5b3V0SW5mbykge1xuICAgICAgICBsZXQgbiA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGJ5IGludGVyc2VjdGluZyB0aGUgdmFsaWRSZWN0IG9mIHRoaXMgbm9kZSB3aXRoIHRoZSBvdmVyYWxsIHZhbGlkUmVjdC5cbiAgICAgICAgICAgIG4udmFsaWRSZWN0ID0gbi52YWxpZFJlY3QuaW50ZXJzZWN0aW9uKHRoaXMudmFsaWRSZWN0KTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgbGF5b3V0IGluZm8gaW4gTGF5b3V0Tm9kZVxuICAgICAgICAgICAgaWYgKG4ubGF5b3V0SW5mbyA9PT0gb2xkTGF5b3V0SW5mbykgbi5sYXlvdXRJbmZvID0gbmV3TGF5b3V0SW5mbztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNpemU7XG4gICAgfVxuICAgIGdldERyb3BUYXJnZXRGcm9tUG9pbnQoeCwgeSwgaXNWYWxpZERyb3BUYXJnZXQpIHtcbiAgICAgICAgeCArPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lng7XG4gICAgICAgIHkgKz0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC55O1xuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGl0ZW0gd2l0aGluIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludCB1c2luZyB0aGUgZ2FwIHdpZHRoLlxuICAgICAgICBsZXQgc2VhcmNoUmVjdCA9IG5ldyAoMCwgJGltZzI2JFJlY3QpKHgsIE1hdGgubWF4KDAsIHkgLSB0aGlzLmdhcCksIDEsIHRoaXMuZ2FwICogMik7XG4gICAgICAgIGxldCBjYW5kaWRhdGVzID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3Moc2VhcmNoUmVjdCk7XG4gICAgICAgIGxldCBrZXkgPSBudWxsO1xuICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpe1xuICAgICAgICAgICAgLy8gSWdub3JlIGl0ZW1zIG91dHNpZGUgdGhlIHNlYXJjaCByZWN0LCBlLmcuIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUucmVjdC5pbnRlcnNlY3RzKHNlYXJjaFJlY3QpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB5RGlzdCA9IE1hdGguYWJzKGNhbmRpZGF0ZS5yZWN0LnkgLSB5KTtcbiAgICAgICAgICAgIGxldCBtYXhZRGlzdCA9IE1hdGguYWJzKGNhbmRpZGF0ZS5yZWN0Lm1heFkgLSB5KTtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5taW4oeURpc3QsIG1heFlEaXN0KTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uLnNpemUgPT09IDApIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncm9vdCdcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlY3QgPSBsYXlvdXRJbmZvLnJlY3Q7XG4gICAgICAgIGxldCB0YXJnZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiAnaXRlbScsXG4gICAgICAgICAgICBrZXk6IGxheW91dEluZm8ua2V5LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnb24nXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzbid0IGFjY2VwdGVkLCB0cnkgdGhlIHRhcmdldCBiZWZvcmUgb3IgYWZ0ZXIgZGVwZW5kaW5nIG9uIHRoZSB5IHBvc2l0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzIGFjY2VwdGVkLCBzdGlsbCB0cnkgdGhlIGJlZm9yZS9hZnRlciBwb3NpdGlvbnMgaWYgd2l0aGluIDEwcHhcbiAgICAgICAgLy8gb2YgdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIGl0ZW0uXG4gICAgICAgIGlmICghaXNWYWxpZERyb3BUYXJnZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYmVmb3JlJ1xuICAgICAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYmVmb3JlJztcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYWZ0ZXInXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8PSByZWN0LnkgKyAxMCAmJiBpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICBkcm9wUG9zaXRpb246ICdiZWZvcmUnXG4gICAgICAgIH0pKSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2JlZm9yZSc7XG4gICAgICAgIGVsc2UgaWYgKHkgPj0gcmVjdC5tYXhZIC0gMTAgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYWZ0ZXInXG4gICAgICAgIH0pKSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZ2V0RHJvcFRhcmdldExheW91dEluZm8odGFyZ2V0KSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5nZXRMYXlvdXRJbmZvKHRhcmdldC5rZXkpO1xuICAgICAgICBsZXQgcmVjdDtcbiAgICAgICAgaWYgKHRhcmdldC5kcm9wUG9zaXRpb24gPT09ICdiZWZvcmUnKSByZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkobGF5b3V0SW5mby5yZWN0LngsIGxheW91dEluZm8ucmVjdC55IC0gdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIC8gMiwgbGF5b3V0SW5mby5yZWN0LndpZHRoLCB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MpO1xuICAgICAgICBlbHNlIGlmICh0YXJnZXQuZHJvcFBvc2l0aW9uID09PSAnYWZ0ZXInKSByZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkobGF5b3V0SW5mby5yZWN0LngsIGxheW91dEluZm8ucmVjdC5tYXhZIC0gdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIC8gMiwgbGF5b3V0SW5mby5yZWN0LndpZHRoLCB0aGlzLmRyb3BJbmRpY2F0b3JUaGlja25lc3MpO1xuICAgICAgICBlbHNlIHJlY3QgPSBsYXlvdXRJbmZvLnJlY3Q7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICRpbWcyNiRMYXlvdXRJbmZvKSgnZHJvcEluZGljYXRvcicsIHRhcmdldC5rZXkgKyAnOicgKyB0YXJnZXQuZHJvcFBvc2l0aW9uLCByZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTGlzdExheW91dCB3aXRoIG9wdGlvbnMuIFNlZSB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzIGJlbG93IGZvciBhIGRlc2NyaXB0aW9uXG4gICAqIG9mIHRoZSBvcHRpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkLlxuICAgKi8gY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdmFyIF9vcHRpb25zX3Jvd0hlaWdodDtcbiAgICAgICAgdGhpcy5yb3dIZWlnaHQgPSAoX29wdGlvbnNfcm93SGVpZ2h0ID0gb3B0aW9ucy5yb3dIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX3Jvd0hlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfcm93SGVpZ2h0IDogbnVsbDtcbiAgICAgICAgdmFyIF9vcHRpb25zX2VzdGltYXRlZFJvd0hlaWdodDtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQgPSAoX29wdGlvbnNfZXN0aW1hdGVkUm93SGVpZ2h0ID0gb3B0aW9ucy5lc3RpbWF0ZWRSb3dIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2VzdGltYXRlZFJvd0hlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfZXN0aW1hdGVkUm93SGVpZ2h0IDogbnVsbDtcbiAgICAgICAgdmFyIF9vcHRpb25zX2hlYWRpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuaGVhZGluZ0hlaWdodCA9IChfb3B0aW9uc19oZWFkaW5nSGVpZ2h0ID0gb3B0aW9ucy5oZWFkaW5nSGVpZ2h0KSAhPT0gbnVsbCAmJiBfb3B0aW9uc19oZWFkaW5nSGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19oZWFkaW5nSGVpZ2h0IDogbnVsbDtcbiAgICAgICAgdmFyIF9vcHRpb25zX2VzdGltYXRlZEhlYWRpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuZXN0aW1hdGVkSGVhZGluZ0hlaWdodCA9IChfb3B0aW9uc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ID0gb3B0aW9ucy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0KSAhPT0gbnVsbCAmJiBfb3B0aW9uc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ICE9PSB2b2lkIDAgPyBfb3B0aW9uc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0IDogbnVsbDtcbiAgICAgICAgdmFyIF9vcHRpb25zX2xvYWRlckhlaWdodDtcbiAgICAgICAgdGhpcy5sb2FkZXJIZWlnaHQgPSAoX29wdGlvbnNfbG9hZGVySGVpZ2h0ID0gb3B0aW9ucy5sb2FkZXJIZWlnaHQpICE9PSBudWxsICYmIF9vcHRpb25zX2xvYWRlckhlaWdodCAhPT0gdm9pZCAwID8gX29wdGlvbnNfbG9hZGVySGVpZ2h0IDogbnVsbDtcbiAgICAgICAgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzID0gb3B0aW9ucy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIHx8IDI7XG4gICAgICAgIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nIHx8IDA7XG4gICAgICAgIHRoaXMubGF5b3V0Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gW107XG4gICAgICAgIHRoaXMubGFzdENvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmludmFsaWRhdGVFdmVyeXRoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsaWRSZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZWN0ID0gbmV3ICgwLCAkaW1nMjYkUmVjdCkoKTtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGltZzI2JFNpemUpKCk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7JDYxZWY2MGZjOWIxMDQxZjQkZXhwb3J0JGNhY2JiMzkyNDE1NWQ2OGUgYXMgTGlzdExheW91dH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXN0TGF5b3V0Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs":
/*!**********************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs ***!
  \**********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableLayout: () => (/* binding */ $a152112e902709bf$export$62444c3c724b1b20)\n/* harmony export */ });\n/* harmony import */ var _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ListLayout.mjs */ \"../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"../../../../node_modules/.pnpm/@react-stately+collections@3.12.2_react@19.0.0/node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/virtualizer */ \"../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n/* harmony import */ var _react_stately_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/table */ \"../../../../node_modules/.pnpm/@react-stately+table@3.14.0_react@19.0.0/node_modules/@react-stately/table/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\nconst $a152112e902709bf$var$DEFAULT_ROW_HEIGHT = 48;\nclass $a152112e902709bf$export$62444c3c724b1b20 extends (0, _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_0__.ListLayout) {\n    // Backward compatibility for subclassing.\n    get collection() {\n        return this.virtualizer.collection;\n    }\n    columnsChanged(newCollection, oldCollection) {\n        return !oldCollection || newCollection.columns !== oldCollection.columns && newCollection.columns.length !== oldCollection.columns.length || newCollection.columns.some((c, i)=>c.key !== oldCollection.columns[i].key || c.props.width !== oldCollection.columns[i].props.width || c.props.minWidth !== oldCollection.columns[i].props.minWidth || c.props.maxWidth !== oldCollection.columns[i].props.maxWidth);\n    }\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.columnWidths !== oldOptions.columnWidths || super.shouldInvalidateLayoutOptions(newOptions, oldOptions);\n    }\n    update(invalidationContext) {\n        var _invalidationContext_layoutOptions;\n        let newCollection = this.virtualizer.collection;\n        // If columnWidths were provided via layoutOptions, update those.\n        // Otherwise, calculate column widths ourselves.\n        if ((_invalidationContext_layoutOptions = invalidationContext.layoutOptions) === null || _invalidationContext_layoutOptions === void 0 ? void 0 : _invalidationContext_layoutOptions.columnWidths) {\n            if (invalidationContext.layoutOptions.columnWidths !== this.columnWidths) {\n                this.columnWidths = invalidationContext.layoutOptions.columnWidths;\n                invalidationContext.sizeChanged = true;\n            }\n        } else if (invalidationContext.sizeChanged || this.columnsChanged(newCollection, this.lastCollection)) {\n            let columnLayout = new (0, _react_stately_table__WEBPACK_IMPORTED_MODULE_1__.TableColumnLayout)({});\n            this.columnWidths = columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width - this.padding * 2, newCollection, new Map());\n            invalidationContext.sizeChanged = true;\n        }\n        super.update(invalidationContext);\n    }\n    buildCollection() {\n        this.stickyColumnIndices = [];\n        let collection = this.virtualizer.collection;\n        for (let column of collection.columns)// The selection cell and any other sticky columns always need to be visible.\n        // In addition, row headers need to be in the DOM for accessibility labeling.\n        if (this.isStickyColumn(column) || collection.rowHeaderColumnKeys.has(column.key)) this.stickyColumnIndices.push(column.index);\n        let header = this.buildTableHeader();\n        this.layoutNodes.set(header.layoutInfo.key, header);\n        let body = this.buildBody(header.layoutInfo.rect.maxY + this.gap);\n        this.lastPersistedKeys = null;\n        body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Size)(body.layoutInfo.rect.width + this.padding * 2, body.layoutInfo.rect.maxY + this.padding);\n        return [\n            header,\n            body\n        ];\n    }\n    buildTableHeader() {\n        var _collection_head;\n        let collection = this.virtualizer.collection;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(this.padding, this.padding, 0, 0);\n        var _collection_head_key;\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('header', (_collection_head_key = (_collection_head = collection.head) === null || _collection_head === void 0 ? void 0 : _collection_head.key) !== null && _collection_head_key !== void 0 ? _collection_head_key : 'header', rect);\n        layoutInfo.isSticky = true;\n        layoutInfo.zIndex = 1;\n        let y = this.padding;\n        let width = 0;\n        let children = [];\n        for (let headerRow of collection.headerRows){\n            let layoutNode = this.buildChild(headerRow, this.padding, y, layoutInfo.key);\n            layoutNode.layoutInfo.parentKey = layoutInfo.key;\n            y = layoutNode.layoutInfo.rect.maxY;\n            width = Math.max(width, layoutNode.layoutInfo.rect.width);\n            layoutNode.index = children.length;\n            children.push(layoutNode);\n        }\n        rect.width = width;\n        rect.height = y - this.padding;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect,\n            node: collection.head\n        };\n    }\n    buildHeaderRow(headerRow, x, y) {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, 0, 0);\n        let row = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('headerrow', headerRow.key, rect);\n        let height = 0;\n        let columns = [];\n        for (let cell of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.getChildNodes)(headerRow, this.virtualizer.collection)){\n            let layoutNode = this.buildChild(cell, x, y, row.key);\n            layoutNode.layoutInfo.parentKey = row.key;\n            x = layoutNode.layoutInfo.rect.maxX;\n            height = Math.max(height, layoutNode.layoutInfo.rect.height);\n            layoutNode.index = columns.length;\n            columns.push(layoutNode);\n        }\n        for (let [i, layout] of columns.entries())layout.layoutInfo.zIndex = columns.length - i + 1;\n        this.setChildHeights(columns, height);\n        rect.height = height;\n        rect.width = x - rect.x;\n        return {\n            layoutInfo: row,\n            children: columns,\n            validRect: rect,\n            node: headerRow\n        };\n    }\n    setChildHeights(children, height) {\n        for (let child of children)if (child.layoutInfo.rect.height !== height) {\n            // Need to copy the layout info before we mutate it.\n            child.layoutInfo = child.layoutInfo.copy();\n            child.layoutInfo.rect.height = height;\n        }\n    }\n    // used to get the column widths when rendering to the DOM\n    getRenderedColumnWidth(node) {\n        let collection = this.virtualizer.collection;\n        var _node_colSpan;\n        let colSpan = (_node_colSpan = node.colSpan) !== null && _node_colSpan !== void 0 ? _node_colSpan : 1;\n        var _node_colIndex;\n        let colIndex = (_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index;\n        let width = 0;\n        for(let i = colIndex; i < colIndex + colSpan; i++){\n            let column = collection.columns[i];\n            var _this_columnWidths_get;\n            if ((column === null || column === void 0 ? void 0 : column.key) != null) width += (_this_columnWidths_get = this.columnWidths.get(column.key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n        }\n        return width;\n    }\n    getEstimatedHeight(node, width, height, estimatedHeight) {\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (height == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall collection view changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            if (previousLayoutNode) {\n                height = previousLayoutNode.layoutInfo.rect.height;\n                isEstimated = node !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n            } else {\n                height = estimatedHeight !== null && estimatedHeight !== void 0 ? estimatedHeight : $a152112e902709bf$var$DEFAULT_ROW_HEIGHT;\n                isEstimated = true;\n            }\n        }\n        return {\n            height: height,\n            isEstimated: isEstimated\n        };\n    }\n    getEstimatedRowHeight() {\n        var _this_rowHeight, _ref;\n        return (_ref = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) !== null && _ref !== void 0 ? _ref : $a152112e902709bf$var$DEFAULT_ROW_HEIGHT;\n    }\n    buildColumn(node, x, y) {\n        let width = this.getRenderedColumnWidth(node);\n        var _this_headingHeight, _this_estimatedHeadingHeight;\n        let { height: height, isEstimated: isEstimated } = this.getEstimatedHeight(node, width, (_this_headingHeight = this.headingHeight) !== null && _this_headingHeight !== void 0 ? _this_headingHeight : this.rowHeight, (_this_estimatedHeadingHeight = this.estimatedHeadingHeight) !== null && _this_estimatedHeadingHeight !== void 0 ? _this_estimatedHeadingHeight : this.estimatedRowHeight);\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, width, height);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.isSticky = this.isStickyColumn(node);\n        layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            children: [],\n            validRect: layoutInfo.rect,\n            node: node\n        };\n    }\n    // For subclasses.\n    // eslint-disable-next-line\n    isStickyColumn(node) {\n        return false;\n    }\n    buildBody(y) {\n        let collection = this.virtualizer.collection;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(this.padding, y, 0, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('rowgroup', collection.body.key, rect);\n        let startY = y;\n        let skipped = 0;\n        let width = 0;\n        let children = [];\n        let rowHeight = this.getEstimatedRowHeight() + this.gap;\n        for (let node of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.getChildNodes)(collection.body, collection)){\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(node, this.padding, y, layoutInfo.key);\n            layoutNode.layoutInfo.parentKey = layoutInfo.key;\n            layoutNode.index = children.length;\n            y = layoutNode.layoutInfo.rect.maxY + this.gap;\n            width = Math.max(width, layoutNode.layoutInfo.rect.width);\n            children.push(layoutNode);\n            if (y > this.requestedRect.maxY) {\n                // Estimate the remaining height for rows that we don't need to layout right now.\n                y += (collection.size - (skipped + children.length)) * rowHeight;\n                break;\n            }\n        }\n        if (children.length === 0) y = this.virtualizer.visibleRect.maxY;\n        else y -= this.gap;\n        rect.width = width;\n        rect.height = y - startY;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect.intersection(this.requestedRect),\n            node: collection.body\n        };\n    }\n    buildNode(node, x, y) {\n        switch(node.type){\n            case 'headerrow':\n                return this.buildHeaderRow(node, x, y);\n            case 'item':\n                return this.buildRow(node, x, y);\n            case 'column':\n            case 'placeholder':\n                return this.buildColumn(node, x, y);\n            case 'cell':\n                return this.buildCell(node, x, y);\n            case 'loader':\n                return this.buildLoader(node, x, y);\n            default:\n                throw new Error('Unknown node type ' + node.type);\n        }\n    }\n    buildRow(node, x, y) {\n        var _collection_head;\n        let collection = this.virtualizer.collection;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, 0, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)('row', node.key, rect);\n        let children = [];\n        let height = 0;\n        for (let child of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.getChildNodes)(node, collection))if (child.type === 'cell') {\n            if (x > this.requestedRect.maxX) {\n                // Adjust existing cached layoutInfo to ensure that it is out of view.\n                // This can happen due to column resizing.\n                let layoutNode = this.layoutNodes.get(child.key);\n                if (layoutNode) {\n                    layoutNode.layoutInfo.rect.x = x;\n                    x += layoutNode.layoutInfo.rect.width;\n                } else break;\n            } else {\n                let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n                x = layoutNode.layoutInfo.rect.maxX;\n                height = Math.max(height, layoutNode.layoutInfo.rect.height);\n                layoutNode.index = children.length;\n                children.push(layoutNode);\n            }\n        }\n        this.setChildHeights(children, height);\n        var _collection_head_key;\n        rect.width = this.layoutNodes.get((_collection_head_key = (_collection_head = collection.head) === null || _collection_head === void 0 ? void 0 : _collection_head.key) !== null && _collection_head_key !== void 0 ? _collection_head_key : 'header').layoutInfo.rect.width;\n        rect.height = height;\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: rect.intersection(this.requestedRect),\n            node: node\n        };\n    }\n    buildCell(node, x, y) {\n        let width = this.getRenderedColumnWidth(node);\n        let { height: height, isEstimated: isEstimated } = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, y, width, height);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.isSticky = this.isStickyColumn(node);\n        layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            children: [],\n            validRect: rect,\n            node: node\n        };\n    }\n    getVisibleLayoutInfos(rect) {\n        // Adjust rect to keep number of visible rows consistent.\n        // (only if height > 1 for getDropTargetFromPoint)\n        if (rect.height > 1) {\n            let rowHeight = this.getEstimatedRowHeight();\n            rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n            rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n        }\n        // If layout hasn't yet been done for the requested rect, union the\n        // new rect with the existing valid rect, and recompute.\n        this.layoutIfNeeded(rect);\n        let res = [];\n        this.buildPersistedIndices();\n        for (let node of this.rootNodes){\n            res.push(node.layoutInfo);\n            this.addVisibleLayoutInfos(res, node, rect);\n        }\n        return res;\n    }\n    addVisibleLayoutInfos(res, node, rect) {\n        if (!node.children || node.children.length === 0) return;\n        switch(node.layoutInfo.type){\n            case 'header':\n                for (let child of node.children){\n                    res.push(child.layoutInfo);\n                    this.addVisibleLayoutInfos(res, child, rect);\n                }\n                break;\n            case 'rowgroup':\n                {\n                    let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n                    let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n                    // Add persisted rows before the visible rows.\n                    let persistedRowIndices = this.persistedIndices.get(node.layoutInfo.key);\n                    let persistIndex = 0;\n                    while(persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < firstVisibleRow){\n                        let idx = persistedRowIndices[persistIndex];\n                        if (idx < node.children.length) {\n                            res.push(node.children[idx].layoutInfo);\n                            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n                        }\n                        persistIndex++;\n                    }\n                    for(let i = firstVisibleRow; i <= lastVisibleRow; i++){\n                        // Skip persisted rows that overlap with visible cells.\n                        while(persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i)persistIndex++;\n                        res.push(node.children[i].layoutInfo);\n                        this.addVisibleLayoutInfos(res, node.children[i], rect);\n                    }\n                    // Add persisted rows after the visible rows.\n                    while(persistedRowIndices && persistIndex < persistedRowIndices.length){\n                        let idx = persistedRowIndices[persistIndex++];\n                        if (idx < node.children.length) {\n                            res.push(node.children[idx].layoutInfo);\n                            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n                        }\n                    }\n                    break;\n                }\n            case 'headerrow':\n            case 'row':\n                {\n                    let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n                    let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n                    let stickyIndex = 0;\n                    // Add persisted/sticky cells before the visible cells.\n                    let persistedCellIndices = this.persistedIndices.get(node.layoutInfo.key) || this.stickyColumnIndices;\n                    while(stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell){\n                        let idx = persistedCellIndices[stickyIndex];\n                        if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n                        stickyIndex++;\n                    }\n                    for(let i = firstVisibleCell; i <= lastVisibleCell; i++){\n                        // Skip sticky cells that overlap with visible cells.\n                        while(stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i)stickyIndex++;\n                        res.push(node.children[i].layoutInfo);\n                    }\n                    // Add any remaining sticky cells after the visible cells.\n                    while(stickyIndex < persistedCellIndices.length){\n                        let idx = persistedCellIndices[stickyIndex++];\n                        if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n                    }\n                    break;\n                }\n            default:\n                throw new Error('Unknown node type ' + node.layoutInfo.type);\n        }\n    }\n    binarySearch(items, point, axis) {\n        let low = 0;\n        let high = items.length - 1;\n        while(low <= high){\n            let mid = low + high >> 1;\n            let item = items[mid];\n            if (axis === 'x' && item.layoutInfo.rect.maxX <= point.x || axis === 'y' && item.layoutInfo.rect.maxY <= point.y) low = mid + 1;\n            else if (axis === 'x' && item.layoutInfo.rect.x > point.x || axis === 'y' && item.layoutInfo.rect.y > point.y) high = mid - 1;\n            else return mid;\n        }\n        return Math.max(0, Math.min(items.length - 1, low));\n    }\n    buildPersistedIndices() {\n        if (this.virtualizer.persistedKeys === this.lastPersistedKeys) return;\n        this.lastPersistedKeys = this.virtualizer.persistedKeys;\n        this.persistedIndices.clear();\n        // Build a map of parentKey => indices of children to persist.\n        for (let key of this.virtualizer.persistedKeys){\n            var _this_layoutNodes_get;\n            let layoutInfo = (_this_layoutNodes_get = this.layoutNodes.get(key)) === null || _this_layoutNodes_get === void 0 ? void 0 : _this_layoutNodes_get.layoutInfo;\n            // Walk up ancestors so parents are also persisted if children are.\n            while(layoutInfo && layoutInfo.parentKey){\n                var _this_layoutNodes_get1, _this_layoutNodes_get2;\n                let collectionNode = this.virtualizer.collection.getItem(layoutInfo.key);\n                let indices = this.persistedIndices.get(layoutInfo.parentKey);\n                if (!indices) {\n                    // stickyColumnIndices are always persisted along with any cells from persistedKeys.\n                    indices = (collectionNode === null || collectionNode === void 0 ? void 0 : collectionNode.type) === 'cell' || (collectionNode === null || collectionNode === void 0 ? void 0 : collectionNode.type) === 'column' ? [\n                        ...this.stickyColumnIndices\n                    ] : [];\n                    this.persistedIndices.set(layoutInfo.parentKey, indices);\n                }\n                let index = (_this_layoutNodes_get1 = this.layoutNodes.get(layoutInfo.key)) === null || _this_layoutNodes_get1 === void 0 ? void 0 : _this_layoutNodes_get1.index;\n                if (index != null && !indices.includes(index)) indices.push(index);\n                layoutInfo = (_this_layoutNodes_get2 = this.layoutNodes.get(layoutInfo.parentKey)) === null || _this_layoutNodes_get2 === void 0 ? void 0 : _this_layoutNodes_get2.layoutInfo;\n            }\n        }\n        for (let indices of this.persistedIndices.values())indices.sort((a, b)=>a - b);\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        // Find the closest item within on either side of the point using the gap width.\n        let searchRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_2__.Rect)(x, Math.max(0, y - this.gap), 1, this.gap * 2);\n        let candidates = this.getVisibleLayoutInfos(searchRect);\n        let key = null;\n        let minDistance = Infinity;\n        for (let candidate of candidates){\n            // Ignore items outside the search rect, e.g. persisted keys.\n            if (candidate.type !== 'row' || !candidate.rect.intersects(searchRect)) continue;\n            let yDist = Math.abs(candidate.rect.y - y);\n            let maxYDist = Math.abs(candidate.rect.maxY - y);\n            let dist = Math.min(yDist, maxYDist);\n            if (dist < minDistance) {\n                minDistance = dist;\n                key = candidate.key;\n            }\n        }\n        if (key == null || this.virtualizer.collection.size === 0) return {\n            type: 'root'\n        };\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = layoutInfo.rect;\n        let target = {\n            type: 'item',\n            key: layoutInfo.key,\n            dropPosition: 'on'\n        };\n        // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n        // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n        // of the top or bottom of the item.\n        if (!isValidDropTarget(target)) {\n            if (y <= rect.y + rect.height / 2 && isValidDropTarget({\n                ...target,\n                dropPosition: 'before'\n            })) target.dropPosition = 'before';\n            else if (isValidDropTarget({\n                ...target,\n                dropPosition: 'after'\n            })) target.dropPosition = 'after';\n        } else if (y <= rect.y + 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'before'\n        })) target.dropPosition = 'before';\n        else if (y >= rect.maxY - 10 && isValidDropTarget({\n            ...target,\n            dropPosition: 'after'\n        })) target.dropPosition = 'after';\n        return target;\n    }\n    getDropTargetLayoutInfo(target) {\n        let layoutInfo = super.getDropTargetLayoutInfo(target);\n        layoutInfo.parentKey = this.virtualizer.collection.body.key;\n        return layoutInfo;\n    }\n    constructor(options){\n        super(options), this.lastCollection = null, this.columnWidths = new Map(), this.lastPersistedKeys = null, this.persistedIndices = new Map();\n        this.stickyColumnIndices = [];\n    }\n}\n\n\n\n//# sourceMappingURL=TableLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9UYWJsZUxheW91dC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUY7QUFDUjtBQUNvQztBQUNsQzs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0EsNERBQTRELHVEQUF5QztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QyxtRUFBd0IsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDO0FBQ0EsaUNBQWlDLGtFQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDLDBCQUEwQixrRUFBaUI7QUFDM0M7QUFDQTtBQUNBLDZCQUE2QixxRUFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQsMkJBQTJCLDREQUFXO0FBQ3RDLGlDQUFpQyxrRUFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBVztBQUN0QyxpQ0FBaUMsa0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUVBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDLGlDQUFpQyxrRUFBaUI7QUFDbEQ7QUFDQTtBQUNBLDhCQUE4QixxRUFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCwyQkFBMkIsNERBQVc7QUFDdEMsaUNBQWlDLGtFQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2tFO0FBQ2xFIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVhY3Qtc3RhdGVseStsYXlvdXRANC4yLjFfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGF5b3V0L2Rpc3QvVGFibGVMYXlvdXQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TGlzdExheW91dCBhcyAkNjFlZjYwZmM5YjEwNDFmNCRleHBvcnQkY2FjYmIzOTI0MTU1ZDY4ZX0gZnJvbSBcIi4vTGlzdExheW91dC5tanNcIjtcbmltcG9ydCB7Z2V0Q2hpbGROb2RlcyBhcyAkYm1zSnYkZ2V0Q2hpbGROb2Rlc30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge1NpemUgYXMgJGJtc0p2JFNpemUsIFJlY3QgYXMgJGJtc0p2JFJlY3QsIExheW91dEluZm8gYXMgJGJtc0p2JExheW91dEluZm99IGZyb20gXCJAcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplclwiO1xuaW1wb3J0IHtUYWJsZUNvbHVtbkxheW91dCBhcyAkYm1zSnYkVGFibGVDb2x1bW5MYXlvdXR9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS90YWJsZVwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5jb25zdCAkYTE1MjExMmU5MDI3MDliZiR2YXIkREVGQVVMVF9ST1dfSEVJR0hUID0gNDg7XG5jbGFzcyAkYTE1MjExMmU5MDI3MDliZiRleHBvcnQkNjI0NDRjM2M3MjRiMWIyMCBleHRlbmRzICgwLCAkNjFlZjYwZmM5YjEwNDFmNCRleHBvcnQkY2FjYmIzOTI0MTU1ZDY4ZSkge1xuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHN1YmNsYXNzaW5nLlxuICAgIGdldCBjb2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBjb2x1bW5zQ2hhbmdlZChuZXdDb2xsZWN0aW9uLCBvbGRDb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhb2xkQ29sbGVjdGlvbiB8fCBuZXdDb2xsZWN0aW9uLmNvbHVtbnMgIT09IG9sZENvbGxlY3Rpb24uY29sdW1ucyAmJiBuZXdDb2xsZWN0aW9uLmNvbHVtbnMubGVuZ3RoICE9PSBvbGRDb2xsZWN0aW9uLmNvbHVtbnMubGVuZ3RoIHx8IG5ld0NvbGxlY3Rpb24uY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IG9sZENvbGxlY3Rpb24uY29sdW1uc1tpXS5rZXkgfHwgYy5wcm9wcy53aWR0aCAhPT0gb2xkQ29sbGVjdGlvbi5jb2x1bW5zW2ldLnByb3BzLndpZHRoIHx8IGMucHJvcHMubWluV2lkdGggIT09IG9sZENvbGxlY3Rpb24uY29sdW1uc1tpXS5wcm9wcy5taW5XaWR0aCB8fCBjLnByb3BzLm1heFdpZHRoICE9PSBvbGRDb2xsZWN0aW9uLmNvbHVtbnNbaV0ucHJvcHMubWF4V2lkdGgpO1xuICAgIH1cbiAgICBzaG91bGRJbnZhbGlkYXRlTGF5b3V0T3B0aW9ucyhuZXdPcHRpb25zLCBvbGRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zLmNvbHVtbldpZHRocyAhPT0gb2xkT3B0aW9ucy5jb2x1bW5XaWR0aHMgfHwgc3VwZXIuc2hvdWxkSW52YWxpZGF0ZUxheW91dE9wdGlvbnMobmV3T3B0aW9ucywgb2xkT3B0aW9ucyk7XG4gICAgfVxuICAgIHVwZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgIHZhciBfaW52YWxpZGF0aW9uQ29udGV4dF9sYXlvdXRPcHRpb25zO1xuICAgICAgICBsZXQgbmV3Q29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgLy8gSWYgY29sdW1uV2lkdGhzIHdlcmUgcHJvdmlkZWQgdmlhIGxheW91dE9wdGlvbnMsIHVwZGF0ZSB0aG9zZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgY29sdW1uIHdpZHRocyBvdXJzZWx2ZXMuXG4gICAgICAgIGlmICgoX2ludmFsaWRhdGlvbkNvbnRleHRfbGF5b3V0T3B0aW9ucyA9IGludmFsaWRhdGlvbkNvbnRleHQubGF5b3V0T3B0aW9ucykgPT09IG51bGwgfHwgX2ludmFsaWRhdGlvbkNvbnRleHRfbGF5b3V0T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ludmFsaWRhdGlvbkNvbnRleHRfbGF5b3V0T3B0aW9ucy5jb2x1bW5XaWR0aHMpIHtcbiAgICAgICAgICAgIGlmIChpbnZhbGlkYXRpb25Db250ZXh0LmxheW91dE9wdGlvbnMuY29sdW1uV2lkdGhzICE9PSB0aGlzLmNvbHVtbldpZHRocykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gaW52YWxpZGF0aW9uQ29udGV4dC5sYXlvdXRPcHRpb25zLmNvbHVtbldpZHRocztcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRpb25Db250ZXh0LnNpemVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnZhbGlkYXRpb25Db250ZXh0LnNpemVDaGFuZ2VkIHx8IHRoaXMuY29sdW1uc0NoYW5nZWQobmV3Q29sbGVjdGlvbiwgdGhpcy5sYXN0Q29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW5MYXlvdXQgPSBuZXcgKDAsICRibXNKdiRUYWJsZUNvbHVtbkxheW91dCkoe30pO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBjb2x1bW5MYXlvdXQuYnVpbGRDb2x1bW5XaWR0aHModGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCAtIHRoaXMucGFkZGluZyAqIDIsIG5ld0NvbGxlY3Rpb24sIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBpbnZhbGlkYXRpb25Db250ZXh0LnNpemVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci51cGRhdGUoaW52YWxpZGF0aW9uQ29udGV4dCk7XG4gICAgfVxuICAgIGJ1aWxkQ29sbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdGlja3lDb2x1bW5JbmRpY2VzID0gW107XG4gICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sbGVjdGlvbi5jb2x1bW5zKS8vIFRoZSBzZWxlY3Rpb24gY2VsbCBhbmQgYW55IG90aGVyIHN0aWNreSBjb2x1bW5zIGFsd2F5cyBuZWVkIHRvIGJlIHZpc2libGUuXG4gICAgICAgIC8vIEluIGFkZGl0aW9uLCByb3cgaGVhZGVycyBuZWVkIHRvIGJlIGluIHRoZSBET00gZm9yIGFjY2Vzc2liaWxpdHkgbGFiZWxpbmcuXG4gICAgICAgIGlmICh0aGlzLmlzU3RpY2t5Q29sdW1uKGNvbHVtbikgfHwgY29sbGVjdGlvbi5yb3dIZWFkZXJDb2x1bW5LZXlzLmhhcyhjb2x1bW4ua2V5KSkgdGhpcy5zdGlja3lDb2x1bW5JbmRpY2VzLnB1c2goY29sdW1uLmluZGV4KTtcbiAgICAgICAgbGV0IGhlYWRlciA9IHRoaXMuYnVpbGRUYWJsZUhlYWRlcigpO1xuICAgICAgICB0aGlzLmxheW91dE5vZGVzLnNldChoZWFkZXIubGF5b3V0SW5mby5rZXksIGhlYWRlcik7XG4gICAgICAgIGxldCBib2R5ID0gdGhpcy5idWlsZEJvZHkoaGVhZGVyLmxheW91dEluZm8ucmVjdC5tYXhZICsgdGhpcy5nYXApO1xuICAgICAgICB0aGlzLmxhc3RQZXJzaXN0ZWRLZXlzID0gbnVsbDtcbiAgICAgICAgYm9keS5sYXlvdXRJbmZvLnJlY3Qud2lkdGggPSBNYXRoLm1heChoZWFkZXIubGF5b3V0SW5mby5yZWN0LndpZHRoLCBib2R5LmxheW91dEluZm8ucmVjdC53aWR0aCk7XG4gICAgICAgIHRoaXMuY29udGVudFNpemUgPSBuZXcgKDAsICRibXNKdiRTaXplKShib2R5LmxheW91dEluZm8ucmVjdC53aWR0aCArIHRoaXMucGFkZGluZyAqIDIsIGJvZHkubGF5b3V0SW5mby5yZWN0Lm1heFkgKyB0aGlzLnBhZGRpbmcpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICBdO1xuICAgIH1cbiAgICBidWlsZFRhYmxlSGVhZGVyKCkge1xuICAgICAgICB2YXIgX2NvbGxlY3Rpb25faGVhZDtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkYm1zSnYkUmVjdCkodGhpcy5wYWRkaW5nLCB0aGlzLnBhZGRpbmcsIDAsIDApO1xuICAgICAgICB2YXIgX2NvbGxlY3Rpb25faGVhZF9rZXk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkYm1zSnYkTGF5b3V0SW5mbykoJ2hlYWRlcicsIChfY29sbGVjdGlvbl9oZWFkX2tleSA9IChfY29sbGVjdGlvbl9oZWFkID0gY29sbGVjdGlvbi5oZWFkKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9oZWFkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9oZWFkLmtleSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25faGVhZF9rZXkgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2hlYWRfa2V5IDogJ2hlYWRlcicsIHJlY3QpO1xuICAgICAgICBsYXlvdXRJbmZvLmlzU3RpY2t5ID0gdHJ1ZTtcbiAgICAgICAgbGF5b3V0SW5mby56SW5kZXggPSAxO1xuICAgICAgICBsZXQgeSA9IHRoaXMucGFkZGluZztcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGhlYWRlclJvdyBvZiBjb2xsZWN0aW9uLmhlYWRlclJvd3Mpe1xuICAgICAgICAgICAgbGV0IGxheW91dE5vZGUgPSB0aGlzLmJ1aWxkQ2hpbGQoaGVhZGVyUm93LCB0aGlzLnBhZGRpbmcsIHksIGxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgIGxheW91dE5vZGUubGF5b3V0SW5mby5wYXJlbnRLZXkgPSBsYXlvdXRJbmZvLmtleTtcbiAgICAgICAgICAgIHkgPSBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5tYXhZO1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGF5b3V0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xuICAgICAgICByZWN0LmhlaWdodCA9IHkgLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiBsYXlvdXRJbmZvLnJlY3QsXG4gICAgICAgICAgICBub2RlOiBjb2xsZWN0aW9uLmhlYWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRIZWFkZXJSb3coaGVhZGVyUm93LCB4LCB5KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkYm1zSnYkUmVjdCkoeCwgeSwgMCwgMCk7XG4gICAgICAgIGxldCByb3cgPSBuZXcgKDAsICRibXNKdiRMYXlvdXRJbmZvKSgnaGVhZGVycm93JywgaGVhZGVyUm93LmtleSwgcmVjdCk7XG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xuICAgICAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjZWxsIG9mICgwLCAkYm1zSnYkZ2V0Q2hpbGROb2RlcykoaGVhZGVyUm93LCB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb24pKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZENoaWxkKGNlbGwsIHgsIHksIHJvdy5rZXkpO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnBhcmVudEtleSA9IHJvdy5rZXk7XG4gICAgICAgICAgICB4ID0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QubWF4WDtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIGxheW91dE5vZGUuaW5kZXggPSBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaChsYXlvdXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBbaSwgbGF5b3V0XSBvZiBjb2x1bW5zLmVudHJpZXMoKSlsYXlvdXQubGF5b3V0SW5mby56SW5kZXggPSBjb2x1bW5zLmxlbmd0aCAtIGkgKyAxO1xuICAgICAgICB0aGlzLnNldENoaWxkSGVpZ2h0cyhjb2x1bW5zLCBoZWlnaHQpO1xuICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmVjdC53aWR0aCA9IHggLSByZWN0Lng7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiByb3csXG4gICAgICAgICAgICBjaGlsZHJlbjogY29sdW1ucyxcbiAgICAgICAgICAgIHZhbGlkUmVjdDogcmVjdCxcbiAgICAgICAgICAgIG5vZGU6IGhlYWRlclJvd1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRDaGlsZEhlaWdodHMoY2hpbGRyZW4sIGhlaWdodCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilpZiAoY2hpbGQubGF5b3V0SW5mby5yZWN0LmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNvcHkgdGhlIGxheW91dCBpbmZvIGJlZm9yZSB3ZSBtdXRhdGUgaXQuXG4gICAgICAgICAgICBjaGlsZC5sYXlvdXRJbmZvID0gY2hpbGQubGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBjaGlsZC5sYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgdG8gZ2V0IHRoZSBjb2x1bW4gd2lkdGhzIHdoZW4gcmVuZGVyaW5nIHRvIHRoZSBET01cbiAgICBnZXRSZW5kZXJlZENvbHVtbldpZHRoKG5vZGUpIHtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgICAgIHZhciBfbm9kZV9jb2xTcGFuO1xuICAgICAgICBsZXQgY29sU3BhbiA9IChfbm9kZV9jb2xTcGFuID0gbm9kZS5jb2xTcGFuKSAhPT0gbnVsbCAmJiBfbm9kZV9jb2xTcGFuICE9PSB2b2lkIDAgPyBfbm9kZV9jb2xTcGFuIDogMTtcbiAgICAgICAgdmFyIF9ub2RlX2NvbEluZGV4O1xuICAgICAgICBsZXQgY29sSW5kZXggPSAoX25vZGVfY29sSW5kZXggPSBub2RlLmNvbEluZGV4KSAhPT0gbnVsbCAmJiBfbm9kZV9jb2xJbmRleCAhPT0gdm9pZCAwID8gX25vZGVfY29sSW5kZXggOiBub2RlLmluZGV4O1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSBjb2xJbmRleDsgaSA8IGNvbEluZGV4ICsgY29sU3BhbjsgaSsrKXtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSBjb2xsZWN0aW9uLmNvbHVtbnNbaV07XG4gICAgICAgICAgICB2YXIgX3RoaXNfY29sdW1uV2lkdGhzX2dldDtcbiAgICAgICAgICAgIGlmICgoY29sdW1uID09PSBudWxsIHx8IGNvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uLmtleSkgIT0gbnVsbCkgd2lkdGggKz0gKF90aGlzX2NvbHVtbldpZHRoc19nZXQgPSB0aGlzLmNvbHVtbldpZHRocy5nZXQoY29sdW1uLmtleSkpICE9PSBudWxsICYmIF90aGlzX2NvbHVtbldpZHRoc19nZXQgIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbldpZHRoc19nZXQgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gICAgZ2V0RXN0aW1hdGVkSGVpZ2h0KG5vZGUsIHdpZHRoLCBoZWlnaHQsIGVzdGltYXRlZEhlaWdodCkge1xuICAgICAgICBsZXQgaXNFc3RpbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgaGVpZ2h0IGlzIGF2YWlsYWJsZSwgdXNlIGFuIGVzdGltYXRlZCBoZWlnaHQuXG4gICAgICAgIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgYSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgbGF5b3V0IGluZm8gZXhpc3RzLCByZXVzZSBpdHMgaGVpZ2h0LlxuICAgICAgICAgICAgLy8gTWFyayBhcyBlc3RpbWF0ZWQgaWYgdGhlIHNpemUgb2YgdGhlIG92ZXJhbGwgY29sbGVjdGlvbiB2aWV3IGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBvciB0aGUgY29udGVudCBvZiB0aGUgaXRlbSBjaGFuZ2VkLlxuICAgICAgICAgICAgbGV0IHByZXZpb3VzTGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xheW91dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBwcmV2aW91c0xheW91dE5vZGUubGF5b3V0SW5mby5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBpc0VzdGltYXRlZCA9IG5vZGUgIT09IHByZXZpb3VzTGF5b3V0Tm9kZS5ub2RlIHx8IHdpZHRoICE9PSBwcmV2aW91c0xheW91dE5vZGUubGF5b3V0SW5mby5yZWN0LndpZHRoIHx8IHByZXZpb3VzTGF5b3V0Tm9kZS5sYXlvdXRJbmZvLmVzdGltYXRlZFNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVzdGltYXRlZEhlaWdodCAhPT0gbnVsbCAmJiBlc3RpbWF0ZWRIZWlnaHQgIT09IHZvaWQgMCA/IGVzdGltYXRlZEhlaWdodCA6ICRhMTUyMTEyZTkwMjcwOWJmJHZhciRERUZBVUxUX1JPV19IRUlHSFQ7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGlzRXN0aW1hdGVkOiBpc0VzdGltYXRlZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRFc3RpbWF0ZWRSb3dIZWlnaHQoKSB7XG4gICAgICAgIHZhciBfdGhpc19yb3dIZWlnaHQsIF9yZWY7XG4gICAgICAgIHJldHVybiAoX3JlZiA9IChfdGhpc19yb3dIZWlnaHQgPSB0aGlzLnJvd0hlaWdodCkgIT09IG51bGwgJiYgX3RoaXNfcm93SGVpZ2h0ICE9PSB2b2lkIDAgPyBfdGhpc19yb3dIZWlnaHQgOiB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6ICRhMTUyMTEyZTkwMjcwOWJmJHZhciRERUZBVUxUX1JPV19IRUlHSFQ7XG4gICAgfVxuICAgIGJ1aWxkQ29sdW1uKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5nZXRSZW5kZXJlZENvbHVtbldpZHRoKG5vZGUpO1xuICAgICAgICB2YXIgX3RoaXNfaGVhZGluZ0hlaWdodCwgX3RoaXNfZXN0aW1hdGVkSGVhZGluZ0hlaWdodDtcbiAgICAgICAgbGV0IHsgaGVpZ2h0OiBoZWlnaHQsIGlzRXN0aW1hdGVkOiBpc0VzdGltYXRlZCB9ID0gdGhpcy5nZXRFc3RpbWF0ZWRIZWlnaHQobm9kZSwgd2lkdGgsIChfdGhpc19oZWFkaW5nSGVpZ2h0ID0gdGhpcy5oZWFkaW5nSGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpc19oZWFkaW5nSGVpZ2h0ICE9PSB2b2lkIDAgPyBfdGhpc19oZWFkaW5nSGVpZ2h0IDogdGhpcy5yb3dIZWlnaHQsIChfdGhpc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ID0gdGhpcy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0ICE9PSB2b2lkIDAgPyBfdGhpc19lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0IDogdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQpO1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGJtc0p2JFJlY3QpKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGJtc0p2JExheW91dEluZm8pKG5vZGUudHlwZSwgbm9kZS5rZXksIHJlY3QpO1xuICAgICAgICBsYXlvdXRJbmZvLmlzU3RpY2t5ID0gdGhpcy5pc1N0aWNreUNvbHVtbihub2RlKTtcbiAgICAgICAgbGF5b3V0SW5mby56SW5kZXggPSBsYXlvdXRJbmZvLmlzU3RpY2t5ID8gMiA6IDE7XG4gICAgICAgIGxheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGlzRXN0aW1hdGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHZhbGlkUmVjdDogbGF5b3V0SW5mby5yZWN0LFxuICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3Igc3ViY2xhc3Nlcy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpc1N0aWNreUNvbHVtbihub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYnVpbGRCb2R5KHkpIHtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLnZpcnR1YWxpemVyLmNvbGxlY3Rpb247XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkYm1zSnYkUmVjdCkodGhpcy5wYWRkaW5nLCB5LCAwLCAwKTtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSBuZXcgKDAsICRibXNKdiRMYXlvdXRJbmZvKSgncm93Z3JvdXAnLCBjb2xsZWN0aW9uLmJvZHkua2V5LCByZWN0KTtcbiAgICAgICAgbGV0IHN0YXJ0WSA9IHk7XG4gICAgICAgIGxldCBza2lwcGVkID0gMDtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGxldCByb3dIZWlnaHQgPSB0aGlzLmdldEVzdGltYXRlZFJvd0hlaWdodCgpICsgdGhpcy5nYXA7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgKDAsICRibXNKdiRnZXRDaGlsZE5vZGVzKShjb2xsZWN0aW9uLmJvZHksIGNvbGxlY3Rpb24pKXtcbiAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZWZvcmUgdGhlIHZhbGlkIHJlY3RhbmdsZSB1bmxlc3MgdGhleSBhcmUgYWxyZWFkeSBjYWNoZWQuXG4gICAgICAgICAgICBpZiAoeSArIHJvd0hlaWdodCA8IHRoaXMucmVxdWVzdGVkUmVjdC55ICYmICF0aGlzLmlzVmFsaWQobm9kZSwgeSkpIHtcbiAgICAgICAgICAgICAgICB5ICs9IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGRDaGlsZChub2RlLCB0aGlzLnBhZGRpbmcsIHksIGxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgIGxheW91dE5vZGUubGF5b3V0SW5mby5wYXJlbnRLZXkgPSBsYXlvdXRJbmZvLmtleTtcbiAgICAgICAgICAgIGxheW91dE5vZGUuaW5kZXggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB5ID0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QubWF4WSArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsYXlvdXROb2RlKTtcbiAgICAgICAgICAgIGlmICh5ID4gdGhpcy5yZXF1ZXN0ZWRSZWN0Lm1heFkpIHtcbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSB0aGUgcmVtYWluaW5nIGhlaWdodCBmb3Igcm93cyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbGF5b3V0IHJpZ2h0IG5vdy5cbiAgICAgICAgICAgICAgICB5ICs9IChjb2xsZWN0aW9uLnNpemUgLSAoc2tpcHBlZCArIGNoaWxkcmVuLmxlbmd0aCkpICogcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHkgPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lm1heFk7XG4gICAgICAgIGVsc2UgeSAtPSB0aGlzLmdhcDtcbiAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xuICAgICAgICByZWN0LmhlaWdodCA9IHkgLSBzdGFydFk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiBsYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0aW9uKHRoaXMucmVxdWVzdGVkUmVjdCksXG4gICAgICAgICAgICBub2RlOiBjb2xsZWN0aW9uLmJvZHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGROb2RlKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdoZWFkZXJyb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkSGVhZGVyUm93KG5vZGUsIHgsIHkpO1xuICAgICAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRSb3cobm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICAgICAgY2FzZSAncGxhY2Vob2xkZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQ29sdW1uKG5vZGUsIHgsIHkpO1xuICAgICAgICAgICAgY2FzZSAnY2VsbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDZWxsKG5vZGUsIHgsIHkpO1xuICAgICAgICAgICAgY2FzZSAnbG9hZGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZExvYWRlcihub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgbm9kZS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZFJvdyhub2RlLCB4LCB5KSB7XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9oZWFkO1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRibXNKdiRSZWN0KSh4LCB5LCAwLCAwKTtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSBuZXcgKDAsICRibXNKdiRMYXlvdXRJbmZvKSgncm93Jywgbm9kZS5rZXksIHJlY3QpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mICgwLCAkYm1zSnYkZ2V0Q2hpbGROb2Rlcykobm9kZSwgY29sbGVjdGlvbikpaWYgKGNoaWxkLnR5cGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgaWYgKHggPiB0aGlzLnJlcXVlc3RlZFJlY3QubWF4WCkge1xuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBleGlzdGluZyBjYWNoZWQgbGF5b3V0SW5mbyB0byBlbnN1cmUgdGhhdCBpdCBpcyBvdXQgb2Ygdmlldy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gZHVlIHRvIGNvbHVtbiByZXNpemluZy5cbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGNoaWxkLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QueCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGRDaGlsZChjaGlsZCwgeCwgeSwgbGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgICAgIHggPSBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5tYXhYO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsYXlvdXROb2RlLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGF5b3V0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDaGlsZEhlaWdodHMoY2hpbGRyZW4sIGhlaWdodCk7XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9oZWFkX2tleTtcbiAgICAgICAgcmVjdC53aWR0aCA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KChfY29sbGVjdGlvbl9oZWFkX2tleSA9IChfY29sbGVjdGlvbl9oZWFkID0gY29sbGVjdGlvbi5oZWFkKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9oZWFkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9oZWFkLmtleSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25faGVhZF9rZXkgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2hlYWRfa2V5IDogJ2hlYWRlcicpLmxheW91dEluZm8ucmVjdC53aWR0aDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiByZWN0LmludGVyc2VjdGlvbih0aGlzLnJlcXVlc3RlZFJlY3QpLFxuICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZENlbGwobm9kZSwgeCwgeSkge1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmdldFJlbmRlcmVkQ29sdW1uV2lkdGgobm9kZSk7XG4gICAgICAgIGxldCB7IGhlaWdodDogaGVpZ2h0LCBpc0VzdGltYXRlZDogaXNFc3RpbWF0ZWQgfSA9IHRoaXMuZ2V0RXN0aW1hdGVkSGVpZ2h0KG5vZGUsIHdpZHRoLCB0aGlzLnJvd0hlaWdodCwgdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQpO1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGJtc0p2JFJlY3QpKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGJtc0p2JExheW91dEluZm8pKG5vZGUudHlwZSwgbm9kZS5rZXksIHJlY3QpO1xuICAgICAgICBsYXlvdXRJbmZvLmlzU3RpY2t5ID0gdGhpcy5pc1N0aWNreUNvbHVtbihub2RlKTtcbiAgICAgICAgbGF5b3V0SW5mby56SW5kZXggPSBsYXlvdXRJbmZvLmlzU3RpY2t5ID8gMiA6IDE7XG4gICAgICAgIGxheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGlzRXN0aW1hdGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHZhbGlkUmVjdDogcmVjdCxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpIHtcbiAgICAgICAgLy8gQWRqdXN0IHJlY3QgdG8ga2VlcCBudW1iZXIgb2YgdmlzaWJsZSByb3dzIGNvbnNpc3RlbnQuXG4gICAgICAgIC8vIChvbmx5IGlmIGhlaWdodCA+IDEgZm9yIGdldERyb3BUYXJnZXRGcm9tUG9pbnQpXG4gICAgICAgIGlmIChyZWN0LmhlaWdodCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByb3dIZWlnaHQgPSB0aGlzLmdldEVzdGltYXRlZFJvd0hlaWdodCgpO1xuICAgICAgICAgICAgcmVjdC55ID0gTWF0aC5mbG9vcihyZWN0LnkgLyByb3dIZWlnaHQpICogcm93SGVpZ2h0O1xuICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBNYXRoLmNlaWwocmVjdC5oZWlnaHQgLyByb3dIZWlnaHQpICogcm93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGxheW91dCBoYXNuJ3QgeWV0IGJlZW4gZG9uZSBmb3IgdGhlIHJlcXVlc3RlZCByZWN0LCB1bmlvbiB0aGVcbiAgICAgICAgLy8gbmV3IHJlY3Qgd2l0aCB0aGUgZXhpc3RpbmcgdmFsaWQgcmVjdCwgYW5kIHJlY29tcHV0ZS5cbiAgICAgICAgdGhpcy5sYXlvdXRJZk5lZWRlZChyZWN0KTtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1aWxkUGVyc2lzdGVkSW5kaWNlcygpO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMucm9vdE5vZGVzKXtcbiAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICB0aGlzLmFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIG5vZGUsIHJlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIG5vZGUsIHJlY3QpIHtcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHN3aXRjaChub2RlLmxheW91dEluZm8udHlwZSl7XG4gICAgICAgICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pe1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChjaGlsZC5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWaXNpYmxlTGF5b3V0SW5mb3MocmVzLCBjaGlsZCwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm93Z3JvdXAnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0VmlzaWJsZVJvdyA9IHRoaXMuYmluYXJ5U2VhcmNoKG5vZGUuY2hpbGRyZW4sIHJlY3QudG9wTGVmdCwgJ3knKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RWaXNpYmxlUm93ID0gdGhpcy5iaW5hcnlTZWFyY2gobm9kZS5jaGlsZHJlbiwgcmVjdC5ib3R0b21SaWdodCwgJ3knKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHBlcnNpc3RlZCByb3dzIGJlZm9yZSB0aGUgdmlzaWJsZSByb3dzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyc2lzdGVkUm93SW5kaWNlcyA9IHRoaXMucGVyc2lzdGVkSW5kaWNlcy5nZXQobm9kZS5sYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXJzaXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShwZXJzaXN0ZWRSb3dJbmRpY2VzICYmIHBlcnNpc3RJbmRleCA8IHBlcnNpc3RlZFJvd0luZGljZXMubGVuZ3RoICYmIHBlcnNpc3RlZFJvd0luZGljZXNbcGVyc2lzdEluZGV4XSA8IGZpcnN0VmlzaWJsZVJvdyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gcGVyc2lzdGVkUm93SW5kaWNlc1twZXJzaXN0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5jaGlsZHJlbltpZHhdLmxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmlzaWJsZUxheW91dEluZm9zKHJlcywgbm9kZS5jaGlsZHJlbltpZHhdLCByZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGZpcnN0VmlzaWJsZVJvdzsgaSA8PSBsYXN0VmlzaWJsZVJvdzsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGVyc2lzdGVkIHJvd3MgdGhhdCBvdmVybGFwIHdpdGggdmlzaWJsZSBjZWxscy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHBlcnNpc3RlZFJvd0luZGljZXMgJiYgcGVyc2lzdEluZGV4IDwgcGVyc2lzdGVkUm93SW5kaWNlcy5sZW5ndGggJiYgcGVyc2lzdGVkUm93SW5kaWNlc1twZXJzaXN0SW5kZXhdIDwgaSlwZXJzaXN0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUuY2hpbGRyZW5baV0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIG5vZGUuY2hpbGRyZW5baV0sIHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBwZXJzaXN0ZWQgcm93cyBhZnRlciB0aGUgdmlzaWJsZSByb3dzLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZShwZXJzaXN0ZWRSb3dJbmRpY2VzICYmIHBlcnNpc3RJbmRleCA8IHBlcnNpc3RlZFJvd0luZGljZXMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSBwZXJzaXN0ZWRSb3dJbmRpY2VzW3BlcnNpc3RJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPCBub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUuY2hpbGRyZW5baWR4XS5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIG5vZGUuY2hpbGRyZW5baWR4XSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaGVhZGVycm93JzpcbiAgICAgICAgICAgIGNhc2UgJ3Jvdyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RWaXNpYmxlQ2VsbCA9IHRoaXMuYmluYXJ5U2VhcmNoKG5vZGUuY2hpbGRyZW4sIHJlY3QudG9wTGVmdCwgJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RWaXNpYmxlQ2VsbCA9IHRoaXMuYmluYXJ5U2VhcmNoKG5vZGUuY2hpbGRyZW4sIHJlY3QudG9wUmlnaHQsICd4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGlja3lJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBwZXJzaXN0ZWQvc3RpY2t5IGNlbGxzIGJlZm9yZSB0aGUgdmlzaWJsZSBjZWxscy5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlcnNpc3RlZENlbGxJbmRpY2VzID0gdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLmdldChub2RlLmxheW91dEluZm8ua2V5KSB8fCB0aGlzLnN0aWNreUNvbHVtbkluZGljZXM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHN0aWNreUluZGV4IDwgcGVyc2lzdGVkQ2VsbEluZGljZXMubGVuZ3RoICYmIHBlcnNpc3RlZENlbGxJbmRpY2VzW3N0aWNreUluZGV4XSA8IGZpcnN0VmlzaWJsZUNlbGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IHBlcnNpc3RlZENlbGxJbmRpY2VzW3N0aWNreUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPCBub2RlLmNoaWxkcmVuLmxlbmd0aCkgcmVzLnB1c2gobm9kZS5jaGlsZHJlbltpZHhdLmxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RpY2t5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSBmaXJzdFZpc2libGVDZWxsOyBpIDw9IGxhc3RWaXNpYmxlQ2VsbDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgc3RpY2t5IGNlbGxzIHRoYXQgb3ZlcmxhcCB3aXRoIHZpc2libGUgY2VsbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShzdGlja3lJbmRleCA8IHBlcnNpc3RlZENlbGxJbmRpY2VzLmxlbmd0aCAmJiBwZXJzaXN0ZWRDZWxsSW5kaWNlc1tzdGlja3lJbmRleF0gPCBpKXN0aWNreUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChub2RlLmNoaWxkcmVuW2ldLmxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgcmVtYWluaW5nIHN0aWNreSBjZWxscyBhZnRlciB0aGUgdmlzaWJsZSBjZWxscy5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoc3RpY2t5SW5kZXggPCBwZXJzaXN0ZWRDZWxsSW5kaWNlcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IHBlcnNpc3RlZENlbGxJbmRpY2VzW3N0aWNreUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSByZXMucHVzaChub2RlLmNoaWxkcmVuW2lkeF0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlLmxheW91dEluZm8udHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluYXJ5U2VhcmNoKGl0ZW1zLCBwb2ludCwgYXhpcykge1xuICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgbGV0IGhpZ2ggPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZShsb3cgPD0gaGlnaCl7XG4gICAgICAgICAgICBsZXQgbWlkID0gbG93ICsgaGlnaCA+PiAxO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBpdGVtc1ttaWRdO1xuICAgICAgICAgICAgaWYgKGF4aXMgPT09ICd4JyAmJiBpdGVtLmxheW91dEluZm8ucmVjdC5tYXhYIDw9IHBvaW50LnggfHwgYXhpcyA9PT0gJ3knICYmIGl0ZW0ubGF5b3V0SW5mby5yZWN0Lm1heFkgPD0gcG9pbnQueSkgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGF4aXMgPT09ICd4JyAmJiBpdGVtLmxheW91dEluZm8ucmVjdC54ID4gcG9pbnQueCB8fCBheGlzID09PSAneScgJiYgaXRlbS5sYXlvdXRJbmZvLnJlY3QueSA+IHBvaW50LnkpIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gbWlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihpdGVtcy5sZW5ndGggLSAxLCBsb3cpKTtcbiAgICB9XG4gICAgYnVpbGRQZXJzaXN0ZWRJbmRpY2VzKCkge1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsaXplci5wZXJzaXN0ZWRLZXlzID09PSB0aGlzLmxhc3RQZXJzaXN0ZWRLZXlzKSByZXR1cm47XG4gICAgICAgIHRoaXMubGFzdFBlcnNpc3RlZEtleXMgPSB0aGlzLnZpcnR1YWxpemVyLnBlcnNpc3RlZEtleXM7XG4gICAgICAgIHRoaXMucGVyc2lzdGVkSW5kaWNlcy5jbGVhcigpO1xuICAgICAgICAvLyBCdWlsZCBhIG1hcCBvZiBwYXJlbnRLZXkgPT4gaW5kaWNlcyBvZiBjaGlsZHJlbiB0byBwZXJzaXN0LlxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy52aXJ0dWFsaXplci5wZXJzaXN0ZWRLZXlzKXtcbiAgICAgICAgICAgIHZhciBfdGhpc19sYXlvdXROb2Rlc19nZXQ7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IChfdGhpc19sYXlvdXROb2Rlc19nZXQgPSB0aGlzLmxheW91dE5vZGVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfdGhpc19sYXlvdXROb2Rlc19nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2xheW91dE5vZGVzX2dldC5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgLy8gV2FsayB1cCBhbmNlc3RvcnMgc28gcGFyZW50cyBhcmUgYWxzbyBwZXJzaXN0ZWQgaWYgY2hpbGRyZW4gYXJlLlxuICAgICAgICAgICAgd2hpbGUobGF5b3V0SW5mbyAmJiBsYXlvdXRJbmZvLnBhcmVudEtleSl7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzX2xheW91dE5vZGVzX2dldDEsIF90aGlzX2xheW91dE5vZGVzX2dldDI7XG4gICAgICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb25Ob2RlID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uLmdldEl0ZW0obGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLmdldChsYXlvdXRJbmZvLnBhcmVudEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWNreUNvbHVtbkluZGljZXMgYXJlIGFsd2F5cyBwZXJzaXN0ZWQgYWxvbmcgd2l0aCBhbnkgY2VsbHMgZnJvbSBwZXJzaXN0ZWRLZXlzLlxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzID0gKGNvbGxlY3Rpb25Ob2RlID09PSBudWxsIHx8IGNvbGxlY3Rpb25Ob2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xsZWN0aW9uTm9kZS50eXBlKSA9PT0gJ2NlbGwnIHx8IChjb2xsZWN0aW9uTm9kZSA9PT0gbnVsbCB8fCBjb2xsZWN0aW9uTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sbGVjdGlvbk5vZGUudHlwZSkgPT09ICdjb2x1bW4nID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5zdGlja3lDb2x1bW5JbmRpY2VzXG4gICAgICAgICAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLnNldChsYXlvdXRJbmZvLnBhcmVudEtleSwgaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IChfdGhpc19sYXlvdXROb2Rlc19nZXQxID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQobGF5b3V0SW5mby5rZXkpKSA9PT0gbnVsbCB8fCBfdGhpc19sYXlvdXROb2Rlc19nZXQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19sYXlvdXROb2Rlc19nZXQxLmluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsICYmICFpbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICBsYXlvdXRJbmZvID0gKF90aGlzX2xheW91dE5vZGVzX2dldDIgPSB0aGlzLmxheW91dE5vZGVzLmdldChsYXlvdXRJbmZvLnBhcmVudEtleSkpID09PSBudWxsIHx8IF90aGlzX2xheW91dE5vZGVzX2dldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2xheW91dE5vZGVzX2dldDIubGF5b3V0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbmRpY2VzIG9mIHRoaXMucGVyc2lzdGVkSW5kaWNlcy52YWx1ZXMoKSlpbmRpY2VzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgfVxuICAgIGdldERyb3BUYXJnZXRGcm9tUG9pbnQoeCwgeSwgaXNWYWxpZERyb3BUYXJnZXQpIHtcbiAgICAgICAgeCArPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lng7XG4gICAgICAgIHkgKz0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC55O1xuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGl0ZW0gd2l0aGluIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludCB1c2luZyB0aGUgZ2FwIHdpZHRoLlxuICAgICAgICBsZXQgc2VhcmNoUmVjdCA9IG5ldyAoMCwgJGJtc0p2JFJlY3QpKHgsIE1hdGgubWF4KDAsIHkgLSB0aGlzLmdhcCksIDEsIHRoaXMuZ2FwICogMik7XG4gICAgICAgIGxldCBjYW5kaWRhdGVzID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3Moc2VhcmNoUmVjdCk7XG4gICAgICAgIGxldCBrZXkgPSBudWxsO1xuICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpe1xuICAgICAgICAgICAgLy8gSWdub3JlIGl0ZW1zIG91dHNpZGUgdGhlIHNlYXJjaCByZWN0LCBlLmcuIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS50eXBlICE9PSAncm93JyB8fCAhY2FuZGlkYXRlLnJlY3QuaW50ZXJzZWN0cyhzZWFyY2hSZWN0KSkgY29udGludWU7XG4gICAgICAgICAgICBsZXQgeURpc3QgPSBNYXRoLmFicyhjYW5kaWRhdGUucmVjdC55IC0geSk7XG4gICAgICAgICAgICBsZXQgbWF4WURpc3QgPSBNYXRoLmFicyhjYW5kaWRhdGUucmVjdC5tYXhZIC0geSk7XG4gICAgICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWluKHlEaXN0LCBtYXhZRGlzdCk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZS5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbi5zaXplID09PSAwKSByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3Jvb3QnXG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5nZXRMYXlvdXRJbmZvKGtleSk7XG4gICAgICAgIGlmICghbGF5b3V0SW5mbykgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCByZWN0ID0gbGF5b3V0SW5mby5yZWN0O1xuICAgICAgICBsZXQgdGFyZ2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogJ2l0ZW0nLFxuICAgICAgICAgICAga2V5OiBsYXlvdXRJbmZvLmtleSxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ29uJ1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiBkcm9wcGluZyBvbiB0aGUgaXRlbSBpc24ndCBhY2NlcHRlZCwgdHJ5IHRoZSB0YXJnZXQgYmVmb3JlIG9yIGFmdGVyIGRlcGVuZGluZyBvbiB0aGUgeSBwb3NpdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBkcm9wcGluZyBvbiB0aGUgaXRlbSBpcyBhY2NlcHRlZCwgc3RpbGwgdHJ5IHRoZSBiZWZvcmUvYWZ0ZXIgcG9zaXRpb25zIGlmIHdpdGhpbiAxMHB4XG4gICAgICAgIC8vIG9mIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSBpdGVtLlxuICAgICAgICBpZiAoIWlzVmFsaWREcm9wVGFyZ2V0KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmICh5IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiAmJiBpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ2JlZm9yZSdcbiAgICAgICAgICAgIH0pKSB0YXJnZXQuZHJvcFBvc2l0aW9uID0gJ2JlZm9yZSc7XG4gICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ2FmdGVyJ1xuICAgICAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSAnYWZ0ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKHkgPD0gcmVjdC55ICsgMTAgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiAnYmVmb3JlJ1xuICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9ICdiZWZvcmUnO1xuICAgICAgICBlbHNlIGlmICh5ID49IHJlY3QubWF4WSAtIDEwICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogJ2FmdGVyJ1xuICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGdldERyb3BUYXJnZXRMYXlvdXRJbmZvKHRhcmdldCkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHN1cGVyLmdldERyb3BUYXJnZXRMYXlvdXRJbmZvKHRhcmdldCk7XG4gICAgICAgIGxheW91dEluZm8ucGFyZW50S2V5ID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uLmJvZHkua2V5O1xuICAgICAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpLCB0aGlzLmxhc3RDb2xsZWN0aW9uID0gbnVsbCwgdGhpcy5jb2x1bW5XaWR0aHMgPSBuZXcgTWFwKCksIHRoaXMubGFzdFBlcnNpc3RlZEtleXMgPSBudWxsLCB0aGlzLnBlcnNpc3RlZEluZGljZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3RpY2t5Q29sdW1uSW5kaWNlcyA9IFtdO1xuICAgIH1cbn1cblxuXG5leHBvcnQgeyRhMTUyMTEyZTkwMjcwOWJmJGV4cG9ydCQ2MjQ0NGMzYzcyNGIxYjIwIGFzIFRhYmxlTGF5b3V0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhYmxlTGF5b3V0Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs":
/*!**************************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs ***!
  \**************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WaterfallLayout: () => (/* binding */ $f483179558aa907f$export$e9f7cda058ba8df8)\n/* harmony export */ });\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/virtualizer */ \"../../../../node_modules/.pnpm/@react-stately+virtualizer@4.3.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n\n\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nclass $f483179558aa907f$var$WaterfallLayoutInfo extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo) {\n    copy() {\n        let res = super.copy();\n        res.column = this.column;\n        return res;\n    }\n    constructor(...args){\n        super(...args), this.column = 0;\n    }\n}\nconst $f483179558aa907f$var$DEFAULT_OPTIONS = {\n    minItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(200, 200),\n    maxItemSize: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(Infinity, Infinity),\n    minSpace: new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(18, 18),\n    maxColumns: Infinity,\n    dropIndicatorThickness: 2\n};\nclass $f483179558aa907f$export$e9f7cda058ba8df8 extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Layout) {\n    shouldInvalidateLayoutOptions(newOptions, oldOptions) {\n        return newOptions.maxColumns !== oldOptions.maxColumns || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness || !(newOptions.minItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.minItemSize).equals(oldOptions.minItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.minItemSize) || !(newOptions.maxItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.maxItemSize).equals(oldOptions.maxItemSize || $f483179558aa907f$var$DEFAULT_OPTIONS.maxItemSize) || !(newOptions.minSpace || $f483179558aa907f$var$DEFAULT_OPTIONS.minSpace).equals(oldOptions.minSpace || $f483179558aa907f$var$DEFAULT_OPTIONS.minSpace);\n    }\n    update(invalidationContext) {\n        let { minItemSize: minItemSize = $f483179558aa907f$var$DEFAULT_OPTIONS.minItemSize, maxItemSize: maxItemSize = $f483179558aa907f$var$DEFAULT_OPTIONS.maxItemSize, minSpace: minSpace = $f483179558aa907f$var$DEFAULT_OPTIONS.minSpace, maxColumns: maxColumns = $f483179558aa907f$var$DEFAULT_OPTIONS.maxColumns, dropIndicatorThickness: dropIndicatorThickness = $f483179558aa907f$var$DEFAULT_OPTIONS.dropIndicatorThickness } = invalidationContext.layoutOptions || {};\n        this.dropIndicatorThickness = dropIndicatorThickness;\n        let visibleWidth = this.virtualizer.visibleRect.width;\n        // The max item width is always the entire viewport.\n        // If the max item height is infinity, scale in proportion to the max width.\n        let maxItemWidth = Math.min(maxItemSize.width, visibleWidth);\n        let maxItemHeight = Number.isFinite(maxItemSize.height) ? maxItemSize.height : Math.floor(minItemSize.height / minItemSize.width * maxItemWidth);\n        // Compute the number of rows and columns needed to display the content\n        let columns = Math.floor(visibleWidth / (minItemSize.width + minSpace.width));\n        let numColumns = Math.max(1, Math.min(maxColumns, columns));\n        // Compute the available width (minus the space between items)\n        let width = visibleWidth - minSpace.width * Math.max(0, numColumns);\n        // Compute the item width based on the space available\n        let itemWidth = Math.floor(width / numColumns);\n        itemWidth = Math.max(minItemSize.width, Math.min(maxItemWidth, itemWidth));\n        // Compute the item height, which is proportional to the item width\n        let t = (itemWidth - minItemSize.width) / Math.max(1, maxItemWidth - minItemSize.width);\n        let itemHeight = minItemSize.height + Math.floor((maxItemHeight - minItemSize.height) * t);\n        itemHeight = Math.max(minItemSize.height, Math.min(maxItemHeight, itemHeight));\n        // Compute the horizontal spacing and content height\n        let horizontalSpacing = Math.floor((visibleWidth - numColumns * itemWidth) / (numColumns + 1));\n        // Setup an array of column heights\n        let columnHeights = Array(numColumns).fill(minSpace.height);\n        let newLayoutInfos = new Map();\n        let addNode = (key, node)=>{\n            let oldLayoutInfo = this.layoutInfos.get(key);\n            let height = itemHeight;\n            let estimatedSize = true;\n            if (oldLayoutInfo) {\n                height = oldLayoutInfo.rect.height;\n                estimatedSize = invalidationContext.sizeChanged || oldLayoutInfo.estimatedSize || oldLayoutInfo.content !== node;\n            }\n            // Figure out which column to place the item in, and compute its position.\n            // Preserve the previous column index so items don't jump around during resizing unless the number of columns changed.\n            let prevColumn = numColumns === this.numColumns && oldLayoutInfo && oldLayoutInfo.rect.y < this.virtualizer.visibleRect.maxY ? oldLayoutInfo.column : undefined;\n            let column = prevColumn !== null && prevColumn !== void 0 ? prevColumn : columnHeights.reduce((minIndex, h, i)=>h < columnHeights[minIndex] ? i : minIndex, 0);\n            let x = horizontalSpacing + column * (itemWidth + horizontalSpacing);\n            let y = columnHeights[column];\n            let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, itemWidth, height);\n            let layoutInfo = new $f483179558aa907f$var$WaterfallLayoutInfo(node.type, key, rect);\n            layoutInfo.estimatedSize = estimatedSize;\n            layoutInfo.allowOverflow = true;\n            layoutInfo.content = node;\n            layoutInfo.column = column;\n            newLayoutInfos.set(key, layoutInfo);\n            columnHeights[column] += layoutInfo.rect.height + minSpace.height;\n        };\n        let skeletonCount = 0;\n        for (let node of this.virtualizer.collection)if (node.type === 'skeleton') {\n            // Add skeleton cards until every column has at least one, and we fill the viewport.\n            let startingHeights = [\n                ...columnHeights\n            ];\n            while(!columnHeights.every((h, i)=>h !== startingHeights[i]) || Math.min(...columnHeights) < this.virtualizer.visibleRect.height){\n                var _this_layoutInfos_get;\n                let key = `${node.key}-${skeletonCount++}`;\n                let content = ((_this_layoutInfos_get = this.layoutInfos.get(key)) === null || _this_layoutInfos_get === void 0 ? void 0 : _this_layoutInfos_get.content) || {\n                    ...node\n                };\n                addNode(key, content);\n            }\n            break;\n        } else addNode(node.key, node);\n        // Reset all columns to the maximum for the next section\n        let maxHeight = Math.max(...columnHeights);\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(this.virtualizer.visibleRect.width, maxHeight);\n        this.layoutInfos = newLayoutInfos;\n        this.numColumns = numColumns;\n    }\n    getLayoutInfo(key) {\n        return this.layoutInfos.get(key);\n    }\n    getContentSize() {\n        return this.contentSize;\n    }\n    getVisibleLayoutInfos(rect) {\n        let layoutInfos = [];\n        for (let layoutInfo of this.layoutInfos.values())if (layoutInfo.rect.intersects(rect) || this.virtualizer.isPersistedKey(layoutInfo.key)) layoutInfos.push(layoutInfo);\n        return layoutInfos;\n    }\n    updateItemSize(key, size) {\n        let layoutInfo = this.layoutInfos.get(key);\n        if (!size || !layoutInfo) return false;\n        if (size.height !== layoutInfo.rect.height) {\n            let newLayoutInfo = layoutInfo.copy();\n            newLayoutInfo.rect.height = size.height;\n            newLayoutInfo.estimatedSize = false;\n            this.layoutInfos.set(key, newLayoutInfo);\n            return true;\n        }\n        return false;\n    }\n    // Override keyboard navigation to work spatially.\n    getKeyRightOf(key) {\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(layoutInfo.rect.maxX, layoutInfo.rect.y, this.virtualizer.visibleRect.maxX - layoutInfo.rect.maxX, layoutInfo.rect.height);\n        let layoutInfos = this.getVisibleLayoutInfos(rect);\n        let bestKey = null;\n        let bestDistance = Infinity;\n        for (let candidate of layoutInfos){\n            if (candidate.key === key) continue;\n            // Find the closest item in the x direction with the most overlap in the y direction.\n            let deltaX = candidate.rect.x - rect.x;\n            let overlapY = Math.min(candidate.rect.maxY, rect.maxY) - Math.max(candidate.rect.y, rect.y);\n            let distance = deltaX - overlapY;\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestKey = candidate.key;\n            }\n        }\n        return bestKey;\n    }\n    getKeyLeftOf(key) {\n        let layoutInfo = this.getLayoutInfo(key);\n        if (!layoutInfo) return null;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, layoutInfo.rect.y, layoutInfo.rect.x, layoutInfo.rect.height);\n        let layoutInfos = this.getVisibleLayoutInfos(rect);\n        let bestKey = null;\n        let bestDistance = Infinity;\n        for (let candidate of layoutInfos){\n            if (candidate.key === key) continue;\n            // Find the closest item in the x direction with the most overlap in the y direction.\n            let deltaX = rect.maxX - candidate.rect.maxX;\n            let overlapY = Math.min(candidate.rect.maxY, rect.maxY) - Math.max(candidate.rect.y, rect.y);\n            let distance = deltaX - overlapY;\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestKey = candidate.key;\n            }\n        }\n        return bestKey;\n    }\n    // This overrides the default behavior of shift selection to work spatially\n    // rather than following the order of the items in the collection (which may appear unpredictable).\n    getKeyRange(from, to) {\n        let fromLayoutInfo = this.getLayoutInfo(from);\n        let toLayoutInfo = this.getLayoutInfo(to);\n        if (!fromLayoutInfo || !toLayoutInfo) return [];\n        // Find items where half of the area intersects the rectangle\n        // formed from the first item to the last item in the range.\n        let rect = fromLayoutInfo.rect.union(toLayoutInfo.rect);\n        let keys = [];\n        for (let layoutInfo of this.layoutInfos.values())if (rect.intersection(layoutInfo.rect).area > layoutInfo.rect.area / 2) keys.push(layoutInfo.key);\n        return keys;\n    }\n    getDropTargetFromPoint(x, y) {\n        if (this.layoutInfos.size === 0) return {\n            type: 'root'\n        };\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        let key = this.virtualizer.keyAtPoint(new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Point)(x, y));\n        if (key == null) return {\n            type: 'root'\n        };\n        // Only support \"on\" drop position in waterfall layout.\n        // Reordering doesn't make sense because the items don't have a deterministic order.\n        return {\n            type: 'item',\n            key: key,\n            dropPosition: 'on'\n        };\n    }\n    constructor(...args){\n        super(...args), this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(), this.layoutInfos = new Map(), this.numColumns = 0, this.dropIndicatorThickness = 2;\n    }\n}\n\n\n\n//# sourceMappingURL=WaterfallLayout.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9XYXRlcmZhbGxMYXlvdXQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFLOztBQUVySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtFQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0REFBVztBQUNwQyx5QkFBeUIsNERBQVc7QUFDcEMsc0JBQXNCLDREQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw4REFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNFpBQTRaO0FBQzFhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsR0FBRyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtQ0FBbUMsNERBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNkRBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDREQUFXO0FBQzlEO0FBQ0E7OztBQUdzRTtBQUN0RSIsInNvdXJjZXMiOlsiL1VzZXJzL2phaW1laXNyYWVsY2FtcGVhcy9rZXlzdG9uZS9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDQuMi4xX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L1dhdGVyZmFsbExheW91dC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMYXlvdXRJbmZvIGFzICRsRnp3SSRMYXlvdXRJbmZvLCBTaXplIGFzICRsRnp3SSRTaXplLCBSZWN0IGFzICRsRnp3SSRSZWN0LCBQb2ludCBhcyAkbEZ6d0kkUG9pbnQsIExheW91dCBhcyAkbEZ6d0kkTGF5b3V0fSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXJcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDI0IEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY2xhc3MgJGY0ODMxNzk1NThhYTkwN2YkdmFyJFdhdGVyZmFsbExheW91dEluZm8gZXh0ZW5kcyAoMCwgJGxGendJJExheW91dEluZm8pIHtcbiAgICBjb3B5KCkge1xuICAgICAgICBsZXQgcmVzID0gc3VwZXIuY29weSgpO1xuICAgICAgICByZXMuY29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKSwgdGhpcy5jb2x1bW4gPSAwO1xuICAgIH1cbn1cbmNvbnN0ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMgPSB7XG4gICAgbWluSXRlbVNpemU6IG5ldyAoMCwgJGxGendJJFNpemUpKDIwMCwgMjAwKSxcbiAgICBtYXhJdGVtU2l6ZTogbmV3ICgwLCAkbEZ6d0kkU2l6ZSkoSW5maW5pdHksIEluZmluaXR5KSxcbiAgICBtaW5TcGFjZTogbmV3ICgwLCAkbEZ6d0kkU2l6ZSkoMTgsIDE4KSxcbiAgICBtYXhDb2x1bW5zOiBJbmZpbml0eSxcbiAgICBkcm9wSW5kaWNhdG9yVGhpY2tuZXNzOiAyXG59O1xuY2xhc3MgJGY0ODMxNzk1NThhYTkwN2YkZXhwb3J0JGU5ZjdjZGEwNThiYThkZjggZXh0ZW5kcyAoMCwgJGxGendJJExheW91dCkge1xuICAgIHNob3VsZEludmFsaWRhdGVMYXlvdXRPcHRpb25zKG5ld09wdGlvbnMsIG9sZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnMubWF4Q29sdW1ucyAhPT0gb2xkT3B0aW9ucy5tYXhDb2x1bW5zIHx8IG5ld09wdGlvbnMuZHJvcEluZGljYXRvclRoaWNrbmVzcyAhPT0gb2xkT3B0aW9ucy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIHx8ICEobmV3T3B0aW9ucy5taW5JdGVtU2l6ZSB8fCAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1pbkl0ZW1TaXplKS5lcXVhbHMob2xkT3B0aW9ucy5taW5JdGVtU2l6ZSB8fCAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1pbkl0ZW1TaXplKSB8fCAhKG5ld09wdGlvbnMubWF4SXRlbVNpemUgfHwgJGY0ODMxNzk1NThhYTkwN2YkdmFyJERFRkFVTFRfT1BUSU9OUy5tYXhJdGVtU2l6ZSkuZXF1YWxzKG9sZE9wdGlvbnMubWF4SXRlbVNpemUgfHwgJGY0ODMxNzk1NThhYTkwN2YkdmFyJERFRkFVTFRfT1BUSU9OUy5tYXhJdGVtU2l6ZSkgfHwgIShuZXdPcHRpb25zLm1pblNwYWNlIHx8ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMubWluU3BhY2UpLmVxdWFscyhvbGRPcHRpb25zLm1pblNwYWNlIHx8ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRERUZBVUxUX09QVElPTlMubWluU3BhY2UpO1xuICAgIH1cbiAgICB1cGRhdGUoaW52YWxpZGF0aW9uQ29udGV4dCkge1xuICAgICAgICBsZXQgeyBtaW5JdGVtU2l6ZTogbWluSXRlbVNpemUgPSAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1pbkl0ZW1TaXplLCBtYXhJdGVtU2l6ZTogbWF4SXRlbVNpemUgPSAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1heEl0ZW1TaXplLCBtaW5TcGFjZTogbWluU3BhY2UgPSAkZjQ4MzE3OTU1OGFhOTA3ZiR2YXIkREVGQVVMVF9PUFRJT05TLm1pblNwYWNlLCBtYXhDb2x1bW5zOiBtYXhDb2x1bW5zID0gJGY0ODMxNzk1NThhYTkwN2YkdmFyJERFRkFVTFRfT1BUSU9OUy5tYXhDb2x1bW5zLCBkcm9wSW5kaWNhdG9yVGhpY2tuZXNzOiBkcm9wSW5kaWNhdG9yVGhpY2tuZXNzID0gJGY0ODMxNzk1NThhYTkwN2YkdmFyJERFRkFVTFRfT1BUSU9OUy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzIH0gPSBpbnZhbGlkYXRpb25Db250ZXh0LmxheW91dE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuZHJvcEluZGljYXRvclRoaWNrbmVzcyA9IGRyb3BJbmRpY2F0b3JUaGlja25lc3M7XG4gICAgICAgIGxldCB2aXNpYmxlV2lkdGggPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoO1xuICAgICAgICAvLyBUaGUgbWF4IGl0ZW0gd2lkdGggaXMgYWx3YXlzIHRoZSBlbnRpcmUgdmlld3BvcnQuXG4gICAgICAgIC8vIElmIHRoZSBtYXggaXRlbSBoZWlnaHQgaXMgaW5maW5pdHksIHNjYWxlIGluIHByb3BvcnRpb24gdG8gdGhlIG1heCB3aWR0aC5cbiAgICAgICAgbGV0IG1heEl0ZW1XaWR0aCA9IE1hdGgubWluKG1heEl0ZW1TaXplLndpZHRoLCB2aXNpYmxlV2lkdGgpO1xuICAgICAgICBsZXQgbWF4SXRlbUhlaWdodCA9IE51bWJlci5pc0Zpbml0ZShtYXhJdGVtU2l6ZS5oZWlnaHQpID8gbWF4SXRlbVNpemUuaGVpZ2h0IDogTWF0aC5mbG9vcihtaW5JdGVtU2l6ZS5oZWlnaHQgLyBtaW5JdGVtU2l6ZS53aWR0aCAqIG1heEl0ZW1XaWR0aCk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIG5lZWRlZCB0byBkaXNwbGF5IHRoZSBjb250ZW50XG4gICAgICAgIGxldCBjb2x1bW5zID0gTWF0aC5mbG9vcih2aXNpYmxlV2lkdGggLyAobWluSXRlbVNpemUud2lkdGggKyBtaW5TcGFjZS53aWR0aCkpO1xuICAgICAgICBsZXQgbnVtQ29sdW1ucyA9IE1hdGgubWF4KDEsIE1hdGgubWluKG1heENvbHVtbnMsIGNvbHVtbnMpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYXZhaWxhYmxlIHdpZHRoIChtaW51cyB0aGUgc3BhY2UgYmV0d2VlbiBpdGVtcylcbiAgICAgICAgbGV0IHdpZHRoID0gdmlzaWJsZVdpZHRoIC0gbWluU3BhY2Uud2lkdGggKiBNYXRoLm1heCgwLCBudW1Db2x1bW5zKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaXRlbSB3aWR0aCBiYXNlZCBvbiB0aGUgc3BhY2UgYXZhaWxhYmxlXG4gICAgICAgIGxldCBpdGVtV2lkdGggPSBNYXRoLmZsb29yKHdpZHRoIC8gbnVtQ29sdW1ucyk7XG4gICAgICAgIGl0ZW1XaWR0aCA9IE1hdGgubWF4KG1pbkl0ZW1TaXplLndpZHRoLCBNYXRoLm1pbihtYXhJdGVtV2lkdGgsIGl0ZW1XaWR0aCkpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBpdGVtIGhlaWdodCwgd2hpY2ggaXMgcHJvcG9ydGlvbmFsIHRvIHRoZSBpdGVtIHdpZHRoXG4gICAgICAgIGxldCB0ID0gKGl0ZW1XaWR0aCAtIG1pbkl0ZW1TaXplLndpZHRoKSAvIE1hdGgubWF4KDEsIG1heEl0ZW1XaWR0aCAtIG1pbkl0ZW1TaXplLndpZHRoKTtcbiAgICAgICAgbGV0IGl0ZW1IZWlnaHQgPSBtaW5JdGVtU2l6ZS5oZWlnaHQgKyBNYXRoLmZsb29yKChtYXhJdGVtSGVpZ2h0IC0gbWluSXRlbVNpemUuaGVpZ2h0KSAqIHQpO1xuICAgICAgICBpdGVtSGVpZ2h0ID0gTWF0aC5tYXgobWluSXRlbVNpemUuaGVpZ2h0LCBNYXRoLm1pbihtYXhJdGVtSGVpZ2h0LCBpdGVtSGVpZ2h0KSk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGhvcml6b250YWwgc3BhY2luZyBhbmQgY29udGVudCBoZWlnaHRcbiAgICAgICAgbGV0IGhvcml6b250YWxTcGFjaW5nID0gTWF0aC5mbG9vcigodmlzaWJsZVdpZHRoIC0gbnVtQ29sdW1ucyAqIGl0ZW1XaWR0aCkgLyAobnVtQ29sdW1ucyArIDEpKTtcbiAgICAgICAgLy8gU2V0dXAgYW4gYXJyYXkgb2YgY29sdW1uIGhlaWdodHNcbiAgICAgICAgbGV0IGNvbHVtbkhlaWdodHMgPSBBcnJheShudW1Db2x1bW5zKS5maWxsKG1pblNwYWNlLmhlaWdodCk7XG4gICAgICAgIGxldCBuZXdMYXlvdXRJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGFkZE5vZGUgPSAoa2V5LCBub2RlKT0+e1xuICAgICAgICAgICAgbGV0IG9sZExheW91dEluZm8gPSB0aGlzLmxheW91dEluZm9zLmdldChrZXkpO1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGl0ZW1IZWlnaHQ7XG4gICAgICAgICAgICBsZXQgZXN0aW1hdGVkU2l6ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAob2xkTGF5b3V0SW5mbykge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IG9sZExheW91dEluZm8ucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkU2l6ZSA9IGludmFsaWRhdGlvbkNvbnRleHQuc2l6ZUNoYW5nZWQgfHwgb2xkTGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplIHx8IG9sZExheW91dEluZm8uY29udGVudCAhPT0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggY29sdW1uIHRvIHBsYWNlIHRoZSBpdGVtIGluLCBhbmQgY29tcHV0ZSBpdHMgcG9zaXRpb24uXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgcHJldmlvdXMgY29sdW1uIGluZGV4IHNvIGl0ZW1zIGRvbid0IGp1bXAgYXJvdW5kIGR1cmluZyByZXNpemluZyB1bmxlc3MgdGhlIG51bWJlciBvZiBjb2x1bW5zIGNoYW5nZWQuXG4gICAgICAgICAgICBsZXQgcHJldkNvbHVtbiA9IG51bUNvbHVtbnMgPT09IHRoaXMubnVtQ29sdW1ucyAmJiBvbGRMYXlvdXRJbmZvICYmIG9sZExheW91dEluZm8ucmVjdC55IDwgdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC5tYXhZID8gb2xkTGF5b3V0SW5mby5jb2x1bW4gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gcHJldkNvbHVtbiAhPT0gbnVsbCAmJiBwcmV2Q29sdW1uICE9PSB2b2lkIDAgPyBwcmV2Q29sdW1uIDogY29sdW1uSGVpZ2h0cy5yZWR1Y2UoKG1pbkluZGV4LCBoLCBpKT0+aCA8IGNvbHVtbkhlaWdodHNbbWluSW5kZXhdID8gaSA6IG1pbkluZGV4LCAwKTtcbiAgICAgICAgICAgIGxldCB4ID0gaG9yaXpvbnRhbFNwYWNpbmcgKyBjb2x1bW4gKiAoaXRlbVdpZHRoICsgaG9yaXpvbnRhbFNwYWNpbmcpO1xuICAgICAgICAgICAgbGV0IHkgPSBjb2x1bW5IZWlnaHRzW2NvbHVtbl07XG4gICAgICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGxGendJJFJlY3QpKHgsIHksIGl0ZW1XaWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICRmNDgzMTc5NTU4YWE5MDdmJHZhciRXYXRlcmZhbGxMYXlvdXRJbmZvKG5vZGUudHlwZSwga2V5LCByZWN0KTtcbiAgICAgICAgICAgIGxheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGVzdGltYXRlZFNpemU7XG4gICAgICAgICAgICBsYXlvdXRJbmZvLmFsbG93T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5jb250ZW50ID0gbm9kZTtcbiAgICAgICAgICAgIGxheW91dEluZm8uY29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgbmV3TGF5b3V0SW5mb3Muc2V0KGtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgICAgICBjb2x1bW5IZWlnaHRzW2NvbHVtbl0gKz0gbGF5b3V0SW5mby5yZWN0LmhlaWdodCArIG1pblNwYWNlLmhlaWdodDtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNrZWxldG9uQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMudmlydHVhbGl6ZXIuY29sbGVjdGlvbilpZiAobm9kZS50eXBlID09PSAnc2tlbGV0b24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgc2tlbGV0b24gY2FyZHMgdW50aWwgZXZlcnkgY29sdW1uIGhhcyBhdCBsZWFzdCBvbmUsIGFuZCB3ZSBmaWxsIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgIGxldCBzdGFydGluZ0hlaWdodHMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY29sdW1uSGVpZ2h0c1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHdoaWxlKCFjb2x1bW5IZWlnaHRzLmV2ZXJ5KChoLCBpKT0+aCAhPT0gc3RhcnRpbmdIZWlnaHRzW2ldKSB8fCBNYXRoLm1pbiguLi5jb2x1bW5IZWlnaHRzKSA8IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QuaGVpZ2h0KXtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbGF5b3V0SW5mb3NfZ2V0O1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBgJHtub2RlLmtleX0tJHtza2VsZXRvbkNvdW50Kyt9YDtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9ICgoX3RoaXNfbGF5b3V0SW5mb3NfZ2V0ID0gdGhpcy5sYXlvdXRJbmZvcy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3RoaXNfbGF5b3V0SW5mb3NfZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19sYXlvdXRJbmZvc19nZXQuY29udGVudCkgfHwge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGROb2RlKGtleSwgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGFkZE5vZGUobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAvLyBSZXNldCBhbGwgY29sdW1ucyB0byB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQgc2VjdGlvblxuICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoLi4uY29sdW1uSGVpZ2h0cyk7XG4gICAgICAgIHRoaXMuY29udGVudFNpemUgPSBuZXcgKDAsICRsRnp3SSRTaXplKSh0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoLCBtYXhIZWlnaHQpO1xuICAgICAgICB0aGlzLmxheW91dEluZm9zID0gbmV3TGF5b3V0SW5mb3M7XG4gICAgICAgIHRoaXMubnVtQ29sdW1ucyA9IG51bUNvbHVtbnM7XG4gICAgfVxuICAgIGdldExheW91dEluZm8oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dEluZm9zLmdldChrZXkpO1xuICAgIH1cbiAgICBnZXRDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNpemU7XG4gICAgfVxuICAgIGdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KSB7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIHRoaXMubGF5b3V0SW5mb3MudmFsdWVzKCkpaWYgKGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3RzKHJlY3QpIHx8IHRoaXMudmlydHVhbGl6ZXIuaXNQZXJzaXN0ZWRLZXkobGF5b3V0SW5mby5rZXkpKSBsYXlvdXRJbmZvcy5wdXNoKGxheW91dEluZm8pO1xuICAgICAgICByZXR1cm4gbGF5b3V0SW5mb3M7XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgIGlmICghc2l6ZSB8fCAhbGF5b3V0SW5mbykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc2l6ZS5oZWlnaHQgIT09IGxheW91dEluZm8ucmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdMYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBuZXdMYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBuZXdMYXlvdXRJbmZvLmVzdGltYXRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0SW5mb3Muc2V0KGtleSwgbmV3TGF5b3V0SW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIGtleWJvYXJkIG5hdmlnYXRpb24gdG8gd29yayBzcGF0aWFsbHkuXG4gICAgZ2V0S2V5UmlnaHRPZihrZXkpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRsRnp3SSRSZWN0KShsYXlvdXRJbmZvLnJlY3QubWF4WCwgbGF5b3V0SW5mby5yZWN0LnksIHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QubWF4WCAtIGxheW91dEluZm8ucmVjdC5tYXhYLCBsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0KTtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCk7XG4gICAgICAgIGxldCBiZXN0S2V5ID0gbnVsbDtcbiAgICAgICAgbGV0IGJlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBjYW5kaWRhdGUgb2YgbGF5b3V0SW5mb3Mpe1xuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5rZXkgPT09IGtleSkgY29udGludWU7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGl0ZW0gaW4gdGhlIHggZGlyZWN0aW9uIHdpdGggdGhlIG1vc3Qgb3ZlcmxhcCBpbiB0aGUgeSBkaXJlY3Rpb24uXG4gICAgICAgICAgICBsZXQgZGVsdGFYID0gY2FuZGlkYXRlLnJlY3QueCAtIHJlY3QueDtcbiAgICAgICAgICAgIGxldCBvdmVybGFwWSA9IE1hdGgubWluKGNhbmRpZGF0ZS5yZWN0Lm1heFksIHJlY3QubWF4WSkgLSBNYXRoLm1heChjYW5kaWRhdGUucmVjdC55LCByZWN0LnkpO1xuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gZGVsdGFYIC0gb3ZlcmxhcFk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBiZXN0S2V5ID0gY2FuZGlkYXRlLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdEtleTtcbiAgICB9XG4gICAgZ2V0S2V5TGVmdE9mKGtleSkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICBpZiAoIWxheW91dEluZm8pIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGxGendJJFJlY3QpKDAsIGxheW91dEluZm8ucmVjdC55LCBsYXlvdXRJbmZvLnJlY3QueCwgbGF5b3V0SW5mby5yZWN0LmhlaWdodCk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IHRoaXMuZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpO1xuICAgICAgICBsZXQgYmVzdEtleSA9IG51bGw7XG4gICAgICAgIGxldCBiZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgY2FuZGlkYXRlIG9mIGxheW91dEluZm9zKXtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUua2V5ID09PSBrZXkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBpdGVtIGluIHRoZSB4IGRpcmVjdGlvbiB3aXRoIHRoZSBtb3N0IG92ZXJsYXAgaW4gdGhlIHkgZGlyZWN0aW9uLlxuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IHJlY3QubWF4WCAtIGNhbmRpZGF0ZS5yZWN0Lm1heFg7XG4gICAgICAgICAgICBsZXQgb3ZlcmxhcFkgPSBNYXRoLm1pbihjYW5kaWRhdGUucmVjdC5tYXhZLCByZWN0Lm1heFkpIC0gTWF0aC5tYXgoY2FuZGlkYXRlLnJlY3QueSwgcmVjdC55KTtcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGRlbHRhWCAtIG92ZXJsYXBZO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgYmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgYmVzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYmVzdEtleSA9IGNhbmRpZGF0ZS5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RLZXk7XG4gICAgfVxuICAgIC8vIFRoaXMgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHNoaWZ0IHNlbGVjdGlvbiB0byB3b3JrIHNwYXRpYWxseVxuICAgIC8vIHJhdGhlciB0aGFuIGZvbGxvd2luZyB0aGUgb3JkZXIgb2YgdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uICh3aGljaCBtYXkgYXBwZWFyIHVucHJlZGljdGFibGUpLlxuICAgIGdldEtleVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBmcm9tTGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhmcm9tKTtcbiAgICAgICAgbGV0IHRvTGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyh0byk7XG4gICAgICAgIGlmICghZnJvbUxheW91dEluZm8gfHwgIXRvTGF5b3V0SW5mbykgcmV0dXJuIFtdO1xuICAgICAgICAvLyBGaW5kIGl0ZW1zIHdoZXJlIGhhbGYgb2YgdGhlIGFyZWEgaW50ZXJzZWN0cyB0aGUgcmVjdGFuZ2xlXG4gICAgICAgIC8vIGZvcm1lZCBmcm9tIHRoZSBmaXJzdCBpdGVtIHRvIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHJhbmdlLlxuICAgICAgICBsZXQgcmVjdCA9IGZyb21MYXlvdXRJbmZvLnJlY3QudW5pb24odG9MYXlvdXRJbmZvLnJlY3QpO1xuICAgICAgICBsZXQga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIHRoaXMubGF5b3V0SW5mb3MudmFsdWVzKCkpaWYgKHJlY3QuaW50ZXJzZWN0aW9uKGxheW91dEluZm8ucmVjdCkuYXJlYSA+IGxheW91dEluZm8ucmVjdC5hcmVhIC8gMikga2V5cy5wdXNoKGxheW91dEluZm8ua2V5KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGdldERyb3BUYXJnZXRGcm9tUG9pbnQoeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5sYXlvdXRJbmZvcy5zaXplID09PSAwKSByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3Jvb3QnXG4gICAgICAgIH07XG4gICAgICAgIHggKz0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC54O1xuICAgICAgICB5ICs9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QueTtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMudmlydHVhbGl6ZXIua2V5QXRQb2ludChuZXcgKDAsICRsRnp3SSRQb2ludCkoeCwgeSkpO1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncm9vdCdcbiAgICAgICAgfTtcbiAgICAgICAgLy8gT25seSBzdXBwb3J0IFwib25cIiBkcm9wIHBvc2l0aW9uIGluIHdhdGVyZmFsbCBsYXlvdXQuXG4gICAgICAgIC8vIFJlb3JkZXJpbmcgZG9lc24ndCBtYWtlIHNlbnNlIGJlY2F1c2UgdGhlIGl0ZW1zIGRvbid0IGhhdmUgYSBkZXRlcm1pbmlzdGljIG9yZGVyLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2l0ZW0nLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBkcm9wUG9zaXRpb246ICdvbidcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpLCB0aGlzLmNvbnRlbnRTaXplID0gbmV3ICgwLCAkbEZ6d0kkU2l6ZSkoKSwgdGhpcy5sYXlvdXRJbmZvcyA9IG5ldyBNYXAoKSwgdGhpcy5udW1Db2x1bW5zID0gMCwgdGhpcy5kcm9wSW5kaWNhdG9yVGhpY2tuZXNzID0gMjtcbiAgICB9XG59XG5cblxuZXhwb3J0IHskZjQ4MzE3OTU1OGFhOTA3ZiRleHBvcnQkZTlmN2NkYTA1OGJhOGRmOCBhcyBXYXRlcmZhbGxMYXlvdXR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2F0ZXJmYWxsTGF5b3V0Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/import.mjs":
/*!*****************************************************************************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/import.mjs ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayout: () => (/* reexport safe */ _GridLayout_mjs__WEBPACK_IMPORTED_MODULE_0__.GridLayout),\n/* harmony export */   ListLayout: () => (/* reexport safe */ _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_1__.ListLayout),\n/* harmony export */   TableLayout: () => (/* reexport safe */ _TableLayout_mjs__WEBPACK_IMPORTED_MODULE_2__.TableLayout),\n/* harmony export */   WaterfallLayout: () => (/* reexport safe */ _WaterfallLayout_mjs__WEBPACK_IMPORTED_MODULE_3__.WaterfallLayout)\n/* harmony export */ });\n/* harmony import */ var _GridLayout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GridLayout.mjs */ \"../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/GridLayout.mjs\");\n/* harmony import */ var _ListLayout_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ListLayout.mjs */ \"../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/ListLayout.mjs\");\n/* harmony import */ var _TableLayout_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TableLayout.mjs */ \"../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/TableLayout.mjs\");\n/* harmony import */ var _WaterfallLayout_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WaterfallLayout.mjs */ \"../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/WaterfallLayout.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlGO0FBQ0E7QUFDRTtBQUNROztBQUVuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNa1A7QUFDbFAiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEA0LjIuMV9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9pbXBvcnQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7R3JpZExheW91dCBhcyAkYTU4NTkyZDI5NWExNzBhNCRleHBvcnQkN2QyYjEyNTc4MTU0YTczNX0gZnJvbSBcIi4vR3JpZExheW91dC5tanNcIjtcbmltcG9ydCB7TGlzdExheW91dCBhcyAkNjFlZjYwZmM5YjEwNDFmNCRleHBvcnQkY2FjYmIzOTI0MTU1ZDY4ZX0gZnJvbSBcIi4vTGlzdExheW91dC5tanNcIjtcbmltcG9ydCB7VGFibGVMYXlvdXQgYXMgJGExNTIxMTJlOTAyNzA5YmYkZXhwb3J0JDYyNDQ0YzNjNzI0YjFiMjB9IGZyb20gXCIuL1RhYmxlTGF5b3V0Lm1qc1wiO1xuaW1wb3J0IHtXYXRlcmZhbGxMYXlvdXQgYXMgJGY0ODMxNzk1NThhYTkwN2YkZXhwb3J0JGU5ZjdjZGEwNThiYThkZjh9IGZyb20gXCIuL1dhdGVyZmFsbExheW91dC5tanNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuXG5cbmV4cG9ydCB7JGE1ODU5MmQyOTVhMTcwYTQkZXhwb3J0JDdkMmIxMjU3ODE1NGE3MzUgYXMgR3JpZExheW91dCwgJDYxZWY2MGZjOWIxMDQxZjQkZXhwb3J0JGNhY2JiMzkyNDE1NWQ2OGUgYXMgTGlzdExheW91dCwgJGExNTIxMTJlOTAyNzA5YmYkZXhwb3J0JDYyNDQ0YzNjNzI0YjFiMjAgYXMgVGFibGVMYXlvdXQsICRmNDgzMTc5NTU4YWE5MDdmJGV4cG9ydCRlOWY3Y2RhMDU4YmE4ZGY4IGFzIFdhdGVyZmFsbExheW91dH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/@react-stately+layout@4.2.1_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-stately/layout/dist/import.mjs\n");

/***/ })

};
;