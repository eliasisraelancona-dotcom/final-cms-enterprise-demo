"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-dom@0.112.2_slate@0.112.0";
exports.ids = ["vendor-chunks/slate-dom@0.112.2_slate@0.112.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/slate-dom@0.112.2_slate@0.112.0/node_modules/slate-dom/dist/index.js":
/*!***********************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/slate-dom@0.112.2_slate@0.112.0/node_modules/slate-dom/dist/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar slate = __webpack_require__(/*! slate */ \"(pages-dir-node)/../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js\");\nvar isHotkey = __webpack_require__(/*! is-hotkey */ \"(pages-dir-node)/../../../../node_modules/.pnpm/is-hotkey@0.2.0/node_modules/is-hotkey/lib/index.js\");\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar arrayLikeToArray = createCommonjsModule(function (module) {\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayLikeToArray);\n\nvar arrayWithoutHoles = createCommonjsModule(function (module) {\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithoutHoles);\n\nvar iterableToArray = createCommonjsModule(function (module) {\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArray);\n\nvar unsupportedIterableToArray = createCommonjsModule(function (module) {\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(unsupportedIterableToArray);\n\nvar nonIterableSpread = createCommonjsModule(function (module) {\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableSpread);\n\nvar toConsumableArray = createCommonjsModule(function (module) {\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nvar arrayWithHoles = createCommonjsModule(function (module) {\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithHoles);\n\nvar iterableToArrayLimit = createCommonjsModule(function (module) {\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArrayLimit);\n\nvar nonIterableRest = createCommonjsModule(function (module) {\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableRest);\n\nvar slicedToArray = createCommonjsModule(function (module) {\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Types.\n */\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */\nvar getDefaultView = function getDefaultView(value) {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */\nvar isDOMComment = function isDOMComment(value) {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMElement = function isDOMElement(value) {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */\nvar isDOMNode = function isDOMNode(value) {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */\nvar isDOMSelection = function isDOMSelection(value) {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMText = function isDOMText(value) {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\nvar isPlainTextOnlyPaste = function isPlainTextOnlyPaste(event) {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\nvar normalizeDOMPoint = function normalizeDOMPoint(domPoint) {\n  var _domPoint = _slicedToArray(domPoint, 2),\n    node = _domPoint[0],\n    offset = _domPoint[1];\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    // If the editable child found is in front of input offset, we instead seek to its end\n    var _getEditableChildAndI = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    var _getEditableChildAndI2 = _slicedToArray(_getEditableChildAndI, 2);\n    node = _getEditableChildAndI2[0];\n    index = _getEditableChildAndI2[1];\n    isLast = index < offset;\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    }\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  // Return the node and offset.\n  return [node, offset];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\nvar hasShadowRoot = function hasShadowRoot(node) {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChildAndIndex = function getEditableChildAndIndex(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChild = function getEditableChild(parent, index, direction) {\n  var _getEditableChildAndI3 = getEditableChildAndIndex(parent, index, direction),\n    _getEditableChildAndI4 = _slicedToArray(_getEditableChildAndI3, 1),\n    child = _getEditableChildAndI4[0];\n  return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\nvar getPlainText = function getPlainText(domNode) {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var _i = 0, _Array$from = Array.from(domNode.childNodes); _i < _Array$from.length; _i++) {\n      var childNode = _Array$from[_i];\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = function getSlateFragmentAttribute(dataTransfer) {\n  var htmlData = dataTransfer.getData('text/html');\n  var _ref = htmlData.match(catchSlateFragment) || [],\n    _ref2 = _slicedToArray(_ref, 2),\n    fragment = _ref2[1];\n  return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nvar getSelection = function getSelection(root) {\n  if (root.getSelection != null) {\n    return root.getSelection();\n  }\n  return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\nvar isTrackedMutation = function isTrackedMutation(editor, mutation, batch) {\n  var target = mutation.target;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var _DOMEditor$getWindow = DOMEditor.getWindow(editor),\n    document = _DOMEditor$getWindow.document;\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(function (_ref3) {\n    var addedNodes = _ref3.addedNodes,\n      removedNodes = _ref3.removedNodes;\n    var _iterator = _createForOfIteratorHelper$1(addedNodes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var node = _step.value;\n        if (node === target || node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper$1(removedNodes),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _node = _step2.value;\n        if (_node === target || _node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nvar getActiveElement = function getActiveElement() {\n  var activeElement = document.activeElement;\n  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {\n    var _activeElement, _activeElement$shadow, _activeElement2;\n    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n  }\n  return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nvar isBefore = function isBefore(node, otherNode) {\n  return Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n};\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nvar isAfter = function isAfter(node, otherNode) {\n  return Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\n};\n\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n// Check if the browser is Safari and older than 17\ntypeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nvar _typeof_1 = createCommonjsModule(function (module) {\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(_typeof_1);\n\nvar toPrimitive = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPrimitive);\n\nvar toPropertyKey = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\n\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPropertyKey);\n\nvar createClass = createCommonjsModule(function (module) {\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _createClass = unwrapExports(createClass);\n\nvar classCallCheck = createCommonjsModule(function (module) {\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _classCallCheck = unwrapExports(classCallCheck);\n\nvar defineProperty = createCommonjsModule(function (module) {\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _defineProperty = unwrapExports(defineProperty);\n\n/**\n * An auto-incrementing identifier for keys.\n */\nvar n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\nvar Key = /*#__PURE__*/_createClass(function Key() {\n  _classCallCheck(this, Key);\n  _defineProperty(this, \"id\", void 0);\n  this.id = \"\".concat(n++);\n});\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nvar IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n  androidPendingDiffs: function androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  },\n  androidScheduleFlush: function androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: function blur(editor) {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      slate.Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: function findDocumentOrShadowRoot(editor) {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  findEventRange: function findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var _event = event,\n      x = _event.clientX,\n      y = _event.clientY,\n      target = _event.target;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = DOMEditor.toSlateNode(editor, event.target);\n    var path = DOMEditor.findPath(editor, node);\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (slate.Element.isElement(node) && slate.Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = slate.Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? slate.Editor.before(editor, edge) : slate.Editor.after(editor, edge);\n      if (point) {\n        var _range = slate.Editor.range(editor, point);\n        return _range;\n      }\n    }\n    // Else resolve a range from the caret position where the drop occured.\n    var domRange;\n    var _DOMEditor$getWindow = DOMEditor.getWindow(editor),\n      document = _DOMEditor$getWindow.document;\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    // Resolve a Slate range from the DOM range.\n    var range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: function findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  findPath: function findPath(editor, node) {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (slate.Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(slate.Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      retries: 5\n    };\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return;\n    }\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error('Could not set focus, editor seems stuck with pending operations');\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(function () {\n        DOMEditor.focus(editor, {\n          retries: options.retries - 1\n        });\n      }, 10);\n      return;\n    }\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        var domSelection = getSelection(root);\n        var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        slate.Transforms.select(editor, slate.Editor.start(editor, []));\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true);\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: function getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$editable = options.editable,\n      editable = _options$editable === void 0 ? false : _options$editable;\n    var editorEl = DOMEditor.toDOMNode(editor, editor);\n    var targetEl;\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: function hasEditableTarget(editor, target) {\n    return isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  },\n  hasRange: function hasRange(editor, range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    return slate.Editor.hasPath(editor, anchor.path) && slate.Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: function hasSelectableTarget(editor, target) {\n    return DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target);\n  },\n  hasTarget: function hasTarget(editor, target) {\n    return isDOMNode(target) && DOMEditor.hasDOMNode(editor, target);\n  },\n  insertData: function insertData(editor, data) {\n    editor.insertData(data);\n  },\n  insertFragmentData: function insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n  insertTextData: function insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n  isComposing: function isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: function isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n  isReadOnly: function isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n  isTargetInsideNonReadonlyVoid: function isTargetInsideNonReadonlyVoid(editor, target) {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n    return slate.Element.isElement(slateNode) && slate.Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: function setFragmentData(editor, data, originEvent) {\n    return editor.setFragmentData(data, originEvent);\n  },\n  toDOMNode: function toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = slate.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate.Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  toDOMPoint: function toDOMPoint(editor, point) {\n    var _Editor$node = slate.Editor.node(editor, point.path),\n      _Editor$node2 = _slicedToArray(_Editor$node, 1),\n      node = _Editor$node2[0];\n    var el = DOMEditor.toDOMNode(editor, node);\n    var domPoint;\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (slate.Editor[\"void\"](editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var length = domNode.textContent.length;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate.Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  toDOMRange: function toDOMRange(editor, range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    var isBackward = slate.Range.isBackward(range);\n    var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n    var domFocus = slate.Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n    var window = DOMEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var _ref = isBackward ? domFocus : domAnchor,\n      _ref2 = _slicedToArray(_ref, 2),\n      startNode = _ref2[0],\n      startOffset = _ref2[1];\n    var _ref3 = isBackward ? domAnchor : domFocus,\n      _ref4 = _slicedToArray(_ref3, 2),\n      endNode = _ref4[0],\n      endOffset = _ref4[1];\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: function toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  toSlatePoint: function toSlatePoint(editor, domPoint, options) {\n    var exactMatch = options.exactMatch,\n      suppressThrow = options.suppressThrow,\n      _options$searchDirect = options.searchDirection,\n      searchDirection = _options$searchDirect === void 0 ? 'backward' : _options$searchDirect;\n    var _ref5 = exactMatch ? domPoint : normalizeDOMPoint(domPoint),\n      _ref6 = _slicedToArray(_ref5, 2),\n      nearestNode = _ref6[0],\n      nearestOffset = _ref6[1];\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = DOMEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null;\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = DOMEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [].concat(_toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]'))), _toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))));\n          removals.forEach(function (el) {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n              if (el.textContent.startsWith(\"\\uFEFF\")) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(function (el) {\n            offset -= el.textContent.length;\n          });\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        var getLeafNodes = function getLeafNodes(node) {\n          return node ? node.querySelectorAll(\n          // Exclude leaf nodes in nested editors\n          '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];\n        };\n        var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n        if (searchDirection === 'forward') {\n          var _leafNodes$find;\n          var _leafNodes = [].concat(_toConsumableArray(getLeafNodes(elementNode)), _toConsumableArray(getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)));\n          leafNode = (_leafNodes$find = _leafNodes.find(function (leaf) {\n            return isAfter(nonEditableNode, leaf);\n          })) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n        } else {\n          var _leafNodes2$findLast;\n          var _leafNodes2 = [].concat(_toConsumableArray(getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling)), _toConsumableArray(getLeafNodes(elementNode)));\n          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast(function (leaf) {\n            return isBefore(nonEditableNode, leaf);\n          })) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n        }\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          if (searchDirection === 'forward') {\n            offset = 0;\n          } else {\n            offset = domNode.textContent.length;\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(function (el) {\n              offset -= el.textContent.length;\n            });\n          }\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      parentNode.hasAttribute('data-slate-zero-width') ||\n      // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n      // when the document ends with a new-line character. This results in the offset\n      // length being off by one, so we need to subtract one to account for this.\n      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && DOMEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = DOMEditor.toSlateNode(editor, node);\n        var _Editor$start = slate.Editor.start(editor, DOMEditor.findPath(editor, _slateNode)),\n          _path = _Editor$start.path,\n          _offset = _Editor$start.offset;\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    var slateNode = DOMEditor.toSlateNode(editor, textNode);\n    var path = DOMEditor.findPath(editor, slateNode);\n    return {\n      path: path,\n      offset: offset\n    };\n  },\n  toSlateRange: function toSlateRange(editor, domRange, options) {\n    var _focusNode$textConten;\n    var exactMatch = options.exactMatch,\n      suppressThrow = options.suppressThrow;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n          // Here we are in the contenteditable mode of a table in firefox\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            var getLastChildren = function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            };\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer;\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0;\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        }\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\\n\\n') && focusOffset === focusNode.textContent.length) {\n      focusOffset--;\n    }\n    var anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n    var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow,\n      searchDirection: focusBeforeAnchor ? 'forward' : 'backward'\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (slate.Range.isExpanded(range) && slate.Range.isForward(range) && isDOMElement(focusNode) && slate.Editor[\"void\"](editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = slate.Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  }\n};\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nfunction verifyDiffState(editor, textDiff) {\n  var path = textDiff.path,\n    diff = textDiff.diff;\n  if (!slate.Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = slate.Node.get(editor, path);\n  if (!slate.Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = slate.Path.next(path);\n  if (!slate.Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = slate.Node.get(editor, nextPath);\n  return slate.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce(function (text, diff) {\n    return text.slice(0, diff.start) + diff.text + text.slice(diff.end);\n  }, text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nfunction normalizeStringDiff(targetText, diff) {\n  var start = diff.start,\n    end = diff.end,\n    text = diff.text;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start: start,\n    end: end,\n    text: text\n  });\n}\n/**\n * Get the slate range the text diff spans.\n */\nfunction targetRange(textDiff) {\n  var path = textDiff.path,\n    diff = textDiff.diff;\n  return {\n    anchor: {\n      path: path,\n      offset: diff.start\n    },\n    focus: {\n      path: path,\n      offset: diff.end\n    }\n  };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nfunction normalizePoint(editor, point) {\n  var path = point.path,\n    offset = point.offset;\n  if (!slate.Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = slate.Node.get(editor, path);\n  if (!slate.Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = slate.Editor.above(editor, {\n    match: function match(n) {\n      return slate.Element.isElement(n) && slate.Editor.isBlock(editor, n);\n    },\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = slate.Editor.next(editor, {\n      at: path,\n      match: slate.Text.isText\n    });\n    if (!entry || !slate.Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path: path,\n    offset: offset\n  };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (slate.Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(function (_ref) {\n    var path = _ref.path;\n    return slate.Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return slate.Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var diff = textDiff.diff;\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = slate.Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  // Point references location after the diff\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = slate.Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && slate.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (slate.Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var path = textDiff.path,\n    diff = textDiff.diff,\n    id = textDiff.id;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!slate.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!slate.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n    case 'split_node':\n      {\n        if (!slate.Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff: diff,\n            id: id,\n            path: slate.Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id: id,\n          path: slate.Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!slate.Path.equals(op.path, path)) {\n          return {\n            diff: diff,\n            id: id,\n            path: slate.Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id: id,\n          path: slate.Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = slate.Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff: diff,\n    path: newPath,\n    id: id\n  };\n}\n\n/**\n * Utilities for single-line deletion\n */\nvar doRectsIntersect = function doRectsIntersect(rect, compareRect) {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = function areRangesSameLine(editor, range1, range2) {\n  var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nvar findCurrentLineRange = function findCurrentLineRange(editor, parentRange) {\n  var parentRangeBoundary = slate.Editor.range(editor, slate.Range.end(parentRange));\n  var positions = Array.from(slate.Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, slate.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return slate.Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return slate.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, slate.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return slate.Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withDOM = function withDOM(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var apply = e.apply,\n    onChange = e.onChange,\n    deleteBackward = e.deleteBackward,\n    addMark = e.addMark,\n    removeMark = e.removeMark;\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = function (key, value) {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS[\"delete\"](e);\n    addMark(key, value);\n  };\n  e.removeMark = function (key) {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS[\"delete\"](e);\n    removeMark(key);\n  };\n  e.deleteBackward = function (unit) {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && slate.Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = slate.Editor.above(e, {\n        match: function match(n) {\n          return slate.Element.isElement(n) && slate.Editor.isBlock(e, n);\n        },\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var _parentBlockEntry = _slicedToArray(parentBlockEntry, 2),\n          parentBlockPath = _parentBlockEntry[1];\n        var parentElementRange = slate.Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!slate.Range.isCollapsed(currentLineRange)) {\n          slate.Transforms[\"delete\"](e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = function (op) {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(function (textDiff) {\n        return transformTextDiff(textDiff, op);\n      }).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = slate.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at: at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, op.path)));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION[\"delete\"](e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, slate.Path.parent(op.path))));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = slate.Path.previous(op.path);\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, prevPath)));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = slate.Path.common(slate.Path.parent(op.path), slate.Path.parent(op.newPath));\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, commonPath)));\n          var changedPath;\n          if (slate.Path.isBefore(op.path, op.newPath)) {\n            matches.push.apply(matches, _toConsumableArray(getMatches(e, slate.Path.parent(op.path))));\n            changedPath = op.newPath;\n          } else {\n            matches.push.apply(matches, _toConsumableArray(getMatches(e, slate.Path.parent(op.newPath))));\n            changedPath = op.path;\n          }\n          var changedNode = slate.Node.get(editor, slate.Path.parent(changedPath));\n          var changedNodeKey = DOMEditor.findKey(e, changedNode);\n          var changedPathRef = slate.Editor.pathRef(e, slate.Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n    apply(op);\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node':\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_selection':\n        {\n          // FIXME: Rename to something like IS_DOM_EDITOR_DESYNCED\n          // to better reflect reality, see #5792\n          IS_NODE_MAP_DIRTY.set(e, true);\n        }\n    }\n    for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n      var _matches$_i = _slicedToArray(_matches[_i], 2),\n        path = _matches$_i[0],\n        key = _matches$_i[1];\n      var _Editor$node = slate.Editor.node(e, path),\n        _Editor$node2 = _slicedToArray(_Editor$node, 1),\n        node = _Editor$node2[0];\n      NODE_TO_KEY.set(node, key);\n    }\n    for (var _i2 = 0, _pathRefMatches = pathRefMatches; _i2 < _pathRefMatches.length; _i2++) {\n      var _pathRefMatches$_i = _slicedToArray(_pathRefMatches[_i2], 2),\n        pathRef = _pathRefMatches$_i[0],\n        _key = _pathRefMatches$_i[1];\n      if (pathRef.current) {\n        var _Editor$node3 = slate.Editor.node(e, pathRef.current),\n          _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n          _node = _Editor$node4[0];\n        NODE_TO_KEY.set(_node, _key);\n      }\n      pathRef.unref();\n    }\n  };\n  e.setFragmentData = function (data) {\n    var selection = e.selection;\n    if (!selection) {\n      return;\n    }\n    var _Range$edges = slate.Range.edges(selection),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      start = _Range$edges2[0],\n      end = _Range$edges2[1];\n    var startVoid = slate.Editor[\"void\"](e, {\n      at: start.path\n    });\n    var endVoid = slate.Editor[\"void\"](e, {\n      at: end.path\n    });\n    if (slate.Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    var domRange = DOMEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(function (node) {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    });\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      var _endVoid = _slicedToArray(endVoid, 1),\n        voidNode = _endVoid[0];\n      var r = domRange.cloneRange();\n      var domNode = DOMEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    }\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    }\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(function (zw) {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    });\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span');\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n    // Add the content to a <div> so that we can get its inner HTML.\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = function (data) {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = function (data) {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = function (data) {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      var _iterator = _createForOfIteratorHelper(lines),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          if (split) {\n            slate.Transforms.splitNodes(e, {\n              always: true\n            });\n          }\n          e.insertText(line);\n          split = true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = function (options) {\n    var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n    if (onContextChange) {\n      onContextChange(options);\n    }\n    onChange(options);\n  };\n  return e;\n};\nvar getMatches = function getMatches(e, path) {\n  var matches = [];\n  var _iterator2 = _createForOfIteratorHelper(slate.Editor.levels(e, {\n      at: path\n    })),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        n = _step2$value[0],\n        p = _step2$value[1];\n      var key = DOMEditor.findKey(e, n);\n      matches.push([p, key]);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return matches;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\n * Hotkey mappings for each platform.\n */\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\n * Create a platform-aware hotkey checker.\n */\nvar create = function create(key) {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isHotkey.isHotkey(generic);\n  var isApple = apple && isHotkey.isHotkey(apple);\n  var isWindows = windows && isHotkey.isHotkey(windows);\n  return function (event) {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\n * Hotkeys.\n */\nvar hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nvar objectWithoutPropertiesLoose = createCommonjsModule(function (module) {\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(objectWithoutPropertiesLoose);\n\nvar objectWithoutProperties = createCommonjsModule(function (module) {\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\nvar _excluded = [\"anchor\", \"focus\"],\n  _excluded2 = [\"anchor\", \"focus\"];\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\nvar isDecorationFlagsEqual = function isDecorationFlagsEqual(range, other) {\n  range.anchor;\n    range.focus;\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n  other.anchor;\n    other.focus;\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isElementDecorationsEqual = function isElementDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!slate.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isTextDecorationsEqual = function isTextDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    // compare only offsets because paths doesn't matter for text\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.CAN_USE_DOM = CAN_USE_DOM;\nexports.DOMEditor = DOMEditor;\nexports.DOMElement = DOMElement;\nexports.DOMNode = DOMNode;\nexports.DOMRange = DOMRange;\nexports.DOMSelection = DOMSelection;\nexports.DOMStaticRange = DOMStaticRange;\nexports.DOMText = DOMText;\nexports.EDITOR_TO_ELEMENT = EDITOR_TO_ELEMENT;\nexports.EDITOR_TO_FORCE_RENDER = EDITOR_TO_FORCE_RENDER;\nexports.EDITOR_TO_KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT;\nexports.EDITOR_TO_ON_CHANGE = EDITOR_TO_ON_CHANGE;\nexports.EDITOR_TO_PENDING_ACTION = EDITOR_TO_PENDING_ACTION;\nexports.EDITOR_TO_PENDING_DIFFS = EDITOR_TO_PENDING_DIFFS;\nexports.EDITOR_TO_PENDING_INSERTION_MARKS = EDITOR_TO_PENDING_INSERTION_MARKS;\nexports.EDITOR_TO_PENDING_SELECTION = EDITOR_TO_PENDING_SELECTION;\nexports.EDITOR_TO_PLACEHOLDER_ELEMENT = EDITOR_TO_PLACEHOLDER_ELEMENT;\nexports.EDITOR_TO_SCHEDULE_FLUSH = EDITOR_TO_SCHEDULE_FLUSH;\nexports.EDITOR_TO_USER_MARKS = EDITOR_TO_USER_MARKS;\nexports.EDITOR_TO_USER_SELECTION = EDITOR_TO_USER_SELECTION;\nexports.EDITOR_TO_WINDOW = EDITOR_TO_WINDOW;\nexports.ELEMENT_TO_NODE = ELEMENT_TO_NODE;\nexports.HAS_BEFORE_INPUT_SUPPORT = HAS_BEFORE_INPUT_SUPPORT;\nexports.Hotkeys = hotkeys;\nexports.IS_ANDROID = IS_ANDROID;\nexports.IS_CHROME = IS_CHROME;\nexports.IS_COMPOSING = IS_COMPOSING;\nexports.IS_FIREFOX = IS_FIREFOX;\nexports.IS_FIREFOX_LEGACY = IS_FIREFOX_LEGACY;\nexports.IS_FOCUSED = IS_FOCUSED;\nexports.IS_IOS = IS_IOS;\nexports.IS_NODE_MAP_DIRTY = IS_NODE_MAP_DIRTY;\nexports.IS_READ_ONLY = IS_READ_ONLY;\nexports.IS_UC_MOBILE = IS_UC_MOBILE;\nexports.IS_WEBKIT = IS_WEBKIT;\nexports.IS_WECHATBROWSER = IS_WECHATBROWSER;\nexports.Key = Key;\nexports.MARK_PLACEHOLDER_SYMBOL = MARK_PLACEHOLDER_SYMBOL;\nexports.NODE_TO_ELEMENT = NODE_TO_ELEMENT;\nexports.NODE_TO_INDEX = NODE_TO_INDEX;\nexports.NODE_TO_KEY = NODE_TO_KEY;\nexports.NODE_TO_PARENT = NODE_TO_PARENT;\nexports.PLACEHOLDER_SYMBOL = PLACEHOLDER_SYMBOL;\nexports.TRIPLE_CLICK = TRIPLE_CLICK;\nexports.applyStringDiff = applyStringDiff;\nexports.getActiveElement = getActiveElement;\nexports.getDefaultView = getDefaultView;\nexports.getSelection = getSelection;\nexports.hasShadowRoot = hasShadowRoot;\nexports.isAfter = isAfter;\nexports.isBefore = isBefore;\nexports.isDOMElement = isDOMElement;\nexports.isDOMNode = isDOMNode;\nexports.isDOMSelection = isDOMSelection;\nexports.isElementDecorationsEqual = isElementDecorationsEqual;\nexports.isPlainTextOnlyPaste = isPlainTextOnlyPaste;\nexports.isTextDecorationsEqual = isTextDecorationsEqual;\nexports.isTrackedMutation = isTrackedMutation;\nexports.mergeStringDiffs = mergeStringDiffs;\nexports.normalizeDOMPoint = normalizeDOMPoint;\nexports.normalizePoint = normalizePoint;\nexports.normalizeRange = normalizeRange;\nexports.normalizeStringDiff = normalizeStringDiff;\nexports.targetRange = targetRange;\nexports.verifyDiffState = verifyDiffState;\nexports.withDOM = withDOM;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGUtZG9tQDAuMTEyLjJfc2xhdGVAMC4xMTIuMC9ub2RlX21vZHVsZXMvc2xhdGUtZG9tL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDZHQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxzSEFBVzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZLGtFQUFrRTtBQUN0RixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsMkRBQTJELGlGQUFpRixXQUFXLDBIQUEwSCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7QUFDajlCLG9EQUFvRCxnQkFBZ0Isa0VBQWtFLHdEQUF3RCw2REFBNkQsc0RBQXNEO0FBQ2pULHlDQUF5Qyx1REFBdUQsdUNBQXVDLFNBQVMsdUJBQXVCO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUseUJBQXlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkk7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsaUZBQWlGLFdBQVcsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTtBQUM3OEIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7QUFDN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyx1QkFBdUI7QUFDcksseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxvQkFBb0I7QUFDN0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDhCQUE4QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekMsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyxnQ0FBZ0M7QUFDaEMsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQyxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQix3QkFBd0I7QUFDeEIsV0FBVztBQUNYLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWltZWlzcmFlbGNhbXBlYXMva2V5c3RvbmUvbm9kZV9tb2R1bGVzLy5wbnBtL3NsYXRlLWRvbUAwLjExMi4yX3NsYXRlQDAuMTEyLjAvbm9kZV9tb2R1bGVzL3NsYXRlLWRvbS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHNsYXRlID0gcmVxdWlyZSgnc2xhdGUnKTtcbnZhciBpc0hvdGtleSA9IHJlcXVpcmUoJ2lzLWhvdGtleScpO1xuXG5mdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgYXJyYXlMaWtlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlMaWtlVG9BcnJheSk7XG5cbnZhciBhcnJheVdpdGhvdXRIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhvdXRIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhYmxlVG9BcnJheSk7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHModW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKG5vbkl0ZXJhYmxlU3ByZWFkKTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkgPSB1bndyYXBFeHBvcnRzKHRvQ29uc3VtYWJsZUFycmF5KTtcblxudmFyIGFycmF5V2l0aEhvbGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5V2l0aEhvbGVzKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhYmxlVG9BcnJheUxpbWl0KTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKG5vbkl0ZXJhYmxlUmVzdCk7XG5cbnZhciBzbGljZWRUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSB1bndyYXBFeHBvcnRzKHNsaWNlZFRvQXJyYXkpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDEoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbi8qKlxuICogVHlwZXMuXG4gKi9cbi8vIENPTVBBVDogVGhpcyBpcyByZXF1aXJlZCB0byBwcmV2ZW50IFR5cGVTY3JpcHQgYWxpYXNlcyBmcm9tIGRvaW5nIHNvbWUgdmVyeVxuLy8gd2VpcmQgdGhpbmdzIGZvciBTbGF0ZSdzIHR5cGVzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBnbG9iYWxzLiAoMjAxOS8xMS8yNylcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzUwMDJcbnZhciBET01Ob2RlID0gZ2xvYmFsVGhpcy5Ob2RlO1xudmFyIERPTUVsZW1lbnQgPSBnbG9iYWxUaGlzLkVsZW1lbnQ7XG52YXIgRE9NVGV4dCA9IGdsb2JhbFRoaXMuVGV4dDtcbnZhciBET01SYW5nZSA9IGdsb2JhbFRoaXMuUmFuZ2U7XG52YXIgRE9NU2VsZWN0aW9uID0gZ2xvYmFsVGhpcy5TZWxlY3Rpb247XG52YXIgRE9NU3RhdGljUmFuZ2UgPSBnbG9iYWxUaGlzLlN0YXRpY1JhbmdlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBob3N0IHdpbmRvdyBvZiBhIERPTSBub2RlXG4gKi9cbnZhciBnZXREZWZhdWx0VmlldyA9IGZ1bmN0aW9uIGdldERlZmF1bHRWaWV3KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5vd25lckRvY3VtZW50ICYmIHZhbHVlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgbnVsbDtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYSBjb21tZW50IG5vZGUuXG4gKi9cbnZhciBpc0RPTUNvbW1lbnQgPSBmdW5jdGlvbiBpc0RPTUNvbW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDg7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIGVsZW1lbnQgbm9kZS5cbiAqL1xudmFyIGlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIGlzRE9NRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gbm9kZS5cbiAqL1xudmFyIGlzRE9NTm9kZSA9IGZ1bmN0aW9uIGlzRE9NTm9kZSh2YWx1ZSkge1xuICB2YXIgd2luZG93ID0gZ2V0RGVmYXVsdFZpZXcodmFsdWUpO1xuICByZXR1cm4gISF3aW5kb3cgJiYgdmFsdWUgaW5zdGFuY2VvZiB3aW5kb3cuTm9kZTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gc2VsZWN0aW9uLlxuICovXG52YXIgaXNET01TZWxlY3Rpb24gPSBmdW5jdGlvbiBpc0RPTVNlbGVjdGlvbih2YWx1ZSkge1xuICB2YXIgd2luZG93ID0gdmFsdWUgJiYgdmFsdWUuYW5jaG9yTm9kZSAmJiBnZXREZWZhdWx0Vmlldyh2YWx1ZS5hbmNob3JOb2RlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93LlNlbGVjdGlvbjtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxuICovXG52YXIgaXNET01UZXh0ID0gZnVuY3Rpb24gaXNET01UZXh0KHZhbHVlKSB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAzO1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwYXN0ZSBldmVudCBpcyBhIHBsYWludGV4dC1vbmx5IGV2ZW50LlxuICovXG52YXIgaXNQbGFpblRleHRPbmx5UGFzdGUgPSBmdW5jdGlvbiBpc1BsYWluVGV4dE9ubHlQYXN0ZShldmVudCkge1xuICByZXR1cm4gZXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSAhPT0gJycgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcy5sZW5ndGggPT09IDE7XG59O1xuLyoqXG4gKiBOb3JtYWxpemUgYSBET00gcG9pbnQgc28gdGhhdCBpdCBhbHdheXMgcmVmZXJzIHRvIGEgdGV4dCBub2RlLlxuICovXG52YXIgbm9ybWFsaXplRE9NUG9pbnQgPSBmdW5jdGlvbiBub3JtYWxpemVET01Qb2ludChkb21Qb2ludCkge1xuICB2YXIgX2RvbVBvaW50ID0gX3NsaWNlZFRvQXJyYXkoZG9tUG9pbnQsIDIpLFxuICAgIG5vZGUgPSBfZG9tUG9pbnRbMF0sXG4gICAgb2Zmc2V0ID0gX2RvbVBvaW50WzFdO1xuICAvLyBJZiBpdCdzIGFuIGVsZW1lbnQgbm9kZSwgaXRzIG9mZnNldCByZWZlcnMgdG8gdGhlIGluZGV4IG9mIGl0cyBjaGlsZHJlblxuICAvLyBpbmNsdWRpbmcgY29tbWVudCBub2Rlcywgc28gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IHRleHQgY2hpbGQgbm9kZS5cbiAgaWYgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIGlzTGFzdCA9IG9mZnNldCA9PT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBpc0xhc3QgPyBvZmZzZXQgLSAxIDogb2Zmc2V0O1xuICAgIC8vIElmIHRoZSBlZGl0YWJsZSBjaGlsZCBmb3VuZCBpcyBpbiBmcm9udCBvZiBpbnB1dCBvZmZzZXQsIHdlIGluc3RlYWQgc2VlayB0byBpdHMgZW5kXG4gICAgdmFyIF9nZXRFZGl0YWJsZUNoaWxkQW5kSSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChub2RlLCBpbmRleCwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgdmFyIF9nZXRFZGl0YWJsZUNoaWxkQW5kSTIgPSBfc2xpY2VkVG9BcnJheShfZ2V0RWRpdGFibGVDaGlsZEFuZEksIDIpO1xuICAgIG5vZGUgPSBfZ2V0RWRpdGFibGVDaGlsZEFuZEkyWzBdO1xuICAgIGluZGV4ID0gX2dldEVkaXRhYmxlQ2hpbGRBbmRJMlsxXTtcbiAgICBpc0xhc3QgPSBpbmRleCA8IG9mZnNldDtcbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgY2hpbGRyZW4sIHRyYXZlcnNlIHVudGlsIHdlIGhhdmUgYSBsZWFmIG5vZGUuIExlYWYgbm9kZXNcbiAgICAvLyBjYW4gYmUgZWl0aGVyIHRleHQgbm9kZXMsIG9yIG90aGVyIHZvaWQgRE9NIG5vZGVzLlxuICAgIHdoaWxlIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGkgPSBpc0xhc3QgPyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICBub2RlID0gZ2V0RWRpdGFibGVDaGlsZChub2RlLCBpLCBpc0xhc3QgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnKTtcbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBuZXcgb2Zmc2V0IGluc2lkZSB0aGUgdGV4dCBub2RlLlxuICAgIG9mZnNldCA9IGlzTGFzdCAmJiBub2RlLnRleHRDb250ZW50ICE9IG51bGwgPyBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA6IDA7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBub2RlIGFuZCBvZmZzZXQuXG4gIHJldHVybiBbbm9kZSwgb2Zmc2V0XTtcbn07XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgbmVzdGVkIHdpdGhpbiBhIHNoYWRvd1Jvb3RcbiAqL1xudmFyIGhhc1NoYWRvd1Jvb3QgPSBmdW5jdGlvbiBoYXNTaGFkb3dSb290KG5vZGUpIHtcbiAgdmFyIHBhcmVudCA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBHZXQgdGhlIG5lYXJlc3QgZWRpdGFibGUgY2hpbGQgYW5kIGluZGV4IGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xuICogYGRpcmVjdGlvbmAuXG4gKi9cbnZhciBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXggPSBmdW5jdGlvbiBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKSB7XG4gIHZhciBjaGlsZE5vZGVzID0gcGFyZW50LmNoaWxkTm9kZXM7XG4gIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbaW5kZXhdO1xuICB2YXIgaSA9IGluZGV4O1xuICB2YXIgdHJpZWRGb3J3YXJkID0gZmFsc2U7XG4gIHZhciB0cmllZEJhY2t3YXJkID0gZmFsc2U7XG4gIC8vIFdoaWxlIHRoZSBjaGlsZCBpcyBhIGNvbW1lbnQgbm9kZSwgb3IgYW4gZWxlbWVudCBub2RlIHdpdGggbm8gY2hpbGRyZW4sXG4gIC8vIGtlZXAgaXRlcmF0aW5nIHRvIGZpbmQgYSBzaWJsaW5nIG5vbi12b2lkLCBub24tY29tbWVudCBub2RlLlxuICB3aGlsZSAoaXNET01Db21tZW50KGNoaWxkKSB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ2ZhbHNlJykge1xuICAgIGlmICh0cmllZEZvcndhcmQgJiYgdHJpZWRCYWNrd2FyZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB0cmllZEZvcndhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4IC0gMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdiYWNrd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0cmllZEJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCArIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY2hpbGQgPSBjaGlsZE5vZGVzW2ldO1xuICAgIGluZGV4ID0gaTtcbiAgICBpICs9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiBbY2hpbGQsIGluZGV4XTtcbn07XG4vKipcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcbiAqIGBkaXJlY3Rpb25gLlxuICovXG52YXIgZ2V0RWRpdGFibGVDaGlsZCA9IGZ1bmN0aW9uIGdldEVkaXRhYmxlQ2hpbGQocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKSB7XG4gIHZhciBfZ2V0RWRpdGFibGVDaGlsZEFuZEkzID0gZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4KHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbiksXG4gICAgX2dldEVkaXRhYmxlQ2hpbGRBbmRJNCA9IF9zbGljZWRUb0FycmF5KF9nZXRFZGl0YWJsZUNoaWxkQW5kSTMsIDEpLFxuICAgIGNoaWxkID0gX2dldEVkaXRhYmxlQ2hpbGRBbmRJNFswXTtcbiAgcmV0dXJuIGNoaWxkO1xufTtcbi8qKlxuICogR2V0IGEgcGxhaW50ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250ZW50IG9mIGEgbm9kZSwgYWNjb3VudGluZyBmb3IgYmxvY2tcbiAqIGVsZW1lbnRzIHdoaWNoIGdldCBhIG5ld2xpbmUgYXBwZW5kZWQuXG4gKlxuICogVGhlIGRvbU5vZGUgbXVzdCBiZSBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICovXG52YXIgZ2V0UGxhaW5UZXh0ID0gZnVuY3Rpb24gZ2V0UGxhaW5UZXh0KGRvbU5vZGUpIHtcbiAgdmFyIHRleHQgPSAnJztcbiAgaWYgKGlzRE9NVGV4dChkb21Ob2RlKSAmJiBkb21Ob2RlLm5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBkb21Ob2RlLm5vZGVWYWx1ZTtcbiAgfVxuICBpZiAoaXNET01FbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfQXJyYXkkZnJvbSA9IEFycmF5LmZyb20oZG9tTm9kZS5jaGlsZE5vZGVzKTsgX2kgPCBfQXJyYXkkZnJvbS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSBfQXJyYXkkZnJvbVtfaV07XG4gICAgICB0ZXh0ICs9IGdldFBsYWluVGV4dChjaGlsZE5vZGUpO1xuICAgIH1cbiAgICB2YXIgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoZG9tTm9kZSkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYmxvY2snIHx8IGRpc3BsYXkgPT09ICdsaXN0JyB8fCBkb21Ob2RlLnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0O1xufTtcbi8qKlxuICogR2V0IHgtc2xhdGUtZnJhZ21lbnQgYXR0cmlidXRlIGZyb20gZGF0YS1zbGF0ZS1mcmFnbWVudFxuICovXG52YXIgY2F0Y2hTbGF0ZUZyYWdtZW50ID0gL2RhdGEtc2xhdGUtZnJhZ21lbnQ9XCIoLis/KVwiL207XG52YXIgZ2V0U2xhdGVGcmFnbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YVRyYW5zZmVyKSB7XG4gIHZhciBodG1sRGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgdmFyIF9yZWYgPSBodG1sRGF0YS5tYXRjaChjYXRjaFNsYXRlRnJhZ21lbnQpIHx8IFtdLFxuICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgZnJhZ21lbnQgPSBfcmVmMlsxXTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxuICogR2V0IHRoZSBkb20gc2VsZWN0aW9uIGZyb20gU2hhZG93IFJvb3QgaWYgcG9zc2libGUsIG90aGVyd2lzZSBmcm9tIHRoZSBkb2N1bWVudFxuICovXG52YXIgZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHJvb3QpIHtcbiAgaWYgKHJvb3QuZ2V0U2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICByZXR1cm4gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG59O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgbXV0YXRpb24gb3JpZ2luYXRlcyBmcm9tIGEgZWRpdGFibGUgZWxlbWVudCBpbnNpZGUgdGhlIGVkaXRvci5cbiAqL1xudmFyIGlzVHJhY2tlZE11dGF0aW9uID0gZnVuY3Rpb24gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgYmF0Y2gpIHtcbiAgdmFyIHRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcbiAgaWYgKGlzRE9NRWxlbWVudCh0YXJnZXQpICYmIHRhcmdldC5tYXRjaGVzKCdbY29udGVudEVkaXRhYmxlPVwiZmFsc2VcIl0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgX0RPTUVkaXRvciRnZXRXaW5kb3cgPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvciksXG4gICAgZG9jdW1lbnQgPSBfRE9NRWRpdG9yJGdldFdpbmRvdy5kb2N1bWVudDtcbiAgaWYgKGRvY3VtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICByZXR1cm4gRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdmFyIHBhcmVudE11dGF0aW9uID0gYmF0Y2guZmluZChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgYWRkZWROb2RlcyA9IF9yZWYzLmFkZGVkTm9kZXMsXG4gICAgICByZW1vdmVkTm9kZXMgPSBfcmVmMy5yZW1vdmVkTm9kZXM7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoYWRkZWROb2RlcyksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRhcmdldCB8fCBub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKHJlbW92ZWROb2RlcyksXG4gICAgICBfc3RlcDI7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfbm9kZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgaWYgKF9ub2RlID09PSB0YXJnZXQgfHwgX25vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXJlbnRNdXRhdGlvbiB8fCBwYXJlbnRNdXRhdGlvbiA9PT0gbXV0YXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGFyZ2V0IGFkZC9yZW1vdmUgaXMgdHJhY2tlZC4gVHJhY2sgdGhlIG11dGF0aW9uIGlmIHdlIHRyYWNrIHRoZSBwYXJlbnQgbXV0YXRpb24uXG4gIHJldHVybiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIHBhcmVudE11dGF0aW9uLCBiYXRjaCk7XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGRlZXBlc3QgYWN0aXZlIGVsZW1lbnQgaW4gdGhlIERPTSwgY29uc2lkZXJpbmcgbmVzdGVkIHNoYWRvdyBET01zLlxuICovXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSB7XG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKChfYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQpICE9PSBudWxsICYmIF9hY3RpdmVFbGVtZW50ICE9PSB2b2lkIDAgJiYgX2FjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCAmJiAoX2FjdGl2ZUVsZW1lbnQkc2hhZG93ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSAhPT0gbnVsbCAmJiBfYWN0aXZlRWxlbWVudCRzaGFkb3cgIT09IHZvaWQgMCAmJiBfYWN0aXZlRWxlbWVudCRzaGFkb3cuYWN0aXZlRWxlbWVudCkge1xuICAgIHZhciBfYWN0aXZlRWxlbWVudCwgX2FjdGl2ZUVsZW1lbnQkc2hhZG93LCBfYWN0aXZlRWxlbWVudDI7XG4gICAgYWN0aXZlRWxlbWVudCA9IChfYWN0aXZlRWxlbWVudDIgPSBhY3RpdmVFbGVtZW50KSA9PT0gbnVsbCB8fCBfYWN0aXZlRWxlbWVudDIgPT09IHZvaWQgMCB8fCAoX2FjdGl2ZUVsZW1lbnQyID0gX2FjdGl2ZUVsZW1lbnQyLnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9hY3RpdmVFbGVtZW50MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FjdGl2ZUVsZW1lbnQyLmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59O1xuLyoqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyTm9kZWAgaXMgYmVmb3JlIGBub2RlYCBpbiB0aGUgZG9jdW1lbnQ7IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAqL1xudmFyIGlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUobm9kZSwgb3RoZXJOb2RlKSB7XG4gIHJldHVybiBCb29sZWFuKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKSAmIERPTU5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKTtcbn07XG4vKipcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBgb3RoZXJOb2RlYCBpcyBhZnRlciBgbm9kZWAgaW4gdGhlIGRvY3VtZW50OyBvdGhlcndpc2UsIGBmYWxzZWAuXG4gKi9cbnZhciBpc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihub2RlLCBvdGhlck5vZGUpIHtcbiAgcmV0dXJuIEJvb2xlYW4obm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihvdGhlck5vZGUpICYgRE9NTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpO1xufTtcblxudmFyIF9uYXZpZ2F0b3IkdXNlckFnZW50JCwgX25hdmlnYXRvciR1c2VyQWdlbnQkMjtcbnZhciBJU19JT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xudmFyIElTX0FQUExFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL01hYyBPUyBYLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0FORFJPSUQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19GSVJFRk9YID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX1dFQktJVCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BcHBsZVdlYktpdCg/IS4qQ2hyb21lKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBcIm1vZGVyblwiIEVkZ2Ugd2FzIHJlbGVhc2VkIGF0IDc5LnhcbnZhciBJU19FREdFX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9FZGdlP1xcLyg/OlswLTZdWzAtOV18WzAtN11bMC04XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19DSFJPTUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIE5hdGl2ZSBgYmVmb3JlSW5wdXRgIGV2ZW50cyBkb24ndCB3b3JrIHdlbGwgd2l0aCByZWFjdCBvbiBDaHJvbWUgNzVcbi8vIGFuZCBvbGRlciwgQ2hyb21lIDc2KyBjYW4gdXNlIGBiZWZvcmVJbnB1dGAgdGhvdWdoLlxudmFyIElTX0NIUk9NRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTddWzAtNV18WzAtNl1bMC05XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kgPSBJU19BTkRST0lEICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWU/XFwvKD86WzAtNV0/XFxkKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gRmlyZWZveCBkaWQgbm90IHN1cHBvcnQgYGJlZm9yZUlucHV0YCB1bnRpbCBgdjg3YC5cbnZhciBJU19GSVJFRk9YX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94XFwvKD86WzAtN11bMC05XXxbMC04XVswLTZdKSg/OlxcLikpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gVUMgbW9iaWxlIGJyb3dzZXJcbnZhciBJU19VQ19NT0JJTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipVQ0Jyb3dzZXIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBXZWNoYXQgYnJvd3NlciAobm90IGluY2x1ZGluZyBtYWMgd2VjaGF0KVxudmFyIElTX1dFQ0hBVEJST1dTRVIgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS8uKk1hY1dlY2hhdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gYXZvaWQgbG9va2JlaGluZCAoYnVnZ3kgaW4gc2FmYXJpIDwgMTYuNClcbi8vIENoZWNrIGlmIERPTSBpcyBhdmFpbGFibGUgYXMgUmVhY3QgZG9lcyBpbnRlcm5hbGx5LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xudmFyIENBTl9VU0VfRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG4vLyBDaGVjayBpZiB0aGUgYnJvd3NlciBpcyBTYWZhcmkgYW5kIG9sZGVyIHRoYW4gMTdcbnR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL1ZlcnNpb25cXC8oXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKChfbmF2aWdhdG9yJHVzZXJBZ2VudCQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCspLykpICE9PSBudWxsICYmIF9uYXZpZ2F0b3IkdXNlckFnZW50JCAhPT0gdm9pZCAwICYmIF9uYXZpZ2F0b3IkdXNlckFnZW50JFsxXSA/IHBhcnNlSW50KChfbmF2aWdhdG9yJHVzZXJBZ2VudCQyID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhcXGQrKS8pKSA9PT0gbnVsbCB8fCBfbmF2aWdhdG9yJHVzZXJBZ2VudCQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmF2aWdhdG9yJHVzZXJBZ2VudCQyWzFdLCAxMCkgPCAxNyA6IGZhbHNlKTtcbi8vIENPTVBBVDogRmlyZWZveC9FZGdlIExlZ2FjeSBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50XG4vLyBDaHJvbWUgTGVnYWN5IGRvZXNuJ3Qgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGNvcnJlY3RseVxudmFyIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCA9ICghSVNfQ0hST01FX0xFR0FDWSB8fCAhSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZKSAmJiAhSVNfRURHRV9MRUdBQ1kgJiZcbi8vIGdsb2JhbFRoaXMgaXMgdW5kZWZpbmVkIGluIG9sZGVyIGJyb3dzZXJzXG50eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5JbnB1dEV2ZW50ICYmXG4vLyBAdHMtaWdub3JlIFRoZSBgZ2V0VGFyZ2V0UmFuZ2VzYCBwcm9wZXJ0eSBpc24ndCByZWNvZ25pemVkLlxudHlwZW9mIGdsb2JhbFRoaXMuSW5wdXRFdmVudC5wcm90b3R5cGUuZ2V0VGFyZ2V0UmFuZ2VzID09PSAnZnVuY3Rpb24nO1xuXG52YXIgX3R5cGVvZl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gKG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSwgX3R5cGVvZihvKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoX3R5cGVvZl8xKTtcblxudmFyIHRvUHJpbWl0aXZlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIF90eXBlb2YgPSBfdHlwZW9mXzFbXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3RvUHJpbWl0aXZlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyh0b1ByaW1pdGl2ZSk7XG5cbnZhciB0b1Byb3BlcnR5S2V5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIF90eXBlb2YgPSBfdHlwZW9mXzFbXCJkZWZhdWx0XCJdO1xuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3RvUHJvcGVydHlLZXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKHRvUHJvcGVydHlLZXkpO1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB0b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSB1bndyYXBFeHBvcnRzKGNyZWF0ZUNsYXNzKTtcblxudmFyIGNsYXNzQ2FsbENoZWNrID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjayA9IHVud3JhcEV4cG9ydHMoY2xhc3NDYWxsQ2hlY2spO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHVud3JhcEV4cG9ydHMoZGVmaW5lUHJvcGVydHkpO1xuXG4vKipcbiAqIEFuIGF1dG8taW5jcmVtZW50aW5nIGlkZW50aWZpZXIgZm9yIGtleXMuXG4gKi9cbnZhciBuID0gMDtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGEga2V5IHN0cmluZy4gV2UgdXNlIGEgZnVsbCBjbGFzcyBoZXJlIGJlY2F1c2Ugd2VcbiAqIHdhbnQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbSBhcyBrZXlzIGluIGBXZWFrTWFwYCBvYmplY3RzLlxuICovXG52YXIgS2V5ID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhmdW5jdGlvbiBLZXkoKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXkpO1xuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB2b2lkIDApO1xuICB0aGlzLmlkID0gXCJcIi5jb25jYXQobisrKTtcbn0pO1xuXG4vKipcbiAqIFR3byB3ZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyByZWJ1aWxkIGEgcGF0aCBnaXZlbiBhIG5vZGUuIFRoZXkgYXJlIHBvcHVsYXRlZFxuICogYXQgcmVuZGVyIHRpbWUgc3VjaCB0aGF0IGFmdGVyIGEgcmVuZGVyIG9jY3VycyB3ZSBjYW4gYWx3YXlzIGJhY2t0cmFjay5cbiAqL1xudmFyIElTX05PREVfTUFQX0RJUlRZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0lOREVYID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX1BBUkVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHRvIGdvIGJldHdlZW4gU2xhdGUgbm9kZXMgYW5kIERPTSBub2Rlcy4gVGhlc2VcbiAqIGFyZSB1c2VkIHRvIHJlc29sdmUgRE9NIGV2ZW50LXJlbGF0ZWQgbG9naWMgaW50byBTbGF0ZSBhY3Rpb25zLlxuICovXG52YXIgRURJVE9SX1RPX1dJTkRPVyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFTEVNRU5UX1RPX05PREUgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19LRVkgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwcyBmb3Igc3RvcmluZyBlZGl0b3ItcmVsYXRlZCBzdGF0ZS5cbiAqL1xudmFyIElTX1JFQURfT05MWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfRk9DVVNFRCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfQ09NUE9TSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcCBmb3IgYXNzb2NpYXRpbmcgdGhlIGNvbnRleHQgYG9uQ2hhbmdlYCBjb250ZXh0IHdpdGggdGhlIHBsdWdpbi5cbiAqL1xudmFyIEVESVRPUl9UT19PTl9DSEFOR0UgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcHMgZm9yIHNhdmluZyBwZW5kaW5nIHN0YXRlIG9uIGNvbXBvc2l0aW9uIHN0YWdlLlxuICovXG52YXIgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQW5kcm9pZCBpbnB1dCBoYW5kbGluZyBzcGVjaWZpYyB3ZWFrLW1hcHNcbiAqL1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19BQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFN5bWJvbHMuXG4gKi9cbnZhciBQTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ3BsYWNlaG9sZGVyJyk7XG52YXIgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ21hcmstcGxhY2Vob2xkZXInKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIERPTUVkaXRvciA9IHtcbiAgYW5kcm9pZFBlbmRpbmdEaWZmczogZnVuY3Rpb24gYW5kcm9pZFBlbmRpbmdEaWZmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIGFuZHJvaWRTY2hlZHVsZUZsdXNoOiBmdW5jdGlvbiBhbmRyb2lkU2NoZWR1bGVGbHVzaChlZGl0b3IpIHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GO1xuICAgIChfRURJVE9SX1RPX1NDSEVEVUxFX0YgPSBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRigpO1xuICB9LFxuICBibHVyOiBmdW5jdGlvbiBibHVyKGVkaXRvcikge1xuICAgIHZhciBlbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gRE9NRWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICB9LFxuICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIHJvb3QgPSBET01FZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihyb290KTtcbiAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgfVxuICB9LFxuICBmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3Q6IGZ1bmN0aW9uIGZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50O1xuICB9LFxuICBmaW5kRXZlbnRSYW5nZTogZnVuY3Rpb24gZmluZEV2ZW50UmFuZ2UoZWRpdG9yLCBldmVudCkge1xuICAgIGlmICgnbmF0aXZlRXZlbnQnIGluIGV2ZW50KSB7XG4gICAgICBldmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgIH1cbiAgICB2YXIgX2V2ZW50ID0gZXZlbnQsXG4gICAgICB4ID0gX2V2ZW50LmNsaWVudFgsXG4gICAgICB5ID0gX2V2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQgPSBfZXZlbnQudGFyZ2V0O1xuICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IERPTUVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgdmFyIHBhdGggPSBET01FZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAvLyBJZiB0aGUgZHJvcCB0YXJnZXQgaXMgaW5zaWRlIGEgdm9pZCBub2RlLCBtb3ZlIGl0IGludG8gZWl0aGVyIHRoZVxuICAgIC8vIG5leHQgb3IgcHJldmlvdXMgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGUgdGhlIGB4YCBhbmQgYHlgXG4gICAgLy8gY29vcmRpbmF0ZXMgYXJlIGNsb3Nlc3QgdG8uXG4gICAgaWYgKHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIHNsYXRlLkVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgaXNQcmV2ID0gZWRpdG9yLmlzSW5saW5lKG5vZGUpID8geCAtIHJlY3QubGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSB4IDogeSAtIHJlY3QudG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAtIHk7XG4gICAgICB2YXIgZWRnZSA9IHNsYXRlLkVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZWRnZTogaXNQcmV2ID8gJ3N0YXJ0JyA6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludCA9IGlzUHJldiA/IHNsYXRlLkVkaXRvci5iZWZvcmUoZWRpdG9yLCBlZGdlKSA6IHNsYXRlLkVkaXRvci5hZnRlcihlZGl0b3IsIGVkZ2UpO1xuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHZhciBfcmFuZ2UgPSBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIHJldHVybiBfcmFuZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVsc2UgcmVzb2x2ZSBhIHJhbmdlIGZyb20gdGhlIGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRoZSBkcm9wIG9jY3VyZWQuXG4gICAgdmFyIGRvbVJhbmdlO1xuICAgIHZhciBfRE9NRWRpdG9yJGdldFdpbmRvdyA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKSxcbiAgICAgIGRvY3VtZW50ID0gX0RPTUVkaXRvciRnZXRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgY2FyZXRSYW5nZUZyb21Qb2ludGAgZG9lc24ndCBleGlzdC4gKDIwMTYvMDcvMjUpXG4gICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc2l0aW9uID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBkb21SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGRvbVJhbmdlLnNldFN0YXJ0KHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICAgIGRvbVJhbmdlLnNldEVuZChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRvbVJhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cbiAgICAvLyBSZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSB0aGUgRE9NIHJhbmdlLlxuICAgIHZhciByYW5nZSA9IERPTUVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21SYW5nZSwge1xuICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICBzdXBwcmVzc1Rocm93OiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiByYW5nZTtcbiAgfSxcbiAgZmluZEtleTogZnVuY3Rpb24gZmluZEtleShlZGl0b3IsIG5vZGUpIHtcbiAgICB2YXIga2V5ID0gTk9ERV9UT19LRVkuZ2V0KG5vZGUpO1xuICAgIGlmICgha2V5KSB7XG4gICAgICBrZXkgPSBuZXcgS2V5KCk7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQobm9kZSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSxcbiAgZmluZFBhdGg6IGZ1bmN0aW9uIGZpbmRQYXRoKGVkaXRvciwgbm9kZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIGNoaWxkID0gbm9kZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHBhcmVudCA9IE5PREVfVE9fUEFSRU5ULmdldChjaGlsZCk7XG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKHNsYXRlLkVkaXRvci5pc0VkaXRvcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGkgPSBOT0RFX1RPX0lOREVYLmdldChjaGlsZCk7XG4gICAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBwYXRoIGZvciBTbGF0ZSBub2RlOiBcIi5jb25jYXQoc2xhdGUuU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gIH0sXG4gIGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgcmV0cmllczogNVxuICAgIH07XG4gICAgLy8gUmV0dXJuIGlmIGFscmVhZHkgZm9jdXNlZFxuICAgIGlmIChJU19GT0NVU0VELmdldChlZGl0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJldHJ5IHNldHRpbmcgZm9jdXMgaWYgdGhlIGVkaXRvciBoYXMgcGVuZGluZyBvcGVyYXRpb25zLlxuICAgIC8vIFRoZSBET00gKHNlbGVjdGlvbikgaXMgdW5zdGFibGUgd2hpbGUgY2hhbmdlcyBhcmUgYXBwbGllZC5cbiAgICAvLyBSZXRyeSB1bnRpbCByZXRyaWVzIGFyZSBleGhhdXN0ZWQgb3IgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgaWYgKG9wdGlvbnMucmV0cmllcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzZXQgZm9jdXMsIGVkaXRvciBzZWVtcyBzdHVjayB3aXRoIHBlbmRpbmcgb3BlcmF0aW9ucycpO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIERPTUVkaXRvci5mb2N1cyhlZGl0b3IsIHtcbiAgICAgICAgICByZXRyaWVzOiBvcHRpb25zLnJldHJpZXMgLSAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IERPTUVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ICE9PSBlbCkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIERPTSBzZWxlY3Rpb24gc3RhdGUgaXMgc2V0IHRvIHRoZSBlZGl0b3IncyBzZWxlY3Rpb25cbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgICAgICB2YXIgZG9tUmFuZ2UgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKGRvbVJhbmdlKTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzZWxlY3Rpb24gaW4gdGhlIHRvcCBvZiB0aGUgZG9jdW1lbnQgaWYgbWlzc2luZ1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2xhdGUuRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pKTtcbiAgICAgIH1cbiAgICAgIC8vIElTX0ZPQ1VTRUQgc2hvdWxkIGJlIHNldCBiZWZvcmUgY2FsbGluZyBlbC5mb2N1cygpIHRvIGVuc3VyZSB0aGF0XG4gICAgICAvLyBGb2N1c2VkQ29udGV4dCBpcyB1cGRhdGVkIHRvIHRoZSBjb3JyZWN0IHZhbHVlXG4gICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgZWwuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldFdpbmRvdzogZnVuY3Rpb24gZ2V0V2luZG93KGVkaXRvcikge1xuICAgIHZhciB3aW5kb3cgPSBFRElUT1JfVE9fV0lORE9XLmdldChlZGl0b3IpO1xuICAgIGlmICghd2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGEgaG9zdCB3aW5kb3cgZWxlbWVudCBmb3IgdGhpcyBlZGl0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSxcbiAgaGFzRE9NTm9kZTogZnVuY3Rpb24gaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkZWRpdGFibGUgPSBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgZWRpdGFibGUgPSBfb3B0aW9ucyRlZGl0YWJsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRlZGl0YWJsZTtcbiAgICB2YXIgZWRpdG9yRWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgdGFyZ2V0RWw7XG4gICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCByZWFkaW5nIGB0YXJnZXQubm9kZVR5cGVgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICAvLyB0YXJnZXQgaXMgb3JpZ2luYXRpbmcgZnJvbSBhbiBpbnRlcm5hbCBcInJlc3RyaWN0ZWRcIiBlbGVtZW50IChlLmcuIGFcbiAgICAvLyBzdGVwcGVyIGFycm93IG9uIGEgbnVtYmVyIGlucHV0KS4gKDIwMTgvMDUvMDQpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy8xODE5XG4gICAgdHJ5IHtcbiAgICAgIHRhcmdldEVsID0gaXNET01FbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiAhZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSBcIm5vZGVUeXBlXCInKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGFyZ2V0RWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldEVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1lZGl0b3JdXCIpID09PSBlZGl0b3JFbCAmJiAoIWVkaXRhYmxlIHx8IHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID8gdHJ1ZSA6IHR5cGVvZiB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgLy8gaXNDb250ZW50RWRpdGFibGUgZXhpc3RzIG9ubHkgb24gSFRNTEVsZW1lbnQsIGFuZCBvbiBvdGhlciBub2RlcyBpdCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgIC8vIHRoaXMgaXMgdGhlIGNvcmUgbG9naWMgdGhhdCBsZXRzIHlvdSBrbm93IHlvdSBnb3QgdGhlIHJpZ2h0IGVkaXRvci5zZWxlY3Rpb24gaW5zdGVhZCBvZiBudWxsIHdoZW4gZWRpdG9yIGlzIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIocmVhZE9ubHkpXG4gICAgdGFyZ2V0RWwuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdJykgPT09IGVkaXRvckVsIHx8ICEhdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSk7XG4gIH0sXG4gIGhhc0VkaXRhYmxlVGFyZ2V0OiBmdW5jdGlvbiBoYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkge1xuICAgIHJldHVybiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCwge1xuICAgICAgZWRpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSxcbiAgaGFzUmFuZ2U6IGZ1bmN0aW9uIGhhc1JhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICByZXR1cm4gc2xhdGUuRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBhbmNob3IucGF0aCkgJiYgc2xhdGUuRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBmb2N1cy5wYXRoKTtcbiAgfSxcbiAgaGFzU2VsZWN0YWJsZVRhcmdldDogZnVuY3Rpb24gaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkge1xuICAgIHJldHVybiBET01FZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHx8IERPTUVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIHRhcmdldCk7XG4gIH0sXG4gIGhhc1RhcmdldDogZnVuY3Rpb24gaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzRE9NTm9kZSh0YXJnZXQpICYmIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0KTtcbiAgfSxcbiAgaW5zZXJ0RGF0YTogZnVuY3Rpb24gaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RGF0YShkYXRhKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnREYXRhOiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSk7XG4gIH0sXG4gIGluc2VydFRleHREYXRhOiBmdW5jdGlvbiBpbnNlcnRUZXh0RGF0YShlZGl0b3IsIGRhdGEpIHtcbiAgICByZXR1cm4gZWRpdG9yLmluc2VydFRleHREYXRhKGRhdGEpO1xuICB9LFxuICBpc0NvbXBvc2luZzogZnVuY3Rpb24gaXNDb21wb3NpbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuICEhSVNfQ09NUE9TSU5HLmdldChlZGl0b3IpO1xuICB9LFxuICBpc0ZvY3VzZWQ6IGZ1bmN0aW9uIGlzRm9jdXNlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19GT0NVU0VELmdldChlZGl0b3IpO1xuICB9LFxuICBpc1JlYWRPbmx5OiBmdW5jdGlvbiBpc1JlYWRPbmx5KGVkaXRvcikge1xuICAgIHJldHVybiAhIUlTX1JFQURfT05MWS5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQ6IGZ1bmN0aW9uIGlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgaWYgKElTX1JFQURfT05MWS5nZXQoZWRpdG9yKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzbGF0ZU5vZGUgPSBET01FZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSAmJiBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybiBzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChzbGF0ZU5vZGUpICYmIHNsYXRlLkVkaXRvci5pc1ZvaWQoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICB9LFxuICBzZXRGcmFnbWVudERhdGE6IGZ1bmN0aW9uIHNldEZyYWdtZW50RGF0YShlZGl0b3IsIGRhdGEsIG9yaWdpbkV2ZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5zZXRGcmFnbWVudERhdGEoZGF0YSwgb3JpZ2luRXZlbnQpO1xuICB9LFxuICB0b0RPTU5vZGU6IGZ1bmN0aW9uIHRvRE9NTm9kZShlZGl0b3IsIG5vZGUpIHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgdmFyIGRvbU5vZGUgPSBzbGF0ZS5FZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKSA6IEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5nZXQoRE9NRWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBub2RlKSk7XG4gICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBub2RlIGZyb20gU2xhdGUgbm9kZTogXCIuY29uY2F0KHNsYXRlLlNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tTm9kZTtcbiAgfSxcbiAgdG9ET01Qb2ludDogZnVuY3Rpb24gdG9ET01Qb2ludChlZGl0b3IsIHBvaW50KSB7XG4gICAgdmFyIF9FZGl0b3Ikbm9kZSA9IHNsYXRlLkVkaXRvci5ub2RlKGVkaXRvciwgcG9pbnQucGF0aCksXG4gICAgICBfRWRpdG9yJG5vZGUyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlLCAxKSxcbiAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdO1xuICAgIHZhciBlbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBub2RlKTtcbiAgICB2YXIgZG9tUG9pbnQ7XG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgdm9pZCBub2RlLCBmb3JjZSB0aGUgb2Zmc2V0IHRvIDAsIG90aGVyd2lzZSB0aGUgemVyb1xuICAgIC8vIHdpZHRoIHNwYWNpbmcgY2hhcmFjdGVyIHdpbGwgcmVzdWx0IGluIGFuIGluY29ycmVjdCBvZmZzZXQgb2YgMVxuICAgIGlmIChzbGF0ZS5FZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IHBvaW50XG4gICAgfSkpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGxlYWYsIHdlIG5lZWQgdG8gaXNvbGF0ZSBpdHMgY29udGVudCwgd2hpY2ggbWVhbnMgZmlsdGVyaW5nXG4gICAgLy8gdG8gaXRzIGRpcmVjdCB0ZXh0IGFuZCB6ZXJvLXdpZHRoIHNwYW5zLiAoV2UgaGF2ZSB0byBmaWx0ZXIgb3V0IGFueVxuICAgIC8vIG90aGVyIHNpYmxpbmdzIHRoYXQgbWF5IGhhdmUgYmVlbiByZW5kZXJlZCBhbG9uZ3NpZGUgdGhlbS4pXG4gICAgdmFyIHNlbGVjdG9yID0gXCJbZGF0YS1zbGF0ZS1zdHJpbmddLCBbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiO1xuICAgIHZhciB0ZXh0cyA9IEFycmF5LmZyb20oZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRleHQgPSB0ZXh0c1tpXTtcbiAgICAgIHZhciBkb21Ob2RlID0gdGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgaWYgKGRvbU5vZGUgPT0gbnVsbCB8fCBkb21Ob2RlLnRleHRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICB2YXIgYXR0ciA9IHRleHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWxlbmd0aCcpO1xuICAgICAgdmFyIHRydWVMZW5ndGggPSBhdHRyID09IG51bGwgPyBsZW5ndGggOiBwYXJzZUludChhdHRyLCAxMCk7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyB0cnVlTGVuZ3RoO1xuICAgICAgLy8gUHJlZmVyIHB1dHRpbmcgdGhlIHNlbGVjdGlvbiBpbnNpZGUgdGhlIG1hcmsgcGxhY2Vob2xkZXIgdG8gZW5zdXJlXG4gICAgICAvLyBjb21wb3NlZCB0ZXh0IGlzIGRpc3BsYXllZCB3aXRoIHRoZSBjb3JyZWN0IG1hcmtzLlxuICAgICAgdmFyIG5leHRUZXh0ID0gdGV4dHNbaSArIDFdO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA9PT0gZW5kICYmIG5leHRUZXh0ICE9PSBudWxsICYmIG5leHRUZXh0ICE9PSB2b2lkIDAgJiYgbmV4dFRleHQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICB2YXIgX25leHRUZXh0JHRleHRDb250ZW50O1xuICAgICAgICB2YXIgZG9tVGV4dCA9IG5leHRUZXh0LmNoaWxkTm9kZXNbMF07XG4gICAgICAgIGRvbVBvaW50ID0gW1xuICAgICAgICAvLyBDT01QQVQ6IElmIHdlIGRvbid0IGV4cGxpY2l0eSBzZXQgdGhlIGRvbSBwb2ludCB0byBiZSBvbiB0aGUgYWN0dWFsXG4gICAgICAgIC8vIGRvbSB0ZXh0IGVsZW1lbnQsIGNocm9tZSB3aWxsIHB1dCB0aGUgc2VsZWN0aW9uIGJlaGluZCB0aGUgYWN0dWFsIGRvbVxuICAgICAgICAvLyB0ZXh0IGVsZW1lbnQsIGNhdXNpbmcgZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgY2FsbHMgb24gYSBjb2xsYXBzZWRcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHJldHVybiBpbmNvcnJlY3QgemVybyB2YWx1ZXMgKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQzNTQzOClcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMgd2hlbiBzY3JvbGxpbmcgdG8gaXQuXG4gICAgICAgIGRvbVRleHQgaW5zdGFuY2VvZiBET01UZXh0ID8gZG9tVGV4dCA6IG5leHRUZXh0LCAoX25leHRUZXh0JHRleHRDb250ZW50ID0gbmV4dFRleHQudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudCAhPT0gdm9pZCAwICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudC5zdGFydHNXaXRoKFwiXFx1RkVGRlwiKSA/IDEgOiAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnQub2Zmc2V0IDw9IGVuZCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBNYXRoLm1heCgwLCBwb2ludC5vZmZzZXQgLSBzdGFydCkpO1xuICAgICAgICBkb21Qb2ludCA9IFtkb21Ob2RlLCBvZmZzZXRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoIWRvbVBvaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBwb2ludCBmcm9tIFNsYXRlIHBvaW50OiBcIi5jb25jYXQoc2xhdGUuU2NydWJiZXIuc3RyaW5naWZ5KHBvaW50KSkpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tUG9pbnQ7XG4gIH0sXG4gIHRvRE9NUmFuZ2U6IGZ1bmN0aW9uIHRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHZhciBpc0JhY2t3YXJkID0gc2xhdGUuUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gICAgdmFyIGRvbUFuY2hvciA9IERPTUVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICB2YXIgZG9tRm9jdXMgPSBzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgPyBkb21BbmNob3IgOiBET01FZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGZvY3VzKTtcbiAgICB2YXIgd2luZG93ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21SYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHZhciBfcmVmID0gaXNCYWNrd2FyZCA/IGRvbUZvY3VzIDogZG9tQW5jaG9yLFxuICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgIHN0YXJ0Tm9kZSA9IF9yZWYyWzBdLFxuICAgICAgc3RhcnRPZmZzZXQgPSBfcmVmMlsxXTtcbiAgICB2YXIgX3JlZjMgPSBpc0JhY2t3YXJkID8gZG9tQW5jaG9yIDogZG9tRm9jdXMsXG4gICAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgIGVuZE5vZGUgPSBfcmVmNFswXSxcbiAgICAgIGVuZE9mZnNldCA9IF9yZWY0WzFdO1xuICAgIC8vIEEgc2xhdGUgUG9pbnQgYXQgemVyby13aWR0aCBMZWFmIGFsd2F5cyBoYXMgYW4gb2Zmc2V0IG9mIDAgYnV0IGEgbmF0aXZlIERPTSBzZWxlY3Rpb24gYXRcbiAgICAvLyB6ZXJvLXdpZHRoIG5vZGUgaGFzIGFuIG9mZnNldCBvZiAxIHNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgd2UgYXJlIGluIGEgemVyby13aWR0aCBub2RlIGFuZFxuICAgIC8vIGFkanVzdCB0aGUgb2Zmc2V0IGFjY29yZGluZ2x5LlxuICAgIHZhciBzdGFydEVsID0gaXNET01FbGVtZW50KHN0YXJ0Tm9kZSkgPyBzdGFydE5vZGUgOiBzdGFydE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNTdGFydEF0WmVyb1dpZHRoID0gISFzdGFydEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgdmFyIGVuZEVsID0gaXNET01FbGVtZW50KGVuZE5vZGUpID8gZW5kTm9kZSA6IGVuZE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNFbmRBdFplcm9XaWR0aCA9ICEhZW5kRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICBkb21SYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIGlzU3RhcnRBdFplcm9XaWR0aCA/IDEgOiBzdGFydE9mZnNldCk7XG4gICAgZG9tUmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGlzRW5kQXRaZXJvV2lkdGggPyAxIDogZW5kT2Zmc2V0KTtcbiAgICByZXR1cm4gZG9tUmFuZ2U7XG4gIH0sXG4gIHRvU2xhdGVOb2RlOiBmdW5jdGlvbiB0b1NsYXRlTm9kZShlZGl0b3IsIGRvbU5vZGUpIHtcbiAgICB2YXIgZG9tRWwgPSBpc0RPTUVsZW1lbnQoZG9tTm9kZSkgPyBkb21Ob2RlIDogZG9tTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChkb21FbCAmJiAhZG9tRWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSkge1xuICAgICAgZG9tRWwgPSBkb21FbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtbm9kZV1cIik7XG4gICAgfVxuICAgIHZhciBub2RlID0gZG9tRWwgPyBFTEVNRU5UX1RPX05PREUuZ2V0KGRvbUVsKSA6IG51bGw7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIG5vZGUgZnJvbSBET00gbm9kZTogXCIuY29uY2F0KGRvbUVsKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICB0b1NsYXRlUG9pbnQ6IGZ1bmN0aW9uIHRvU2xhdGVQb2ludChlZGl0b3IsIGRvbVBvaW50LCBvcHRpb25zKSB7XG4gICAgdmFyIGV4YWN0TWF0Y2ggPSBvcHRpb25zLmV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93ID0gb3B0aW9ucy5zdXBwcmVzc1Rocm93LFxuICAgICAgX29wdGlvbnMkc2VhcmNoRGlyZWN0ID0gb3B0aW9ucy5zZWFyY2hEaXJlY3Rpb24sXG4gICAgICBzZWFyY2hEaXJlY3Rpb24gPSBfb3B0aW9ucyRzZWFyY2hEaXJlY3QgPT09IHZvaWQgMCA/ICdiYWNrd2FyZCcgOiBfb3B0aW9ucyRzZWFyY2hEaXJlY3Q7XG4gICAgdmFyIF9yZWY1ID0gZXhhY3RNYXRjaCA/IGRvbVBvaW50IDogbm9ybWFsaXplRE9NUG9pbnQoZG9tUG9pbnQpLFxuICAgICAgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICBuZWFyZXN0Tm9kZSA9IF9yZWY2WzBdLFxuICAgICAgbmVhcmVzdE9mZnNldCA9IF9yZWY2WzFdO1xuICAgIHZhciBwYXJlbnROb2RlID0gbmVhcmVzdE5vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgdGV4dE5vZGUgPSBudWxsO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICB2YXIgX2RvbU5vZGUkdGV4dENvbnRlbnQsIF9kb21Ob2RlJHRleHRDb250ZW50MjtcbiAgICAgIHZhciBlZGl0b3JFbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgdmFyIHBvdGVudGlhbFZvaWROb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS12b2lkPVwidHJ1ZVwiXScpO1xuICAgICAgLy8gTmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgY2xvc2VzdCB2b2lkIG5vZGUgaXMgYWN0dWFsbHkgYSB2b2lkIG5vZGVcbiAgICAgIC8vIHdpdGhpbiB0aGlzIGVkaXRvciwgYW5kIG5vdCBhIHZvaWQgbm9kZSB3aXRoaW4gc29tZSBwYXJlbnQgZWRpdG9yLiBUaGlzIGNhbiBoYXBwZW5cbiAgICAgIC8vIGlmIHRoaXMgZWRpdG9yIGlzIHdpdGhpbiBhIHZvaWQgbm9kZSBvZiBhbm90aGVyIGVkaXRvciAoXCJuZXN0ZWQgZWRpdG9yc1wiLCBsaWtlIGluXG4gICAgICAvLyB0aGUgXCJFZGl0YWJsZSBWb2lkc1wiIGV4YW1wbGUgb24gdGhlIGRvY3Mgc2l0ZSkuXG4gICAgICB2YXIgdm9pZE5vZGUgPSBwb3RlbnRpYWxWb2lkTm9kZSAmJiBlZGl0b3JFbC5jb250YWlucyhwb3RlbnRpYWxWb2lkTm9kZSkgPyBwb3RlbnRpYWxWb2lkTm9kZSA6IG51bGw7XG4gICAgICB2YXIgcG90ZW50aWFsTm9uRWRpdGFibGVOb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0nKTtcbiAgICAgIHZhciBub25FZGl0YWJsZU5vZGUgPSBwb3RlbnRpYWxOb25FZGl0YWJsZU5vZGUgJiYgZWRpdG9yRWwuY29udGFpbnMocG90ZW50aWFsTm9uRWRpdGFibGVOb2RlKSA/IHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSA6IG51bGw7XG4gICAgICB2YXIgbGVhZk5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICB2YXIgZG9tTm9kZSA9IG51bGw7XG4gICAgICAvLyBDYWxjdWxhdGUgaG93IGZhciBpbnRvIHRoZSB0ZXh0IG5vZGUgdGhlIGBuZWFyZXN0Tm9kZWAgaXMsIHNvIHRoYXQgd2VcbiAgICAgIC8vIGNhbiBkZXRlcm1pbmUgd2hhdCB0aGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSB0ZXh0IG5vZGUgaXMuXG4gICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICBpZiAodGV4dE5vZGUpIHtcbiAgICAgICAgICB2YXIgd2luZG93ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgICAgICAgIHZhciByYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXQpO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpKSwgX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjb250ZW50ZWRpdGFibGU9ZmFsc2VdJykpKSk7XG4gICAgICAgICAgcmVtb3ZhbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIENPTVBBVDogV2hpbGUgY29tcG9zaW5nIGF0IHRoZSBzdGFydCBvZiBhIHRleHQgbm9kZSwgc29tZSBrZXlib2FyZHMgcHV0XG4gICAgICAgICAgICAvLyB0aGUgdGV4dCBjb250ZW50IGluc2lkZSB0aGUgemVybyB3aWR0aCBzcGFjZS5cbiAgICAgICAgICAgIGlmIChJU19BTkRST0lEICYmICFleGFjdE1hdGNoICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgJiYgZWwudGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiBlbC50ZXh0Q29udGV4dCAhPT0gXCJcXHVGRUZGXCIpIHtcbiAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50LnN0YXJ0c1dpdGgoXCJcXHVGRUZGXCIpKSB7XG4gICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBDT01QQVQ6IEVkZ2UgaGFzIGEgYnVnIHdoZXJlIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZygpIHdpbGxcbiAgICAgICAgICAvLyBjb252ZXJ0IFxcbiBpbnRvIFxcclxcbi4gVGhlIGJ1ZyBjYXVzZXMgYSBsb29wIHdoZW4gc2xhdGUtZG9tXG4gICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVwb3NpdGlvbiBpdHMgY3Vyc29yIHRvIG1hdGNoIHRoZSBuYXRpdmUgcG9zaXRpb24uIFVzZVxuICAgICAgICAgIC8vIHRleHRDb250ZW50Lmxlbmd0aCBpbnN0ZWFkLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMjkxMTE2L1xuICAgICAgICAgIG9mZnNldCA9IGNvbnRlbnRzLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlID0gdGV4dE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodm9pZE5vZGUpIHtcbiAgICAgICAgLy8gRm9yIHZvaWQgbm9kZXMsIHRoZSBlbGVtZW50IHdpdGggdGhlIG9mZnNldCBrZXkgd2lsbCBiZSBhIGNvdXNpbiwgbm90IGFuXG4gICAgICAgIC8vIGFuY2VzdG9yLCBzbyBmaW5kIGl0IGJ5IGdvaW5nIGRvd24gZnJvbSB0aGUgbmVhcmVzdCB2b2lkIHBhcmVudCBhbmQgdGFraW5nIHRoZVxuICAgICAgICAvLyBmaXJzdCBvbmUgdGhhdCBpc24ndCBpbnNpZGUgYSBuZXN0ZWQgZWRpdG9yLlxuICAgICAgICB2YXIgbGVhZk5vZGVzID0gdm9pZE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlYWZOb2Rlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGxlYWZOb2Rlc1tpbmRleF07XG4gICAgICAgICAgaWYgKERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgY3VycmVudCkpIHtcbiAgICAgICAgICAgIGxlYWZOb2RlID0gY3VycmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDT01QQVQ6IEluIHJlYWQtb25seSBlZGl0b3JzIHRoZSBsZWFmIGlzIG5vdCByZW5kZXJlZC5cbiAgICAgICAgaWYgKCFsZWFmTm9kZSkge1xuICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICAgIGRvbU5vZGUgPSBsZWFmTm9kZTtcbiAgICAgICAgICBvZmZzZXQgPSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9uRWRpdGFibGVOb2RlKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVkZ2Ugb2YgdGhlIG5lYXJlc3QgbGVhZiBpbiBgc2VhcmNoRGlyZWN0aW9uYFxuICAgICAgICB2YXIgZ2V0TGVhZk5vZGVzID0gZnVuY3Rpb24gZ2V0TGVhZk5vZGVzKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAvLyBFeGNsdWRlIGxlYWYgbm9kZXMgaW4gbmVzdGVkIGVkaXRvcnNcbiAgICAgICAgICAnW2RhdGEtc2xhdGUtbGVhZl06bm90KDpzY29wZSBbZGF0YS1zbGF0ZS1lZGl0b3JdIFtkYXRhLXNsYXRlLWxlYWZdKScpIDogW107XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlbGVtZW50Tm9kZSA9IG5vbkVkaXRhYmxlTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwiZWxlbWVudFwiXScpO1xuICAgICAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlcyRmaW5kO1xuICAgICAgICAgIHZhciBfbGVhZk5vZGVzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShnZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUpKSwgX3RvQ29uc3VtYWJsZUFycmF5KGdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSA9PT0gbnVsbCB8fCBlbGVtZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudE5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKSkpO1xuICAgICAgICAgIGxlYWZOb2RlID0gKF9sZWFmTm9kZXMkZmluZCA9IF9sZWFmTm9kZXMuZmluZChmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGlzQWZ0ZXIobm9uRWRpdGFibGVOb2RlLCBsZWFmKTtcbiAgICAgICAgICB9KSkgIT09IG51bGwgJiYgX2xlYWZOb2RlcyRmaW5kICE9PSB2b2lkIDAgPyBfbGVhZk5vZGVzJGZpbmQgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfbGVhZk5vZGVzMiRmaW5kTGFzdDtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlczIgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSA9PT0gbnVsbCB8fCBlbGVtZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudE5vZGUucHJldmlvdXNFbGVtZW50U2libGluZykpLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TGVhZk5vZGVzKGVsZW1lbnROb2RlKSkpO1xuICAgICAgICAgIGxlYWZOb2RlID0gKF9sZWFmTm9kZXMyJGZpbmRMYXN0ID0gX2xlYWZOb2RlczIuZmluZExhc3QoZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JlZm9yZShub25FZGl0YWJsZU5vZGUsIGxlYWYpO1xuICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfbGVhZk5vZGVzMiRmaW5kTGFzdCAhPT0gdm9pZCAwID8gX2xlYWZOb2RlczIkZmluZExhc3QgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFmTm9kZSkge1xuICAgICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgICBkb21Ob2RlID0gbGVhZk5vZGU7XG4gICAgICAgICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICBvZmZzZXQgLT0gZWwudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9tTm9kZSAmJiBvZmZzZXQgPT09IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoICYmXG4gICAgICAvLyBDT01QQVQ6IEFuZHJvaWQgSU1FcyBtaWdodCByZW1vdmUgdGhlIHplcm8gd2lkdGggc3BhY2Ugd2hpbGUgY29tcG9zaW5nLFxuICAgICAgLy8gYW5kIHdlIGRvbid0IGFkZCBpdCBmb3IgbGluZS1icmVha3MuXG4gICAgICBJU19BTkRST0lEICYmIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ3onICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9kb21Ob2RlJHRleHRDb250ZW50ICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQuc3RhcnRzV2l0aChcIlxcdUZFRkZcIikgJiYgKFxuICAgICAgLy8gQ09NUEFUOiBJZiB0aGUgcGFyZW50IG5vZGUgaXMgYSBTbGF0ZSB6ZXJvLXdpZHRoIHNwYWNlLCBlZGl0b3IgaXNcbiAgICAgIC8vIGJlY2F1c2UgdGhlIHRleHQgbm9kZSBzaG91bGQgaGF2ZSBubyBjaGFyYWN0ZXJzLiBIb3dldmVyLCBkdXJpbmcgSU1FXG4gICAgICAvLyBjb21wb3NpdGlvbiB0aGUgQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgemVyby13aWR0aFxuICAgICAgLy8gc3BhY2UsIHNvIHN1YnRyYWN0IDEgZnJvbSB0aGUgb2Zmc2V0IHRvIGFjY291bnQgZm9yIHRoZSB6ZXJvLXdpZHRoXG4gICAgICAvLyBzcGFjZSBjaGFyYWN0ZXIuXG4gICAgICBwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgfHxcbiAgICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgYHJhbmdlLmNsb25lQ29udGVudHMoKWAgcmV0dXJucyBhbiBleHRyYSB0cmFpbGluZyAnXFxuJ1xuICAgICAgLy8gd2hlbiB0aGUgZG9jdW1lbnQgZW5kcyB3aXRoIGEgbmV3LWxpbmUgY2hhcmFjdGVyLiBUaGlzIHJlc3VsdHMgaW4gdGhlIG9mZnNldFxuICAgICAgLy8gbGVuZ3RoIGJlaW5nIG9mZiBieSBvbmUsIHNvIHdlIG5lZWQgdG8gc3VidHJhY3Qgb25lIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAgICBJU19GSVJFRk9YICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudDIgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIuZW5kc1dpdGgoJ1xcblxcbicpKSkge1xuICAgICAgICBvZmZzZXQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKElTX0FORFJPSUQgJiYgIXRleHROb2RlICYmICFleGFjdE1hdGNoKSB7XG4gICAgICB2YXIgbm9kZSA9IHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSA/IHBhcmVudE5vZGUgOiBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGVdJyk7XG4gICAgICBpZiAobm9kZSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBfc2xhdGVOb2RlID0gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIHZhciBfRWRpdG9yJHN0YXJ0ID0gc2xhdGUuRWRpdG9yLnN0YXJ0KGVkaXRvciwgRE9NRWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgX3NsYXRlTm9kZSkpLFxuICAgICAgICAgIF9wYXRoID0gX0VkaXRvciRzdGFydC5wYXRoLFxuICAgICAgICAgIF9vZmZzZXQgPSBfRWRpdG9yJHN0YXJ0Lm9mZnNldDtcbiAgICAgICAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLWxlYWZdJykpIHtcbiAgICAgICAgICBfb2Zmc2V0ID0gbmVhcmVzdE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICBpZiAoc3VwcHJlc3NUaHJvdykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcG9pbnQgZnJvbSBET00gcG9pbnQ6IFwiLmNvbmNhdChkb21Qb2ludCkpO1xuICAgIH1cbiAgICAvLyBDT01QQVQ6IElmIHNvbWVvbmUgaXMgY2xpY2tpbmcgZnJvbSBvbmUgU2xhdGUgZWRpdG9yIGludG8gYW5vdGhlcixcbiAgICAvLyB0aGUgc2VsZWN0IGV2ZW50IGZpcmVzIHR3aWNlLCBvbmNlIGZvciB0aGUgb2xkIGVkaXRvcidzIGBlbGVtZW50YFxuICAgIC8vIGZpcnN0LCBhbmQgdGhlbiBhZnRlcndhcmRzIGZvciB0aGUgY29ycmVjdCBgZWxlbWVudGAuICgyMDE3LzAzLzAzKVxuICAgIHZhciBzbGF0ZU5vZGUgPSBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0ZXh0Tm9kZSk7XG4gICAgdmFyIHBhdGggPSBET01FZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICB9O1xuICB9LFxuICB0b1NsYXRlUmFuZ2U6IGZ1bmN0aW9uIHRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9mb2N1c05vZGUkdGV4dENvbnRlbjtcbiAgICB2YXIgZXhhY3RNYXRjaCA9IG9wdGlvbnMuZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3cgPSBvcHRpb25zLnN1cHByZXNzVGhyb3c7XG4gICAgdmFyIGVsID0gaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpID8gZG9tUmFuZ2UuYW5jaG9yTm9kZSA6IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBhbmNob3JOb2RlO1xuICAgIHZhciBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzTm9kZTtcbiAgICB2YXIgZm9jdXNPZmZzZXQ7XG4gICAgdmFyIGlzQ29sbGFwc2VkO1xuICAgIGlmIChlbCkge1xuICAgICAgaWYgKGlzRE9NU2VsZWN0aW9uKGRvbVJhbmdlKSkge1xuICAgICAgICAvLyBDT01QQVQ6IEluIGZpcmVmb3ggdGhlIG5vcm1hbCBzZWxldGlvbiB3YXkgZG9lcyBub3Qgd29ya1xuICAgICAgICAvLyAoaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNTQ4NiNpc3N1ZS0xODIwNzIwMjIzKVxuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBkb21SYW5nZS5yYW5nZUNvdW50ID4gMSkge1xuICAgICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTsgLy8gRm9jdXMgbm9kZSB3b3JrcyBmaW5lXG4gICAgICAgICAgdmFyIGZpcnN0UmFuZ2UgPSBkb21SYW5nZS5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgIHZhciBsYXN0UmFuZ2UgPSBkb21SYW5nZS5nZXRSYW5nZUF0KGRvbVJhbmdlLnJhbmdlQ291bnQgLSAxKTtcbiAgICAgICAgICAvLyBIZXJlIHdlIGFyZSBpbiB0aGUgY29udGVudGVkaXRhYmxlIG1vZGUgb2YgYSB0YWJsZSBpbiBmaXJlZm94XG4gICAgICAgICAgaWYgKGZvY3VzTm9kZSBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQgJiYgZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQgJiYgbGFzdFJhbmdlLnN0YXJ0Q29udGFpbmVyIGluc3RhbmNlb2YgSFRNTFRhYmxlUm93RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSFRNTEVsZW1lbnQsIGJlY291c2UgRWxlbWVudCBpcyBhIHNsYXRlIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBnZXRMYXN0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRMYXN0Q2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TGFzdENoaWxkcmVuKGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZVJvdyA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGVSb3cgPSBsYXN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBmYWlsIGFzIFwiVGhlIEhUTUxFbGVtZW50IGludGVyZmFjZSByZXByZXNlbnRzIGFueSBIVE1MIGVsZW1lbnQuXCJcbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGUgPSBnZXRMYXN0Q2hpbGRyZW4oZmlyc3ROb2RlUm93LmNoaWxkcmVuW2ZpcnN0UmFuZ2Uuc3RhcnRPZmZzZXRdKTtcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IGdldExhc3RDaGlsZHJlbihsYXN0Tm9kZVJvdy5jaGlsZHJlbltsYXN0UmFuZ2Uuc3RhcnRPZmZzZXRdKTtcbiAgICAgICAgICAgIC8vIFplcm8sIGFzIHdlIGFsbHdheXMgdGFrZSB0aGUgcmlnaHQgb25lIGFzIHRoZSBhbmNob3IgcG9pbnRcbiAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3ROb2RlLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmaXJzdE5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3ROb2RlLmlubmVySFRNTC5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjayBvcHRpb25cbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhZCBvbmx5IG1vZGUgb2YgYSBmaXJlZm94IHRhYmxlXG4gICAgICAgICAgICAvLyBSaWdodCB0byBsZWZ0XG4gICAgICAgICAgICBpZiAoZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lciA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0UmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBsYXN0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IGZpcnN0UmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMZWZ0IHRvIHJpZ2h0XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBmaXJzdFJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSBsYXN0UmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5hbmNob3JOb2RlO1xuICAgICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLmFuY2hvck9mZnNldDtcbiAgICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7XG4gICAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDT01QQVQ6IFRoZXJlJ3MgYSBidWcgaW4gY2hyb21lIHRoYXQgYWx3YXlzIHJldHVybnMgYHRydWVgIGZvclxuICAgICAgICAvLyBgaXNDb2xsYXBzZWRgIGZvciBhIFNlbGVjdGlvbiB0aGF0IGNvbWVzIGZyb20gYSBTaGFkb3dSb290LlxuICAgICAgICAvLyAoMjAyMC8wOC8wOClcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4gICAgICAgIC8vIElzQ29sbGFwc2VkIG1pZ2h0IG5vdCB3b3JrIGluIGZpcmVmb3gsIGJ1dCB0aGlzIHdpbGxcbiAgICAgICAgaWYgKElTX0NIUk9NRSAmJiBoYXNTaGFkb3dSb290KGFuY2hvck5vZGUpIHx8IElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmFuY2hvck5vZGUgPT09IGRvbVJhbmdlLmZvY3VzTm9kZSAmJiBkb21SYW5nZS5hbmNob3JPZmZzZXQgPT09IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuaXNDb2xsYXBzZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuY29sbGFwc2VkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYW5jaG9yTm9kZSA9PSBudWxsIHx8IGZvY3VzTm9kZSA9PSBudWxsIHx8IGFuY2hvck9mZnNldCA9PSBudWxsIHx8IGZvY3VzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBET00gcmFuZ2U6IFwiLmNvbmNhdChkb21SYW5nZSkpO1xuICAgIH1cbiAgICAvLyBDT01QQVQ6IEZpcmVmb3ggc29tZXRpbWVzIGluY2x1ZGVzIGFuIGV4dHJhIFxcbiAocmVuZGVyZWQgYnkgVGV4dFN0cmluZ1xuICAgIC8vIHdoZW4gaXNUcmFpbGluZyBpcyB0cnVlKSBpbiB0aGUgZm9jdXNPZmZzZXQsIHJlc3VsdGluZyBpbiBhbiBpbnZhbGlkXG4gICAgLy8gU2xhdGUgcG9pbnQuICgyMDIzLzExLzAxKVxuICAgIGlmIChJU19GSVJFRk9YICYmIChfZm9jdXNOb2RlJHRleHRDb250ZW4gPSBmb2N1c05vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9mb2N1c05vZGUkdGV4dENvbnRlbiAhPT0gdm9pZCAwICYmIF9mb2N1c05vZGUkdGV4dENvbnRlbi5lbmRzV2l0aCgnXFxuXFxuJykgJiYgZm9jdXNPZmZzZXQgPT09IGZvY3VzTm9kZS50ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgIGZvY3VzT2Zmc2V0LS07XG4gICAgfVxuICAgIHZhciBhbmNob3IgPSBET01FZGl0b3IudG9TbGF0ZVBvaW50KGVkaXRvciwgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldF0sIHtcbiAgICAgIGV4YWN0TWF0Y2g6IGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93OiBzdXBwcmVzc1Rocm93XG4gICAgfSk7XG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZm9jdXNCZWZvcmVBbmNob3IgPSBpc0JlZm9yZShhbmNob3JOb2RlLCBmb2N1c05vZGUpIHx8IGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBmb2N1c09mZnNldCA8IGFuY2hvck9mZnNldDtcbiAgICB2YXIgZm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFuY2hvciA6IERPTUVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbZm9jdXNOb2RlLCBmb2N1c09mZnNldF0sIHtcbiAgICAgIGV4YWN0TWF0Y2g6IGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93OiBzdXBwcmVzc1Rocm93LFxuICAgICAgc2VhcmNoRGlyZWN0aW9uOiBmb2N1c0JlZm9yZUFuY2hvciA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgICBpZiAoIWZvY3VzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogZm9jdXNcbiAgICB9O1xuICAgIC8vIGlmIHRoZSBzZWxlY3Rpb24gaXMgYSBoYW5naW5nIHJhbmdlIHRoYXQgZW5kcyBpbiBhIHZvaWRcbiAgICAvLyBhbmQgdGhlIERPTSBmb2N1cyBpcyBhbiBFbGVtZW50XG4gICAgLy8gKG1lYW5pbmcgdGhhdCB0aGUgc2VsZWN0aW9uIGVuZHMgYmVmb3JlIHRoZSBlbGVtZW50KVxuICAgIC8vIHVuaGFuZyB0aGUgcmFuZ2UgdG8gYXZvaWQgbWlzdGFrZW5seSBpbmNsdWRpbmcgdGhlIHZvaWRcbiAgICBpZiAoc2xhdGUuUmFuZ2UuaXNFeHBhbmRlZChyYW5nZSkgJiYgc2xhdGUuUmFuZ2UuaXNGb3J3YXJkKHJhbmdlKSAmJiBpc0RPTUVsZW1lbnQoZm9jdXNOb2RlKSAmJiBzbGF0ZS5FZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlLmZvY3VzLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpIHtcbiAgICAgIHJhbmdlID0gc2xhdGUuRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIHtcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHRleHQgZGlmZiB3YXMgYXBwbGllZCBpbiBhIHdheSB3ZSBjYW4gcGVyZm9ybSB0aGUgcGVuZGluZyBhY3Rpb24gb24gL1xuICogcmVjb3ZlciB0aGUgcGVuZGluZyBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeURpZmZTdGF0ZShlZGl0b3IsIHRleHREaWZmKSB7XG4gIHZhciBwYXRoID0gdGV4dERpZmYucGF0aCxcbiAgICBkaWZmID0gdGV4dERpZmYuZGlmZjtcbiAgaWYgKCFzbGF0ZS5FZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBub2RlID0gc2xhdGUuTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCFzbGF0ZS5UZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGlmZi5zdGFydCAhPT0gbm9kZS50ZXh0Lmxlbmd0aCB8fCBkaWZmLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5vZGUudGV4dC5zbGljZShkaWZmLnN0YXJ0LCBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkgPT09IGRpZmYudGV4dDtcbiAgfVxuICB2YXIgbmV4dFBhdGggPSBzbGF0ZS5QYXRoLm5leHQocGF0aCk7XG4gIGlmICghc2xhdGUuRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBuZXh0UGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG5leHROb2RlID0gc2xhdGUuTm9kZS5nZXQoZWRpdG9yLCBuZXh0UGF0aCk7XG4gIHJldHVybiBzbGF0ZS5UZXh0LmlzVGV4dChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUudGV4dC5zdGFydHNXaXRoKGRpZmYudGV4dCk7XG59XG5mdW5jdGlvbiBhcHBseVN0cmluZ0RpZmYodGV4dCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGlmZnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGRpZmZzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZGlmZnMucmVkdWNlKGZ1bmN0aW9uICh0ZXh0LCBkaWZmKSB7XG4gICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgZGlmZi5zdGFydCkgKyBkaWZmLnRleHQgKyB0ZXh0LnNsaWNlKGRpZmYuZW5kKTtcbiAgfSwgdGV4dCk7XG59XG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHN0ciwgYW5vdGhlcikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoaSkgIT09IGFub3RoZXIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgoc3RyLCBhbm90aGVyLCBtYXgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoLCBtYXgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIGkgLSAxKSAhPT0gYW5vdGhlci5jaGFyQXQoYW5vdGhlci5sZW5ndGggLSBpIC0gMSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXG4gKiBSZW1vdmUgcmVkdW5kYW50IGNoYW5nZXMgZnJvbSB0aGUgZGlmZiBzbyB0aGF0IGl0IHNwYW5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHJhbmdlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgZGlmZikge1xuICB2YXIgc3RhcnQgPSBkaWZmLnN0YXJ0LFxuICAgIGVuZCA9IGRpZmYuZW5kLFxuICAgIHRleHQgPSBkaWZmLnRleHQ7XG4gIHZhciByZW1vdmVkVGV4dCA9IHRhcmdldFRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciBwcmVmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0KTtcbiAgdmFyIG1heCA9IE1hdGgubWluKHJlbW92ZWRUZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgpO1xuICB2YXIgc3VmZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCwgbWF4KTtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB7XG4gICAgc3RhcnQ6IHN0YXJ0ICsgcHJlZml4TGVuZ3RoLFxuICAgIGVuZDogZW5kIC0gc3VmZml4TGVuZ3RoLFxuICAgIHRleHQ6IHRleHQuc2xpY2UocHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHN1ZmZpeExlbmd0aClcbiAgfTtcbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnQgPT09IG5vcm1hbGl6ZWQuZW5kICYmIG5vcm1hbGl6ZWQudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIGRpZmYgdGhhdCBpcyBlcXVpdmFsZW50IHRvIGFwcGx5aW5nIGIgYWZ0ZXIgYSBzcGFubmluZyB0aGUgcmFuZ2Ugb2ZcbiAqIGJvdGggY2hhbmdlc1xuICovXG5mdW5jdGlvbiBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldFRleHQsIGEsIGIpIHtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4oYS5zdGFydCwgYi5zdGFydCk7XG4gIHZhciBvdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYS5zdGFydCArIGEudGV4dC5sZW5ndGgsIGIuZW5kKSAtIGIuc3RhcnQpO1xuICB2YXIgYXBwbGllZCA9IGFwcGx5U3RyaW5nRGlmZih0YXJnZXRUZXh0LCBhLCBiKTtcbiAgdmFyIHNsaWNlRW5kID0gTWF0aC5tYXgoYi5zdGFydCArIGIudGV4dC5sZW5ndGgsIGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoICsgKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoID4gYi5zdGFydCA/IGIudGV4dC5sZW5ndGggOiAwKSAtIG92ZXJsYXApO1xuICB2YXIgdGV4dCA9IGFwcGxpZWQuc2xpY2Uoc3RhcnQsIHNsaWNlRW5kKTtcbiAgdmFyIGVuZCA9IE1hdGgubWF4KGEuZW5kLCBiLmVuZCAtIGEudGV4dC5sZW5ndGggKyAoYS5lbmQgLSBhLnN0YXJ0KSk7XG4gIHJldHVybiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gICAgdGV4dDogdGV4dFxuICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSBzbGF0ZSByYW5nZSB0aGUgdGV4dCBkaWZmIHNwYW5zLlxuICovXG5mdW5jdGlvbiB0YXJnZXRSYW5nZSh0ZXh0RGlmZikge1xuICB2YXIgcGF0aCA9IHRleHREaWZmLnBhdGgsXG4gICAgZGlmZiA9IHRleHREaWZmLmRpZmY7XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5lbmRcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhICdwZW5kaW5nIHBvaW50JyBhLmsuYSBhIHBvaW50IGJhc2VkIG9uIHRoZSBkb20gc3RhdGUgYmVmb3JlIGFwcGx5aW5nXG4gKiB0aGUgcGVuZGluZyBkaWZmcy4gU2luY2UgdGhlIHBlbmRpbmcgZGlmZnMgbWlnaHQgaGF2ZSBiZWVuIGluc2VydGVkIHdpdGggZGlmZmVyZW50XG4gKiBtYXJrcyB3ZSBoYXZlIHRvICd3YWxrJyB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGVuc3VyZSB3ZSBzdGlsbFxuICogaGF2ZSBhIHZhbGlkIHBvaW50IGluc2lkZSB0aGUgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICB2YXIgcGF0aCA9IHBvaW50LnBhdGgsXG4gICAgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICBpZiAoIXNsYXRlLkVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVhZiA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIGlmICghc2xhdGUuVGV4dC5pc1RleHQobGVhZikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcGFyZW50QmxvY2sgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgIHJldHVybiBzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChuKSAmJiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH0sXG4gICAgYXQ6IHBhdGhcbiAgfSk7XG4gIGlmICghcGFyZW50QmxvY2spIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID4gbGVhZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IHNsYXRlLkVkaXRvci5uZXh0KGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtYXRjaDogc2xhdGUuVGV4dC5pc1RleHRcbiAgICB9KTtcbiAgICBpZiAoIWVudHJ5IHx8ICFzbGF0ZS5QYXRoLmlzRGVzY2VuZGFudChlbnRyeVsxXSwgcGFyZW50QmxvY2tbMV0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb2Zmc2V0IC09IGxlYWYudGV4dC5sZW5ndGg7XG4gICAgbGVhZiA9IGVudHJ5WzBdO1xuICAgIHBhdGggPSBlbnRyeVsxXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgc2VsZWN0aW9uJyB0byBlbnN1cmUgaXQncyB2YWxpZCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgYW5jaG9yID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5hbmNob3IpO1xuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuICB2YXIgZm9jdXMgPSBub3JtYWxpemVQb2ludChlZGl0b3IsIHJhbmdlLmZvY3VzKTtcbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiBhbmNob3IsXG4gICAgZm9jdXM6IGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCBwb2ludCwgb3ApIHtcbiAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB2YXIgdGV4dERpZmYgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBwYXRoID0gX3JlZi5wYXRoO1xuICAgIHJldHVybiBzbGF0ZS5QYXRoLmVxdWFscyhwYXRoLCBwb2ludC5wYXRoKTtcbiAgfSk7XG4gIGlmICghdGV4dERpZmYgfHwgcG9pbnQub2Zmc2V0IDw9IHRleHREaWZmLmRpZmYuc3RhcnQpIHtcbiAgICByZXR1cm4gc2xhdGUuUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgfVxuICB2YXIgZGlmZiA9IHRleHREaWZmLmRpZmY7XG4gIC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gaW5zaWRlIHRoZSBkaWZmID0+IHRyYW5zZm9ybSB0aGUgcG9pbnQgYmFzZWQgb24gdGhlIGxvY2F0aW9uXG4gIC8vIHRoZSBkaWZmIHdpbGwgYmUgYXBwbGllZCB0byBhbmQgYWRkIHRoZSBvZmZzZXQgaW5zaWRlIHRoZSBkaWZmLlxuICBpZiAocG9pbnQub2Zmc2V0IDw9IGRpZmYuc3RhcnQgKyBkaWZmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIF9hbmNob3IgPSB7XG4gICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfTtcbiAgICB2YXIgX3RyYW5zZm9ybWVkID0gc2xhdGUuUG9pbnQudHJhbnNmb3JtKF9hbmNob3IsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICAgIGlmICghX3RyYW5zZm9ybWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IF90cmFuc2Zvcm1lZC5wYXRoLFxuICAgICAgb2Zmc2V0OiBfdHJhbnNmb3JtZWQub2Zmc2V0ICsgcG9pbnQub2Zmc2V0IC0gZGlmZi5zdGFydFxuICAgIH07XG4gIH1cbiAgLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBhZnRlciB0aGUgZGlmZlxuICB2YXIgYW5jaG9yID0ge1xuICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgb2Zmc2V0OiBwb2ludC5vZmZzZXQgLSBkaWZmLnRleHQubGVuZ3RoICsgZGlmZi5lbmQgLSBkaWZmLnN0YXJ0XG4gIH07XG4gIHZhciB0cmFuc2Zvcm1lZCA9IHNsYXRlLlBvaW50LnRyYW5zZm9ybShhbmNob3IsIG9wLCB7XG4gICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgfSk7XG4gIGlmICghdHJhbnNmb3JtZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3AudHlwZSA9PT0gJ3NwbGl0X25vZGUnICYmIHNsYXRlLlBhdGguZXF1YWxzKG9wLnBhdGgsIHBvaW50LnBhdGgpICYmIGFuY2hvci5vZmZzZXQgPCBvcC5wb3NpdGlvbiAmJiBkaWZmLnN0YXJ0IDwgb3AucG9zaXRpb24pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiB0cmFuc2Zvcm1lZC5wYXRoLFxuICAgIG9mZnNldDogdHJhbnNmb3JtZWQub2Zmc2V0ICsgZGlmZi50ZXh0Lmxlbmd0aCAtIGRpZmYuZW5kICsgZGlmZi5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIG9wKSB7XG4gIHZhciBhbmNob3IgPSB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCByYW5nZS5hbmNob3IsIG9wKTtcbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cbiAgdmFyIGZvY3VzID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMsIG9wKTtcbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiBhbmNob3IsXG4gICAgZm9jdXM6IGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0RGlmZih0ZXh0RGlmZiwgb3ApIHtcbiAgdmFyIHBhdGggPSB0ZXh0RGlmZi5wYXRoLFxuICAgIGRpZmYgPSB0ZXh0RGlmZi5kaWZmLFxuICAgIGlkID0gdGV4dERpZmYuaWQ7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFzbGF0ZS5QYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5vZmZzZXQgPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLm9mZnNldCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IG9wLnRleHQubGVuZ3RoICsgZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFzbGF0ZS5QYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5vZmZzZXQgPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoIDw9IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghc2xhdGUuUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3AucG9zaXRpb24gPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjogZGlmZixcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhdGg6IHNsYXRlLlBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLnBvc2l0aW9uID4gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IE1hdGgubWluKG9wLnBvc2l0aW9uLCBkaWZmLmVuZCksXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhdGg6IHNsYXRlLlBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFzbGF0ZS5QYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogc2xhdGUuUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0ICsgb3AucG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kICsgb3AucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXRoOiBzbGF0ZS5QYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgfVxuICB2YXIgbmV3UGF0aCA9IHNsYXRlLlBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgaWYgKCFuZXdQYXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkaWZmOiBkaWZmLFxuICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgaWQ6IGlkXG4gIH07XG59XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBzaW5nbGUtbGluZSBkZWxldGlvblxuICovXG52YXIgZG9SZWN0c0ludGVyc2VjdCA9IGZ1bmN0aW9uIGRvUmVjdHNJbnRlcnNlY3QocmVjdCwgY29tcGFyZVJlY3QpIHtcbiAgdmFyIG1pZGRsZSA9IChjb21wYXJlUmVjdC50b3AgKyBjb21wYXJlUmVjdC5ib3R0b20pIC8gMjtcbiAgcmV0dXJuIHJlY3QudG9wIDw9IG1pZGRsZSAmJiByZWN0LmJvdHRvbSA+PSBtaWRkbGU7XG59O1xudmFyIGFyZVJhbmdlc1NhbWVMaW5lID0gZnVuY3Rpb24gYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCByYW5nZTEsIHJhbmdlMikge1xuICB2YXIgcmVjdDEgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciByZWN0MiA9IERPTUVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGRvUmVjdHNJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSAmJiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QyLCByZWN0MSk7XG59O1xuLyoqXG4gKiBBIGhlbHBlciB1dGlsaXR5IHRoYXQgcmV0dXJucyB0aGUgZW5kIHBvcnRpb24gb2YgYSBgUmFuZ2VgXG4gKiB3aGljaCBpcyBsb2NhdGVkIG9uIGEgc2luZ2xlIGxpbmUuXG4gKlxuICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvciBUaGUgZWRpdG9yIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7UmFuZ2V9IHBhcmVudFJhbmdlIFRoZSBwYXJlbnQgcmFuZ2UgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7UmFuZ2V9IEEgdmFsaWQgcG9ydGlvbiBvZiB0aGUgcGFyZW50UmFuZ2Ugd2hpY2ggaXMgb25lIGEgc2luZ2xlIGxpbmVcbiAqL1xudmFyIGZpbmRDdXJyZW50TGluZVJhbmdlID0gZnVuY3Rpb24gZmluZEN1cnJlbnRMaW5lUmFuZ2UoZWRpdG9yLCBwYXJlbnRSYW5nZSkge1xuICB2YXIgcGFyZW50UmFuZ2VCb3VuZGFyeSA9IHNsYXRlLkVkaXRvci5yYW5nZShlZGl0b3IsIHNsYXRlLlJhbmdlLmVuZChwYXJlbnRSYW5nZSkpO1xuICB2YXIgcG9zaXRpb25zID0gQXJyYXkuZnJvbShzbGF0ZS5FZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiBwYXJlbnRSYW5nZVxuICB9KSk7XG4gIHZhciBsZWZ0ID0gMDtcbiAgdmFyIHJpZ2h0ID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IocmlnaHQgLyAyKTtcbiAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpIHtcbiAgICByZXR1cm4gc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbiAgfVxuICBpZiAocG9zaXRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cbiAgd2hpbGUgKG1pZGRsZSAhPT0gcG9zaXRpb25zLmxlbmd0aCAmJiBtaWRkbGUgIT09IGxlZnQpIHtcbiAgICBpZiAoYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbWlkZGxlXSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgICByaWdodCA9IG1pZGRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IG1pZGRsZTtcbiAgICB9XG4gICAgbWlkZGxlID0gTWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICB9XG4gIHJldHVybiBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbcmlnaHRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vKipcbiAqIGB3aXRoRE9NYCBhZGRzIERPTSBzcGVjaWZpYyBiZWhhdmlvcnMgdG8gdGhlIGVkaXRvci5cbiAqXG4gKiBJZiB5b3UgYXJlIHVzaW5nIFR5cGVTY3JpcHQsIHlvdSBtdXN0IGV4dGVuZCBTbGF0ZSdzIEN1c3RvbVR5cGVzIHRvIHVzZVxuICogdGhpcyBwbHVnaW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZG9jcy5zbGF0ZWpzLm9yZy9jb25jZXB0cy8xMS10eXBlc2NyaXB0IHRvIGxlYXJuIGhvdy5cbiAqL1xudmFyIHdpdGhET00gPSBmdW5jdGlvbiB3aXRoRE9NKGVkaXRvcikge1xuICB2YXIgY2xpcGJvYXJkRm9ybWF0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneC1zbGF0ZS1mcmFnbWVudCc7XG4gIHZhciBlID0gZWRpdG9yO1xuICB2YXIgYXBwbHkgPSBlLmFwcGx5LFxuICAgIG9uQ2hhbmdlID0gZS5vbkNoYW5nZSxcbiAgICBkZWxldGVCYWNrd2FyZCA9IGUuZGVsZXRlQmFja3dhcmQsXG4gICAgYWRkTWFyayA9IGUuYWRkTWFyayxcbiAgICByZW1vdmVNYXJrID0gZS5yZW1vdmVNYXJrO1xuICAvLyBUaGUgV2Vha01hcCB3aGljaCBtYXBzIGEga2V5IHRvIGEgc3BlY2lmaWMgSFRNTEVsZW1lbnQgbXVzdCBiZSBzY29wZWQgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSB0b1xuICAvLyBhdm9pZCBjb2xsaXNpb25zIGJldHdlZW4gZWRpdG9ycyBpbiB0aGUgRE9NIHRoYXQgc2hhcmUgdGhlIHNhbWUgdmFsdWUuXG4gIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5zZXQoZSwgbmV3IFdlYWtNYXAoKSk7XG4gIGUuYWRkTWFyayA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRiwgX0VESVRPUl9UT19QRU5ESU5HX0RJO1xuICAgIChfRURJVE9SX1RPX1NDSEVEVUxFX0YgPSBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guZ2V0KGUpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YgPT09IHZvaWQgMCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESSA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLU1tcImRlbGV0ZVwiXShlKTtcbiAgICBhZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9O1xuICBlLnJlbW92ZU1hcmsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG4gICAgaWYgKCFFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGUpICYmIChfRURJVE9SX1RPX1BFTkRJTkdfREkyID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkyICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMi5sZW5ndGgpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGUgY3VycmVudCBwZW5kaW5nIGRpZmZzIG9yaWdpbmF0aW5nIGZyb20gY2hhbmdlcyBiZWZvcmUgdGhlIGFkZE1hcmtcbiAgICAgIC8vIGFyZSBhcHBsaWVkIHdpdGggdGhlIGN1cnJlbnQgZm9ybWF0dGluZ1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlLCBudWxsKTtcbiAgICB9XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1NbXCJkZWxldGVcIl0oZSk7XG4gICAgcmVtb3ZlTWFyayhrZXkpO1xuICB9O1xuICBlLmRlbGV0ZUJhY2t3YXJkID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICBpZiAodW5pdCAhPT0gJ2xpbmUnKSB7XG4gICAgICByZXR1cm4gZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gICAgfVxuICAgIGlmIChlLnNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChlLnNlbGVjdGlvbikpIHtcbiAgICAgIHZhciBwYXJlbnRCbG9ja0VudHJ5ID0gc2xhdGUuRWRpdG9yLmFib3ZlKGUsIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobikgJiYgc2xhdGUuRWRpdG9yLmlzQmxvY2soZSwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIGF0OiBlLnNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAocGFyZW50QmxvY2tFbnRyeSkge1xuICAgICAgICB2YXIgX3BhcmVudEJsb2NrRW50cnkgPSBfc2xpY2VkVG9BcnJheShwYXJlbnRCbG9ja0VudHJ5LCAyKSxcbiAgICAgICAgICBwYXJlbnRCbG9ja1BhdGggPSBfcGFyZW50QmxvY2tFbnRyeVsxXTtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnRSYW5nZSA9IHNsYXRlLkVkaXRvci5yYW5nZShlLCBwYXJlbnRCbG9ja1BhdGgsIGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVJhbmdlID0gZmluZEN1cnJlbnRMaW5lUmFuZ2UoZSwgcGFyZW50RWxlbWVudFJhbmdlKTtcbiAgICAgICAgaWYgKCFzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChjdXJyZW50TGluZVJhbmdlKSkge1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZSwge1xuICAgICAgICAgICAgYXQ6IGN1cnJlbnRMaW5lUmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhpcyBhdHRlbXB0cyB0byByZXNldCB0aGUgTk9ERV9UT19LRVkgZW50cnkgdG8gdGhlIGNvcnJlY3QgdmFsdWVcbiAgLy8gYXMgYXBwbHkoKSBjaGFuZ2VzIHRoZSBvYmplY3QgcmVmZXJlbmNlIGFuZCBoZW5jZSBpbnZhbGlkYXRlcyB0aGUgTk9ERV9UT19LRVkgZW50cnlcbiAgZS5hcHBseSA9IGZ1bmN0aW9uIChvcCkge1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIHBhdGhSZWZNYXRjaGVzID0gW107XG4gICAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKTtcbiAgICBpZiAocGVuZGluZ0RpZmZzICE9PSBudWxsICYmIHBlbmRpbmdEaWZmcyAhPT0gdm9pZCAwICYmIHBlbmRpbmdEaWZmcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHBlbmRpbmdEaWZmcy5tYXAoZnVuY3Rpb24gKHRleHREaWZmKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1UZXh0RGlmZih0ZXh0RGlmZiwgb3ApO1xuICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGUsIHRyYW5zZm9ybWVkKTtcbiAgICB9XG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGUpO1xuICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uKSB7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uc2V0KGUsIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlLCBwZW5kaW5nU2VsZWN0aW9uLCBvcCkpO1xuICAgIH1cbiAgICB2YXIgcGVuZGluZ0FjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZSk7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gIT09IG51bGwgJiYgcGVuZGluZ0FjdGlvbiAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb24uYXQpIHtcbiAgICAgIHZhciBhdCA9IHNsYXRlLlBvaW50LmlzUG9pbnQocGVuZGluZ0FjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nQWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nQWN0aW9uLmF0KSA/IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCkgOiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLnNldChlLCBhdCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGVuZGluZ0FjdGlvbiksIHt9LCB7XG4gICAgICAgIGF0OiBhdFxuICAgICAgfSkgOiBudWxsKTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TWF0Y2hlcyhlLCBvcC5wYXRoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG4gICAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyBtYW51YWxseSBzZXQsIGRvbid0IHJlc3RvcmUgdGhlIHVzZXIgc2VsZWN0aW9uIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQy51bnJlZigpO1xuICAgICAgICAgIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTltcImRlbGV0ZVwiXShlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIF90b0NvbnN1bWFibGVBcnJheShnZXRNYXRjaGVzKGUsIHNsYXRlLlBhdGgucGFyZW50KG9wLnBhdGgpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IHNsYXRlLlBhdGgucHJldmlvdXMob3AucGF0aCk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIF90b0NvbnN1bWFibGVBcnJheShnZXRNYXRjaGVzKGUsIHByZXZQYXRoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBzbGF0ZS5QYXRoLmNvbW1vbihzbGF0ZS5QYXRoLnBhcmVudChvcC5wYXRoKSwgc2xhdGUuUGF0aC5wYXJlbnQob3AubmV3UGF0aCkpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TWF0Y2hlcyhlLCBjb21tb25QYXRoKSkpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkUGF0aDtcbiAgICAgICAgICBpZiAoc2xhdGUuUGF0aC5pc0JlZm9yZShvcC5wYXRoLCBvcC5uZXdQYXRoKSkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIF90b0NvbnN1bWFibGVBcnJheShnZXRNYXRjaGVzKGUsIHNsYXRlLlBhdGgucGFyZW50KG9wLnBhdGgpKSkpO1xuICAgICAgICAgICAgY2hhbmdlZFBhdGggPSBvcC5uZXdQYXRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2guYXBwbHkobWF0Y2hlcywgX3RvQ29uc3VtYWJsZUFycmF5KGdldE1hdGNoZXMoZSwgc2xhdGUuUGF0aC5wYXJlbnQob3AubmV3UGF0aCkpKSk7XG4gICAgICAgICAgICBjaGFuZ2VkUGF0aCA9IG9wLnBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgc2xhdGUuUGF0aC5wYXJlbnQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZE5vZGVLZXkgPSBET01FZGl0b3IuZmluZEtleShlLCBjaGFuZ2VkTm9kZSk7XG4gICAgICAgICAgdmFyIGNoYW5nZWRQYXRoUmVmID0gc2xhdGUuRWRpdG9yLnBhdGhSZWYoZSwgc2xhdGUuUGF0aC5wYXJlbnQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICBwYXRoUmVmTWF0Y2hlcy5wdXNoKFtjaGFuZ2VkUGF0aFJlZiwgY2hhbmdlZE5vZGVLZXldKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseShvcCk7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRklYTUU6IFJlbmFtZSB0byBzb21ldGhpbmcgbGlrZSBJU19ET01fRURJVE9SX0RFU1lOQ0VEXG4gICAgICAgICAgLy8gdG8gYmV0dGVyIHJlZmxlY3QgcmVhbGl0eSwgc2VlICM1NzkyXG4gICAgICAgICAgSVNfTk9ERV9NQVBfRElSVFkuc2V0KGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgX21hdGNoZXMgPSBtYXRjaGVzOyBfaSA8IF9tYXRjaGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9tYXRjaGVzJF9pID0gX3NsaWNlZFRvQXJyYXkoX21hdGNoZXNbX2ldLCAyKSxcbiAgICAgICAgcGF0aCA9IF9tYXRjaGVzJF9pWzBdLFxuICAgICAgICBrZXkgPSBfbWF0Y2hlcyRfaVsxXTtcbiAgICAgIHZhciBfRWRpdG9yJG5vZGUgPSBzbGF0ZS5FZGl0b3Iubm9kZShlLCBwYXRoKSxcbiAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pMiA9IDAsIF9wYXRoUmVmTWF0Y2hlcyA9IHBhdGhSZWZNYXRjaGVzOyBfaTIgPCBfcGF0aFJlZk1hdGNoZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9wYXRoUmVmTWF0Y2hlcyRfaSA9IF9zbGljZWRUb0FycmF5KF9wYXRoUmVmTWF0Y2hlc1tfaTJdLCAyKSxcbiAgICAgICAgcGF0aFJlZiA9IF9wYXRoUmVmTWF0Y2hlcyRfaVswXSxcbiAgICAgICAgX2tleSA9IF9wYXRoUmVmTWF0Y2hlcyRfaVsxXTtcbiAgICAgIGlmIChwYXRoUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZTMgPSBzbGF0ZS5FZGl0b3Iubm9kZShlLCBwYXRoUmVmLmN1cnJlbnQpLFxuICAgICAgICAgIF9FZGl0b3Ikbm9kZTQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUzLCAxKSxcbiAgICAgICAgICBfbm9kZSA9IF9FZGl0b3Ikbm9kZTRbMF07XG4gICAgICAgIE5PREVfVE9fS0VZLnNldChfbm9kZSwgX2tleSk7XG4gICAgICB9XG4gICAgICBwYXRoUmVmLnVucmVmKCk7XG4gICAgfVxuICB9O1xuICBlLnNldEZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGUuc2VsZWN0aW9uO1xuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBzbGF0ZS5SYW5nZS5lZGdlcyhzZWxlY3Rpb24pLFxuICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuICAgIHZhciBzdGFydFZvaWQgPSBzbGF0ZS5FZGl0b3JbXCJ2b2lkXCJdKGUsIHtcbiAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgfSk7XG4gICAgdmFyIGVuZFZvaWQgPSBzbGF0ZS5FZGl0b3JbXCJ2b2lkXCJdKGUsIHtcbiAgICAgIGF0OiBlbmQucGF0aFxuICAgIH0pO1xuICAgIGlmIChzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pICYmICFzdGFydFZvaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgZmFrZSBzZWxlY3Rpb24gc28gdGhhdCB3ZSBjYW4gYWRkIGEgQmFzZTY0LWVuY29kZWQgY29weSBvZiB0aGVcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgSFRNTCwgdG8gZGVjb2RlIG9uIGZ1dHVyZSBwYXN0ZXMuXG4gICAgdmFyIGRvbVJhbmdlID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBkb21SYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgdmFyIGF0dGFjaCA9IGNvbnRlbnRzLmNoaWxkTm9kZXNbMF07XG4gICAgLy8gTWFrZSBzdXJlIGF0dGFjaCBpcyBub24tZW1wdHksIHNpbmNlIGVtcHR5IG5vZGVzIHdpbGwgbm90IGdldCBjb3BpZWQuXG4gICAgY29udGVudHMuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgYXR0YWNoID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDT01QQVQ6IElmIHRoZSBlbmQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gcmFuZ2UgZnJvbSB0aGUgdm9pZCBub2RlJ3Mgc3BhY2VyIHNwYW4sIHRvIHRoZSBlbmQgb2YgdGhlIHZvaWQgbm9kZSdzXG4gICAgLy8gY29udGVudCwgc2luY2UgdGhlIHNwYWNlciBpcyBiZWZvcmUgdm9pZCdzIGNvbnRlbnQgaW4gdGhlIERPTS5cbiAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgdmFyIF9lbmRWb2lkID0gX3NsaWNlZFRvQXJyYXkoZW5kVm9pZCwgMSksXG4gICAgICAgIHZvaWROb2RlID0gX2VuZFZvaWRbMF07XG4gICAgICB2YXIgciA9IGRvbVJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHZhciBkb21Ob2RlID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlLCB2b2lkTm9kZSk7XG4gICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpO1xuICAgICAgY29udGVudHMgPSByLmNsb25lQ29udGVudHMoKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBJZiB0aGUgc3RhcnQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBhdHRhY2ggdGhlIGVuY29kZWRcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgdm9pZCBub2RlJ3MgY29udGVudCBub2RlIGluc3RlYWQgb2YgdGhlIHNwYWNlciwgYmVjYXVzZVxuICAgIC8vIGF0dGFjaGluZyBpdCB0byBlbXB0eSBgPGRpdj4vPHNwYW4+YCBub2RlcyB3aWxsIGVuZCB1cCBoYXZpbmcgaXQgZXJhc2VkIGJ5XG4gICAgLy8gbW9zdCBicm93c2Vycy4gKDIwMTgvMDQvMjcpXG4gICAgaWYgKHN0YXJ0Vm9pZCkge1xuICAgICAgYXR0YWNoID0gY29udGVudHMucXVlcnlTZWxlY3RvcignW2RhdGEtc2xhdGUtc3BhY2VyXScpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IHplcm8td2lkdGggc3BhY2Ugc3BhbnMgZnJvbSB0aGUgY2xvbmVkIERPTSBzbyB0aGF0IHRoZXkgZG9uJ3RcbiAgICAvLyBzaG93IHVwIGVsc2V3aGVyZSB3aGVuIHBhc3RlZC5cbiAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLmZvckVhY2goZnVuY3Rpb24gKHp3KSB7XG4gICAgICB2YXIgaXNOZXdsaW5lID0gencuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ24nO1xuICAgICAgencudGV4dENvbnRlbnQgPSBpc05ld2xpbmUgPyAnXFxuJyA6ICcnO1xuICAgIH0pO1xuICAgIC8vIFNldCBhIGBkYXRhLXNsYXRlLWZyYWdtZW50YCBhdHRyaWJ1dGUgb24gYSBub24tZW1wdHkgbm9kZSwgc28gaXQgc2hvd3MgdXBcbiAgICAvLyBpbiB0aGUgSFRNTCwgYW5kIGNhbiBiZSB1c2VkIGZvciBpbnRyYS1TbGF0ZSBwYXN0aW5nLiBJZiBpdCdzIGEgdGV4dFxuICAgIC8vIG5vZGUsIHdyYXAgaXQgaW4gYSBgPHNwYW4+YCBzbyB3ZSBoYXZlIHNvbWV0aGluZyB0byBzZXQgYW4gYXR0cmlidXRlIG9uLlxuICAgIGlmIChpc0RPTVRleHQoYXR0YWNoKSkge1xuICAgICAgdmFyIHNwYW4gPSBhdHRhY2gub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAvLyBDT01QQVQ6IEluIENocm9tZSBhbmQgU2FmYXJpLCBpZiB3ZSBkb24ndCBhZGQgdGhlIGB3aGl0ZS1zcGFjZWAgc3R5bGVcbiAgICAgIC8vIHRoZW4gbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzIHdpbGwgYmUgaWdub3JlZC4gKDIwMTcvMDkvMjEpXG4gICAgICBzcGFuLnN0eWxlLndoaXRlU3BhY2UgPSAncHJlJztcbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYXR0YWNoKTtcbiAgICAgIGNvbnRlbnRzLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgYXR0YWNoID0gc3BhbjtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50ID0gZS5nZXRGcmFnbWVudCgpO1xuICAgIHZhciBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShmcmFnbWVudCk7XG4gICAgdmFyIGVuY29kZWQgPSB3aW5kb3cuYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSk7XG4gICAgYXR0YWNoLnNldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1mcmFnbWVudCcsIGVuY29kZWQpO1xuICAgIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL1wiLmNvbmNhdChjbGlwYm9hcmRGb3JtYXRLZXkpLCBlbmNvZGVkKTtcbiAgICAvLyBBZGQgdGhlIGNvbnRlbnQgdG8gYSA8ZGl2PiBzbyB0aGF0IHdlIGNhbiBnZXQgaXRzIGlubmVyIEhUTUwuXG4gICAgdmFyIGRpdiA9IGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAndHJ1ZScpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgZGl2LmlubmVySFRNTCk7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgZ2V0UGxhaW5UZXh0KGRpdikpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICBlLmluc2VydERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghZS5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSkpIHtcbiAgICAgIGUuaW5zZXJ0VGV4dERhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuICBlLmluc2VydEZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tpbmcgY29waWVkIGZyYWdtZW50IGZyb20gYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCBvciBkYXRhLXNsYXRlLWZyYWdtZW50XG4gICAgICovXG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSkpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cuYXRvYihmcmFnbWVudCkpO1xuICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgICBlLmluc2VydEZyYWdtZW50KHBhcnNlZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBlLmluc2VydFRleHREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdGV4dCA9IGRhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobGluZXMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc3BsaXROb2RlcyhlLCB7XG4gICAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUuaW5zZXJ0VGV4dChsaW5lKTtcbiAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGUub25DaGFuZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBvbkNvbnRleHRDaGFuZ2UgPSBFRElUT1JfVE9fT05fQ0hBTkdFLmdldChlKTtcbiAgICBpZiAob25Db250ZXh0Q2hhbmdlKSB7XG4gICAgICBvbkNvbnRleHRDaGFuZ2Uob3B0aW9ucyk7XG4gICAgfVxuICAgIG9uQ2hhbmdlKG9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gZTtcbn07XG52YXIgZ2V0TWF0Y2hlcyA9IGZ1bmN0aW9uIGdldE1hdGNoZXMoZSwgcGF0aCkge1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNsYXRlLkVkaXRvci5sZXZlbHMoZSwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KSksXG4gICAgX3N0ZXAyO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgbiA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgcCA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgIHZhciBrZXkgPSBET01FZGl0b3IuZmluZEtleShlLCBuKTtcbiAgICAgIG1hdGNoZXMucHVzaChbcCwga2V5XSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbnZhciBUUklQTEVfQ0xJQ0sgPSAzO1xuXG4vKipcbiAqIEhvdGtleSBtYXBwaW5ncyBmb3IgZWFjaCBwbGF0Zm9ybS5cbiAqL1xudmFyIEhPVEtFWVMgPSB7XG4gIGJvbGQ6ICdtb2QrYicsXG4gIGNvbXBvc2U6IFsnZG93bicsICdsZWZ0JywgJ3JpZ2h0JywgJ3VwJywgJ2JhY2tzcGFjZScsICdlbnRlciddLFxuICBtb3ZlQmFja3dhcmQ6ICdsZWZ0JyxcbiAgbW92ZUZvcndhcmQ6ICdyaWdodCcsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdjdHJsK2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdjdHJsK3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6ICdzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlRm9yd2FyZDogJ3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRCYWNrd2FyZDogJ3NoaWZ0K2xlZnQnLFxuICBleHRlbmRGb3J3YXJkOiAnc2hpZnQrcmlnaHQnLFxuICBpdGFsaWM6ICdtb2QraScsXG4gIGluc2VydFNvZnRCcmVhazogJ3NoaWZ0K2VudGVyJyxcbiAgc3BsaXRCbG9jazogJ2VudGVyJyxcbiAgdW5kbzogJ21vZCt6J1xufTtcbnZhciBBUFBMRV9IT1RLRVlTID0ge1xuICBtb3ZlTGluZUJhY2t3YXJkOiAnb3B0K3VwJyxcbiAgbW92ZUxpbmVGb3J3YXJkOiAnb3B0K2Rvd24nLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnb3B0K2xlZnQnLFxuICBtb3ZlV29yZEZvcndhcmQ6ICdvcHQrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogWydjdHJsK2JhY2tzcGFjZScsICdjdHJsK2gnXSxcbiAgZGVsZXRlRm9yd2FyZDogWydjdHJsK2RlbGV0ZScsICdjdHJsK2QnXSxcbiAgZGVsZXRlTGluZUJhY2t3YXJkOiAnY21kK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVMaW5lRm9yd2FyZDogWydjbWQrc2hpZnQ/K2RlbGV0ZScsICdjdHJsK2snXSxcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnb3B0K3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ29wdCtzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kTGluZUJhY2t3YXJkOiAnb3B0K3NoaWZ0K3VwJyxcbiAgZXh0ZW5kTGluZUZvcndhcmQ6ICdvcHQrc2hpZnQrZG93bicsXG4gIHJlZG86ICdjbWQrc2hpZnQreicsXG4gIHRyYW5zcG9zZUNoYXJhY3RlcjogJ2N0cmwrdCdcbn07XG52YXIgV0lORE9XU19IT1RLRVlTID0ge1xuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdjdHJsK3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVXb3JkRm9yd2FyZDogJ2N0cmwrc2hpZnQ/K2RlbGV0ZScsXG4gIHJlZG86IFsnY3RybCt5JywgJ2N0cmwrc2hpZnQreiddXG59O1xuLyoqXG4gKiBDcmVhdGUgYSBwbGF0Zm9ybS1hd2FyZSBob3RrZXkgY2hlY2tlci5cbiAqL1xudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShrZXkpIHtcbiAgdmFyIGdlbmVyaWMgPSBIT1RLRVlTW2tleV07XG4gIHZhciBhcHBsZSA9IEFQUExFX0hPVEtFWVNba2V5XTtcbiAgdmFyIHdpbmRvd3MgPSBXSU5ET1dTX0hPVEtFWVNba2V5XTtcbiAgdmFyIGlzR2VuZXJpYyA9IGdlbmVyaWMgJiYgaXNIb3RrZXkuaXNIb3RrZXkoZ2VuZXJpYyk7XG4gIHZhciBpc0FwcGxlID0gYXBwbGUgJiYgaXNIb3RrZXkuaXNIb3RrZXkoYXBwbGUpO1xuICB2YXIgaXNXaW5kb3dzID0gd2luZG93cyAmJiBpc0hvdGtleS5pc0hvdGtleSh3aW5kb3dzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChpc0dlbmVyaWMgJiYgaXNHZW5lcmljKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKElTX0FQUExFICYmIGlzQXBwbGUgJiYgaXNBcHBsZShldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmICghSVNfQVBQTEUgJiYgaXNXaW5kb3dzICYmIGlzV2luZG93cyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn07XG4vKipcbiAqIEhvdGtleXMuXG4gKi9cbnZhciBob3RrZXlzID0ge1xuICBpc0JvbGQ6IGNyZWF0ZSgnYm9sZCcpLFxuICBpc0NvbXBvc2U6IGNyZWF0ZSgnY29tcG9zZScpLFxuICBpc01vdmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlQmFja3dhcmQnKSxcbiAgaXNNb3ZlRm9yd2FyZDogY3JlYXRlKCdtb3ZlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlRm9yd2FyZDogY3JlYXRlKCdkZWxldGVGb3J3YXJkJyksXG4gIGlzRGVsZXRlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUZvcndhcmQnKSxcbiAgaXNJdGFsaWM6IGNyZWF0ZSgnaXRhbGljJyksXG4gIGlzTW92ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlTGluZUJhY2t3YXJkJyksXG4gIGlzTW92ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVMaW5lRm9yd2FyZCcpLFxuICBpc01vdmVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRCYWNrd2FyZCcpLFxuICBpc01vdmVXb3JkRm9yd2FyZDogY3JlYXRlKCdtb3ZlV29yZEZvcndhcmQnKSxcbiAgaXNSZWRvOiBjcmVhdGUoJ3JlZG8nKSxcbiAgaXNTb2Z0QnJlYWs6IGNyZWF0ZSgnaW5zZXJ0U29mdEJyZWFrJyksXG4gIGlzU3BsaXRCbG9jazogY3JlYXRlKCdzcGxpdEJsb2NrJyksXG4gIGlzVHJhbnNwb3NlQ2hhcmFjdGVyOiBjcmVhdGUoJ3RyYW5zcG9zZUNoYXJhY3RlcicpLFxuICBpc1VuZG86IGNyZWF0ZSgndW5kbycpXG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gdW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllcyk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xudmFyIHNoYWxsb3dDb21wYXJlID0gZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUob2JqMSwgb2JqMikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGggJiYgT2JqZWN0LmtleXMob2JqMSkuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvYmoyLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqMVtrZXldID09PSBvYmoyW2tleV07XG4gIH0pO1xufTtcbnZhciBpc0RlY29yYXRpb25GbGFnc0VxdWFsID0gZnVuY3Rpb24gaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpIHtcbiAgcmFuZ2UuYW5jaG9yO1xuICAgIHJhbmdlLmZvY3VzO1xuICAgIHZhciByYW5nZU93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQpO1xuICBvdGhlci5hbmNob3I7XG4gICAgb3RoZXIuZm9jdXM7XG4gICAgdmFyIG90aGVyT3duUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3RoZXIsIF9leGNsdWRlZDIpO1xuICByZXR1cm4gcmFuZ2VbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gb3RoZXJbUExBQ0VIT0xERVJfU1lNQk9MXSAmJiBzaGFsbG93Q29tcGFyZShyYW5nZU93blByb3BzLCBvdGhlck93blByb3BzKTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiBkZWNvcmF0b3IgcmFuZ2VzIGFyZSBlcXVhbCB0byBhbm90aGVyLlxuICpcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcbiAqIHNhbWUgb3JkZXIsIGJ1dCB0aGlzIGlzIGFuIG9rYXkgY29uc3RyYWludCBmb3IgdXMgc2luY2UgZGVjb3JhdGlvbnMgYXJlXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cbiAqL1xudmFyIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwgPSBmdW5jdGlvbiBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsKGxpc3QsIGFub3RoZXIpIHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgIHZhciBvdGhlciA9IGFub3RoZXJbaV07XG4gICAgaWYgKCFzbGF0ZS5SYW5nZS5lcXVhbHMocmFuZ2UsIG90aGVyKSB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBsaXN0IG9mIGRlY29yYXRvciByYW5nZXMgYXJlIGVxdWFsIHRvIGFub3RoZXIuXG4gKlxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcbiAqIGtlcHQgaW4gb3JkZXIsIGFuZCB0aGUgb2RkIGNhc2Ugd2hlcmUgdGhleSBhcmVuJ3QgaXMgb2theSB0byByZS1yZW5kZXIgZm9yLlxuICovXG52YXIgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbCA9IGZ1bmN0aW9uIGlzVGV4dERlY29yYXRpb25zRXF1YWwobGlzdCwgYW5vdGhlcikge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcbiAgICAvLyBjb21wYXJlIG9ubHkgb2Zmc2V0cyBiZWNhdXNlIHBhdGhzIGRvZXNuJ3QgbWF0dGVyIGZvciB0ZXh0XG4gICAgaWYgKHJhbmdlLmFuY2hvci5vZmZzZXQgIT09IG90aGVyLmFuY2hvci5vZmZzZXQgfHwgcmFuZ2UuZm9jdXMub2Zmc2V0ICE9PSBvdGhlci5mb2N1cy5vZmZzZXQgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydHMuQ0FOX1VTRV9ET00gPSBDQU5fVVNFX0RPTTtcbmV4cG9ydHMuRE9NRWRpdG9yID0gRE9NRWRpdG9yO1xuZXhwb3J0cy5ET01FbGVtZW50ID0gRE9NRWxlbWVudDtcbmV4cG9ydHMuRE9NTm9kZSA9IERPTU5vZGU7XG5leHBvcnRzLkRPTVJhbmdlID0gRE9NUmFuZ2U7XG5leHBvcnRzLkRPTVNlbGVjdGlvbiA9IERPTVNlbGVjdGlvbjtcbmV4cG9ydHMuRE9NU3RhdGljUmFuZ2UgPSBET01TdGF0aWNSYW5nZTtcbmV4cG9ydHMuRE9NVGV4dCA9IERPTVRleHQ7XG5leHBvcnRzLkVESVRPUl9UT19FTEVNRU5UID0gRURJVE9SX1RPX0VMRU1FTlQ7XG5leHBvcnRzLkVESVRPUl9UT19GT1JDRV9SRU5ERVIgPSBFRElUT1JfVE9fRk9SQ0VfUkVOREVSO1xuZXhwb3J0cy5FRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQ7XG5leHBvcnRzLkVESVRPUl9UT19PTl9DSEFOR0UgPSBFRElUT1JfVE9fT05fQ0hBTkdFO1xuZXhwb3J0cy5FRElUT1JfVE9fUEVORElOR19BQ1RJT04gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT047XG5leHBvcnRzLkVESVRPUl9UT19QRU5ESU5HX0RJRkZTID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlM7XG5leHBvcnRzLkVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUyA9IEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUztcbmV4cG9ydHMuRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OO1xuZXhwb3J0cy5FRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCA9IEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5UO1xuZXhwb3J0cy5FRElUT1JfVE9fU0NIRURVTEVfRkxVU0ggPSBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0g7XG5leHBvcnRzLkVESVRPUl9UT19VU0VSX01BUktTID0gRURJVE9SX1RPX1VTRVJfTUFSS1M7XG5leHBvcnRzLkVESVRPUl9UT19VU0VSX1NFTEVDVElPTiA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTjtcbmV4cG9ydHMuRURJVE9SX1RPX1dJTkRPVyA9IEVESVRPUl9UT19XSU5ET1c7XG5leHBvcnRzLkVMRU1FTlRfVE9fTk9ERSA9IEVMRU1FTlRfVE9fTk9ERTtcbmV4cG9ydHMuSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUID0gSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUO1xuZXhwb3J0cy5Ib3RrZXlzID0gaG90a2V5cztcbmV4cG9ydHMuSVNfQU5EUk9JRCA9IElTX0FORFJPSUQ7XG5leHBvcnRzLklTX0NIUk9NRSA9IElTX0NIUk9NRTtcbmV4cG9ydHMuSVNfQ09NUE9TSU5HID0gSVNfQ09NUE9TSU5HO1xuZXhwb3J0cy5JU19GSVJFRk9YID0gSVNfRklSRUZPWDtcbmV4cG9ydHMuSVNfRklSRUZPWF9MRUdBQ1kgPSBJU19GSVJFRk9YX0xFR0FDWTtcbmV4cG9ydHMuSVNfRk9DVVNFRCA9IElTX0ZPQ1VTRUQ7XG5leHBvcnRzLklTX0lPUyA9IElTX0lPUztcbmV4cG9ydHMuSVNfTk9ERV9NQVBfRElSVFkgPSBJU19OT0RFX01BUF9ESVJUWTtcbmV4cG9ydHMuSVNfUkVBRF9PTkxZID0gSVNfUkVBRF9PTkxZO1xuZXhwb3J0cy5JU19VQ19NT0JJTEUgPSBJU19VQ19NT0JJTEU7XG5leHBvcnRzLklTX1dFQktJVCA9IElTX1dFQktJVDtcbmV4cG9ydHMuSVNfV0VDSEFUQlJPV1NFUiA9IElTX1dFQ0hBVEJST1dTRVI7XG5leHBvcnRzLktleSA9IEtleTtcbmV4cG9ydHMuTUFSS19QTEFDRUhPTERFUl9TWU1CT0wgPSBNQVJLX1BMQUNFSE9MREVSX1NZTUJPTDtcbmV4cG9ydHMuTk9ERV9UT19FTEVNRU5UID0gTk9ERV9UT19FTEVNRU5UO1xuZXhwb3J0cy5OT0RFX1RPX0lOREVYID0gTk9ERV9UT19JTkRFWDtcbmV4cG9ydHMuTk9ERV9UT19LRVkgPSBOT0RFX1RPX0tFWTtcbmV4cG9ydHMuTk9ERV9UT19QQVJFTlQgPSBOT0RFX1RPX1BBUkVOVDtcbmV4cG9ydHMuUExBQ0VIT0xERVJfU1lNQk9MID0gUExBQ0VIT0xERVJfU1lNQk9MO1xuZXhwb3J0cy5UUklQTEVfQ0xJQ0sgPSBUUklQTEVfQ0xJQ0s7XG5leHBvcnRzLmFwcGx5U3RyaW5nRGlmZiA9IGFwcGx5U3RyaW5nRGlmZjtcbmV4cG9ydHMuZ2V0QWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5leHBvcnRzLmdldERlZmF1bHRWaWV3ID0gZ2V0RGVmYXVsdFZpZXc7XG5leHBvcnRzLmdldFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbjtcbmV4cG9ydHMuaGFzU2hhZG93Um9vdCA9IGhhc1NoYWRvd1Jvb3Q7XG5leHBvcnRzLmlzQWZ0ZXIgPSBpc0FmdGVyO1xuZXhwb3J0cy5pc0JlZm9yZSA9IGlzQmVmb3JlO1xuZXhwb3J0cy5pc0RPTUVsZW1lbnQgPSBpc0RPTUVsZW1lbnQ7XG5leHBvcnRzLmlzRE9NTm9kZSA9IGlzRE9NTm9kZTtcbmV4cG9ydHMuaXNET01TZWxlY3Rpb24gPSBpc0RPTVNlbGVjdGlvbjtcbmV4cG9ydHMuaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbCA9IGlzRWxlbWVudERlY29yYXRpb25zRXF1YWw7XG5leHBvcnRzLmlzUGxhaW5UZXh0T25seVBhc3RlID0gaXNQbGFpblRleHRPbmx5UGFzdGU7XG5leHBvcnRzLmlzVGV4dERlY29yYXRpb25zRXF1YWwgPSBpc1RleHREZWNvcmF0aW9uc0VxdWFsO1xuZXhwb3J0cy5pc1RyYWNrZWRNdXRhdGlvbiA9IGlzVHJhY2tlZE11dGF0aW9uO1xuZXhwb3J0cy5tZXJnZVN0cmluZ0RpZmZzID0gbWVyZ2VTdHJpbmdEaWZmcztcbmV4cG9ydHMubm9ybWFsaXplRE9NUG9pbnQgPSBub3JtYWxpemVET01Qb2ludDtcbmV4cG9ydHMubm9ybWFsaXplUG9pbnQgPSBub3JtYWxpemVQb2ludDtcbmV4cG9ydHMubm9ybWFsaXplUmFuZ2UgPSBub3JtYWxpemVSYW5nZTtcbmV4cG9ydHMubm9ybWFsaXplU3RyaW5nRGlmZiA9IG5vcm1hbGl6ZVN0cmluZ0RpZmY7XG5leHBvcnRzLnRhcmdldFJhbmdlID0gdGFyZ2V0UmFuZ2U7XG5leHBvcnRzLnZlcmlmeURpZmZTdGF0ZSA9IHZlcmlmeURpZmZTdGF0ZTtcbmV4cG9ydHMud2l0aERPTSA9IHdpdGhET007XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/slate-dom@0.112.2_slate@0.112.0/node_modules/slate-dom/dist/index.js\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/slate-dom@0.112.2_slate@0.112.0/node_modules/slate-dom/dist/index.js":
/*!***********************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/slate-dom@0.112.2_slate@0.112.0/node_modules/slate-dom/dist/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar slate = __webpack_require__(/*! slate */ \"../../../../node_modules/.pnpm/slate@0.112.0/node_modules/slate/dist/index.js\");\nvar isHotkey = __webpack_require__(/*! is-hotkey */ \"../../../../node_modules/.pnpm/is-hotkey@0.2.0/node_modules/is-hotkey/lib/index.js\");\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar arrayLikeToArray = createCommonjsModule(function (module) {\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayLikeToArray);\n\nvar arrayWithoutHoles = createCommonjsModule(function (module) {\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithoutHoles);\n\nvar iterableToArray = createCommonjsModule(function (module) {\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArray);\n\nvar unsupportedIterableToArray = createCommonjsModule(function (module) {\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(unsupportedIterableToArray);\n\nvar nonIterableSpread = createCommonjsModule(function (module) {\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableSpread);\n\nvar toConsumableArray = createCommonjsModule(function (module) {\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nvar arrayWithHoles = createCommonjsModule(function (module) {\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(arrayWithHoles);\n\nvar iterableToArrayLimit = createCommonjsModule(function (module) {\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(iterableToArrayLimit);\n\nvar nonIterableRest = createCommonjsModule(function (module) {\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(nonIterableRest);\n\nvar slicedToArray = createCommonjsModule(function (module) {\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Types.\n */\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */\nvar getDefaultView = function getDefaultView(value) {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */\nvar isDOMComment = function isDOMComment(value) {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMElement = function isDOMElement(value) {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */\nvar isDOMNode = function isDOMNode(value) {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */\nvar isDOMSelection = function isDOMSelection(value) {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMText = function isDOMText(value) {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\nvar isPlainTextOnlyPaste = function isPlainTextOnlyPaste(event) {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\nvar normalizeDOMPoint = function normalizeDOMPoint(domPoint) {\n  var _domPoint = _slicedToArray(domPoint, 2),\n    node = _domPoint[0],\n    offset = _domPoint[1];\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    // If the editable child found is in front of input offset, we instead seek to its end\n    var _getEditableChildAndI = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    var _getEditableChildAndI2 = _slicedToArray(_getEditableChildAndI, 2);\n    node = _getEditableChildAndI2[0];\n    index = _getEditableChildAndI2[1];\n    isLast = index < offset;\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    }\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  // Return the node and offset.\n  return [node, offset];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\nvar hasShadowRoot = function hasShadowRoot(node) {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChildAndIndex = function getEditableChildAndIndex(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChild = function getEditableChild(parent, index, direction) {\n  var _getEditableChildAndI3 = getEditableChildAndIndex(parent, index, direction),\n    _getEditableChildAndI4 = _slicedToArray(_getEditableChildAndI3, 1),\n    child = _getEditableChildAndI4[0];\n  return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\nvar getPlainText = function getPlainText(domNode) {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var _i = 0, _Array$from = Array.from(domNode.childNodes); _i < _Array$from.length; _i++) {\n      var childNode = _Array$from[_i];\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = function getSlateFragmentAttribute(dataTransfer) {\n  var htmlData = dataTransfer.getData('text/html');\n  var _ref = htmlData.match(catchSlateFragment) || [],\n    _ref2 = _slicedToArray(_ref, 2),\n    fragment = _ref2[1];\n  return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nvar getSelection = function getSelection(root) {\n  if (root.getSelection != null) {\n    return root.getSelection();\n  }\n  return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\nvar isTrackedMutation = function isTrackedMutation(editor, mutation, batch) {\n  var target = mutation.target;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var _DOMEditor$getWindow = DOMEditor.getWindow(editor),\n    document = _DOMEditor$getWindow.document;\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(function (_ref3) {\n    var addedNodes = _ref3.addedNodes,\n      removedNodes = _ref3.removedNodes;\n    var _iterator = _createForOfIteratorHelper$1(addedNodes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var node = _step.value;\n        if (node === target || node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper$1(removedNodes),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _node = _step2.value;\n        if (_node === target || _node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nvar getActiveElement = function getActiveElement() {\n  var activeElement = document.activeElement;\n  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {\n    var _activeElement, _activeElement$shadow, _activeElement2;\n    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n  }\n  return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nvar isBefore = function isBefore(node, otherNode) {\n  return Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n};\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nvar isAfter = function isAfter(node, otherNode) {\n  return Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\n};\n\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n// Check if the browser is Safari and older than 17\ntypeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nvar _typeof_1 = createCommonjsModule(function (module) {\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(_typeof_1);\n\nvar toPrimitive = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPrimitive);\n\nvar toPropertyKey = createCommonjsModule(function (module) {\nvar _typeof = _typeof_1[\"default\"];\n\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(toPropertyKey);\n\nvar createClass = createCommonjsModule(function (module) {\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _createClass = unwrapExports(createClass);\n\nvar classCallCheck = createCommonjsModule(function (module) {\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _classCallCheck = unwrapExports(classCallCheck);\n\nvar defineProperty = createCommonjsModule(function (module) {\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _defineProperty = unwrapExports(defineProperty);\n\n/**\n * An auto-incrementing identifier for keys.\n */\nvar n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\nvar Key = /*#__PURE__*/_createClass(function Key() {\n  _classCallCheck(this, Key);\n  _defineProperty(this, \"id\", void 0);\n  this.id = \"\".concat(n++);\n});\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nvar IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n  androidPendingDiffs: function androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  },\n  androidScheduleFlush: function androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: function blur(editor) {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      slate.Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: function findDocumentOrShadowRoot(editor) {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  findEventRange: function findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var _event = event,\n      x = _event.clientX,\n      y = _event.clientY,\n      target = _event.target;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = DOMEditor.toSlateNode(editor, event.target);\n    var path = DOMEditor.findPath(editor, node);\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (slate.Element.isElement(node) && slate.Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = slate.Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? slate.Editor.before(editor, edge) : slate.Editor.after(editor, edge);\n      if (point) {\n        var _range = slate.Editor.range(editor, point);\n        return _range;\n      }\n    }\n    // Else resolve a range from the caret position where the drop occured.\n    var domRange;\n    var _DOMEditor$getWindow = DOMEditor.getWindow(editor),\n      document = _DOMEditor$getWindow.document;\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    // Resolve a Slate range from the DOM range.\n    var range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: function findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  findPath: function findPath(editor, node) {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (slate.Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(slate.Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      retries: 5\n    };\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return;\n    }\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error('Could not set focus, editor seems stuck with pending operations');\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(function () {\n        DOMEditor.focus(editor, {\n          retries: options.retries - 1\n        });\n      }, 10);\n      return;\n    }\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        var domSelection = getSelection(root);\n        var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        slate.Transforms.select(editor, slate.Editor.start(editor, []));\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true);\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: function getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$editable = options.editable,\n      editable = _options$editable === void 0 ? false : _options$editable;\n    var editorEl = DOMEditor.toDOMNode(editor, editor);\n    var targetEl;\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: function hasEditableTarget(editor, target) {\n    return isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  },\n  hasRange: function hasRange(editor, range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    return slate.Editor.hasPath(editor, anchor.path) && slate.Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: function hasSelectableTarget(editor, target) {\n    return DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target);\n  },\n  hasTarget: function hasTarget(editor, target) {\n    return isDOMNode(target) && DOMEditor.hasDOMNode(editor, target);\n  },\n  insertData: function insertData(editor, data) {\n    editor.insertData(data);\n  },\n  insertFragmentData: function insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n  insertTextData: function insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n  isComposing: function isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: function isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n  isReadOnly: function isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n  isTargetInsideNonReadonlyVoid: function isTargetInsideNonReadonlyVoid(editor, target) {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n    return slate.Element.isElement(slateNode) && slate.Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: function setFragmentData(editor, data, originEvent) {\n    return editor.setFragmentData(data, originEvent);\n  },\n  toDOMNode: function toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = slate.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate.Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  toDOMPoint: function toDOMPoint(editor, point) {\n    var _Editor$node = slate.Editor.node(editor, point.path),\n      _Editor$node2 = _slicedToArray(_Editor$node, 1),\n      node = _Editor$node2[0];\n    var el = DOMEditor.toDOMNode(editor, node);\n    var domPoint;\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (slate.Editor[\"void\"](editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var length = domNode.textContent.length;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate.Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  toDOMRange: function toDOMRange(editor, range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    var isBackward = slate.Range.isBackward(range);\n    var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n    var domFocus = slate.Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n    var window = DOMEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var _ref = isBackward ? domFocus : domAnchor,\n      _ref2 = _slicedToArray(_ref, 2),\n      startNode = _ref2[0],\n      startOffset = _ref2[1];\n    var _ref3 = isBackward ? domAnchor : domFocus,\n      _ref4 = _slicedToArray(_ref3, 2),\n      endNode = _ref4[0],\n      endOffset = _ref4[1];\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: function toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  toSlatePoint: function toSlatePoint(editor, domPoint, options) {\n    var exactMatch = options.exactMatch,\n      suppressThrow = options.suppressThrow,\n      _options$searchDirect = options.searchDirection,\n      searchDirection = _options$searchDirect === void 0 ? 'backward' : _options$searchDirect;\n    var _ref5 = exactMatch ? domPoint : normalizeDOMPoint(domPoint),\n      _ref6 = _slicedToArray(_ref5, 2),\n      nearestNode = _ref6[0],\n      nearestOffset = _ref6[1];\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = DOMEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null;\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = DOMEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [].concat(_toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]'))), _toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))));\n          removals.forEach(function (el) {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n              if (el.textContent.startsWith(\"\\uFEFF\")) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(function (el) {\n            offset -= el.textContent.length;\n          });\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        var getLeafNodes = function getLeafNodes(node) {\n          return node ? node.querySelectorAll(\n          // Exclude leaf nodes in nested editors\n          '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];\n        };\n        var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n        if (searchDirection === 'forward') {\n          var _leafNodes$find;\n          var _leafNodes = [].concat(_toConsumableArray(getLeafNodes(elementNode)), _toConsumableArray(getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)));\n          leafNode = (_leafNodes$find = _leafNodes.find(function (leaf) {\n            return isAfter(nonEditableNode, leaf);\n          })) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n        } else {\n          var _leafNodes2$findLast;\n          var _leafNodes2 = [].concat(_toConsumableArray(getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling)), _toConsumableArray(getLeafNodes(elementNode)));\n          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast(function (leaf) {\n            return isBefore(nonEditableNode, leaf);\n          })) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n        }\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          if (searchDirection === 'forward') {\n            offset = 0;\n          } else {\n            offset = domNode.textContent.length;\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(function (el) {\n              offset -= el.textContent.length;\n            });\n          }\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      parentNode.hasAttribute('data-slate-zero-width') ||\n      // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n      // when the document ends with a new-line character. This results in the offset\n      // length being off by one, so we need to subtract one to account for this.\n      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && DOMEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = DOMEditor.toSlateNode(editor, node);\n        var _Editor$start = slate.Editor.start(editor, DOMEditor.findPath(editor, _slateNode)),\n          _path = _Editor$start.path,\n          _offset = _Editor$start.offset;\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    var slateNode = DOMEditor.toSlateNode(editor, textNode);\n    var path = DOMEditor.findPath(editor, slateNode);\n    return {\n      path: path,\n      offset: offset\n    };\n  },\n  toSlateRange: function toSlateRange(editor, domRange, options) {\n    var _focusNode$textConten;\n    var exactMatch = options.exactMatch,\n      suppressThrow = options.suppressThrow;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n          // Here we are in the contenteditable mode of a table in firefox\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            var getLastChildren = function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            };\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer;\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0;\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        }\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\\n\\n') && focusOffset === focusNode.textContent.length) {\n      focusOffset--;\n    }\n    var anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n    var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow,\n      searchDirection: focusBeforeAnchor ? 'forward' : 'backward'\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (slate.Range.isExpanded(range) && slate.Range.isForward(range) && isDOMElement(focusNode) && slate.Editor[\"void\"](editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = slate.Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  }\n};\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nfunction verifyDiffState(editor, textDiff) {\n  var path = textDiff.path,\n    diff = textDiff.diff;\n  if (!slate.Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = slate.Node.get(editor, path);\n  if (!slate.Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = slate.Path.next(path);\n  if (!slate.Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = slate.Node.get(editor, nextPath);\n  return slate.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce(function (text, diff) {\n    return text.slice(0, diff.start) + diff.text + text.slice(diff.end);\n  }, text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nfunction normalizeStringDiff(targetText, diff) {\n  var start = diff.start,\n    end = diff.end,\n    text = diff.text;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start: start,\n    end: end,\n    text: text\n  });\n}\n/**\n * Get the slate range the text diff spans.\n */\nfunction targetRange(textDiff) {\n  var path = textDiff.path,\n    diff = textDiff.diff;\n  return {\n    anchor: {\n      path: path,\n      offset: diff.start\n    },\n    focus: {\n      path: path,\n      offset: diff.end\n    }\n  };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nfunction normalizePoint(editor, point) {\n  var path = point.path,\n    offset = point.offset;\n  if (!slate.Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = slate.Node.get(editor, path);\n  if (!slate.Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = slate.Editor.above(editor, {\n    match: function match(n) {\n      return slate.Element.isElement(n) && slate.Editor.isBlock(editor, n);\n    },\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = slate.Editor.next(editor, {\n      at: path,\n      match: slate.Text.isText\n    });\n    if (!entry || !slate.Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path: path,\n    offset: offset\n  };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (slate.Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(function (_ref) {\n    var path = _ref.path;\n    return slate.Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return slate.Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var diff = textDiff.diff;\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = slate.Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  // Point references location after the diff\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = slate.Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && slate.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (slate.Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var path = textDiff.path,\n    diff = textDiff.diff,\n    id = textDiff.id;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!slate.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!slate.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n    case 'split_node':\n      {\n        if (!slate.Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff: diff,\n            id: id,\n            path: slate.Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id: id,\n          path: slate.Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!slate.Path.equals(op.path, path)) {\n          return {\n            diff: diff,\n            id: id,\n            path: slate.Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id: id,\n          path: slate.Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = slate.Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff: diff,\n    path: newPath,\n    id: id\n  };\n}\n\n/**\n * Utilities for single-line deletion\n */\nvar doRectsIntersect = function doRectsIntersect(rect, compareRect) {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = function areRangesSameLine(editor, range1, range2) {\n  var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nvar findCurrentLineRange = function findCurrentLineRange(editor, parentRange) {\n  var parentRangeBoundary = slate.Editor.range(editor, slate.Range.end(parentRange));\n  var positions = Array.from(slate.Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, slate.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return slate.Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return slate.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, slate.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return slate.Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withDOM = function withDOM(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var apply = e.apply,\n    onChange = e.onChange,\n    deleteBackward = e.deleteBackward,\n    addMark = e.addMark,\n    removeMark = e.removeMark;\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = function (key, value) {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS[\"delete\"](e);\n    addMark(key, value);\n  };\n  e.removeMark = function (key) {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS[\"delete\"](e);\n    removeMark(key);\n  };\n  e.deleteBackward = function (unit) {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && slate.Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = slate.Editor.above(e, {\n        match: function match(n) {\n          return slate.Element.isElement(n) && slate.Editor.isBlock(e, n);\n        },\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var _parentBlockEntry = _slicedToArray(parentBlockEntry, 2),\n          parentBlockPath = _parentBlockEntry[1];\n        var parentElementRange = slate.Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!slate.Range.isCollapsed(currentLineRange)) {\n          slate.Transforms[\"delete\"](e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = function (op) {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(function (textDiff) {\n        return transformTextDiff(textDiff, op);\n      }).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = slate.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at: at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, op.path)));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION[\"delete\"](e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, slate.Path.parent(op.path))));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = slate.Path.previous(op.path);\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, prevPath)));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = slate.Path.common(slate.Path.parent(op.path), slate.Path.parent(op.newPath));\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, commonPath)));\n          var changedPath;\n          if (slate.Path.isBefore(op.path, op.newPath)) {\n            matches.push.apply(matches, _toConsumableArray(getMatches(e, slate.Path.parent(op.path))));\n            changedPath = op.newPath;\n          } else {\n            matches.push.apply(matches, _toConsumableArray(getMatches(e, slate.Path.parent(op.newPath))));\n            changedPath = op.path;\n          }\n          var changedNode = slate.Node.get(editor, slate.Path.parent(changedPath));\n          var changedNodeKey = DOMEditor.findKey(e, changedNode);\n          var changedPathRef = slate.Editor.pathRef(e, slate.Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n    apply(op);\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node':\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_selection':\n        {\n          // FIXME: Rename to something like IS_DOM_EDITOR_DESYNCED\n          // to better reflect reality, see #5792\n          IS_NODE_MAP_DIRTY.set(e, true);\n        }\n    }\n    for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n      var _matches$_i = _slicedToArray(_matches[_i], 2),\n        path = _matches$_i[0],\n        key = _matches$_i[1];\n      var _Editor$node = slate.Editor.node(e, path),\n        _Editor$node2 = _slicedToArray(_Editor$node, 1),\n        node = _Editor$node2[0];\n      NODE_TO_KEY.set(node, key);\n    }\n    for (var _i2 = 0, _pathRefMatches = pathRefMatches; _i2 < _pathRefMatches.length; _i2++) {\n      var _pathRefMatches$_i = _slicedToArray(_pathRefMatches[_i2], 2),\n        pathRef = _pathRefMatches$_i[0],\n        _key = _pathRefMatches$_i[1];\n      if (pathRef.current) {\n        var _Editor$node3 = slate.Editor.node(e, pathRef.current),\n          _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n          _node = _Editor$node4[0];\n        NODE_TO_KEY.set(_node, _key);\n      }\n      pathRef.unref();\n    }\n  };\n  e.setFragmentData = function (data) {\n    var selection = e.selection;\n    if (!selection) {\n      return;\n    }\n    var _Range$edges = slate.Range.edges(selection),\n      _Range$edges2 = _slicedToArray(_Range$edges, 2),\n      start = _Range$edges2[0],\n      end = _Range$edges2[1];\n    var startVoid = slate.Editor[\"void\"](e, {\n      at: start.path\n    });\n    var endVoid = slate.Editor[\"void\"](e, {\n      at: end.path\n    });\n    if (slate.Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    var domRange = DOMEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(function (node) {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    });\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      var _endVoid = _slicedToArray(endVoid, 1),\n        voidNode = _endVoid[0];\n      var r = domRange.cloneRange();\n      var domNode = DOMEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    }\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    }\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(function (zw) {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    });\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span');\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n    // Add the content to a <div> so that we can get its inner HTML.\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = function (data) {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = function (data) {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = function (data) {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      var _iterator = _createForOfIteratorHelper(lines),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          if (split) {\n            slate.Transforms.splitNodes(e, {\n              always: true\n            });\n          }\n          e.insertText(line);\n          split = true;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = function (options) {\n    var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n    if (onContextChange) {\n      onContextChange(options);\n    }\n    onChange(options);\n  };\n  return e;\n};\nvar getMatches = function getMatches(e, path) {\n  var matches = [];\n  var _iterator2 = _createForOfIteratorHelper(slate.Editor.levels(e, {\n      at: path\n    })),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        n = _step2$value[0],\n        p = _step2$value[1];\n      var key = DOMEditor.findKey(e, n);\n      matches.push([p, key]);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return matches;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\n * Hotkey mappings for each platform.\n */\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\n * Create a platform-aware hotkey checker.\n */\nvar create = function create(key) {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isHotkey.isHotkey(generic);\n  var isApple = apple && isHotkey.isHotkey(apple);\n  var isWindows = windows && isHotkey.isHotkey(windows);\n  return function (event) {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\n * Hotkeys.\n */\nvar hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nvar objectWithoutPropertiesLoose = createCommonjsModule(function (module) {\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nunwrapExports(objectWithoutPropertiesLoose);\n\nvar objectWithoutProperties = createCommonjsModule(function (module) {\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\nvar _excluded = [\"anchor\", \"focus\"],\n  _excluded2 = [\"anchor\", \"focus\"];\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\nvar isDecorationFlagsEqual = function isDecorationFlagsEqual(range, other) {\n  range.anchor;\n    range.focus;\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n  other.anchor;\n    other.focus;\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isElementDecorationsEqual = function isElementDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!slate.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isTextDecorationsEqual = function isTextDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    // compare only offsets because paths doesn't matter for text\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.CAN_USE_DOM = CAN_USE_DOM;\nexports.DOMEditor = DOMEditor;\nexports.DOMElement = DOMElement;\nexports.DOMNode = DOMNode;\nexports.DOMRange = DOMRange;\nexports.DOMSelection = DOMSelection;\nexports.DOMStaticRange = DOMStaticRange;\nexports.DOMText = DOMText;\nexports.EDITOR_TO_ELEMENT = EDITOR_TO_ELEMENT;\nexports.EDITOR_TO_FORCE_RENDER = EDITOR_TO_FORCE_RENDER;\nexports.EDITOR_TO_KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT;\nexports.EDITOR_TO_ON_CHANGE = EDITOR_TO_ON_CHANGE;\nexports.EDITOR_TO_PENDING_ACTION = EDITOR_TO_PENDING_ACTION;\nexports.EDITOR_TO_PENDING_DIFFS = EDITOR_TO_PENDING_DIFFS;\nexports.EDITOR_TO_PENDING_INSERTION_MARKS = EDITOR_TO_PENDING_INSERTION_MARKS;\nexports.EDITOR_TO_PENDING_SELECTION = EDITOR_TO_PENDING_SELECTION;\nexports.EDITOR_TO_PLACEHOLDER_ELEMENT = EDITOR_TO_PLACEHOLDER_ELEMENT;\nexports.EDITOR_TO_SCHEDULE_FLUSH = EDITOR_TO_SCHEDULE_FLUSH;\nexports.EDITOR_TO_USER_MARKS = EDITOR_TO_USER_MARKS;\nexports.EDITOR_TO_USER_SELECTION = EDITOR_TO_USER_SELECTION;\nexports.EDITOR_TO_WINDOW = EDITOR_TO_WINDOW;\nexports.ELEMENT_TO_NODE = ELEMENT_TO_NODE;\nexports.HAS_BEFORE_INPUT_SUPPORT = HAS_BEFORE_INPUT_SUPPORT;\nexports.Hotkeys = hotkeys;\nexports.IS_ANDROID = IS_ANDROID;\nexports.IS_CHROME = IS_CHROME;\nexports.IS_COMPOSING = IS_COMPOSING;\nexports.IS_FIREFOX = IS_FIREFOX;\nexports.IS_FIREFOX_LEGACY = IS_FIREFOX_LEGACY;\nexports.IS_FOCUSED = IS_FOCUSED;\nexports.IS_IOS = IS_IOS;\nexports.IS_NODE_MAP_DIRTY = IS_NODE_MAP_DIRTY;\nexports.IS_READ_ONLY = IS_READ_ONLY;\nexports.IS_UC_MOBILE = IS_UC_MOBILE;\nexports.IS_WEBKIT = IS_WEBKIT;\nexports.IS_WECHATBROWSER = IS_WECHATBROWSER;\nexports.Key = Key;\nexports.MARK_PLACEHOLDER_SYMBOL = MARK_PLACEHOLDER_SYMBOL;\nexports.NODE_TO_ELEMENT = NODE_TO_ELEMENT;\nexports.NODE_TO_INDEX = NODE_TO_INDEX;\nexports.NODE_TO_KEY = NODE_TO_KEY;\nexports.NODE_TO_PARENT = NODE_TO_PARENT;\nexports.PLACEHOLDER_SYMBOL = PLACEHOLDER_SYMBOL;\nexports.TRIPLE_CLICK = TRIPLE_CLICK;\nexports.applyStringDiff = applyStringDiff;\nexports.getActiveElement = getActiveElement;\nexports.getDefaultView = getDefaultView;\nexports.getSelection = getSelection;\nexports.hasShadowRoot = hasShadowRoot;\nexports.isAfter = isAfter;\nexports.isBefore = isBefore;\nexports.isDOMElement = isDOMElement;\nexports.isDOMNode = isDOMNode;\nexports.isDOMSelection = isDOMSelection;\nexports.isElementDecorationsEqual = isElementDecorationsEqual;\nexports.isPlainTextOnlyPaste = isPlainTextOnlyPaste;\nexports.isTextDecorationsEqual = isTextDecorationsEqual;\nexports.isTrackedMutation = isTrackedMutation;\nexports.mergeStringDiffs = mergeStringDiffs;\nexports.normalizeDOMPoint = normalizeDOMPoint;\nexports.normalizePoint = normalizePoint;\nexports.normalizeRange = normalizeRange;\nexports.normalizeStringDiff = normalizeStringDiff;\nexports.targetRange = targetRange;\nexports.verifyDiffState = verifyDiffState;\nexports.withDOM = withDOM;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NsYXRlLWRvbUAwLjExMi4yX3NsYXRlQDAuMTEyLjAvbm9kZV9tb2R1bGVzL3NsYXRlLWRvbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyw0RkFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMscUdBQVc7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSxrRUFBa0U7QUFDdEYsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLDJEQUEyRCxpRkFBaUYsV0FBVywwSEFBMEgsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVO0FBQ2o5QixvREFBb0QsZ0JBQWdCLGtFQUFrRSx3REFBd0QsNkRBQTZELHNEQUFzRDtBQUNqVCx5Q0FBeUMsdURBQXVELHVDQUF1QyxTQUFTLHVCQUF1QjtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHlCQUF5QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7QUFDNzhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEO0FBQzdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsdUJBQXVCO0FBQ3JLLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsb0JBQW9CO0FBQzdGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixlQUFlO0FBQ2YseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IseUNBQXlDO0FBQ3pDLG1DQUFtQztBQUNuQyxxQ0FBcUM7QUFDckMsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QixnQ0FBZ0M7QUFDaEMsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCx5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIsd0JBQXdCO0FBQ3hCLFdBQVc7QUFDWCwrQkFBK0I7QUFDL0IsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9zbGF0ZS1kb21AMC4xMTIuMl9zbGF0ZUAwLjExMi4wL25vZGVfbW9kdWxlcy9zbGF0ZS1kb20vZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzbGF0ZSA9IHJlcXVpcmUoJ3NsYXRlJyk7XG52YXIgaXNIb3RrZXkgPSByZXF1aXJlKCdpcy1ob3RrZXknKTtcblxuZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5TGlrZVRvQXJyYXkpO1xuXG52YXIgYXJyYXlXaXRob3V0SG9sZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlXaXRob3V0SG9sZXMpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhpdGVyYWJsZVRvQXJyYXkpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhub25JdGVyYWJsZVNwcmVhZCk7XG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5ID0gdW53cmFwRXhwb3J0cyh0b0NvbnN1bWFibGVBcnJheSk7XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhpdGVyYWJsZVRvQXJyYXlMaW1pdCk7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyhub25JdGVyYWJsZVJlc3QpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gdW53cmFwRXhwb3J0cyhzbGljZWRUb0FycmF5KTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQxKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIFR5cGVzLlxuICovXG4vLyBDT01QQVQ6IFRoaXMgaXMgcmVxdWlyZWQgdG8gcHJldmVudCBUeXBlU2NyaXB0IGFsaWFzZXMgZnJvbSBkb2luZyBzb21lIHZlcnlcbi8vIHdlaXJkIHRoaW5ncyBmb3IgU2xhdGUncyB0eXBlcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgZ2xvYmFscy4gKDIwMTkvMTEvMjcpXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM1MDAyXG52YXIgRE9NTm9kZSA9IGdsb2JhbFRoaXMuTm9kZTtcbnZhciBET01FbGVtZW50ID0gZ2xvYmFsVGhpcy5FbGVtZW50O1xudmFyIERPTVRleHQgPSBnbG9iYWxUaGlzLlRleHQ7XG52YXIgRE9NUmFuZ2UgPSBnbG9iYWxUaGlzLlJhbmdlO1xudmFyIERPTVNlbGVjdGlvbiA9IGdsb2JhbFRoaXMuU2VsZWN0aW9uO1xudmFyIERPTVN0YXRpY1JhbmdlID0gZ2xvYmFsVGhpcy5TdGF0aWNSYW5nZTtcbi8qKlxuICogUmV0dXJucyB0aGUgaG9zdCB3aW5kb3cgb2YgYSBET00gbm9kZVxuICovXG52YXIgZ2V0RGVmYXVsdFZpZXcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Vmlldyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUub3duZXJEb2N1bWVudCAmJiB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG51bGw7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGEgY29tbWVudCBub2RlLlxuICovXG52YXIgaXNET01Db21tZW50ID0gZnVuY3Rpb24gaXNET01Db21tZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSA4O1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXG4gKi9cbnZhciBpc0RPTUVsZW1lbnQgPSBmdW5jdGlvbiBpc0RPTUVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIG5vZGUuXG4gKi9cbnZhciBpc0RPTU5vZGUgPSBmdW5jdGlvbiBpc0RPTU5vZGUodmFsdWUpIHtcbiAgdmFyIHdpbmRvdyA9IGdldERlZmF1bHRWaWV3KHZhbHVlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93Lk5vZGU7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIHNlbGVjdGlvbi5cbiAqL1xudmFyIGlzRE9NU2VsZWN0aW9uID0gZnVuY3Rpb24gaXNET01TZWxlY3Rpb24odmFsdWUpIHtcbiAgdmFyIHdpbmRvdyA9IHZhbHVlICYmIHZhbHVlLmFuY2hvck5vZGUgJiYgZ2V0RGVmYXVsdFZpZXcodmFsdWUuYW5jaG9yTm9kZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5TZWxlY3Rpb247XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIGVsZW1lbnQgbm9kZS5cbiAqL1xudmFyIGlzRE9NVGV4dCA9IGZ1bmN0aW9uIGlzRE9NVGV4dCh2YWx1ZSkge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcGFzdGUgZXZlbnQgaXMgYSBwbGFpbnRleHQtb25seSBldmVudC5cbiAqL1xudmFyIGlzUGxhaW5UZXh0T25seVBhc3RlID0gZnVuY3Rpb24gaXNQbGFpblRleHRPbmx5UGFzdGUoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmNsaXBib2FyZERhdGEgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJykgIT09ICcnICYmIGV2ZW50LmNsaXBib2FyZERhdGEudHlwZXMubGVuZ3RoID09PSAxO1xufTtcbi8qKlxuICogTm9ybWFsaXplIGEgRE9NIHBvaW50IHNvIHRoYXQgaXQgYWx3YXlzIHJlZmVycyB0byBhIHRleHQgbm9kZS5cbiAqL1xudmFyIG5vcm1hbGl6ZURPTVBvaW50ID0gZnVuY3Rpb24gbm9ybWFsaXplRE9NUG9pbnQoZG9tUG9pbnQpIHtcbiAgdmFyIF9kb21Qb2ludCA9IF9zbGljZWRUb0FycmF5KGRvbVBvaW50LCAyKSxcbiAgICBub2RlID0gX2RvbVBvaW50WzBdLFxuICAgIG9mZnNldCA9IF9kb21Qb2ludFsxXTtcbiAgLy8gSWYgaXQncyBhbiBlbGVtZW50IG5vZGUsIGl0cyBvZmZzZXQgcmVmZXJzIHRvIHRoZSBpbmRleCBvZiBpdHMgY2hpbGRyZW5cbiAgLy8gaW5jbHVkaW5nIGNvbW1lbnQgbm9kZXMsIHNvIHRyeSB0byBmaW5kIHRoZSByaWdodCB0ZXh0IGNoaWxkIG5vZGUuXG4gIGlmIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBpc0xhc3QgPSBvZmZzZXQgPT09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gaXNMYXN0ID8gb2Zmc2V0IC0gMSA6IG9mZnNldDtcbiAgICAvLyBJZiB0aGUgZWRpdGFibGUgY2hpbGQgZm91bmQgaXMgaW4gZnJvbnQgb2YgaW5wdXQgb2Zmc2V0LCB3ZSBpbnN0ZWFkIHNlZWsgdG8gaXRzIGVuZFxuICAgIHZhciBfZ2V0RWRpdGFibGVDaGlsZEFuZEkgPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgobm9kZSwgaW5kZXgsIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpO1xuICAgIHZhciBfZ2V0RWRpdGFibGVDaGlsZEFuZEkyID0gX3NsaWNlZFRvQXJyYXkoX2dldEVkaXRhYmxlQ2hpbGRBbmRJLCAyKTtcbiAgICBub2RlID0gX2dldEVkaXRhYmxlQ2hpbGRBbmRJMlswXTtcbiAgICBpbmRleCA9IF9nZXRFZGl0YWJsZUNoaWxkQW5kSTJbMV07XG4gICAgaXNMYXN0ID0gaW5kZXggPCBvZmZzZXQ7XG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIGNoaWxkcmVuLCB0cmF2ZXJzZSB1bnRpbCB3ZSBoYXZlIGEgbGVhZiBub2RlLiBMZWFmIG5vZGVzXG4gICAgLy8gY2FuIGJlIGVpdGhlciB0ZXh0IG5vZGVzLCBvciBvdGhlciB2b2lkIERPTSBub2Rlcy5cbiAgICB3aGlsZSAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpID0gaXNMYXN0ID8gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaSwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgfVxuICAgIC8vIERldGVybWluZSB0aGUgbmV3IG9mZnNldCBpbnNpZGUgdGhlIHRleHQgbm9kZS5cbiAgICBvZmZzZXQgPSBpc0xhc3QgJiYgbm9kZS50ZXh0Q29udGVudCAhPSBudWxsID8gbm9kZS50ZXh0Q29udGVudC5sZW5ndGggOiAwO1xuICB9XG4gIC8vIFJldHVybiB0aGUgbm9kZSBhbmQgb2Zmc2V0LlxuICByZXR1cm4gW25vZGUsIG9mZnNldF07XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIG5lc3RlZCB3aXRoaW4gYSBzaGFkb3dSb290XG4gKi9cbnZhciBoYXNTaGFkb3dSb290ID0gZnVuY3Rpb24gaGFzU2hhZG93Um9vdChub2RlKSB7XG4gIHZhciBwYXJlbnQgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZTtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGFuZCBpbmRleCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcbiAqIGBkaXJlY3Rpb25gLlxuICovXG52YXIgZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4ID0gZnVuY3Rpb24gZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4KHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikge1xuICB2YXIgY2hpbGROb2RlcyA9IHBhcmVudC5jaGlsZE5vZGVzO1xuICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzW2luZGV4XTtcbiAgdmFyIGkgPSBpbmRleDtcbiAgdmFyIHRyaWVkRm9yd2FyZCA9IGZhbHNlO1xuICB2YXIgdHJpZWRCYWNrd2FyZCA9IGZhbHNlO1xuICAvLyBXaGlsZSB0aGUgY2hpbGQgaXMgYSBjb21tZW50IG5vZGUsIG9yIGFuIGVsZW1lbnQgbm9kZSB3aXRoIG5vIGNoaWxkcmVuLFxuICAvLyBrZWVwIGl0ZXJhdGluZyB0byBmaW5kIGEgc2libGluZyBub24tdm9pZCwgbm9uLWNvbW1lbnQgbm9kZS5cbiAgd2hpbGUgKGlzRE9NQ29tbWVudChjaGlsZCkgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICBpZiAodHJpZWRGb3J3YXJkICYmIHRyaWVkQmFja3dhcmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaSA+PSBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdHJpZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCAtIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdHJpZWRCYWNrd2FyZCA9IHRydWU7XG4gICAgICBpID0gaW5kZXggKyAxO1xuICAgICAgZGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGROb2Rlc1tpXTtcbiAgICBpbmRleCA9IGk7XG4gICAgaSArPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gW2NoaWxkLCBpbmRleF07XG59O1xuLyoqXG4gKiBHZXQgdGhlIG5lYXJlc3QgZWRpdGFibGUgY2hpbGQgYXQgYGluZGV4YCBpbiBhIGBwYXJlbnRgLCBwcmVmZXJyaW5nXG4gKiBgZGlyZWN0aW9uYC5cbiAqL1xudmFyIGdldEVkaXRhYmxlQ2hpbGQgPSBmdW5jdGlvbiBnZXRFZGl0YWJsZUNoaWxkKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikge1xuICB2YXIgX2dldEVkaXRhYmxlQ2hpbGRBbmRJMyA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pLFxuICAgIF9nZXRFZGl0YWJsZUNoaWxkQW5kSTQgPSBfc2xpY2VkVG9BcnJheShfZ2V0RWRpdGFibGVDaGlsZEFuZEkzLCAxKSxcbiAgICBjaGlsZCA9IF9nZXRFZGl0YWJsZUNoaWxkQW5kSTRbMF07XG4gIHJldHVybiBjaGlsZDtcbn07XG4vKipcbiAqIEdldCBhIHBsYWludGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udGVudCBvZiBhIG5vZGUsIGFjY291bnRpbmcgZm9yIGJsb2NrXG4gKiBlbGVtZW50cyB3aGljaCBnZXQgYSBuZXdsaW5lIGFwcGVuZGVkLlxuICpcbiAqIFRoZSBkb21Ob2RlIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAqL1xudmFyIGdldFBsYWluVGV4dCA9IGZ1bmN0aW9uIGdldFBsYWluVGV4dChkb21Ob2RlKSB7XG4gIHZhciB0ZXh0ID0gJyc7XG4gIGlmIChpc0RPTVRleHQoZG9tTm9kZSkgJiYgZG9tTm9kZS5ub2RlVmFsdWUpIHtcbiAgICByZXR1cm4gZG9tTm9kZS5ub2RlVmFsdWU7XG4gIH1cbiAgaWYgKGlzRE9NRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX0FycmF5JGZyb20gPSBBcnJheS5mcm9tKGRvbU5vZGUuY2hpbGROb2Rlcyk7IF9pIDwgX0FycmF5JGZyb20ubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgY2hpbGROb2RlID0gX0FycmF5JGZyb21bX2ldO1xuICAgICAgdGV4dCArPSBnZXRQbGFpblRleHQoY2hpbGROb2RlKTtcbiAgICB9XG4gICAgdmFyIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBkaXNwbGF5ID09PSAnbGlzdCcgfHwgZG9tTm9kZS50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn07XG4vKipcbiAqIEdldCB4LXNsYXRlLWZyYWdtZW50IGF0dHJpYnV0ZSBmcm9tIGRhdGEtc2xhdGUtZnJhZ21lbnRcbiAqL1xudmFyIGNhdGNoU2xhdGVGcmFnbWVudCA9IC9kYXRhLXNsYXRlLWZyYWdtZW50PVwiKC4rPylcIi9tO1xudmFyIGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlKGRhdGFUcmFuc2Zlcikge1xuICB2YXIgaHRtbERhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIHZhciBfcmVmID0gaHRtbERhdGEubWF0Y2goY2F0Y2hTbGF0ZUZyYWdtZW50KSB8fCBbXSxcbiAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIGZyYWdtZW50ID0gX3JlZjJbMV07XG4gIHJldHVybiBmcmFnbWVudDtcbn07XG4vKipcbiAqIEdldCB0aGUgZG9tIHNlbGVjdGlvbiBmcm9tIFNoYWRvdyBSb290IGlmIHBvc3NpYmxlLCBvdGhlcndpc2UgZnJvbSB0aGUgZG9jdW1lbnRcbiAqL1xudmFyIGdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGdldFNlbGVjdGlvbihyb290KSB7XG4gIGlmIChyb290LmdldFNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xufTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIG11dGF0aW9uIG9yaWdpbmF0ZXMgZnJvbSBhIGVkaXRhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBlZGl0b3IuXG4gKi9cbnZhciBpc1RyYWNrZWRNdXRhdGlvbiA9IGZ1bmN0aW9uIGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIGJhdGNoKSB7XG4gIHZhciB0YXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XG4gIGlmIChpc0RPTUVsZW1lbnQodGFyZ2V0KSAmJiB0YXJnZXQubWF0Y2hlcygnW2NvbnRlbnRFZGl0YWJsZT1cImZhbHNlXCJdJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIF9ET01FZGl0b3IkZ2V0V2luZG93ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpLFxuICAgIGRvY3VtZW50ID0gX0RPTUVkaXRvciRnZXRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmIChkb2N1bWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHZhciBwYXJlbnRNdXRhdGlvbiA9IGJhdGNoLmZpbmQoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIGFkZGVkTm9kZXMgPSBfcmVmMy5hZGRlZE5vZGVzLFxuICAgICAgcmVtb3ZlZE5vZGVzID0gX3JlZjMucmVtb3ZlZE5vZGVzO1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKGFkZGVkTm9kZXMpLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBub2RlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmIChub2RlID09PSB0YXJnZXQgfHwgbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShyZW1vdmVkTm9kZXMpLFxuICAgICAgX3N0ZXAyO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX25vZGUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgIGlmIChfbm9kZSA9PT0gdGFyZ2V0IHx8IF9ub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGFyZW50TXV0YXRpb24gfHwgcGFyZW50TXV0YXRpb24gPT09IG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRhcmdldCBhZGQvcmVtb3ZlIGlzIHRyYWNrZWQuIFRyYWNrIHRoZSBtdXRhdGlvbiBpZiB3ZSB0cmFjayB0aGUgcGFyZW50IG11dGF0aW9uLlxuICByZXR1cm4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBwYXJlbnRNdXRhdGlvbiwgYmF0Y2gpO1xufTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBkZWVwZXN0IGFjdGl2ZSBlbGVtZW50IGluIHRoZSBET00sIGNvbnNpZGVyaW5nIG5lc3RlZCBzaGFkb3cgRE9Ncy5cbiAqL1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkge1xuICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlICgoX2FjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KSAhPT0gbnVsbCAmJiBfYWN0aXZlRWxlbWVudCAhPT0gdm9pZCAwICYmIF9hY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QgJiYgKF9hY3RpdmVFbGVtZW50JHNoYWRvdyA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkgIT09IG51bGwgJiYgX2FjdGl2ZUVsZW1lbnQkc2hhZG93ICE9PSB2b2lkIDAgJiYgX2FjdGl2ZUVsZW1lbnQkc2hhZG93LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICB2YXIgX2FjdGl2ZUVsZW1lbnQsIF9hY3RpdmVFbGVtZW50JHNoYWRvdywgX2FjdGl2ZUVsZW1lbnQyO1xuICAgIGFjdGl2ZUVsZW1lbnQgPSAoX2FjdGl2ZUVsZW1lbnQyID0gYWN0aXZlRWxlbWVudCkgPT09IG51bGwgfHwgX2FjdGl2ZUVsZW1lbnQyID09PSB2b2lkIDAgfHwgKF9hY3RpdmVFbGVtZW50MiA9IF9hY3RpdmVFbGVtZW50Mi5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYWN0aXZlRWxlbWVudDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVFbGVtZW50Mi5hY3RpdmVFbGVtZW50O1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufTtcbi8qKlxuICogQHJldHVybnMgYHRydWVgIGlmIGBvdGhlck5vZGVgIGlzIGJlZm9yZSBgbm9kZWAgaW4gdGhlIGRvY3VtZW50OyBvdGhlcndpc2UsIGBmYWxzZWAuXG4gKi9cbnZhciBpc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG5vZGUsIG90aGVyTm9kZSkge1xuICByZXR1cm4gQm9vbGVhbihub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyTm9kZSkgJiBET01Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyk7XG59O1xuLyoqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyTm9kZWAgaXMgYWZ0ZXIgYG5vZGVgIGluIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICovXG52YXIgaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIobm9kZSwgb3RoZXJOb2RlKSB7XG4gIHJldHVybiBCb29sZWFuKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKSAmIERPTU5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKTtcbn07XG5cbnZhciBfbmF2aWdhdG9yJHVzZXJBZ2VudCQsIF9uYXZpZ2F0b3IkdXNlckFnZW50JDI7XG52YXIgSVNfSU9TID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcbnZhciBJU19BUFBMRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9NYWMgT1MgWC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfRklSRUZPWCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19XRUJLSVQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQXBwbGVXZWJLaXQoPyEuKkNocm9tZSkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gXCJtb2Rlcm5cIiBFZGdlIHdhcyByZWxlYXNlZCBhdCA3OS54XG52YXIgSVNfRURHRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvRWRnZT9cXC8oPzpbMC02XVswLTldfFswLTddWzAtOF0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQ0hST01FID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBOYXRpdmUgYGJlZm9yZUlucHV0YCBldmVudHMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggcmVhY3Qgb24gQ2hyb21lIDc1XG4vLyBhbmQgb2xkZXIsIENocm9tZSA3NisgY2FuIHVzZSBgYmVmb3JlSW5wdXRgIHRob3VnaC5cbnZhciBJU19DSFJPTUVfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZT9cXC8oPzpbMC03XVswLTVdfFswLTZdWzAtOV0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZID0gSVNfQU5EUk9JRCAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTVdP1xcZCkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIEZpcmVmb3ggZGlkIG5vdCBzdXBwb3J0IGBiZWZvcmVJbnB1dGAgdW50aWwgYHY4N2AuXG52YXIgSVNfRklSRUZPWF9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveFxcLyg/OlswLTddWzAtOV18WzAtOF1bMC02XSkoPzpcXC4pKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIFVDIG1vYmlsZSBicm93c2VyXG52YXIgSVNfVUNfTU9CSUxFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qVUNCcm93c2VyLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gV2VjaGF0IGJyb3dzZXIgKG5vdCBpbmNsdWRpbmcgbWFjIHdlY2hhdClcbnZhciBJU19XRUNIQVRCUk9XU0VSID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qV2VjaGF0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvLipNYWNXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIGF2b2lkIGxvb2tiZWhpbmQgKGJ1Z2d5IGluIHNhZmFyaSA8IDE2LjQpXG4vLyBDaGVjayBpZiBET00gaXMgYXZhaWxhYmxlIGFzIFJlYWN0IGRvZXMgaW50ZXJuYWxseS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbnZhciBDQU5fVVNFX0RPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgaXMgU2FmYXJpIGFuZCBvbGRlciB0aGFuIDE3XG50eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9WZXJzaW9uXFwvKFxcZCspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICgoX25hdmlnYXRvciR1c2VyQWdlbnQkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhcXGQrKS8pKSAhPT0gbnVsbCAmJiBfbmF2aWdhdG9yJHVzZXJBZ2VudCQgIT09IHZvaWQgMCAmJiBfbmF2aWdhdG9yJHVzZXJBZ2VudCRbMV0gPyBwYXJzZUludCgoX25hdmlnYXRvciR1c2VyQWdlbnQkMiA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKykvKSkgPT09IG51bGwgfHwgX25hdmlnYXRvciR1c2VyQWdlbnQkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hdmlnYXRvciR1c2VyQWdlbnQkMlsxXSwgMTApIDwgMTcgOiBmYWxzZSk7XG4vLyBDT01QQVQ6IEZpcmVmb3gvRWRnZSBMZWdhY3kgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudFxuLy8gQ2hyb21lIExlZ2FjeSBkb2Vzbid0IHN1cHBvcnQgYGJlZm9yZWlucHV0YCBjb3JyZWN0bHlcbnZhciBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPSAoIUlTX0NIUk9NRV9MRUdBQ1kgfHwgIUlTX0FORFJPSURfQ0hST01FX0xFR0FDWSkgJiYgIUlTX0VER0VfTEVHQUNZICYmXG4vLyBnbG9iYWxUaGlzIGlzIHVuZGVmaW5lZCBpbiBvbGRlciBicm93c2Vyc1xudHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuSW5wdXRFdmVudCAmJlxuLy8gQHRzLWlnbm9yZSBUaGUgYGdldFRhcmdldFJhbmdlc2AgcHJvcGVydHkgaXNuJ3QgcmVjb2duaXplZC5cbnR5cGVvZiBnbG9iYWxUaGlzLklucHV0RXZlbnQucHJvdG90eXBlLmdldFRhcmdldFJhbmdlcyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIF90eXBlb2ZfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG51bndyYXBFeHBvcnRzKF90eXBlb2ZfMSk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBfdHlwZW9mID0gX3R5cGVvZl8xW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1ByaW1pdGl2ZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHModG9QcmltaXRpdmUpO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBfdHlwZW9mID0gX3R5cGVvZl8xW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudW53cmFwRXhwb3J0cyh0b1Byb3BlcnR5S2V5KTtcblxudmFyIGNyZWF0ZUNsYXNzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gdW53cmFwRXhwb3J0cyhjcmVhdGVDbGFzcyk7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2sgPSB1bndyYXBFeHBvcnRzKGNsYXNzQ2FsbENoZWNrKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSB1bndyYXBFeHBvcnRzKGRlZmluZVByb3BlcnR5KTtcblxuLyoqXG4gKiBBbiBhdXRvLWluY3JlbWVudGluZyBpZGVudGlmaWVyIGZvciBrZXlzLlxuICovXG52YXIgbiA9IDA7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBhIGtleSBzdHJpbmcuIFdlIHVzZSBhIGZ1bGwgY2xhc3MgaGVyZSBiZWNhdXNlIHdlXG4gKiB3YW50IHRvIGJlIGFibGUgdG8gdXNlIHRoZW0gYXMga2V5cyBpbiBgV2Vha01hcGAgb2JqZWN0cy5cbiAqL1xudmFyIEtleSA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gS2V5KCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5KTtcbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgdm9pZCAwKTtcbiAgdGhpcy5pZCA9IFwiXCIuY29uY2F0KG4rKyk7XG59KTtcblxuLyoqXG4gKiBUd28gd2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgcmVidWlsZCBhIHBhdGggZ2l2ZW4gYSBub2RlLiBUaGV5IGFyZSBwb3B1bGF0ZWRcbiAqIGF0IHJlbmRlciB0aW1lIHN1Y2ggdGhhdCBhZnRlciBhIHJlbmRlciBvY2N1cnMgd2UgY2FuIGFsd2F5cyBiYWNrdHJhY2suXG4gKi9cbnZhciBJU19OT0RFX01BUF9ESVJUWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19JTkRFWCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19QQVJFTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyB0byBnbyBiZXR3ZWVuIFNsYXRlIG5vZGVzIGFuZCBET00gbm9kZXMuIFRoZXNlXG4gKiBhcmUgdXNlZCB0byByZXNvbHZlIERPTSBldmVudC1yZWxhdGVkIGxvZ2ljIGludG8gU2xhdGUgYWN0aW9ucy5cbiAqL1xudmFyIEVESVRPUl9UT19XSU5ET1cgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRUxFTUVOVF9UT19OT0RFID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fS0VZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcHMgZm9yIHN0b3JpbmcgZWRpdG9yLXJlbGF0ZWQgc3RhdGUuXG4gKi9cbnZhciBJU19SRUFEX09OTFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0ZPQ1VTRUQgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0NPTVBPU0lORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogV2VhayBtYXAgZm9yIGFzc29jaWF0aW5nIHRoZSBjb250ZXh0IGBvbkNoYW5nZWAgY29udGV4dCB3aXRoIHRoZSBwbHVnaW4uXG4gKi9cbnZhciBFRElUT1JfVE9fT05fQ0hBTkdFID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogV2VhayBtYXBzIGZvciBzYXZpbmcgcGVuZGluZyBzdGF0ZSBvbiBjb21wb3NpdGlvbiBzdGFnZS5cbiAqL1xudmFyIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9NQVJLUyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEFuZHJvaWQgaW5wdXQgaGFuZGxpbmcgc3BlY2lmaWMgd2Vhay1tYXBzXG4gKi9cbnZhciBFRElUT1JfVE9fUEVORElOR19ESUZGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19GT1JDRV9SRU5ERVIgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBTeW1ib2xzLlxuICovXG52YXIgUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdwbGFjZWhvbGRlcicpO1xudmFyIE1BUktfUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdtYXJrLXBsYWNlaG9sZGVyJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBET01FZGl0b3IgPSB7XG4gIGFuZHJvaWRQZW5kaW5nRGlmZnM6IGZ1bmN0aW9uIGFuZHJvaWRQZW5kaW5nRGlmZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB9LFxuICBhbmRyb2lkU2NoZWR1bGVGbHVzaDogZnVuY3Rpb24gYW5kcm9pZFNjaGVkdWxlRmx1c2goZWRpdG9yKSB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRjtcbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YgPT09IHZvaWQgMCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcbiAgfSxcbiAgYmx1cjogZnVuY3Rpb24gYmx1cihlZGl0b3IpIHtcbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IERPTUVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgfSxcbiAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KGVkaXRvcikge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHZhciByb290ID0gRE9NRWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24ocm9vdCk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgIH1cbiAgfSxcbiAgZmluZERvY3VtZW50T3JTaGFkb3dSb290OiBmdW5jdGlvbiBmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKSB7XG4gICAgdmFyIGVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBlbC5nZXRSb290Tm9kZSgpO1xuICAgIGlmIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnQgfHwgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudDtcbiAgfSxcbiAgZmluZEV2ZW50UmFuZ2U6IGZ1bmN0aW9uIGZpbmRFdmVudFJhbmdlKGVkaXRvciwgZXZlbnQpIHtcbiAgICBpZiAoJ25hdGl2ZUV2ZW50JyBpbiBldmVudCkge1xuICAgICAgZXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICB9XG4gICAgdmFyIF9ldmVudCA9IGV2ZW50LFxuICAgICAgeCA9IF9ldmVudC5jbGllbnRYLFxuICAgICAgeSA9IF9ldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0ID0gX2V2ZW50LnRhcmdldDtcbiAgICBpZiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgIHZhciBwYXRoID0gRE9NRWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gICAgLy8gSWYgdGhlIGRyb3AgdGFyZ2V0IGlzIGluc2lkZSBhIHZvaWQgbm9kZSwgbW92ZSBpdCBpbnRvIGVpdGhlciB0aGVcbiAgICAvLyBuZXh0IG9yIHByZXZpb3VzIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlIHRoZSBgeGAgYW5kIGB5YFxuICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBjbG9zZXN0IHRvLlxuICAgIGlmIChzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBzbGF0ZS5FZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGlzUHJldiA9IGVkaXRvci5pc0lubGluZShub2RlKSA/IHggLSByZWN0LmxlZnQgPCByZWN0LmxlZnQgKyByZWN0LndpZHRoIC0geCA6IHkgLSByZWN0LnRvcCA8IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLSB5O1xuICAgICAgdmFyIGVkZ2UgPSBzbGF0ZS5FZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoLCB7XG4gICAgICAgIGVkZ2U6IGlzUHJldiA/ICdzdGFydCcgOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9pbnQgPSBpc1ByZXYgPyBzbGF0ZS5FZGl0b3IuYmVmb3JlKGVkaXRvciwgZWRnZSkgOiBzbGF0ZS5FZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlZGdlKTtcbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICB2YXIgX3JhbmdlID0gc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQpO1xuICAgICAgICByZXR1cm4gX3JhbmdlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbHNlIHJlc29sdmUgYSByYW5nZSBmcm9tIHRoZSBjYXJldCBwb3NpdGlvbiB3aGVyZSB0aGUgZHJvcCBvY2N1cmVkLlxuICAgIHZhciBkb21SYW5nZTtcbiAgICB2YXIgX0RPTUVkaXRvciRnZXRXaW5kb3cgPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvciksXG4gICAgICBkb2N1bWVudCA9IF9ET01FZGl0b3IkZ2V0V2luZG93LmRvY3VtZW50O1xuICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgYGNhcmV0UmFuZ2VGcm9tUG9pbnRgIGRvZXNuJ3QgZXhpc3QuICgyMDE2LzA3LzI1KVxuICAgIGlmIChkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICBkb21SYW5nZSA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBkb21SYW5nZS5zZXRTdGFydChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICBkb21SYW5nZS5zZXRFbmQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkb21SYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9XG4gICAgLy8gUmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gdGhlIERPTSByYW5nZS5cbiAgICB2YXIgcmFuZ2UgPSBET01FZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UsIHtcbiAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH0sXG4gIGZpbmRLZXk6IGZ1bmN0aW9uIGZpbmRLZXkoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIGtleSA9IE5PREVfVE9fS0VZLmdldChub2RlKTtcbiAgICBpZiAoIWtleSkge1xuICAgICAga2V5ID0gbmV3IEtleSgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0sXG4gIGZpbmRQYXRoOiBmdW5jdGlvbiBmaW5kUGF0aChlZGl0b3IsIG5vZGUpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBjaGlsZCA9IG5vZGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBOT0RFX1RPX1BBUkVOVC5nZXQoY2hpbGQpO1xuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChzbGF0ZS5FZGl0b3IuaXNFZGl0b3IoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpID0gTk9ERV9UT19JTkRFWC5nZXQoY2hpbGQpO1xuICAgICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBhdGgudW5zaGlmdChpKTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0aGUgcGF0aCBmb3IgU2xhdGUgbm9kZTogXCIuY29uY2F0KHNsYXRlLlNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICB9LFxuICBmb2N1czogZnVuY3Rpb24gZm9jdXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIHJldHJpZXM6IDVcbiAgICB9O1xuICAgIC8vIFJldHVybiBpZiBhbHJlYWR5IGZvY3VzZWRcbiAgICBpZiAoSVNfRk9DVVNFRC5nZXQoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXRyeSBzZXR0aW5nIGZvY3VzIGlmIHRoZSBlZGl0b3IgaGFzIHBlbmRpbmcgb3BlcmF0aW9ucy5cbiAgICAvLyBUaGUgRE9NIChzZWxlY3Rpb24pIGlzIHVuc3RhYmxlIHdoaWxlIGNoYW5nZXMgYXJlIGFwcGxpZWQuXG4gICAgLy8gUmV0cnkgdW50aWwgcmV0cmllcyBhcmUgZXhoYXVzdGVkIG9yIGVkaXRvciBpcyBmb2N1c2VkLlxuICAgIGlmIChvcHRpb25zLnJldHJpZXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3Qgc2V0IGZvY3VzLCBlZGl0b3Igc2VlbXMgc3R1Y2sgd2l0aCBwZW5kaW5nIG9wZXJhdGlvbnMnKTtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBET01FZGl0b3IuZm9jdXMoZWRpdG9yLCB7XG4gICAgICAgICAgcmV0cmllczogb3B0aW9ucy5yZXRyaWVzIC0gMVxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBET01FZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgaWYgKHJvb3QuYWN0aXZlRWxlbWVudCAhPT0gZWwpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIHNldCB0byB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uXG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiByb290IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihyb290KTtcbiAgICAgICAgdmFyIGRvbVJhbmdlID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gdm9pZCAwIHx8IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gdm9pZCAwIHx8IGRvbVNlbGVjdGlvbi5hZGRSYW5nZShkb21SYW5nZSk7XG4gICAgICB9XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc2VsZWN0aW9uIGluIHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50IGlmIG1pc3NpbmdcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNsYXRlLkVkaXRvci5zdGFydChlZGl0b3IsIFtdKSk7XG4gICAgICB9XG4gICAgICAvLyBJU19GT0NVU0VEIHNob3VsZCBiZSBzZXQgYmVmb3JlIGNhbGxpbmcgZWwuZm9jdXMoKSB0byBlbnN1cmUgdGhhdFxuICAgICAgLy8gRm9jdXNlZENvbnRleHQgaXMgdXBkYXRlZCB0byB0aGUgY29ycmVjdCB2YWx1ZVxuICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIGVsLmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBnZXRXaW5kb3c6IGZ1bmN0aW9uIGdldFdpbmRvdyhlZGl0b3IpIHtcbiAgICB2YXIgd2luZG93ID0gRURJVE9SX1RPX1dJTkRPVy5nZXQoZWRpdG9yKTtcbiAgICBpZiAoIXdpbmRvdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIGhvc3Qgd2luZG93IGVsZW1lbnQgZm9yIHRoaXMgZWRpdG9yJyk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3c7XG4gIH0sXG4gIGhhc0RPTU5vZGU6IGZ1bmN0aW9uIGhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGVkaXRhYmxlID0gb3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgIGVkaXRhYmxlID0gX29wdGlvbnMkZWRpdGFibGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkZWRpdGFibGU7XG4gICAgdmFyIGVkaXRvckVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHRhcmdldEVsO1xuICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgcmVhZGluZyBgdGFyZ2V0Lm5vZGVUeXBlYCB3aWxsIHRocm93IGFuIGVycm9yIGlmXG4gICAgLy8gdGFyZ2V0IGlzIG9yaWdpbmF0aW5nIGZyb20gYW4gaW50ZXJuYWwgXCJyZXN0cmljdGVkXCIgZWxlbWVudCAoZS5nLiBhXG4gICAgLy8gc3RlcHBlciBhcnJvdyBvbiBhIG51bWJlciBpbnB1dCkuICgyMDE4LzA1LzA0KVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvMTgxOVxuICAgIHRyeSB7XG4gICAgICB0YXJnZXRFbCA9IGlzRE9NRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgcHJvcGVydHkgXCJub2RlVHlwZVwiJykpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhcmdldEVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRFbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtZWRpdG9yXVwiKSA9PT0gZWRpdG9yRWwgJiYgKCFlZGl0YWJsZSB8fCB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA/IHRydWUgOiB0eXBlb2YgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgPT09ICdib29sZWFuJyAmJlxuICAgIC8vIGlzQ29udGVudEVkaXRhYmxlIGV4aXN0cyBvbmx5IG9uIEhUTUxFbGVtZW50LCBhbmQgb24gb3RoZXIgbm9kZXMgaXQgd2lsbCBiZSB1bmRlZmluZWRcbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIGxvZ2ljIHRoYXQgbGV0cyB5b3Uga25vdyB5b3UgZ290IHRoZSByaWdodCBlZGl0b3Iuc2VsZWN0aW9uIGluc3RlYWQgb2YgbnVsbCB3aGVuIGVkaXRvciBpcyBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiKHJlYWRPbmx5KVxuICAgIHRhcmdldEVsLmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScpID09PSBlZGl0b3JFbCB8fCAhIXRhcmdldEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykpO1xuICB9LFxuICBoYXNFZGl0YWJsZVRhcmdldDogZnVuY3Rpb24gaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gaXNET01Ob2RlKHRhcmdldCkgJiYgRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0sXG4gIGhhc1JhbmdlOiBmdW5jdGlvbiBoYXNSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcixcbiAgICAgIGZvY3VzID0gcmFuZ2UuZm9jdXM7XG4gICAgcmV0dXJuIHNsYXRlLkVkaXRvci5oYXNQYXRoKGVkaXRvciwgYW5jaG9yLnBhdGgpICYmIHNsYXRlLkVkaXRvci5oYXNQYXRoKGVkaXRvciwgZm9jdXMucGF0aCk7XG4gIH0sXG4gIGhhc1NlbGVjdGFibGVUYXJnZXQ6IGZ1bmN0aW9uIGhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gRE9NRWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSB8fCBET01FZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCB0YXJnZXQpO1xuICB9LFxuICBoYXNUYXJnZXQ6IGZ1bmN0aW9uIGhhc1RhcmdldChlZGl0b3IsIHRhcmdldCkge1xuICAgIHJldHVybiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gIH0sXG4gIGluc2VydERhdGE6IGZ1bmN0aW9uIGluc2VydERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgZWRpdG9yLmluc2VydERhdGEoZGF0YSk7XG4gIH0sXG4gIGluc2VydEZyYWdtZW50RGF0YTogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnREYXRhKGVkaXRvciwgZGF0YSkge1xuICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpO1xuICB9LFxuICBpbnNlcnRUZXh0RGF0YTogZnVuY3Rpb24gaW5zZXJ0VGV4dERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgfSxcbiAgaXNDb21wb3Npbmc6IGZ1bmN0aW9uIGlzQ29tcG9zaW5nKGVkaXRvcikge1xuICAgIHJldHVybiAhIUlTX0NPTVBPU0lORy5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgaXNGb2N1c2VkOiBmdW5jdGlvbiBpc0ZvY3VzZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuICEhSVNfRk9DVVNFRC5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgaXNSZWFkT25seTogZnVuY3Rpb24gaXNSZWFkT25seShlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19SRUFEX09OTFkuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIGlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkOiBmdW5jdGlvbiBpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIHRhcmdldCkge1xuICAgIGlmIChJU19SRUFEX09OTFkuZ2V0KGVkaXRvcikpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2xhdGVOb2RlID0gRE9NRWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIHRhcmdldCkgJiYgRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGFyZ2V0KTtcbiAgICByZXR1cm4gc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQoc2xhdGVOb2RlKSAmJiBzbGF0ZS5FZGl0b3IuaXNWb2lkKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgfSxcbiAgc2V0RnJhZ21lbnREYXRhOiBmdW5jdGlvbiBzZXRGcmFnbWVudERhdGEoZWRpdG9yLCBkYXRhLCBvcmlnaW5FdmVudCkge1xuICAgIHJldHVybiBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGRhdGEsIG9yaWdpbkV2ZW50KTtcbiAgfSxcbiAgdG9ET01Ob2RlOiBmdW5jdGlvbiB0b0RPTU5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIHZhciBkb21Ob2RlID0gc2xhdGUuRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcikgOiBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuZ2V0KERPTUVkaXRvci5maW5kS2V5KGVkaXRvciwgbm9kZSkpO1xuICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gbm9kZSBmcm9tIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChzbGF0ZS5TY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbU5vZGU7XG4gIH0sXG4gIHRvRE9NUG9pbnQ6IGZ1bmN0aW9uIHRvRE9NUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBfRWRpdG9yJG5vZGUgPSBzbGF0ZS5FZGl0b3Iubm9kZShlZGl0b3IsIHBvaW50LnBhdGgpLFxuICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgICBub2RlID0gX0VkaXRvciRub2RlMlswXTtcbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgbm9kZSk7XG4gICAgdmFyIGRvbVBvaW50O1xuICAgIC8vIElmIHdlJ3JlIGluc2lkZSBhIHZvaWQgbm9kZSwgZm9yY2UgdGhlIG9mZnNldCB0byAwLCBvdGhlcndpc2UgdGhlIHplcm9cbiAgICAvLyB3aWR0aCBzcGFjaW5nIGNoYXJhY3RlciB3aWxsIHJlc3VsdCBpbiBhbiBpbmNvcnJlY3Qgb2Zmc2V0IG9mIDFcbiAgICBpZiAoc2xhdGUuRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiBwb2ludFxuICAgIH0pKSB7XG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgZWFjaCBsZWFmLCB3ZSBuZWVkIHRvIGlzb2xhdGUgaXRzIGNvbnRlbnQsIHdoaWNoIG1lYW5zIGZpbHRlcmluZ1xuICAgIC8vIHRvIGl0cyBkaXJlY3QgdGV4dCBhbmQgemVyby13aWR0aCBzcGFucy4gKFdlIGhhdmUgdG8gZmlsdGVyIG91dCBhbnlcbiAgICAvLyBvdGhlciBzaWJsaW5ncyB0aGF0IG1heSBoYXZlIGJlZW4gcmVuZGVyZWQgYWxvbmdzaWRlIHRoZW0uKVxuICAgIHZhciBzZWxlY3RvciA9IFwiW2RhdGEtc2xhdGUtc3RyaW5nXSwgW2RhdGEtc2xhdGUtemVyby13aWR0aF1cIjtcbiAgICB2YXIgdGV4dHMgPSBBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ZXh0ID0gdGV4dHNbaV07XG4gICAgICB2YXIgZG9tTm9kZSA9IHRleHQuY2hpbGROb2Rlc1swXTtcbiAgICAgIGlmIChkb21Ob2RlID09IG51bGwgfHwgZG9tTm9kZS50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgdmFyIGF0dHIgPSB0ZXh0LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1sZW5ndGgnKTtcbiAgICAgIHZhciB0cnVlTGVuZ3RoID0gYXR0ciA9PSBudWxsID8gbGVuZ3RoIDogcGFyc2VJbnQoYXR0ciwgMTApO1xuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgdHJ1ZUxlbmd0aDtcbiAgICAgIC8vIFByZWZlciBwdXR0aW5nIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBtYXJrIHBsYWNlaG9sZGVyIHRvIGVuc3VyZVxuICAgICAgLy8gY29tcG9zZWQgdGV4dCBpcyBkaXNwbGF5ZWQgd2l0aCB0aGUgY29ycmVjdCBtYXJrcy5cbiAgICAgIHZhciBuZXh0VGV4dCA9IHRleHRzW2kgKyAxXTtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPT09IGVuZCAmJiBuZXh0VGV4dCAhPT0gbnVsbCAmJiBuZXh0VGV4dCAhPT0gdm9pZCAwICYmIG5leHRUZXh0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgdmFyIF9uZXh0VGV4dCR0ZXh0Q29udGVudDtcbiAgICAgICAgdmFyIGRvbVRleHQgPSBuZXh0VGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBkb21Qb2ludCA9IFtcbiAgICAgICAgLy8gQ09NUEFUOiBJZiB3ZSBkb24ndCBleHBsaWNpdHkgc2V0IHRoZSBkb20gcG9pbnQgdG8gYmUgb24gdGhlIGFjdHVhbFxuICAgICAgICAvLyBkb20gdGV4dCBlbGVtZW50LCBjaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiBiZWhpbmQgdGhlIGFjdHVhbCBkb21cbiAgICAgICAgLy8gdGV4dCBlbGVtZW50LCBjYXVzaW5nIGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGNhbGxzIG9uIGEgY29sbGFwc2VkXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byByZXR1cm4gaW5jb3JyZWN0IHplcm8gdmFsdWVzIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00MzU0MzgpXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzIHdoZW4gc2Nyb2xsaW5nIHRvIGl0LlxuICAgICAgICBkb21UZXh0IGluc3RhbmNlb2YgRE9NVGV4dCA/IGRvbVRleHQgOiBuZXh0VGV4dCwgKF9uZXh0VGV4dCR0ZXh0Q29udGVudCA9IG5leHRUZXh0LnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQuc3RhcnRzV2l0aChcIlxcdUZFRkZcIikgPyAxIDogMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWluKGxlbmd0aCwgTWF0aC5tYXgoMCwgcG9pbnQub2Zmc2V0IC0gc3RhcnQpKTtcbiAgICAgICAgZG9tUG9pbnQgPSBbZG9tTm9kZSwgb2Zmc2V0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKCFkb21Qb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gcG9pbnQgZnJvbSBTbGF0ZSBwb2ludDogXCIuY29uY2F0KHNsYXRlLlNjcnViYmVyLnN0cmluZ2lmeShwb2ludCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVBvaW50O1xuICB9LFxuICB0b0RPTVJhbmdlOiBmdW5jdGlvbiB0b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICB2YXIgaXNCYWNrd2FyZCA9IHNsYXRlLlJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICAgIHZhciBkb21BbmNob3IgPSBET01FZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgdmFyIGRvbUZvY3VzID0gc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpID8gZG9tQW5jaG9yIDogRE9NRWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBmb2N1cyk7XG4gICAgdmFyIHdpbmRvdyA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB2YXIgZG9tUmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICB2YXIgX3JlZiA9IGlzQmFja3dhcmQgPyBkb21Gb2N1cyA6IGRvbUFuY2hvcixcbiAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICBzdGFydE5vZGUgPSBfcmVmMlswXSxcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gX3JlZjJbMV07XG4gICAgdmFyIF9yZWYzID0gaXNCYWNrd2FyZCA/IGRvbUFuY2hvciA6IGRvbUZvY3VzLFxuICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICBlbmROb2RlID0gX3JlZjRbMF0sXG4gICAgICBlbmRPZmZzZXQgPSBfcmVmNFsxXTtcbiAgICAvLyBBIHNsYXRlIFBvaW50IGF0IHplcm8td2lkdGggTGVhZiBhbHdheXMgaGFzIGFuIG9mZnNldCBvZiAwIGJ1dCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIGF0XG4gICAgLy8gemVyby13aWR0aCBub2RlIGhhcyBhbiBvZmZzZXQgb2YgMSBzbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIHdlIGFyZSBpbiBhIHplcm8td2lkdGggbm9kZSBhbmRcbiAgICAvLyBhZGp1c3QgdGhlIG9mZnNldCBhY2NvcmRpbmdseS5cbiAgICB2YXIgc3RhcnRFbCA9IGlzRE9NRWxlbWVudChzdGFydE5vZGUpID8gc3RhcnROb2RlIDogc3RhcnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzU3RhcnRBdFplcm9XaWR0aCA9ICEhc3RhcnRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIHZhciBlbmRFbCA9IGlzRE9NRWxlbWVudChlbmROb2RlKSA/IGVuZE5vZGUgOiBlbmROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzRW5kQXRaZXJvV2lkdGggPSAhIWVuZEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgZG9tUmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBpc1N0YXJ0QXRaZXJvV2lkdGggPyAxIDogc3RhcnRPZmZzZXQpO1xuICAgIGRvbVJhbmdlLnNldEVuZChlbmROb2RlLCBpc0VuZEF0WmVyb1dpZHRoID8gMSA6IGVuZE9mZnNldCk7XG4gICAgcmV0dXJuIGRvbVJhbmdlO1xuICB9LFxuICB0b1NsYXRlTm9kZTogZnVuY3Rpb24gdG9TbGF0ZU5vZGUoZWRpdG9yLCBkb21Ob2RlKSB7XG4gICAgdmFyIGRvbUVsID0gaXNET01FbGVtZW50KGRvbU5vZGUpID8gZG9tTm9kZSA6IGRvbU5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoZG9tRWwgJiYgIWRvbUVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykpIHtcbiAgICAgIGRvbUVsID0gZG9tRWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLW5vZGVdXCIpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IGRvbUVsID8gRUxFTUVOVF9UT19OT0RFLmdldChkb21FbCkgOiBudWxsO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBub2RlIGZyb20gRE9NIG5vZGU6IFwiLmNvbmNhdChkb21FbCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgdG9TbGF0ZVBvaW50OiBmdW5jdGlvbiB0b1NsYXRlUG9pbnQoZWRpdG9yLCBkb21Qb2ludCwgb3B0aW9ucykge1xuICAgIHZhciBleGFjdE1hdGNoID0gb3B0aW9ucy5leGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvdyA9IG9wdGlvbnMuc3VwcHJlc3NUaHJvdyxcbiAgICAgIF9vcHRpb25zJHNlYXJjaERpcmVjdCA9IG9wdGlvbnMuc2VhcmNoRGlyZWN0aW9uLFxuICAgICAgc2VhcmNoRGlyZWN0aW9uID0gX29wdGlvbnMkc2VhcmNoRGlyZWN0ID09PSB2b2lkIDAgPyAnYmFja3dhcmQnIDogX29wdGlvbnMkc2VhcmNoRGlyZWN0O1xuICAgIHZhciBfcmVmNSA9IGV4YWN0TWF0Y2ggPyBkb21Qb2ludCA6IG5vcm1hbGl6ZURPTVBvaW50KGRvbVBvaW50KSxcbiAgICAgIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpLFxuICAgICAgbmVhcmVzdE5vZGUgPSBfcmVmNlswXSxcbiAgICAgIG5lYXJlc3RPZmZzZXQgPSBfcmVmNlsxXTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5lYXJlc3ROb2RlLnBhcmVudE5vZGU7XG4gICAgdmFyIHRleHROb2RlID0gbnVsbDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgdmFyIF9kb21Ob2RlJHRleHRDb250ZW50LCBfZG9tTm9kZSR0ZXh0Q29udGVudDI7XG4gICAgICB2YXIgZWRpdG9yRWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBwb3RlbnRpYWxWb2lkTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtdm9pZD1cInRydWVcIl0nKTtcbiAgICAgIC8vIE5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNsb3Nlc3Qgdm9pZCBub2RlIGlzIGFjdHVhbGx5IGEgdm9pZCBub2RlXG4gICAgICAvLyB3aXRoaW4gdGhpcyBlZGl0b3IsIGFuZCBub3QgYSB2b2lkIG5vZGUgd2l0aGluIHNvbWUgcGFyZW50IGVkaXRvci4gVGhpcyBjYW4gaGFwcGVuXG4gICAgICAvLyBpZiB0aGlzIGVkaXRvciBpcyB3aXRoaW4gYSB2b2lkIG5vZGUgb2YgYW5vdGhlciBlZGl0b3IgKFwibmVzdGVkIGVkaXRvcnNcIiwgbGlrZSBpblxuICAgICAgLy8gdGhlIFwiRWRpdGFibGUgVm9pZHNcIiBleGFtcGxlIG9uIHRoZSBkb2NzIHNpdGUpLlxuICAgICAgdmFyIHZvaWROb2RlID0gcG90ZW50aWFsVm9pZE5vZGUgJiYgZWRpdG9yRWwuY29udGFpbnMocG90ZW50aWFsVm9pZE5vZGUpID8gcG90ZW50aWFsVm9pZE5vZGUgOiBudWxsO1xuICAgICAgdmFyIHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdJyk7XG4gICAgICB2YXIgbm9uRWRpdGFibGVOb2RlID0gcG90ZW50aWFsTm9uRWRpdGFibGVOb2RlICYmIGVkaXRvckVsLmNvbnRhaW5zKHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSkgPyBwb3RlbnRpYWxOb25FZGl0YWJsZU5vZGUgOiBudWxsO1xuICAgICAgdmFyIGxlYWZOb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuICAgICAgdmFyIGRvbU5vZGUgPSBudWxsO1xuICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgaW50byB0aGUgdGV4dCBub2RlIHRoZSBgbmVhcmVzdE5vZGVgIGlzLCBzbyB0aGF0IHdlXG4gICAgICAvLyBjYW4gZGV0ZXJtaW5lIHdoYXQgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdGV4dCBub2RlIGlzLlxuICAgICAgaWYgKGxlYWZOb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgaWYgKHRleHROb2RlKSB7XG4gICAgICAgICAgdmFyIHdpbmRvdyA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0KTtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgICAgdmFyIHJlbW92YWxzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKSksIF90b0NvbnN1bWFibGVBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudGVkaXRhYmxlPWZhbHNlXScpKSkpO1xuICAgICAgICAgIHJlbW92YWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBDT01QQVQ6IFdoaWxlIGNvbXBvc2luZyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUsIHNvbWUga2V5Ym9hcmRzIHB1dFxuICAgICAgICAgICAgLy8gdGhlIHRleHQgY29udGVudCBpbnNpZGUgdGhlIHplcm8gd2lkdGggc3BhY2UuXG4gICAgICAgICAgICBpZiAoSVNfQU5EUk9JRCAmJiAhZXhhY3RNYXRjaCAmJiBlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpICYmIGVsLnRleHRDb250ZW50Lmxlbmd0aCA+IDAgJiYgZWwudGV4dENvbnRleHQgIT09IFwiXFx1RkVGRlwiKSB7XG4gICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudC5zdGFydHNXaXRoKFwiXFx1RkVGRlwiKSkge1xuICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gZWwudGV4dENvbnRlbnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gQ09NUEFUOiBFZGdlIGhhcyBhIGJ1ZyB3aGVyZSBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcoKSB3aWxsXG4gICAgICAgICAgLy8gY29udmVydCBcXG4gaW50byBcXHJcXG4uIFRoZSBidWcgY2F1c2VzIGEgbG9vcCB3aGVuIHNsYXRlLWRvbVxuICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlcG9zaXRpb24gaXRzIGN1cnNvciB0byBtYXRjaCB0aGUgbmF0aXZlIHBvc2l0aW9uLiBVc2VcbiAgICAgICAgICAvLyB0ZXh0Q29udGVudC5sZW5ndGggaW5zdGVhZC5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDI5MTExNi9cbiAgICAgICAgICBvZmZzZXQgPSBjb250ZW50cy50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZSA9IHRleHROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZvaWROb2RlKSB7XG4gICAgICAgIC8vIEZvciB2b2lkIG5vZGVzLCB0aGUgZWxlbWVudCB3aXRoIHRoZSBvZmZzZXQga2V5IHdpbGwgYmUgYSBjb3VzaW4sIG5vdCBhblxuICAgICAgICAvLyBhbmNlc3Rvciwgc28gZmluZCBpdCBieSBnb2luZyBkb3duIGZyb20gdGhlIG5lYXJlc3Qgdm9pZCBwYXJlbnQgYW5kIHRha2luZyB0aGVcbiAgICAgICAgLy8gZmlyc3Qgb25lIHRoYXQgaXNuJ3QgaW5zaWRlIGEgbmVzdGVkIGVkaXRvci5cbiAgICAgICAgdmFyIGxlYWZOb2RlcyA9IHZvaWROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZWFmTm9kZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBsZWFmTm9kZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBsZWFmTm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBJbiByZWFkLW9ubHkgZWRpdG9ycyB0aGUgbGVhZiBpcyBub3QgcmVuZGVyZWQuXG4gICAgICAgIGlmICghbGVhZk5vZGUpIHtcbiAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgICBkb21Ob2RlID0gbGVhZk5vZGU7XG4gICAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gZWwudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vbkVkaXRhYmxlTm9kZSkge1xuICAgICAgICAvLyBGaW5kIHRoZSBlZGdlIG9mIHRoZSBuZWFyZXN0IGxlYWYgaW4gYHNlYXJjaERpcmVjdGlvbmBcbiAgICAgICAgdmFyIGdldExlYWZOb2RlcyA9IGZ1bmN0aW9uIGdldExlYWZOb2Rlcyhub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgLy8gRXhjbHVkZSBsZWFmIG5vZGVzIGluIG5lc3RlZCBlZGl0b3JzXG4gICAgICAgICAgJ1tkYXRhLXNsYXRlLWxlYWZdOm5vdCg6c2NvcGUgW2RhdGEtc2xhdGUtZWRpdG9yXSBbZGF0YS1zbGF0ZS1sZWFmXSknKSA6IFtdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZWxlbWVudE5vZGUgPSBub25FZGl0YWJsZU5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cImVsZW1lbnRcIl0nKTtcbiAgICAgICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMkZmluZDtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TGVhZk5vZGVzKGVsZW1lbnROb2RlKSksIF90b0NvbnN1bWFibGVBcnJheShnZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUgPT09IG51bGwgfHwgZWxlbWVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnROb2RlLm5leHRFbGVtZW50U2libGluZykpKTtcbiAgICAgICAgICBsZWFmTm9kZSA9IChfbGVhZk5vZGVzJGZpbmQgPSBfbGVhZk5vZGVzLmZpbmQoZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FmdGVyKG5vbkVkaXRhYmxlTm9kZSwgbGVhZik7XG4gICAgICAgICAgfSkpICE9PSBudWxsICYmIF9sZWFmTm9kZXMkZmluZCAhPT0gdm9pZCAwID8gX2xlYWZOb2RlcyRmaW5kIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlczIkZmluZExhc3Q7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMyID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShnZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUgPT09IG51bGwgfHwgZWxlbWVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnROb2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpKSwgX3RvQ29uc3VtYWJsZUFycmF5KGdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSkpKTtcbiAgICAgICAgICBsZWFmTm9kZSA9IChfbGVhZk5vZGVzMiRmaW5kTGFzdCA9IF9sZWFmTm9kZXMyLmZpbmRMYXN0KGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCZWZvcmUobm9uRWRpdGFibGVOb2RlLCBsZWFmKTtcbiAgICAgICAgICB9KSkgIT09IG51bGwgJiYgX2xlYWZOb2RlczIkZmluZExhc3QgIT09IHZvaWQgMCA/IF9sZWFmTm9kZXMyJGZpbmRMYXN0IDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IGVsLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRvbU5vZGUgJiYgb2Zmc2V0ID09PSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aCAmJlxuICAgICAgLy8gQ09NUEFUOiBBbmRyb2lkIElNRXMgbWlnaHQgcmVtb3ZlIHRoZSB6ZXJvIHdpZHRoIHNwYWNlIHdoaWxlIGNvbXBvc2luZyxcbiAgICAgIC8vIGFuZCB3ZSBkb24ndCBhZGQgaXQgZm9yIGxpbmUtYnJlYWtzLlxuICAgICAgSVNfQU5EUk9JRCAmJiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICd6JyAmJiAoX2RvbU5vZGUkdGV4dENvbnRlbnQgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudCAhPT0gdm9pZCAwICYmIF9kb21Ob2RlJHRleHRDb250ZW50LnN0YXJ0c1dpdGgoXCJcXHVGRUZGXCIpICYmIChcbiAgICAgIC8vIENPTVBBVDogSWYgdGhlIHBhcmVudCBub2RlIGlzIGEgU2xhdGUgemVyby13aWR0aCBzcGFjZSwgZWRpdG9yIGlzXG4gICAgICAvLyBiZWNhdXNlIHRoZSB0ZXh0IG5vZGUgc2hvdWxkIGhhdmUgbm8gY2hhcmFjdGVycy4gSG93ZXZlciwgZHVyaW5nIElNRVxuICAgICAgLy8gY29tcG9zaXRpb24gdGhlIEFTQ0lJIGNoYXJhY3RlcnMgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIHplcm8td2lkdGhcbiAgICAgIC8vIHNwYWNlLCBzbyBzdWJ0cmFjdCAxIGZyb20gdGhlIG9mZnNldCB0byBhY2NvdW50IGZvciB0aGUgemVyby13aWR0aFxuICAgICAgLy8gc3BhY2UgY2hhcmFjdGVyLlxuICAgICAgcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpIHx8XG4gICAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGByYW5nZS5jbG9uZUNvbnRlbnRzKClgIHJldHVybnMgYW4gZXh0cmEgdHJhaWxpbmcgJ1xcbidcbiAgICAgIC8vIHdoZW4gdGhlIGRvY3VtZW50IGVuZHMgd2l0aCBhIG5ldy1saW5lIGNoYXJhY3Rlci4gVGhpcyByZXN1bHRzIGluIHRoZSBvZmZzZXRcbiAgICAgIC8vIGxlbmd0aCBiZWluZyBvZmYgYnkgb25lLCBzbyB3ZSBuZWVkIHRvIHN1YnRyYWN0IG9uZSB0byBhY2NvdW50IGZvciB0aGlzLlxuICAgICAgSVNfRklSRUZPWCAmJiAoX2RvbU5vZGUkdGV4dENvbnRlbnQyID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyLmVuZHNXaXRoKCdcXG5cXG4nKSkpIHtcbiAgICAgICAgb2Zmc2V0LS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChJU19BTkRST0lEICYmICF0ZXh0Tm9kZSAmJiAhZXhhY3RNYXRjaCkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykgPyBwYXJlbnROb2RlIDogcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlXScpO1xuICAgICAgaWYgKG5vZGUgJiYgRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBub2RlLCB7XG4gICAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgX3NsYXRlTm9kZSA9IERPTUVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIG5vZGUpO1xuICAgICAgICB2YXIgX0VkaXRvciRzdGFydCA9IHNsYXRlLkVkaXRvci5zdGFydChlZGl0b3IsIERPTUVkaXRvci5maW5kUGF0aChlZGl0b3IsIF9zbGF0ZU5vZGUpKSxcbiAgICAgICAgICBfcGF0aCA9IF9FZGl0b3Ikc3RhcnQucGF0aCxcbiAgICAgICAgICBfb2Zmc2V0ID0gX0VkaXRvciRzdGFydC5vZmZzZXQ7XG4gICAgICAgIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1sZWFmXScpKSB7XG4gICAgICAgICAgX29mZnNldCA9IG5lYXJlc3RPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgaWYgKHN1cHByZXNzVGhyb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHBvaW50IGZyb20gRE9NIHBvaW50OiBcIi5jb25jYXQoZG9tUG9pbnQpKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBJZiBzb21lb25lIGlzIGNsaWNraW5nIGZyb20gb25lIFNsYXRlIGVkaXRvciBpbnRvIGFub3RoZXIsXG4gICAgLy8gdGhlIHNlbGVjdCBldmVudCBmaXJlcyB0d2ljZSwgb25jZSBmb3IgdGhlIG9sZCBlZGl0b3IncyBgZWxlbWVudGBcbiAgICAvLyBmaXJzdCwgYW5kIHRoZW4gYWZ0ZXJ3YXJkcyBmb3IgdGhlIGNvcnJlY3QgYGVsZW1lbnRgLiAoMjAxNy8wMy8wMylcbiAgICB2YXIgc2xhdGVOb2RlID0gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGV4dE5vZGUpO1xuICAgIHZhciBwYXRoID0gRE9NRWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgfTtcbiAgfSxcbiAgdG9TbGF0ZVJhbmdlOiBmdW5jdGlvbiB0b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21SYW5nZSwgb3B0aW9ucykge1xuICAgIHZhciBfZm9jdXNOb2RlJHRleHRDb250ZW47XG4gICAgdmFyIGV4YWN0TWF0Y2ggPSBvcHRpb25zLmV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93ID0gb3B0aW9ucy5zdXBwcmVzc1Rocm93O1xuICAgIHZhciBlbCA9IGlzRE9NU2VsZWN0aW9uKGRvbVJhbmdlKSA/IGRvbVJhbmdlLmFuY2hvck5vZGUgOiBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgYW5jaG9yTm9kZTtcbiAgICB2YXIgYW5jaG9yT2Zmc2V0O1xuICAgIHZhciBmb2N1c05vZGU7XG4gICAgdmFyIGZvY3VzT2Zmc2V0O1xuICAgIHZhciBpc0NvbGxhcHNlZDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChpc0RPTVNlbGVjdGlvbihkb21SYW5nZSkpIHtcbiAgICAgICAgLy8gQ09NUEFUOiBJbiBmaXJlZm94IHRoZSBub3JtYWwgc2VsZXRpb24gd2F5IGRvZXMgbm90IHdvcmtcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzU0ODYjaXNzdWUtMTgyMDcyMDIyMylcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZG9tUmFuZ2UucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7IC8vIEZvY3VzIG5vZGUgd29ya3MgZmluZVxuICAgICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdChkb21SYW5nZS5yYW5nZUNvdW50IC0gMSk7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBhcmUgaW4gdGhlIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9mIGEgdGFibGUgaW4gZmlyZWZveFxuICAgICAgICAgIGlmIChmb2N1c05vZGUgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGxhc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEhUTUxFbGVtZW50LCBiZWNvdXNlIEVsZW1lbnQgaXMgYSBzbGF0ZSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgZ2V0TGFzdENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0TGFzdENoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldExhc3RDaGlsZHJlbihlbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGVSb3cgPSBmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlUm93ID0gbGFzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgZmFpbCBhcyBcIlRoZSBIVE1MRWxlbWVudCBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbnkgSFRNTCBlbGVtZW50LlwiXG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gZ2V0TGFzdENoaWxkcmVuKGZpcnN0Tm9kZVJvdy5jaGlsZHJlbltmaXJzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSBnZXRMYXN0Q2hpbGRyZW4obGFzdE5vZGVSb3cuY2hpbGRyZW5bbGFzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7XG4gICAgICAgICAgICAvLyBaZXJvLCBhcyB3ZSBhbGx3YXlzIHRha2UgdGhlIHJpZ2h0IG9uZSBhcyB0aGUgYW5jaG9yIHBvaW50XG4gICAgICAgICAgICBmb2N1c09mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0Tm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9jdXNOb2RlID0gZmlyc3ROb2RlLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmaXJzdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBsYXN0Tm9kZS5pbm5lckhUTUwubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgb3B0aW9uXG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJlYWQgb25seSBtb2RlIG9mIGEgZmlyZWZveCB0YWJsZVxuICAgICAgICAgICAgLy8gUmlnaHQgdG8gbGVmdFxuICAgICAgICAgICAgaWYgKGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdFJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdFJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSBmaXJzdFJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTGVmdCB0byByaWdodFxuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZmlyc3RSYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gbGFzdFJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2UuYW5jaG9yTm9kZTtcbiAgICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5hbmNob3JPZmZzZXQ7XG4gICAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZm9jdXNOb2RlO1xuICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBUaGVyZSdzIGEgYnVnIGluIGNocm9tZSB0aGF0IGFsd2F5cyByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgICAgLy8gYGlzQ29sbGFwc2VkYCBmb3IgYSBTZWxlY3Rpb24gdGhhdCBjb21lcyBmcm9tIGEgU2hhZG93Um9vdC5cbiAgICAgICAgLy8gKDIwMjAvMDgvMDgpXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuICAgICAgICAvLyBJc0NvbGxhcHNlZCBtaWdodCBub3Qgd29yayBpbiBmaXJlZm94LCBidXQgdGhpcyB3aWxsXG4gICAgICAgIGlmIChJU19DSFJPTUUgJiYgaGFzU2hhZG93Um9vdChhbmNob3JOb2RlKSB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5hbmNob3JOb2RlID09PSBkb21SYW5nZS5mb2N1c05vZGUgJiYgZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0ID09PSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmlzQ29sbGFwc2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmNvbGxhcHNlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuY2hvck5vZGUgPT0gbnVsbCB8fCBmb2N1c05vZGUgPT0gbnVsbCB8fCBhbmNob3JPZmZzZXQgPT0gbnVsbCB8fCBmb2N1c09mZnNldCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gRE9NIHJhbmdlOiBcIi5jb25jYXQoZG9tUmFuZ2UpKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBGaXJlZm94IHNvbWV0aW1lcyBpbmNsdWRlcyBhbiBleHRyYSBcXG4gKHJlbmRlcmVkIGJ5IFRleHRTdHJpbmdcbiAgICAvLyB3aGVuIGlzVHJhaWxpbmcgaXMgdHJ1ZSkgaW4gdGhlIGZvY3VzT2Zmc2V0LCByZXN1bHRpbmcgaW4gYW4gaW52YWxpZFxuICAgIC8vIFNsYXRlIHBvaW50LiAoMjAyMy8xMS8wMSlcbiAgICBpZiAoSVNfRklSRUZPWCAmJiAoX2ZvY3VzTm9kZSR0ZXh0Q29udGVuID0gZm9jdXNOb2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZm9jdXNOb2RlJHRleHRDb250ZW4gIT09IHZvaWQgMCAmJiBfZm9jdXNOb2RlJHRleHRDb250ZW4uZW5kc1dpdGgoJ1xcblxcbicpICYmIGZvY3VzT2Zmc2V0ID09PSBmb2N1c05vZGUudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICBmb2N1c09mZnNldC0tO1xuICAgIH1cbiAgICB2YXIgYW5jaG9yID0gRE9NRWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoOiBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvdzogc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGZvY3VzQmVmb3JlQW5jaG9yID0gaXNCZWZvcmUoYW5jaG9yTm9kZSwgZm9jdXNOb2RlKSB8fCBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgZm9jdXNPZmZzZXQgPCBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzID0gaXNDb2xsYXBzZWQgPyBhbmNob3IgOiBET01FZGl0b3IudG9TbGF0ZVBvaW50KGVkaXRvciwgW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoOiBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvdzogc3VwcHJlc3NUaHJvdyxcbiAgICAgIHNlYXJjaERpcmVjdGlvbjogZm9jdXNCZWZvcmVBbmNob3IgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnXG4gICAgfSk7XG4gICAgaWYgKCFmb2N1cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByYW5nZSA9IHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGZvY3VzXG4gICAgfTtcbiAgICAvLyBpZiB0aGUgc2VsZWN0aW9uIGlzIGEgaGFuZ2luZyByYW5nZSB0aGF0IGVuZHMgaW4gYSB2b2lkXG4gICAgLy8gYW5kIHRoZSBET00gZm9jdXMgaXMgYW4gRWxlbWVudFxuICAgIC8vIChtZWFuaW5nIHRoYXQgdGhlIHNlbGVjdGlvbiBlbmRzIGJlZm9yZSB0aGUgZWxlbWVudClcbiAgICAvLyB1bmhhbmcgdGhlIHJhbmdlIHRvIGF2b2lkIG1pc3Rha2VubHkgaW5jbHVkaW5nIHRoZSB2b2lkXG4gICAgaWYgKHNsYXRlLlJhbmdlLmlzRXhwYW5kZWQocmFuZ2UpICYmIHNsYXRlLlJhbmdlLmlzRm9yd2FyZChyYW5nZSkgJiYgaXNET01FbGVtZW50KGZvY3VzTm9kZSkgJiYgc2xhdGUuRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZS5mb2N1cyxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSB7XG4gICAgICByYW5nZSA9IHNsYXRlLkVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCB7XG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSB0ZXh0IGRpZmYgd2FzIGFwcGxpZWQgaW4gYSB3YXkgd2UgY2FuIHBlcmZvcm0gdGhlIHBlbmRpbmcgYWN0aW9uIG9uIC9cbiAqIHJlY292ZXIgdGhlIHBlbmRpbmcgc2VsZWN0aW9uLlxuICovXG5mdW5jdGlvbiB2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCB0ZXh0RGlmZikge1xuICB2YXIgcGF0aCA9IHRleHREaWZmLnBhdGgsXG4gICAgZGlmZiA9IHRleHREaWZmLmRpZmY7XG4gIGlmICghc2xhdGUuRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbm9kZSA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIGlmICghc2xhdGUuVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRpZmYuc3RhcnQgIT09IG5vZGUudGV4dC5sZW5ndGggfHwgZGlmZi50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBub2RlLnRleHQuc2xpY2UoZGlmZi5zdGFydCwgZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpID09PSBkaWZmLnRleHQ7XG4gIH1cbiAgdmFyIG5leHRQYXRoID0gc2xhdGUuUGF0aC5uZXh0KHBhdGgpO1xuICBpZiAoIXNsYXRlLkVkaXRvci5oYXNQYXRoKGVkaXRvciwgbmV4dFBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuZXh0Tm9kZSA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgbmV4dFBhdGgpO1xuICByZXR1cm4gc2xhdGUuVGV4dC5pc1RleHQobmV4dE5vZGUpICYmIG5leHROb2RlLnRleHQuc3RhcnRzV2l0aChkaWZmLnRleHQpO1xufVxuZnVuY3Rpb24gYXBwbHlTdHJpbmdEaWZmKHRleHQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRpZmZzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBkaWZmc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGRpZmZzLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgZGlmZikge1xuICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIGRpZmYuc3RhcnQpICsgZGlmZi50ZXh0ICsgdGV4dC5zbGljZShkaWZmLmVuZCk7XG4gIH0sIHRleHQpO1xufVxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChzdHIsIGFub3RoZXIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KGkpICE9PSBhbm90aGVyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHN0ciwgYW5vdGhlciwgbWF4KSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCwgbWF4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KHN0ci5sZW5ndGggLSBpIC0gMSkgIT09IGFub3RoZXIuY2hhckF0KGFub3RoZXIubGVuZ3RoIC0gaSAtIDEpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogUmVtb3ZlIHJlZHVuZGFudCBjaGFuZ2VzIGZyb20gdGhlIGRpZmYgc28gdGhhdCBpdCBzcGFucyB0aGUgbWluaW1hbCBwb3NzaWJsZSByYW5nZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIGRpZmYpIHtcbiAgdmFyIHN0YXJ0ID0gZGlmZi5zdGFydCxcbiAgICBlbmQgPSBkaWZmLmVuZCxcbiAgICB0ZXh0ID0gZGlmZi50ZXh0O1xuICB2YXIgcmVtb3ZlZFRleHQgPSB0YXJnZXRUZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcHJlZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCk7XG4gIHZhciBtYXggPSBNYXRoLm1pbihyZW1vdmVkVGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoKTtcbiAgdmFyIHN1ZmZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQsIG1heCk7XG4gIHZhciBub3JtYWxpemVkID0ge1xuICAgIHN0YXJ0OiBzdGFydCArIHByZWZpeExlbmd0aCxcbiAgICBlbmQ6IGVuZCAtIHN1ZmZpeExlbmd0aCxcbiAgICB0ZXh0OiB0ZXh0LnNsaWNlKHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBzdWZmaXhMZW5ndGgpXG4gIH07XG4gIGlmIChub3JtYWxpemVkLnN0YXJ0ID09PSBub3JtYWxpemVkLmVuZCAmJiBub3JtYWxpemVkLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG4vKipcbiAqIFJldHVybiBhIHN0cmluZyBkaWZmIHRoYXQgaXMgZXF1aXZhbGVudCB0byBhcHBseWluZyBiIGFmdGVyIGEgc3Bhbm5pbmcgdGhlIHJhbmdlIG9mXG4gKiBib3RoIGNoYW5nZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTdHJpbmdEaWZmcyh0YXJnZXRUZXh0LCBhLCBiKSB7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKGEuc3RhcnQsIGIuc3RhcnQpO1xuICB2YXIgb3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoLCBiLmVuZCkgLSBiLnN0YXJ0KTtcbiAgdmFyIGFwcGxpZWQgPSBhcHBseVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgYSwgYik7XG4gIHZhciBzbGljZUVuZCA9IE1hdGgubWF4KGIuc3RhcnQgKyBiLnRleHQubGVuZ3RoLCBhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCArIChhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCA+IGIuc3RhcnQgPyBiLnRleHQubGVuZ3RoIDogMCkgLSBvdmVybGFwKTtcbiAgdmFyIHRleHQgPSBhcHBsaWVkLnNsaWNlKHN0YXJ0LCBzbGljZUVuZCk7XG4gIHZhciBlbmQgPSBNYXRoLm1heChhLmVuZCwgYi5lbmQgLSBhLnRleHQubGVuZ3RoICsgKGEuZW5kIC0gYS5zdGFydCkpO1xuICByZXR1cm4gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXRUZXh0LCB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kLFxuICAgIHRleHQ6IHRleHRcbiAgfSk7XG59XG4vKipcbiAqIEdldCB0aGUgc2xhdGUgcmFuZ2UgdGhlIHRleHQgZGlmZiBzcGFucy5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0UmFuZ2UodGV4dERpZmYpIHtcbiAgdmFyIHBhdGggPSB0ZXh0RGlmZi5wYXRoLFxuICAgIGRpZmYgPSB0ZXh0RGlmZi5kaWZmO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcjoge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuZW5kXG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSAncGVuZGluZyBwb2ludCcgYS5rLmEgYSBwb2ludCBiYXNlZCBvbiB0aGUgZG9tIHN0YXRlIGJlZm9yZSBhcHBseWluZ1xuICogdGhlIHBlbmRpbmcgZGlmZnMuIFNpbmNlIHRoZSBwZW5kaW5nIGRpZmZzIG1pZ2h0IGhhdmUgYmVlbiBpbnNlcnRlZCB3aXRoIGRpZmZlcmVudFxuICogbWFya3Mgd2UgaGF2ZSB0byAnd2FsaycgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydGluZyBwb3NpdGlvbiB0byBlbnN1cmUgd2Ugc3RpbGxcbiAqIGhhdmUgYSB2YWxpZCBwb2ludCBpbnNpZGUgdGhlIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcG9pbnQpIHtcbiAgdmFyIHBhdGggPSBwb2ludC5wYXRoLFxuICAgIG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgaWYgKCFzbGF0ZS5FZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxlYWYgPSBzbGF0ZS5Ob2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICBpZiAoIXNsYXRlLlRleHQuaXNUZXh0KGxlYWYpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBhcmVudEJsb2NrID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICByZXR1cm4gc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobikgJiYgc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9LFxuICAgIGF0OiBwYXRoXG4gIH0pO1xuICBpZiAoIXBhcmVudEJsb2NrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+IGxlYWYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBzbGF0ZS5FZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IHNsYXRlLlRleHQuaXNUZXh0XG4gICAgfSk7XG4gICAgaWYgKCFlbnRyeSB8fCAhc2xhdGUuUGF0aC5pc0Rlc2NlbmRhbnQoZW50cnlbMV0sIHBhcmVudEJsb2NrWzFdKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9mZnNldCAtPSBsZWFmLnRleHQubGVuZ3RoO1xuICAgIGxlYWYgPSBlbnRyeVswXTtcbiAgICBwYXRoID0gZW50cnlbMV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhICdwZW5kaW5nIHNlbGVjdGlvbicgdG8gZW5zdXJlIGl0J3MgdmFsaWQgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIGFuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yKTtcbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cbiAgdmFyIGZvY3VzID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5mb2N1cyk7XG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuY2hvcjogYW5jaG9yLFxuICAgIGZvY3VzOiBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcG9pbnQsIG9wKSB7XG4gIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKTtcbiAgdmFyIHRleHREaWZmID0gcGVuZGluZ0RpZmZzID09PSBudWxsIHx8IHBlbmRpbmdEaWZmcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0RpZmZzLmZpbmQoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgcGF0aCA9IF9yZWYucGF0aDtcbiAgICByZXR1cm4gc2xhdGUuUGF0aC5lcXVhbHMocGF0aCwgcG9pbnQucGF0aCk7XG4gIH0pO1xuICBpZiAoIXRleHREaWZmIHx8IHBvaW50Lm9mZnNldCA8PSB0ZXh0RGlmZi5kaWZmLnN0YXJ0KSB7XG4gICAgcmV0dXJuIHNsYXRlLlBvaW50LnRyYW5zZm9ybShwb2ludCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cbiAgdmFyIGRpZmYgPSB0ZXh0RGlmZi5kaWZmO1xuICAvLyBQb2ludCByZWZlcmVuY2VzIGxvY2F0aW9uIGluc2lkZSB0aGUgZGlmZiA9PiB0cmFuc2Zvcm0gdGhlIHBvaW50IGJhc2VkIG9uIHRoZSBsb2NhdGlvblxuICAvLyB0aGUgZGlmZiB3aWxsIGJlIGFwcGxpZWQgdG8gYW5kIGFkZCB0aGUgb2Zmc2V0IGluc2lkZSB0aGUgZGlmZi5cbiAgaWYgKHBvaW50Lm9mZnNldCA8PSBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBfYW5jaG9yID0ge1xuICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH07XG4gICAgdmFyIF90cmFuc2Zvcm1lZCA9IHNsYXRlLlBvaW50LnRyYW5zZm9ybShfYW5jaG9yLCBvcCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgICBpZiAoIV90cmFuc2Zvcm1lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBfdHJhbnNmb3JtZWQucGF0aCxcbiAgICAgIG9mZnNldDogX3RyYW5zZm9ybWVkLm9mZnNldCArIHBvaW50Lm9mZnNldCAtIGRpZmYuc3RhcnRcbiAgICB9O1xuICB9XG4gIC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gYWZ0ZXIgdGhlIGRpZmZcbiAgdmFyIGFuY2hvciA9IHtcbiAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgIG9mZnNldDogcG9pbnQub2Zmc2V0IC0gZGlmZi50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kIC0gZGlmZi5zdGFydFxuICB9O1xuICB2YXIgdHJhbnNmb3JtZWQgPSBzbGF0ZS5Qb2ludC50cmFuc2Zvcm0oYW5jaG9yLCBvcCwge1xuICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gIH0pO1xuICBpZiAoIXRyYW5zZm9ybWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wLnR5cGUgPT09ICdzcGxpdF9ub2RlJyAmJiBzbGF0ZS5QYXRoLmVxdWFscyhvcC5wYXRoLCBwb2ludC5wYXRoKSAmJiBhbmNob3Iub2Zmc2V0IDwgb3AucG9zaXRpb24gJiYgZGlmZi5zdGFydCA8IG9wLnBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aDogdHJhbnNmb3JtZWQucGF0aCxcbiAgICBvZmZzZXQ6IHRyYW5zZm9ybWVkLm9mZnNldCArIGRpZmYudGV4dC5sZW5ndGggLSBkaWZmLmVuZCArIGRpZmYuc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcCkge1xuICB2YXIgYW5jaG9yID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yLCBvcCk7XG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBhbmNob3JcbiAgICB9O1xuICB9XG4gIHZhciBmb2N1cyA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmZvY3VzLCBvcCk7XG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuY2hvcjogYW5jaG9yLFxuICAgIGZvY3VzOiBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSB7XG4gIHZhciBwYXRoID0gdGV4dERpZmYucGF0aCxcbiAgICBkaWZmID0gdGV4dERpZmYuZGlmZixcbiAgICBpZCA9IHRleHREaWZmLmlkO1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghc2xhdGUuUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5vZmZzZXQgPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogb3AudGV4dC5sZW5ndGggKyBkaWZmLmVuZCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghc2xhdGUuUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICBpZiAoIXNsYXRlLlBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLnBvc2l0aW9uID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IGRpZmYsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBzbGF0ZS5QYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5wb3NpdGlvbiA+IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBNYXRoLm1pbihvcC5wb3NpdGlvbiwgZGlmZi5lbmQpLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0IC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXRoOiBzbGF0ZS5QYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghc2xhdGUuUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjogZGlmZixcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhdGg6IHNsYXRlLlBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogc2xhdGUuUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgIH07XG4gICAgICB9XG4gIH1cbiAgdmFyIG5ld1BhdGggPSBzbGF0ZS5QYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gIGlmICghbmV3UGF0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGlmZjogZGlmZixcbiAgICBwYXRoOiBuZXdQYXRoLFxuICAgIGlkOiBpZFxuICB9O1xufVxuXG4vKipcbiAqIFV0aWxpdGllcyBmb3Igc2luZ2xlLWxpbmUgZGVsZXRpb25cbiAqL1xudmFyIGRvUmVjdHNJbnRlcnNlY3QgPSBmdW5jdGlvbiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QsIGNvbXBhcmVSZWN0KSB7XG4gIHZhciBtaWRkbGUgPSAoY29tcGFyZVJlY3QudG9wICsgY29tcGFyZVJlY3QuYm90dG9tKSAvIDI7XG4gIHJldHVybiByZWN0LnRvcCA8PSBtaWRkbGUgJiYgcmVjdC5ib3R0b20gPj0gbWlkZGxlO1xufTtcbnZhciBhcmVSYW5nZXNTYW1lTGluZSA9IGZ1bmN0aW9uIGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgcmFuZ2UxLCByYW5nZTIpIHtcbiAgdmFyIHJlY3QxID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgcmVjdDIgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QxLCByZWN0MikgJiYgZG9SZWN0c0ludGVyc2VjdChyZWN0MiwgcmVjdDEpO1xufTtcbi8qKlxuICogQSBoZWxwZXIgdXRpbGl0eSB0aGF0IHJldHVybnMgdGhlIGVuZCBwb3J0aW9uIG9mIGEgYFJhbmdlYFxuICogd2hpY2ggaXMgbG9jYXRlZCBvbiBhIHNpbmdsZSBsaW5lLlxuICpcbiAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3IgVGhlIGVkaXRvciBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAcGFyYW0ge1JhbmdlfSBwYXJlbnRSYW5nZSBUaGUgcGFyZW50IHJhbmdlIHRvIGNvbXBhcmUgYWdhaW5zdFxuICogQHJldHVybnMge1JhbmdlfSBBIHZhbGlkIHBvcnRpb24gb2YgdGhlIHBhcmVudFJhbmdlIHdoaWNoIGlzIG9uZSBhIHNpbmdsZSBsaW5lXG4gKi9cbnZhciBmaW5kQ3VycmVudExpbmVSYW5nZSA9IGZ1bmN0aW9uIGZpbmRDdXJyZW50TGluZVJhbmdlKGVkaXRvciwgcGFyZW50UmFuZ2UpIHtcbiAgdmFyIHBhcmVudFJhbmdlQm91bmRhcnkgPSBzbGF0ZS5FZGl0b3IucmFuZ2UoZWRpdG9yLCBzbGF0ZS5SYW5nZS5lbmQocGFyZW50UmFuZ2UpKTtcbiAgdmFyIHBvc2l0aW9ucyA9IEFycmF5LmZyb20oc2xhdGUuRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIHtcbiAgICBhdDogcGFyZW50UmFuZ2VcbiAgfSkpO1xuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHJpZ2h0IC8gMik7XG4gIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIHNsYXRlLkVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgcmV0dXJuIHNsYXRlLkVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHNsYXRlLkVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoIC0gMV0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG4gIHdoaWxlIChtaWRkbGUgIT09IHBvc2l0aW9ucy5sZW5ndGggJiYgbWlkZGxlICE9PSBsZWZ0KSB7XG4gICAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW21pZGRsZV0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgICAgcmlnaHQgPSBtaWRkbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBtaWRkbGU7XG4gICAgfVxuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuICByZXR1cm4gc2xhdGUuRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3JpZ2h0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBgd2l0aERPTWAgYWRkcyBET00gc3BlY2lmaWMgYmVoYXZpb3JzIHRvIHRoZSBlZGl0b3IuXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcbiAqIHRoaXMgcGx1Z2luLlxuICpcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXG4gKi9cbnZhciB3aXRoRE9NID0gZnVuY3Rpb24gd2l0aERPTShlZGl0b3IpIHtcbiAgdmFyIGNsaXBib2FyZEZvcm1hdEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gtc2xhdGUtZnJhZ21lbnQnO1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIGFwcGx5ID0gZS5hcHBseSxcbiAgICBvbkNoYW5nZSA9IGUub25DaGFuZ2UsXG4gICAgZGVsZXRlQmFja3dhcmQgPSBlLmRlbGV0ZUJhY2t3YXJkLFxuICAgIGFkZE1hcmsgPSBlLmFkZE1hcmssXG4gICAgcmVtb3ZlTWFyayA9IGUucmVtb3ZlTWFyaztcbiAgLy8gVGhlIFdlYWtNYXAgd2hpY2ggbWFwcyBhIGtleSB0byBhIHNwZWNpZmljIEhUTUxFbGVtZW50IG11c3QgYmUgc2NvcGVkIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UgdG9cbiAgLy8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGVkaXRvcnMgaW4gdGhlIERPTSB0aGF0IHNoYXJlIHRoZSBzYW1lIHZhbHVlLlxuICBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuc2V0KGUsIG5ldyBXZWFrTWFwKCkpO1xuICBlLmFkZE1hcmsgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBfRURJVE9SX1RPX1NDSEVEVUxFX0YsIF9FRElUT1JfVE9fUEVORElOR19ESTtcbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GKCk7XG4gICAgaWYgKCFFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGUpICYmIChfRURJVE9SX1RPX1BFTkRJTkdfREkgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSkpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESSAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESS5sZW5ndGgpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGUgY3VycmVudCBwZW5kaW5nIGRpZmZzIG9yaWdpbmF0aW5nIGZyb20gY2hhbmdlcyBiZWZvcmUgdGhlIGFkZE1hcmtcbiAgICAgIC8vIGFyZSBhcHBsaWVkIHdpdGggdGhlIGN1cnJlbnQgZm9ybWF0dGluZ1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlLCBudWxsKTtcbiAgICB9XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1NbXCJkZWxldGVcIl0oZSk7XG4gICAgYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfTtcbiAgZS5yZW1vdmVNYXJrID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkyO1xuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMiAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuICAgIEVESVRPUl9UT19VU0VSX01BUktTW1wiZGVsZXRlXCJdKGUpO1xuICAgIHJlbW92ZU1hcmsoa2V5KTtcbiAgfTtcbiAgZS5kZWxldGVCYWNrd2FyZCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgaWYgKHVuaXQgIT09ICdsaW5lJykge1xuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICAgIH1cbiAgICBpZiAoZS5zZWxlY3Rpb24gJiYgc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQoZS5zZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgcGFyZW50QmxvY2tFbnRyeSA9IHNsYXRlLkVkaXRvci5hYm92ZShlLCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KG4pICYmIHNsYXRlLkVkaXRvci5pc0Jsb2NrKGUsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBhdDogZS5zZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgaWYgKHBhcmVudEJsb2NrRW50cnkpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRCbG9ja0VudHJ5ID0gX3NsaWNlZFRvQXJyYXkocGFyZW50QmxvY2tFbnRyeSwgMiksXG4gICAgICAgICAgcGFyZW50QmxvY2tQYXRoID0gX3BhcmVudEJsb2NrRW50cnlbMV07XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50UmFuZ2UgPSBzbGF0ZS5FZGl0b3IucmFuZ2UoZSwgcGFyZW50QmxvY2tQYXRoLCBlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICB2YXIgY3VycmVudExpbmVSYW5nZSA9IGZpbmRDdXJyZW50TGluZVJhbmdlKGUsIHBhcmVudEVsZW1lbnRSYW5nZSk7XG4gICAgICAgIGlmICghc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQoY3VycmVudExpbmVSYW5nZSkpIHtcbiAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGUsIHtcbiAgICAgICAgICAgIGF0OiBjdXJyZW50TGluZVJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoaXMgYXR0ZW1wdHMgdG8gcmVzZXQgdGhlIE5PREVfVE9fS0VZIGVudHJ5IHRvIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGFzIGFwcGx5KCkgY2hhbmdlcyB0aGUgb2JqZWN0IHJlZmVyZW5jZSBhbmQgaGVuY2UgaW52YWxpZGF0ZXMgdGhlIE5PREVfVE9fS0VZIGVudHJ5XG4gIGUuYXBwbHkgPSBmdW5jdGlvbiAob3ApIHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBwYXRoUmVmTWF0Y2hlcyA9IFtdO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSk7XG4gICAgaWYgKHBlbmRpbmdEaWZmcyAhPT0gbnVsbCAmJiBwZW5kaW5nRGlmZnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nRGlmZnMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBwZW5kaW5nRGlmZnMubWFwKGZ1bmN0aW9uICh0ZXh0RGlmZikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKTtcbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlLCB0cmFuc2Zvcm1lZCk7XG4gICAgfVxuICAgIHZhciBwZW5kaW5nU2VsZWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlKTtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlLCB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ1NlbGVjdGlvbiwgb3ApKTtcbiAgICB9XG4gICAgdmFyIHBlbmRpbmdBY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGUpO1xuICAgIGlmIChwZW5kaW5nQWN0aW9uICE9PSBudWxsICYmIHBlbmRpbmdBY3Rpb24gIT09IHZvaWQgMCAmJiBwZW5kaW5nQWN0aW9uLmF0KSB7XG4gICAgICB2YXIgYXQgPSBzbGF0ZS5Qb2ludC5pc1BvaW50KHBlbmRpbmdBY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ0FjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0FjdGlvbi5hdCkgPyB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApIDogdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGUsIHBlbmRpbmdBY3Rpb24uYXQsIG9wKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5zZXQoZSwgYXQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBlbmRpbmdBY3Rpb24pLCB7fSwge1xuICAgICAgICBhdDogYXRcbiAgICAgIH0pIDogbnVsbCk7XG4gICAgfVxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2guYXBwbHkobWF0Y2hlcywgX3RvQ29uc3VtYWJsZUFycmF5KGdldE1hdGNoZXMoZSwgb3AucGF0aCkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0VESVRPUl9UT19VU0VSX1NFTEVDO1xuICAgICAgICAgIC8vIFNlbGVjdGlvbiB3YXMgbWFudWFsbHkgc2V0LCBkb24ndCByZXN0b3JlIHRoZSB1c2VyIHNlbGVjdGlvbiBhZnRlciB0aGUgY2hhbmdlLlxuICAgICAgICAgIChfRURJVE9SX1RPX1VTRVJfU0VMRUMgPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZ2V0KGUpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMgPT09IHZvaWQgMCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMudW5yZWYoKTtcbiAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT05bXCJkZWxldGVcIl0oZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TWF0Y2hlcyhlLCBzbGF0ZS5QYXRoLnBhcmVudChvcC5wYXRoKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJldlBhdGggPSBzbGF0ZS5QYXRoLnByZXZpb3VzKG9wLnBhdGgpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TWF0Y2hlcyhlLCBwcmV2UGF0aCkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb21tb25QYXRoID0gc2xhdGUuUGF0aC5jb21tb24oc2xhdGUuUGF0aC5wYXJlbnQob3AucGF0aCksIHNsYXRlLlBhdGgucGFyZW50KG9wLm5ld1BhdGgpKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2guYXBwbHkobWF0Y2hlcywgX3RvQ29uc3VtYWJsZUFycmF5KGdldE1hdGNoZXMoZSwgY29tbW9uUGF0aCkpKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZFBhdGg7XG4gICAgICAgICAgaWYgKHNsYXRlLlBhdGguaXNCZWZvcmUob3AucGF0aCwgb3AubmV3UGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaC5hcHBseShtYXRjaGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0TWF0Y2hlcyhlLCBzbGF0ZS5QYXRoLnBhcmVudChvcC5wYXRoKSkpKTtcbiAgICAgICAgICAgIGNoYW5nZWRQYXRoID0gb3AubmV3UGF0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoLmFwcGx5KG1hdGNoZXMsIF90b0NvbnN1bWFibGVBcnJheShnZXRNYXRjaGVzKGUsIHNsYXRlLlBhdGgucGFyZW50KG9wLm5ld1BhdGgpKSkpO1xuICAgICAgICAgICAgY2hhbmdlZFBhdGggPSBvcC5wYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBzbGF0ZS5Ob2RlLmdldChlZGl0b3IsIHNsYXRlLlBhdGgucGFyZW50KGNoYW5nZWRQYXRoKSk7XG4gICAgICAgICAgdmFyIGNoYW5nZWROb2RlS2V5ID0gRE9NRWRpdG9yLmZpbmRLZXkoZSwgY2hhbmdlZE5vZGUpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkUGF0aFJlZiA9IHNsYXRlLkVkaXRvci5wYXRoUmVmKGUsIHNsYXRlLlBhdGgucGFyZW50KGNoYW5nZWRQYXRoKSk7XG4gICAgICAgICAgcGF0aFJlZk1hdGNoZXMucHVzaChbY2hhbmdlZFBhdGhSZWYsIGNoYW5nZWROb2RlS2V5XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHkob3ApO1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEZJWE1FOiBSZW5hbWUgdG8gc29tZXRoaW5nIGxpa2UgSVNfRE9NX0VESVRPUl9ERVNZTkNFRFxuICAgICAgICAgIC8vIHRvIGJldHRlciByZWZsZWN0IHJlYWxpdHksIHNlZSAjNTc5MlxuICAgICAgICAgIElTX05PREVfTUFQX0RJUlRZLnNldChlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9tYXRjaGVzID0gbWF0Y2hlczsgX2kgPCBfbWF0Y2hlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbWF0Y2hlcyRfaSA9IF9zbGljZWRUb0FycmF5KF9tYXRjaGVzW19pXSwgMiksXG4gICAgICAgIHBhdGggPSBfbWF0Y2hlcyRfaVswXSxcbiAgICAgICAga2V5ID0gX21hdGNoZXMkX2lbMV07XG4gICAgICB2YXIgX0VkaXRvciRub2RlID0gc2xhdGUuRWRpdG9yLm5vZGUoZSwgcGF0aCksXG4gICAgICAgIF9FZGl0b3Ikbm9kZTIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUsIDEpLFxuICAgICAgICBub2RlID0gX0VkaXRvciRub2RlMlswXTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfcGF0aFJlZk1hdGNoZXMgPSBwYXRoUmVmTWF0Y2hlczsgX2kyIDwgX3BhdGhSZWZNYXRjaGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfcGF0aFJlZk1hdGNoZXMkX2kgPSBfc2xpY2VkVG9BcnJheShfcGF0aFJlZk1hdGNoZXNbX2kyXSwgMiksXG4gICAgICAgIHBhdGhSZWYgPSBfcGF0aFJlZk1hdGNoZXMkX2lbMF0sXG4gICAgICAgIF9rZXkgPSBfcGF0aFJlZk1hdGNoZXMkX2lbMV07XG4gICAgICBpZiAocGF0aFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHZhciBfRWRpdG9yJG5vZGUzID0gc2xhdGUuRWRpdG9yLm5vZGUoZSwgcGF0aFJlZi5jdXJyZW50KSxcbiAgICAgICAgICBfRWRpdG9yJG5vZGU0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlMywgMSksXG4gICAgICAgICAgX25vZGUgPSBfRWRpdG9yJG5vZGU0WzBdO1xuICAgICAgICBOT0RFX1RPX0tFWS5zZXQoX25vZGUsIF9rZXkpO1xuICAgICAgfVxuICAgICAgcGF0aFJlZi51bnJlZigpO1xuICAgIH1cbiAgfTtcbiAgZS5zZXRGcmFnbWVudERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlLnNlbGVjdGlvbjtcbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX1JhbmdlJGVkZ2VzID0gc2xhdGUuUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKSxcbiAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcbiAgICB2YXIgc3RhcnRWb2lkID0gc2xhdGUuRWRpdG9yW1widm9pZFwiXShlLCB7XG4gICAgICBhdDogc3RhcnQucGF0aFxuICAgIH0pO1xuICAgIHZhciBlbmRWb2lkID0gc2xhdGUuRWRpdG9yW1widm9pZFwiXShlLCB7XG4gICAgICBhdDogZW5kLnBhdGhcbiAgICB9KTtcbiAgICBpZiAoc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGZha2Ugc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBhIEJhc2U2NC1lbmNvZGVkIGNvcHkgb2YgdGhlXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIEhUTUwsIHRvIGRlY29kZSBvbiBmdXR1cmUgcGFzdGVzLlxuICAgIHZhciBkb21SYW5nZSA9IERPTUVkaXRvci50b0RPTVJhbmdlKGUsIHNlbGVjdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgIHZhciBhdHRhY2ggPSBjb250ZW50cy5jaGlsZE5vZGVzWzBdO1xuICAgIC8vIE1ha2Ugc3VyZSBhdHRhY2ggaXMgbm9uLWVtcHR5LCBzaW5jZSBlbXB0eSBub2RlcyB3aWxsIG5vdCBnZXQgY29waWVkLlxuICAgIGNvbnRlbnRzLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUudGV4dENvbnRlbnQgJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIGF0dGFjaCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQ09NUEFUOiBJZiB0aGUgZW5kIG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gbW92ZSB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIHJhbmdlIGZyb20gdGhlIHZvaWQgbm9kZSdzIHNwYWNlciBzcGFuLCB0byB0aGUgZW5kIG9mIHRoZSB2b2lkIG5vZGUnc1xuICAgIC8vIGNvbnRlbnQsIHNpbmNlIHRoZSBzcGFjZXIgaXMgYmVmb3JlIHZvaWQncyBjb250ZW50IGluIHRoZSBET00uXG4gICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgIHZhciBfZW5kVm9pZCA9IF9zbGljZWRUb0FycmF5KGVuZFZvaWQsIDEpLFxuICAgICAgICB2b2lkTm9kZSA9IF9lbmRWb2lkWzBdO1xuICAgICAgdmFyIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICB2YXIgZG9tTm9kZSA9IERPTUVkaXRvci50b0RPTU5vZGUoZSwgdm9pZE5vZGUpO1xuICAgICAgci5zZXRFbmRBZnRlcihkb21Ob2RlKTtcbiAgICAgIGNvbnRlbnRzID0gci5jbG9uZUNvbnRlbnRzKCk7XG4gICAgfVxuICAgIC8vIENPTVBBVDogSWYgdGhlIHN0YXJ0IG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gYXR0YWNoIHRoZSBlbmNvZGVkXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIHZvaWQgbm9kZSdzIGNvbnRlbnQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBzcGFjZXIsIGJlY2F1c2VcbiAgICAvLyBhdHRhY2hpbmcgaXQgdG8gZW1wdHkgYDxkaXY+LzxzcGFuPmAgbm9kZXMgd2lsbCBlbmQgdXAgaGF2aW5nIGl0IGVyYXNlZCBieVxuICAgIC8vIG1vc3QgYnJvd3NlcnMuICgyMDE4LzA0LzI3KVxuICAgIGlmIChzdGFydFZvaWQpIHtcbiAgICAgIGF0dGFjaCA9IGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLXNwYWNlcl0nKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFueSB6ZXJvLXdpZHRoIHNwYWNlIHNwYW5zIGZyb20gdGhlIGNsb25lZCBET00gc28gdGhhdCB0aGV5IGRvbid0XG4gICAgLy8gc2hvdyB1cCBlbHNld2hlcmUgd2hlbiBwYXN0ZWQuXG4gICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKS5mb3JFYWNoKGZ1bmN0aW9uICh6dykge1xuICAgICAgdmFyIGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICduJztcbiAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gJ1xcbicgOiAnJztcbiAgICB9KTtcbiAgICAvLyBTZXQgYSBgZGF0YS1zbGF0ZS1mcmFnbWVudGAgYXR0cmlidXRlIG9uIGEgbm9uLWVtcHR5IG5vZGUsIHNvIGl0IHNob3dzIHVwXG4gICAgLy8gaW4gdGhlIEhUTUwsIGFuZCBjYW4gYmUgdXNlZCBmb3IgaW50cmEtU2xhdGUgcGFzdGluZy4gSWYgaXQncyBhIHRleHRcbiAgICAvLyBub2RlLCB3cmFwIGl0IGluIGEgYDxzcGFuPmAgc28gd2UgaGF2ZSBzb21ldGhpbmcgdG8gc2V0IGFuIGF0dHJpYnV0ZSBvbi5cbiAgICBpZiAoaXNET01UZXh0KGF0dGFjaCkpIHtcbiAgICAgIHZhciBzcGFuID0gYXR0YWNoLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgLy8gQ09NUEFUOiBJbiBDaHJvbWUgYW5kIFNhZmFyaSwgaWYgd2UgZG9uJ3QgYWRkIHRoZSBgd2hpdGUtc3BhY2VgIHN0eWxlXG4gICAgICAvLyB0aGVuIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcyB3aWxsIGJlIGlnbm9yZWQuICgyMDE3LzA5LzIxKVxuICAgICAgc3Bhbi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZSc7XG4gICAgICBzcGFuLmFwcGVuZENoaWxkKGF0dGFjaCk7XG4gICAgICBjb250ZW50cy5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgIGF0dGFjaCA9IHNwYW47XG4gICAgfVxuICAgIHZhciBmcmFnbWVudCA9IGUuZ2V0RnJhZ21lbnQoKTtcbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZnJhZ21lbnQpO1xuICAgIHZhciBlbmNvZGVkID0gd2luZG93LmJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykpO1xuICAgIGF0dGFjaC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTtcbiAgICBkYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9cIi5jb25jYXQoY2xpcGJvYXJkRm9ybWF0S2V5KSwgZW5jb2RlZCk7XG4gICAgLy8gQWRkIHRoZSBjb250ZW50IHRvIGEgPGRpdj4gc28gdGhhdCB3ZSBjYW4gZ2V0IGl0cyBpbm5lciBIVE1MLlxuICAgIHZhciBkaXYgPSBjb250ZW50cy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ3RydWUnKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGRpdi5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGdldFBsYWluVGV4dChkaXYpKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgZS5pbnNlcnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIWUuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpKSB7XG4gICAgICBlLmluc2VydFRleHREYXRhKGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgZS5pbnNlcnRGcmFnbWVudERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8qKlxuICAgICAqIENoZWNraW5nIGNvcGllZCBmcmFnbWVudCBmcm9tIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgb3IgZGF0YS1zbGF0ZS1mcmFnbWVudFxuICAgICAqL1xuICAgIHZhciBmcmFnbWVudCA9IGRhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL1wiLmNvbmNhdChjbGlwYm9hcmRGb3JtYXRLZXkpKSB8fCBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlKGRhdGEpO1xuICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgdmFyIGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQod2luZG93LmF0b2IoZnJhZ21lbnQpKTtcbiAgICAgIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGRlY29kZWQpO1xuICAgICAgZS5pbnNlcnRGcmFnbWVudChwYXJzZWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgZS5pbnNlcnRUZXh0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbiAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxpbmVzKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBsaW5lID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZSwge1xuICAgICAgICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLmluc2VydFRleHQobGluZSk7XG4gICAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgb25Db250ZXh0Q2hhbmdlID0gRURJVE9SX1RPX09OX0NIQU5HRS5nZXQoZSk7XG4gICAgaWYgKG9uQ29udGV4dENoYW5nZSkge1xuICAgICAgb25Db250ZXh0Q2hhbmdlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBvbkNoYW5nZShvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIGU7XG59O1xudmFyIGdldE1hdGNoZXMgPSBmdW5jdGlvbiBnZXRNYXRjaGVzKGUsIHBhdGgpIHtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzbGF0ZS5FZGl0b3IubGV2ZWxzKGUsIHtcbiAgICAgIGF0OiBwYXRoXG4gICAgfSkpLFxuICAgIF9zdGVwMjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgIG4gPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgIHAgPSBfc3RlcDIkdmFsdWVbMV07XG4gICAgICB2YXIga2V5ID0gRE9NRWRpdG9yLmZpbmRLZXkoZSwgbik7XG4gICAgICBtYXRjaGVzLnB1c2goW3AsIGtleV0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG52YXIgVFJJUExFX0NMSUNLID0gMztcblxuLyoqXG4gKiBIb3RrZXkgbWFwcGluZ3MgZm9yIGVhY2ggcGxhdGZvcm0uXG4gKi9cbnZhciBIT1RLRVlTID0ge1xuICBib2xkOiAnbW9kK2InLFxuICBjb21wb3NlOiBbJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcsICd1cCcsICdiYWNrc3BhY2UnLCAnZW50ZXInXSxcbiAgbW92ZUJhY2t3YXJkOiAnbGVmdCcsXG4gIG1vdmVGb3J3YXJkOiAncmlnaHQnLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnY3RybCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnY3RybCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiAnc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUZvcndhcmQ6ICdzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kQmFja3dhcmQ6ICdzaGlmdCtsZWZ0JyxcbiAgZXh0ZW5kRm9yd2FyZDogJ3NoaWZ0K3JpZ2h0JyxcbiAgaXRhbGljOiAnbW9kK2knLFxuICBpbnNlcnRTb2Z0QnJlYWs6ICdzaGlmdCtlbnRlcicsXG4gIHNwbGl0QmxvY2s6ICdlbnRlcicsXG4gIHVuZG86ICdtb2Qreidcbn07XG52YXIgQVBQTEVfSE9US0VZUyA9IHtcbiAgbW92ZUxpbmVCYWNrd2FyZDogJ29wdCt1cCcsXG4gIG1vdmVMaW5lRm9yd2FyZDogJ29wdCtkb3duJyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ29wdCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnb3B0K3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6IFsnY3RybCtiYWNrc3BhY2UnLCAnY3RybCtoJ10sXG4gIGRlbGV0ZUZvcndhcmQ6IFsnY3RybCtkZWxldGUnLCAnY3RybCtkJ10sXG4gIGRlbGV0ZUxpbmVCYWNrd2FyZDogJ2NtZCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlTGluZUZvcndhcmQ6IFsnY21kK3NoaWZ0PytkZWxldGUnLCAnY3RybCtrJ10sXG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ29wdCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdvcHQrc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZExpbmVCYWNrd2FyZDogJ29wdCtzaGlmdCt1cCcsXG4gIGV4dGVuZExpbmVGb3J3YXJkOiAnb3B0K3NoaWZ0K2Rvd24nLFxuICByZWRvOiAnY21kK3NoaWZ0K3onLFxuICB0cmFuc3Bvc2VDaGFyYWN0ZXI6ICdjdHJsK3QnXG59O1xudmFyIFdJTkRPV1NfSE9US0VZUyA9IHtcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnY3RybCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdjdHJsK3NoaWZ0PytkZWxldGUnLFxuICByZWRvOiBbJ2N0cmwreScsICdjdHJsK3NoaWZ0K3onXVxufTtcbi8qKlxuICogQ3JlYXRlIGEgcGxhdGZvcm0tYXdhcmUgaG90a2V5IGNoZWNrZXIuXG4gKi9cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoa2V5KSB7XG4gIHZhciBnZW5lcmljID0gSE9US0VZU1trZXldO1xuICB2YXIgYXBwbGUgPSBBUFBMRV9IT1RLRVlTW2tleV07XG4gIHZhciB3aW5kb3dzID0gV0lORE9XU19IT1RLRVlTW2tleV07XG4gIHZhciBpc0dlbmVyaWMgPSBnZW5lcmljICYmIGlzSG90a2V5LmlzSG90a2V5KGdlbmVyaWMpO1xuICB2YXIgaXNBcHBsZSA9IGFwcGxlICYmIGlzSG90a2V5LmlzSG90a2V5KGFwcGxlKTtcbiAgdmFyIGlzV2luZG93cyA9IHdpbmRvd3MgJiYgaXNIb3RrZXkuaXNIb3RrZXkod2luZG93cyk7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoaXNHZW5lcmljICYmIGlzR2VuZXJpYyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChJU19BUFBMRSAmJiBpc0FwcGxlICYmIGlzQXBwbGUoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIUlTX0FQUExFICYmIGlzV2luZG93cyAmJiBpc1dpbmRvd3MoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59O1xuLyoqXG4gKiBIb3RrZXlzLlxuICovXG52YXIgaG90a2V5cyA9IHtcbiAgaXNCb2xkOiBjcmVhdGUoJ2JvbGQnKSxcbiAgaXNDb21wb3NlOiBjcmVhdGUoJ2NvbXBvc2UnKSxcbiAgaXNNb3ZlQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUJhY2t3YXJkJyksXG4gIGlzTW92ZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lQmFja3dhcmQnKSxcbiAgaXNEZWxldGVMaW5lRm9yd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lRm9yd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkQmFja3dhcmQnKSxcbiAgaXNEZWxldGVXb3JkRm9yd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkRm9yd2FyZCcpLFxuICBpc0V4dGVuZEJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZEJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kRm9yd2FyZDogY3JlYXRlKCdleHRlbmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVCYWNrd2FyZCcpLFxuICBpc0V4dGVuZExpbmVGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVGb3J3YXJkJyksXG4gIGlzSXRhbGljOiBjcmVhdGUoJ2l0YWxpYycpLFxuICBpc01vdmVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVCYWNrd2FyZCcpLFxuICBpc01vdmVMaW5lRm9yd2FyZDogY3JlYXRlKCdtb3ZlTGluZUZvcndhcmQnKSxcbiAgaXNNb3ZlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ21vdmVXb3JkQmFja3dhcmQnKSxcbiAgaXNNb3ZlV29yZEZvcndhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRGb3J3YXJkJyksXG4gIGlzUmVkbzogY3JlYXRlKCdyZWRvJyksXG4gIGlzU29mdEJyZWFrOiBjcmVhdGUoJ2luc2VydFNvZnRCcmVhaycpLFxuICBpc1NwbGl0QmxvY2s6IGNyZWF0ZSgnc3BsaXRCbG9jaycpLFxuICBpc1RyYW5zcG9zZUNoYXJhY3RlcjogY3JlYXRlKCd0cmFuc3Bvc2VDaGFyYWN0ZXInKSxcbiAgaXNVbmRvOiBjcmVhdGUoJ3VuZG8nKVxufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSk7XG5cbnVud3JhcEV4cG9ydHMob2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSk7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59KTtcblxudmFyIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyA9IHVud3JhcEV4cG9ydHMob2JqZWN0V2l0aG91dFByb3BlcnRpZXMpO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcbnZhciBzaGFsbG93Q29tcGFyZSA9IGZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG9iajEsIG9iajIpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoICYmIE9iamVjdC5rZXlzKG9iajEpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9iajFba2V5XSA9PT0gb2JqMltrZXldO1xuICB9KTtcbn07XG52YXIgaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbCA9IGZ1bmN0aW9uIGlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSB7XG4gIHJhbmdlLmFuY2hvcjtcbiAgICByYW5nZS5mb2N1cztcbiAgICB2YXIgcmFuZ2VPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgX2V4Y2x1ZGVkKTtcbiAgb3RoZXIuYW5jaG9yO1xuICAgIG90aGVyLmZvY3VzO1xuICAgIHZhciBvdGhlck93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG90aGVyLCBfZXhjbHVkZWQyKTtcbiAgcmV0dXJuIHJhbmdlW1BMQUNFSE9MREVSX1NZTUJPTF0gPT09IG90aGVyW1BMQUNFSE9MREVSX1NZTUJPTF0gJiYgc2hhbGxvd0NvbXBhcmUocmFuZ2VPd25Qcm9wcywgb3RoZXJPd25Qcm9wcyk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cbiAqXG4gKiBQRVJGOiB0aGlzIHJlcXVpcmVzIHRoZSB0d28gbGlzdHMgdG8gYWxzbyBoYXZlIHRoZSByYW5nZXMgaW5zaWRlIHRoZW0gaW4gdGhlXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXG4gKi9cbnZhciBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsID0gZnVuY3Rpb24gaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbChsaXN0LCBhbm90aGVyKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCAhPT0gYW5vdGhlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldO1xuICAgIGlmICghc2xhdGUuUmFuZ2UuZXF1YWxzKHJhbmdlLCBvdGhlcikgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiBkZWNvcmF0b3IgcmFuZ2VzIGFyZSBlcXVhbCB0byBhbm90aGVyLlxuICpcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcbiAqIHNhbWUgb3JkZXIsIGJ1dCB0aGlzIGlzIGFuIG9rYXkgY29uc3RyYWludCBmb3IgdXMgc2luY2UgZGVjb3JhdGlvbnMgYXJlXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cbiAqL1xudmFyIGlzVGV4dERlY29yYXRpb25zRXF1YWwgPSBmdW5jdGlvbiBpc1RleHREZWNvcmF0aW9uc0VxdWFsKGxpc3QsIGFub3RoZXIpIHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgIHZhciBvdGhlciA9IGFub3RoZXJbaV07XG4gICAgLy8gY29tcGFyZSBvbmx5IG9mZnNldHMgYmVjYXVzZSBwYXRocyBkb2Vzbid0IG1hdHRlciBmb3IgdGV4dFxuICAgIGlmIChyYW5nZS5hbmNob3Iub2Zmc2V0ICE9PSBvdGhlci5hbmNob3Iub2Zmc2V0IHx8IHJhbmdlLmZvY3VzLm9mZnNldCAhPT0gb3RoZXIuZm9jdXMub2Zmc2V0IHx8ICFpc0RlY29yYXRpb25GbGFnc0VxdWFsKHJhbmdlLCBvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLkNBTl9VU0VfRE9NID0gQ0FOX1VTRV9ET007XG5leHBvcnRzLkRPTUVkaXRvciA9IERPTUVkaXRvcjtcbmV4cG9ydHMuRE9NRWxlbWVudCA9IERPTUVsZW1lbnQ7XG5leHBvcnRzLkRPTU5vZGUgPSBET01Ob2RlO1xuZXhwb3J0cy5ET01SYW5nZSA9IERPTVJhbmdlO1xuZXhwb3J0cy5ET01TZWxlY3Rpb24gPSBET01TZWxlY3Rpb247XG5leHBvcnRzLkRPTVN0YXRpY1JhbmdlID0gRE9NU3RhdGljUmFuZ2U7XG5leHBvcnRzLkRPTVRleHQgPSBET01UZXh0O1xuZXhwb3J0cy5FRElUT1JfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19FTEVNRU5UO1xuZXhwb3J0cy5FRElUT1JfVE9fRk9SQ0VfUkVOREVSID0gRURJVE9SX1RPX0ZPUkNFX1JFTkRFUjtcbmV4cG9ydHMuRURJVE9SX1RPX0tFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5UO1xuZXhwb3J0cy5FRElUT1JfVE9fT05fQ0hBTkdFID0gRURJVE9SX1RPX09OX0NIQU5HRTtcbmV4cG9ydHMuRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OID0gRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OO1xuZXhwb3J0cy5FRElUT1JfVE9fUEVORElOR19ESUZGUyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTO1xuZXhwb3J0cy5FRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MgPSBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1M7XG5leHBvcnRzLkVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiA9IEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTjtcbmV4cG9ydHMuRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQgPSBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVDtcbmV4cG9ydHMuRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIO1xuZXhwb3J0cy5FRElUT1JfVE9fVVNFUl9NQVJLUyA9IEVESVRPUl9UT19VU0VSX01BUktTO1xuZXhwb3J0cy5FRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04gPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT047XG5leHBvcnRzLkVESVRPUl9UT19XSU5ET1cgPSBFRElUT1JfVE9fV0lORE9XO1xuZXhwb3J0cy5FTEVNRU5UX1RPX05PREUgPSBFTEVNRU5UX1RPX05PREU7XG5leHBvcnRzLkhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCA9IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVDtcbmV4cG9ydHMuSG90a2V5cyA9IGhvdGtleXM7XG5leHBvcnRzLklTX0FORFJPSUQgPSBJU19BTkRST0lEO1xuZXhwb3J0cy5JU19DSFJPTUUgPSBJU19DSFJPTUU7XG5leHBvcnRzLklTX0NPTVBPU0lORyA9IElTX0NPTVBPU0lORztcbmV4cG9ydHMuSVNfRklSRUZPWCA9IElTX0ZJUkVGT1g7XG5leHBvcnRzLklTX0ZJUkVGT1hfTEVHQUNZID0gSVNfRklSRUZPWF9MRUdBQ1k7XG5leHBvcnRzLklTX0ZPQ1VTRUQgPSBJU19GT0NVU0VEO1xuZXhwb3J0cy5JU19JT1MgPSBJU19JT1M7XG5leHBvcnRzLklTX05PREVfTUFQX0RJUlRZID0gSVNfTk9ERV9NQVBfRElSVFk7XG5leHBvcnRzLklTX1JFQURfT05MWSA9IElTX1JFQURfT05MWTtcbmV4cG9ydHMuSVNfVUNfTU9CSUxFID0gSVNfVUNfTU9CSUxFO1xuZXhwb3J0cy5JU19XRUJLSVQgPSBJU19XRUJLSVQ7XG5leHBvcnRzLklTX1dFQ0hBVEJST1dTRVIgPSBJU19XRUNIQVRCUk9XU0VSO1xuZXhwb3J0cy5LZXkgPSBLZXk7XG5leHBvcnRzLk1BUktfUExBQ0VIT0xERVJfU1lNQk9MID0gTUFSS19QTEFDRUhPTERFUl9TWU1CT0w7XG5leHBvcnRzLk5PREVfVE9fRUxFTUVOVCA9IE5PREVfVE9fRUxFTUVOVDtcbmV4cG9ydHMuTk9ERV9UT19JTkRFWCA9IE5PREVfVE9fSU5ERVg7XG5leHBvcnRzLk5PREVfVE9fS0VZID0gTk9ERV9UT19LRVk7XG5leHBvcnRzLk5PREVfVE9fUEFSRU5UID0gTk9ERV9UT19QQVJFTlQ7XG5leHBvcnRzLlBMQUNFSE9MREVSX1NZTUJPTCA9IFBMQUNFSE9MREVSX1NZTUJPTDtcbmV4cG9ydHMuVFJJUExFX0NMSUNLID0gVFJJUExFX0NMSUNLO1xuZXhwb3J0cy5hcHBseVN0cmluZ0RpZmYgPSBhcHBseVN0cmluZ0RpZmY7XG5leHBvcnRzLmdldEFjdGl2ZUVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50O1xuZXhwb3J0cy5nZXREZWZhdWx0VmlldyA9IGdldERlZmF1bHRWaWV3O1xuZXhwb3J0cy5nZXRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb247XG5leHBvcnRzLmhhc1NoYWRvd1Jvb3QgPSBoYXNTaGFkb3dSb290O1xuZXhwb3J0cy5pc0FmdGVyID0gaXNBZnRlcjtcbmV4cG9ydHMuaXNCZWZvcmUgPSBpc0JlZm9yZTtcbmV4cG9ydHMuaXNET01FbGVtZW50ID0gaXNET01FbGVtZW50O1xuZXhwb3J0cy5pc0RPTU5vZGUgPSBpc0RPTU5vZGU7XG5leHBvcnRzLmlzRE9NU2VsZWN0aW9uID0gaXNET01TZWxlY3Rpb247XG5leHBvcnRzLmlzRWxlbWVudERlY29yYXRpb25zRXF1YWwgPSBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsO1xuZXhwb3J0cy5pc1BsYWluVGV4dE9ubHlQYXN0ZSA9IGlzUGxhaW5UZXh0T25seVBhc3RlO1xuZXhwb3J0cy5pc1RleHREZWNvcmF0aW9uc0VxdWFsID0gaXNUZXh0RGVjb3JhdGlvbnNFcXVhbDtcbmV4cG9ydHMuaXNUcmFja2VkTXV0YXRpb24gPSBpc1RyYWNrZWRNdXRhdGlvbjtcbmV4cG9ydHMubWVyZ2VTdHJpbmdEaWZmcyA9IG1lcmdlU3RyaW5nRGlmZnM7XG5leHBvcnRzLm5vcm1hbGl6ZURPTVBvaW50ID0gbm9ybWFsaXplRE9NUG9pbnQ7XG5leHBvcnRzLm5vcm1hbGl6ZVBvaW50ID0gbm9ybWFsaXplUG9pbnQ7XG5leHBvcnRzLm5vcm1hbGl6ZVJhbmdlID0gbm9ybWFsaXplUmFuZ2U7XG5leHBvcnRzLm5vcm1hbGl6ZVN0cmluZ0RpZmYgPSBub3JtYWxpemVTdHJpbmdEaWZmO1xuZXhwb3J0cy50YXJnZXRSYW5nZSA9IHRhcmdldFJhbmdlO1xuZXhwb3J0cy52ZXJpZnlEaWZmU3RhdGUgPSB2ZXJpZnlEaWZmU3RhdGU7XG5leHBvcnRzLndpdGhET00gPSB3aXRoRE9NO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/slate-dom@0.112.2_slate@0.112.0/node_modules/slate-dom/dist/index.js\n");

/***/ })

};
;