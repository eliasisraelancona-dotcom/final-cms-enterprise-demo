{
  "version": 3,
  "sources": ["../keystone.ts", "../../../packages/auth/src/schema.ts", "../../../packages/auth/src/gql/getBaseAuthSchema.ts", "../../../packages/auth/src/gql/getInitFirstItemSchema.ts", "../../../packages/auth/src/templates/config.ts", "../../../packages/auth/src/templates/signin.ts", "../../../packages/auth/src/templates/init.ts", "../../../packages/auth/src/index.ts", "../schema.ts", "../../../packages/fields-document/src/index.ts", "../../../packages/fields-document/src/DocumentEditor/utils.ts", "../../../packages/fields-document/src/DocumentEditor/component-blocks/initial-values.ts", "../../../packages/fields-document/src/DocumentEditor/component-blocks/preview-props.ts", "../../../packages/fields-document/src/DocumentEditor/component-blocks/utils.ts", "../../../packages/fields-document/src/DocumentEditor/component-blocks/field-assertions.ts", "../../../packages/fields-document/src/relationship-data.ts", "../../../packages/fields-document/src/validation.ts", "../../../packages/fields-document/src/DocumentEditor/editor-shared.ts", "../../../packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx", "../../../packages/fields-document/src/DocumentEditor/document-features-normalization.ts", "../../../packages/fields-document/src/DocumentEditor/paragraphs.ts", "../../../packages/fields-document/src/DocumentEditor/lists-shared.ts", "../../../packages/fields-document/src/DocumentEditor/toolbar-state-shared.ts", "../../../packages/fields-document/src/DocumentEditor/link-shared.ts", "../../../packages/fields-document/src/DocumentEditor/layouts-shared.ts", "../../../packages/fields-document/src/DocumentEditor/heading-shared.ts", "../../../packages/fields-document/src/DocumentEditor/blockquote-shared.ts", "../../../packages/fields-document/src/DocumentEditor/relationship-shared.ts", "../../../packages/fields-document/src/DocumentEditor/divider-shared.ts", "../../../packages/fields-document/src/DocumentEditor/code-block-shared.ts", "../../../packages/fields-document/src/DocumentEditor/marks.tsx", "../../../packages/fields-document/src/DocumentEditor/soft-breaks.ts", "../../../packages/fields-document/src/DocumentEditor/shortcuts.ts", "../../../packages/fields-document/src/DocumentEditor/insert-menu-shared.ts", "../../../packages/fields-document/src/DocumentEditor/block-markdown-shortcuts.ts", "../../../packages/fields-document/src/DocumentEditor/pasting/index.ts", "../../../packages/fields-document/src/DocumentEditor/isValidURL.ts", "../../../packages/fields-document/src/DocumentEditor/pasting/html.ts", "../../../packages/fields-document/src/DocumentEditor/pasting/utils.ts", "../../../packages/fields-document/src/DocumentEditor/pasting/markdown.ts", "../../../packages/fields-document/src/structure-validation.ts", "../../../packages/fields-document/src/structure.ts", "../../../packages/fields-document/src/structure-graphql-input.ts", "../../../packages/fields-document/src/structure-graphql-output.ts", "../access.ts", "../seed-data.ts"],
  "sourcesContent": ["import { config } from '@keystone-6/core'\nimport { statelessSessions } from '@keystone-6/core/session'\nimport { createAuth } from '@keystone-6/auth'\nimport bytes from 'bytes'\nimport express from 'express'\n\nimport { lists } from './schema'\nimport { seedDemoData } from './seed-data'\n\nconst session = statelessSessions()\n\nconst { withAuth } = createAuth({\n  listKey: 'User',\n  identityField: 'email',\n  secretField: 'password',\n  initFirstItem: {\n    fields: ['name', 'email', 'password'],\n    itemData: {\n      // Create an Admin role on first run so the initial user has access\n      role: {\n        create: {\n          name: 'Admin',\n          canUseAdminUI: true,\n          canManageUsers: true,\n          canManageAssets: true,\n          canApproveAssets: true,\n          canManageBrands: true,\n          canManageContent: true,\n          canPublishContent: true,\n          canViewAnalytics: true,\n          canManageDepartments: true,\n          canAnswerQuestions: true,\n          canManageAllDepartments: true,\n        },\n      },\n    },\n  },\n  sessionData: `\n    name\n    email\n    department { id name }\n    role {\n      id\n      name\n      canUseAdminUI\n      canManageUsers\n      canManageAssets\n      canApproveAssets\n      canManageBrands\n      canManageContent\n      canPublishContent\n      canViewAnalytics\n      canManageDepartments\n      canAnswerQuestions\n      canManageAllDepartments\n    }\n  `,\n})\n\nexport default withAuth(\n  config({\n    db: {\n      provider: 'sqlite',\n      url: process.env.DATABASE_URL || 'file:./keystone.db',\n      // Seed demo data on first run; safe to keep enabled. Use sudo to bypass access checks during seeding.\n      onConnect: async (context: any) => {\n        await seedDemoData(context.sudo())\n      },\n    },\n    lists,\n    server: {\n      maxFileSize: bytes('40Mb')!,\n      extendExpressApp: app => {\n        app.use(\n          '/images',\n          express.static('public/images', { index: false, redirect: false, lastModified: false })\n        )\n        app.use(\n          '/files',\n          express.static('public/files', {\n            setHeaders(res) {\n              res.setHeader('Content-Type', 'application/octet-stream')\n            },\n            index: false,\n            redirect: false,\n            lastModified: false,\n          })\n        )\n      },\n    },\n    ui: {\n      isAccessAllowed: ({ session }) => Boolean(session?.data.role?.canUseAdminUI),\n    },\n    session,\n  })\n)\n\n", "import { assertInputObjectType, GraphQLString, GraphQLID, parse, validate } from 'graphql'\n\nimport { g } from '@keystone-6/core'\nimport type { AuthGqlNames, AuthTokenTypeConfig, InitFirstItemConfig } from './types'\nimport { getBaseAuthSchema } from './gql/getBaseAuthSchema'\nimport { getInitFirstItemSchema } from './gql/getInitFirstItemSchema'\n\nexport const getSchemaExtension = ({\n  authGqlNames,\n  listKey,\n  identityField,\n  secretField,\n  initFirstItem,\n  sessionData,\n}: {\n  authGqlNames: AuthGqlNames\n  listKey: string\n  identityField: string\n  secretField: string\n  initFirstItem?: InitFirstItemConfig<any>\n  passwordResetLink?: AuthTokenTypeConfig\n  magicAuthLink?: AuthTokenTypeConfig\n  sessionData: string\n}) =>\n  g.extend(base => {\n    const uniqueWhereInputType = assertInputObjectType(\n      base.schema.getType(authGqlNames.whereUniqueInputName)\n    )\n    const identityFieldOnUniqueWhere = uniqueWhereInputType.getFields()[identityField]\n    if (\n      base.schema.extensions.sudo &&\n      identityFieldOnUniqueWhere?.type !== GraphQLString &&\n      identityFieldOnUniqueWhere?.type !== GraphQLID\n    ) {\n      throw new Error(\n        `createAuth was called with an identityField of ${identityField} on the list ${listKey} ` +\n          `but that field doesn't allow being searched uniquely with a String or ID. ` +\n          `You should likely add \\`isIndexed: 'unique'\\` ` +\n          `to the field at ${listKey}.${identityField}`\n      )\n    }\n\n    const baseSchema = getBaseAuthSchema({\n      authGqlNames: authGqlNames,\n      identityField,\n      listKey,\n      secretField,\n      base,\n    })\n\n    // technically this will incorrectly error if someone has a schema extension that adds a field to the list output type\n    // and then wants to fetch that field with `sessionData` but it's extremely unlikely someone will do that since if\n    // they want to add a GraphQL field, they'll probably use a virtual field\n    const query = `query($id: ID!) { ${authGqlNames.itemQueryName}(where: { id: $id }) { ${sessionData} } }`\n\n    let ast\n    try {\n      ast = parse(query)\n    } catch (err) {\n      throw new Error(\n        `The query to get session data has a syntax error, the sessionData option in your createAuth usage is likely incorrect\\n${err}`\n      )\n    }\n\n    const errors = validate(base.schema, ast)\n    if (errors.length) {\n      throw new Error(\n        `The query to get session data has validation errors, the sessionData option in your createAuth usage is likely incorrect\\n${errors.join('\\n')}`\n      )\n    }\n\n    return [\n      baseSchema.extension,\n      initFirstItem &&\n        getInitFirstItemSchema({\n          authGqlNames,\n          listKey,\n          fields: initFirstItem.fields,\n          defaultItemData: initFirstItem.itemData,\n          graphQLSchema: base.schema,\n          ItemAuthenticationWithPasswordSuccess: baseSchema.ItemAuthenticationWithPasswordSuccess,\n        }),\n    ].filter((x): x is Exclude<typeof x, undefined> => x !== undefined)\n  })\n", "import type { BaseItem, KeystoneContext } from '@keystone-6/core/types'\nimport { g } from '@keystone-6/core'\nimport { getPasswordFieldKDF } from '@keystone-6/core/fields/types/password'\nimport type { AuthGqlNames } from '../types'\nimport type { BaseSchemaMeta } from '@keystone-6/core/graphql-ts'\n\nconst AUTHENTICATION_FAILURE = {\n  code: 'FAILURE',\n  message: 'Authentication failed.',\n} as const\n\nexport function getBaseAuthSchema<I extends string, S extends string>({\n  authGqlNames,\n  listKey,\n  identityField,\n  secretField,\n  base,\n}: {\n  authGqlNames: AuthGqlNames\n  listKey: string\n  identityField: I\n  secretField: S\n  base: BaseSchemaMeta\n}) {\n  const kdf = getPasswordFieldKDF(base.schema, listKey, secretField)\n  if (!kdf) {\n    throw new Error(`${listKey}.${secretField} is not a valid password field.`)\n  }\n\n  const ItemAuthenticationWithPasswordSuccess = g.object<{\n    sessionToken: string\n    item: BaseItem\n  }>()({\n    name: authGqlNames.ItemAuthenticationWithPasswordSuccess,\n    fields: {\n      sessionToken: g.field({ type: g.nonNull(g.String) }),\n      item: g.field({ type: g.nonNull(base.object(listKey)) }),\n    },\n  })\n  const ItemAuthenticationWithPasswordFailure = g.object<{ message: string }>()({\n    name: authGqlNames.ItemAuthenticationWithPasswordFailure,\n    fields: {\n      message: g.field({ type: g.nonNull(g.String) }),\n    },\n  })\n  const AuthenticationResult = g.union({\n    name: authGqlNames.ItemAuthenticationWithPasswordResult,\n    types: [ItemAuthenticationWithPasswordSuccess, ItemAuthenticationWithPasswordFailure],\n    resolveType(val) {\n      if ('sessionToken' in val) return authGqlNames.ItemAuthenticationWithPasswordSuccess\n      return authGqlNames.ItemAuthenticationWithPasswordFailure\n    },\n  })\n\n  const extension = {\n    query: {\n      authenticatedItem: g.field({\n        type: base.object(listKey),\n        resolve(rootVal, args, context: KeystoneContext) {\n          const { session } = context\n          if (!session?.itemId) return null\n\n          return context.db[listKey].findOne({\n            where: {\n              id: session.itemId,\n            },\n          })\n        },\n      }),\n    },\n    mutation: {\n      endSession: g.field({\n        type: g.nonNull(g.Boolean),\n        async resolve(rootVal, args, context) {\n          await context.sessionStrategy?.end({ context })\n          return true\n        },\n      }),\n      [authGqlNames.authenticateItemWithPassword]: g.field({\n        type: AuthenticationResult,\n        args: {\n          [identityField]: g.arg({ type: g.nonNull(g.String) }),\n          [secretField]: g.arg({ type: g.nonNull(g.String) }),\n        },\n        async resolve(\n          rootVal,\n          { [identityField]: identity, [secretField]: secret },\n          context: KeystoneContext\n        ) {\n          if (!context.sessionStrategy) throw new Error('No session strategy on context')\n\n          const item = await context.sudo().db[listKey].findOne({\n            where: { [identityField]: identity },\n          })\n\n          if (typeof item?.[secretField] !== 'string') {\n            await kdf.hash('simulated-password-to-counter-timing-attack')\n            return AUTHENTICATION_FAILURE\n          }\n\n          const equal = await kdf.compare(secret, item[secretField])\n          if (!equal) return AUTHENTICATION_FAILURE\n\n          const sessionToken = await context.sessionStrategy.start({\n            data: {\n              itemId: item.id,\n            },\n            context,\n          })\n\n          if (typeof sessionToken !== 'string' || sessionToken.length === 0) {\n            return AUTHENTICATION_FAILURE\n          }\n\n          return {\n            sessionToken,\n            item,\n          }\n        },\n      }),\n    },\n  }\n\n  return {\n    extension,\n    ItemAuthenticationWithPasswordSuccess,\n  }\n}\n", "import type { BaseItem, KeystoneContext } from '@keystone-6/core/types'\nimport { g } from '@keystone-6/core'\nimport { assertInputObjectType, GraphQLInputObjectType, type GraphQLSchema } from 'graphql'\nimport { type AuthGqlNames, type InitFirstItemConfig } from '../types'\nimport type { Extension } from '@keystone-6/core/graphql-ts'\n\nconst AUTHENTICATION_FAILURE = 'Authentication failed.' as const\n\nexport function getInitFirstItemSchema({\n  authGqlNames,\n  listKey,\n  fields,\n  defaultItemData,\n  graphQLSchema,\n  ItemAuthenticationWithPasswordSuccess,\n}: {\n  authGqlNames: AuthGqlNames\n  listKey: string\n  fields: InitFirstItemConfig<any>['fields']\n  defaultItemData: InitFirstItemConfig<any>['itemData']\n  graphQLSchema: GraphQLSchema\n  ItemAuthenticationWithPasswordSuccess: g<\n    typeof g.object<{\n      item: BaseItem\n      sessionToken: string\n    }>\n  >\n  // TODO: return type required by pnpm :(\n}): Extension {\n  const createInputConfig = assertInputObjectType(\n    graphQLSchema.getType(`${listKey}CreateInput`)\n  ).toConfig()\n  const fieldsSet = new Set(fields)\n  const initialCreateInput = new GraphQLInputObjectType({\n    ...createInputConfig,\n    fields: Object.fromEntries(\n      Object.entries(createInputConfig.fields).filter(([fieldKey]) => fieldsSet.has(fieldKey))\n    ),\n    name: authGqlNames.CreateInitialInput,\n  })\n\n  return {\n    mutation: {\n      [authGqlNames.createInitialItem]: g.field({\n        type: g.nonNull(ItemAuthenticationWithPasswordSuccess),\n        args: { data: g.arg({ type: g.nonNull(initialCreateInput) }) },\n        async resolve(rootVal, { data }, context: KeystoneContext) {\n          if (!context.sessionStrategy) throw new Error('No session strategy on context')\n\n          const sudoContext = context.sudo()\n\n          // should approximate hasInitFirstItemConditions\n          const count = await sudoContext.db[listKey].count()\n          if (count !== 0) throw AUTHENTICATION_FAILURE\n\n          // Update system state\n          // this is strictly speaking incorrect. the db API will do GraphQL coercion on a value which has already been coerced\n          // (this is also mostly fine, the chance that people are using things where\n          // the input value can't round-trip like the Upload scalar here is quite low)\n          const item = await sudoContext.db[listKey].createOne({\n            data: {\n              ...defaultItemData,\n              ...data,\n            },\n          })\n\n          const sessionToken = await context.sessionStrategy.start({\n            data: {\n              listKey,\n              itemId: item.id,\n            },\n            context,\n          })\n\n          if (typeof sessionToken !== 'string' || sessionToken.length === 0) {\n            throw AUTHENTICATION_FAILURE\n          }\n\n          return {\n            sessionToken,\n            item,\n          }\n        },\n      }),\n    },\n  }\n}\n", "export default function ({ labelField }: { labelField: string }) {\n  return `import { type AdminConfig } from '@keystone-6/core/types'\nimport makeNavigation from '@keystone-6/auth/components/Navigation'\n\nexport const components: AdminConfig['components'] = {\n  Navigation: makeNavigation({ labelField: '${labelField}' }),\n}\n`\n}\n", "import type { AuthGqlNames } from '../types'\n\nexport default function ({\n  authGqlNames,\n  identityField,\n  secretField,\n}: {\n  authGqlNames: AuthGqlNames\n  identityField: string\n  secretField: string\n}) {\n  return `import makeSigninPage from '@keystone-6/auth/pages/SigninPage'\n\nexport default makeSigninPage(${JSON.stringify({\n    authGqlNames,\n    identityField,\n    secretField,\n  })})\n`\n}\n", "import type { BaseListTypeInfo } from '@keystone-6/core/types'\nimport type { AuthGqlNames, AuthConfig } from '../types'\n\nexport default function ({\n  authGqlNames,\n  listKey,\n  initFirstItem,\n}: {\n  authGqlNames: AuthGqlNames\n  listKey: string\n  initFirstItem: NonNullable<AuthConfig<BaseListTypeInfo>['initFirstItem']>\n}) {\n  return `import makeInitPage from '@keystone-6/auth/pages/InitPage'\n\nexport default makeInitPage(${JSON.stringify({\n    listKey,\n    authGqlNames,\n    fieldPaths: initFirstItem.fields,\n    enableWelcome: !initFirstItem.skipKeystoneWelcome,\n  })})\n`\n}\n", "import type {\n  AdminFileToWrite,\n  BaseListTypeInfo,\n  KeystoneContext,\n  SessionStrategy,\n  BaseKeystoneTypeInfo,\n  KeystoneConfig,\n} from '@keystone-6/core/types'\nimport type { AuthConfig, AuthGqlNames } from './types'\n\nimport { getSchemaExtension } from './schema'\nimport configTemplate from './templates/config'\nimport signinTemplate from './templates/signin'\nimport initTemplate from './templates/init'\n\nexport type AuthSession = {\n  itemId: string | number // TODO: use ListTypeInfo\n  data: unknown // TODO: use ListTypeInfo\n}\n\nfunction getAuthGqlNames(singular: string): AuthGqlNames {\n  const lowerSingularName = singular.charAt(0).toLowerCase() + singular.slice(1)\n  return {\n    itemQueryName: lowerSingularName,\n    whereUniqueInputName: `${singular}WhereUniqueInput`,\n\n    authenticateItemWithPassword: `authenticate${singular}WithPassword`,\n    ItemAuthenticationWithPasswordResult: `${singular}AuthenticationWithPasswordResult`,\n    ItemAuthenticationWithPasswordSuccess: `${singular}AuthenticationWithPasswordSuccess`,\n    ItemAuthenticationWithPasswordFailure: `${singular}AuthenticationWithPasswordFailure`,\n\n    CreateInitialInput: `CreateInitial${singular}Input`,\n    createInitialItem: `createInitial${singular}`,\n  } as const\n}\n\n// TODO: use TypeInfo and listKey for types\n/**\n * createAuth function\n *\n * Generates config for Keystone to implement standard auth features.\n */\nexport function createAuth<ListTypeInfo extends BaseListTypeInfo>({\n  listKey,\n  secretField,\n  initFirstItem,\n  identityField,\n  sessionData = 'id',\n}: AuthConfig<ListTypeInfo>) {\n  /**\n   * getAdditionalFiles\n   *\n   * This function adds files to be generated into the Admin UI build. Must be added to the\n   * ui.getAdditionalFiles config.\n   *\n   * The signin page is always included, and the init page is included when initFirstItem is set\n   */\n  const authGetAdditionalFiles = (config: KeystoneConfig) => {\n    // TODO: FIXME: this is a duplication of initialise-lists:747\n    const listConfig = config.lists[listKey]\n    const labelField =\n      listConfig.ui?.labelField ??\n      (listConfig.fields.label\n        ? 'label'\n        : listConfig.fields.name\n          ? 'name'\n          : listConfig.fields.title\n            ? 'title'\n            : 'id')\n\n    const authGqlNames = getAuthGqlNames(listConfig.graphql?.singular ?? listKey)\n    const filesToWrite: AdminFileToWrite[] = [\n      {\n        mode: 'write',\n        src: signinTemplate({ authGqlNames, identityField, secretField }),\n        outputPath: 'pages/signin.js',\n      },\n      {\n        mode: 'write',\n        src: configTemplate({ labelField }),\n        outputPath: 'config.ts',\n      },\n    ]\n    if (initFirstItem) {\n      filesToWrite.push({\n        mode: 'write',\n        src: initTemplate({ authGqlNames, listKey, initFirstItem }),\n        outputPath: 'pages/init.js',\n      })\n    }\n    return filesToWrite\n  }\n\n  function throwIfInvalidConfig<TypeInfo extends BaseKeystoneTypeInfo>(\n    config: KeystoneConfig<TypeInfo>\n  ) {\n    if (!(listKey in config.lists)) {\n      throw new Error(`withAuth cannot find the list \"${listKey}\"`)\n    }\n\n    // TODO: verify that the identity field is unique\n    // TODO: verify that the field is required\n    const list = config.lists[listKey]\n    if (!(identityField in list.fields)) {\n      throw new Error(`withAuth cannot find the identity field \"${listKey}.${identityField}\"`)\n    }\n\n    if (!(secretField in list.fields)) {\n      throw new Error(`withAuth cannot find the secret field \"${listKey}.${secretField}\"`)\n    }\n\n    for (const fieldKey of initFirstItem?.fields || []) {\n      if (fieldKey in list.fields) continue\n\n      throw new Error(`initFirstItem.fields has unknown field \"${listKey}.${fieldKey}\"`)\n    }\n  }\n\n  // this strategy wraps the existing session strategy,\n  //   and injects the requested session.data before returning\n  function authSessionStrategy<Session extends AuthSession>(\n    _sessionStrategy: SessionStrategy<Session>\n  ): SessionStrategy<Session> {\n    const { get, ...sessionStrategy } = _sessionStrategy\n    return {\n      ...sessionStrategy,\n      get: async ({ context }) => {\n        const session = await get({ context })\n        const sudoContext = context.sudo()\n        if (!session?.itemId) return\n\n        // TODO: replace with SessionSecret: HMAC({ listKey, identityField, secretField }, SessionSecretVar)\n        // if (session.listKey !== listKey) return null\n\n        try {\n          const data = await sudoContext.query[listKey].findOne({\n            where: { id: session.itemId },\n            query: sessionData,\n          })\n          if (!data) return\n\n          return {\n            ...session,\n            itemId: session.itemId,\n            data,\n          }\n        } catch (e) {\n          console.error(e)\n          // WARNING: this is probably an invalid configuration\n          return\n        }\n      },\n    }\n  }\n\n  async function hasInitFirstItemConditions<TypeInfo extends BaseKeystoneTypeInfo>(\n    context: KeystoneContext<TypeInfo>\n  ) {\n    // do nothing if they aren't using this feature\n    if (!initFirstItem) return false\n\n    // if they have a session, there is no initialisation necessary\n    if (context.session) return false\n\n    const count = await context.sudo().db[listKey].count({})\n    return count === 0\n  }\n\n  async function authMiddleware<TypeInfo extends BaseKeystoneTypeInfo>({\n    context,\n    wasAccessAllowed,\n    basePath,\n  }: {\n    context: KeystoneContext<TypeInfo>\n    wasAccessAllowed: boolean\n    basePath: string\n  }): Promise<{ kind: 'redirect'; to: string } | void> {\n    const { req } = context\n    const { pathname } = new URL(req!.url!, 'http://_')\n\n    // redirect to init if initFirstItem conditions are met\n    if (pathname !== `${basePath}/init` && (await hasInitFirstItemConditions(context))) {\n      return { kind: 'redirect', to: `${basePath}/init` }\n    }\n\n    // redirect to / if attempting to /init and initFirstItem conditions are not met\n    if (pathname === `${basePath}/init` && !(await hasInitFirstItemConditions(context))) {\n      return { kind: 'redirect', to: basePath }\n    }\n\n    // don't redirect if we have access\n    if (wasAccessAllowed) return\n\n    // otherwise, redirect to signin\n    return { kind: 'redirect', to: `${basePath}/signin` }\n  }\n\n  function defaultIsAccessAllowed({ session }: KeystoneContext) {\n    return session !== undefined\n  }\n\n  function defaultExtendGraphqlSchema<T>(schema: T) {\n    return schema\n  }\n\n  /**\n   * withAuth\n   *\n   * Automatically extends your configuration with a prescriptive implementation.\n   */\n  function withAuth<TypeInfo extends BaseKeystoneTypeInfo>(\n    config: KeystoneConfig<TypeInfo>\n  ): KeystoneConfig<TypeInfo> {\n    throwIfInvalidConfig(config)\n    let { ui } = config\n    if (!ui?.isDisabled) {\n      const {\n        getAdditionalFiles = [],\n        isAccessAllowed = defaultIsAccessAllowed,\n        pageMiddleware,\n        publicPages = [],\n      } = ui || {}\n      const authPublicPages = [`${ui?.basePath ?? ''}/signin`]\n      ui = {\n        ...ui,\n        publicPages: [...publicPages, ...authPublicPages],\n        getAdditionalFiles: [...getAdditionalFiles, () => authGetAdditionalFiles(config)],\n\n        isAccessAllowed: async (context: KeystoneContext) => {\n          if (await hasInitFirstItemConditions(context)) return true\n          return isAccessAllowed(context)\n        },\n\n        pageMiddleware: async args => {\n          const shouldRedirect = await authMiddleware(args)\n          if (shouldRedirect) return shouldRedirect\n          return pageMiddleware?.(args)\n        },\n      }\n    }\n\n    if (!config.session) throw new TypeError('Missing .session configuration')\n\n    const { graphql } = config\n    const { extendGraphqlSchema = defaultExtendGraphqlSchema } = graphql ?? {}\n    const listConfig = config.lists[listKey]\n\n    /**\n     * extendGraphqlSchema\n     *\n     * Must be added to the extendGraphqlSchema config. Can be composed.\n     */\n    const authGqlNames = getAuthGqlNames(listConfig.graphql?.singular ?? listKey)\n    const authExtendGraphqlSchema = getSchemaExtension({\n      authGqlNames,\n      listKey,\n      identityField,\n      secretField,\n      initFirstItem,\n      sessionData,\n    })\n\n    return {\n      ...config,\n      graphql: {\n        ...config.graphql,\n        extendGraphqlSchema: schema => {\n          return extendGraphqlSchema(authExtendGraphqlSchema(schema))\n        },\n      },\n      ui,\n      session: authSessionStrategy(config.session),\n      lists: {\n        ...config.lists,\n        [listKey]: {\n          ...listConfig,\n          fields: {\n            ...listConfig.fields,\n          },\n        },\n      },\n    }\n  }\n\n  return {\n    withAuth,\n  }\n}\n", "import { list } from '@keystone-6/core'\nimport { allowAll } from '@keystone-6/core/access'\nimport {\n  checkbox,\n  json,\n  password,\n  relationship,\n  select,\n  text,\n  timestamp,\n  image,\n  file,\n} from '@keystone-6/core/fields'\nimport { document } from '@keystone-6/fields-document'\nimport fs from 'node:fs/promises'\n\nimport type { Lists } from '.keystone/types'\nimport { isSignedIn, permissions, departmentFilter } from './access'\n\nexport const lists = {\n  Role: list({\n    access: {\n      operation: {\n        query: permissions.canManageUsers,\n        create: permissions.canManageUsers,\n        update: permissions.canManageUsers,\n        delete: permissions.canManageUsers,\n      },\n    },\n    fields: {\n      name: text({ validation: { isRequired: true } }),\n      canUseAdminUI: checkbox({ defaultValue: true }),\n      canManageUsers: checkbox({ defaultValue: false }),\n      canManageAssets: checkbox({ defaultValue: true }),\n      canApproveAssets: checkbox({ defaultValue: false }),\n      canManageBrands: checkbox({ defaultValue: false }),\n      canManageContent: checkbox({ defaultValue: true }),\n      canPublishContent: checkbox({ defaultValue: false }),\n      canViewAnalytics: checkbox({ defaultValue: false }),\n      canManageDepartments: checkbox({ defaultValue: false }),\n      canAnswerQuestions: checkbox({ defaultValue: false }),\n      canManageAllDepartments: checkbox({ defaultValue: false }),\n      users: relationship({ ref: 'User.role', many: true }),\n    },\n  }),\n\n  Department: list({\n    access: allowAll,\n    fields: {\n      name: text({ validation: { isRequired: true } }),\n      slug: text({ validation: { isRequired: true }, isIndexed: 'unique' }),\n      description: text({ ui: { displayMode: 'textarea' } }),\n      members: relationship({ ref: 'User.department', many: true }),\n      brands: relationship({ ref: 'Brand.department', many: true }),\n    },\n  }),\n\n  Brand: list({\n    access: {\n      operation: {\n        query: isSignedIn,\n        create: permissions.canManageBrands,\n        update: permissions.canManageBrands,\n        delete: permissions.canManageBrands,\n      },\n      filter: {\n        query: departmentFilter,\n      },\n    },\n    fields: {\n      name: text({ validation: { isRequired: true } }),\n      slug: text({ validation: { isRequired: true }, isIndexed: 'unique' }),\n      description: text({ ui: { displayMode: 'textarea' } }),\n      complianceStatus: select({\n        type: 'enum',\n        options: [\n          { label: 'Compliant', value: 'compliant' },\n          { label: 'Needs Review', value: 'needs_review' },\n          { label: 'Non-Compliant', value: 'non_compliant' },\n        ],\n        defaultValue: 'needs_review',\n      }),\n      guidelines: document({ formatting: true, links: true }),\n      department: relationship({ ref: 'Department.brands' }),\n      owners: relationship({ ref: 'User', many: true }),\n      assets: relationship({ ref: 'Asset.brand', many: true }),\n      content: relationship({ ref: 'Content.brand', many: true }),\n    },\n  }),\n\n  User: list({\n    access: {\n      operation: {\n        query: isSignedIn,\n        create: permissions.canManageUsers,\n        update: permissions.canManageUsers,\n        delete: permissions.canManageUsers,\n      },\n      filter: {\n        query: ({ session }) => {\n          if (!session) return false\n          if (permissions.canManageAllDepartments({ session })) return true\n          if (!session.data.department?.id) return false\n          return {\n            OR: [\n              { id: { equals: session.itemId } },\n              { department: { id: { equals: session.data.department.id } } },\n            ],\n          }\n        },\n      },\n    },\n    fields: {\n      name: text({ validation: { isRequired: true } }),\n      email: text({ validation: { isRequired: true }, isIndexed: 'unique' }),\n      password: password({ validation: { isRequired: true } }),\n      role: relationship({ ref: 'Role.users' }),\n      department: relationship({ ref: 'Department.members' }),\n    },\n    ui: {\n      listView: {\n        initialColumns: ['name', 'email', 'role', 'department'],\n      },\n    },\n  }),\n\n  Tag: list({\n    access: allowAll,\n    fields: {\n      name: text({ validation: { isRequired: true } }),\n      assets: relationship({ ref: 'Asset.tags', many: true }),\n      content: relationship({ ref: 'Content.tags', many: true }),\n      questions: relationship({ ref: 'Question.tags', many: true }),\n    },\n  }),\n\n  Asset: list({\n    access: {\n      operation: {\n        query: isSignedIn,\n        create: permissions.canManageAssets,\n        update: permissions.canManageAssets,\n        delete: permissions.canManageAssets,\n      },\n      filter: { query: departmentFilter },\n    },\n    fields: {\n      title: text({ validation: { isRequired: true } }),\n      description: text({ ui: { displayMode: 'textarea' } }),\n      status: select({\n        type: 'enum',\n        options: [\n          { label: 'Uploaded', value: 'uploaded' },\n          { label: 'In Review', value: 'in_review' },\n          { label: 'Approved', value: 'approved' },\n          { label: 'Archived', value: 'archived' },\n        ],\n        defaultValue: 'uploaded',\n      }),\n      image: image({\n        storage: {\n          async put(key, data: Buffer) {\n            await fs.writeFile(`public/images/${key}`, data)\n          },\n          async delete(key) {\n            await fs.unlink(`public/images/${key}`)\n          },\n          url(key) {\n            return `http://localhost:3000/images/${key}`\n          },\n        },\n      }),\n      file: file({\n        storage: {\n          async put(key, data: Buffer) {\n            await fs.writeFile(`public/files/${key}`, data)\n          },\n          async delete(key) {\n            await fs.unlink(`public/files/${key}`)\n          },\n          url(key) {\n            return `http://localhost:3000/files/${key}`\n          },\n        },\n      }),\n      brand: relationship({ ref: 'Brand.assets' }),\n      department: relationship({ ref: 'Department' }),\n      uploadedBy: relationship({ ref: 'User' }),\n      approvedBy: relationship({ ref: 'User' }),\n      tags: relationship({ ref: 'Tag.assets', many: true }),\n    },\n  }),\n\n  Content: list({\n    access: {\n      operation: {\n        query: isSignedIn,\n        create: permissions.canManageContent,\n        update: permissions.canManageContent,\n        delete: permissions.canManageContent,\n      },\n      filter: { query: departmentFilter },\n    },\n    fields: {\n      title: text({ validation: { isRequired: true } }),\n      status: select({\n        type: 'enum',\n        options: [\n          { label: 'Draft', value: 'draft' },\n          { label: 'Review', value: 'review' },\n          { label: 'Approved', value: 'approved' },\n          { label: 'Published', value: 'published' },\n        ],\n        defaultValue: 'draft',\n      }),\n      body: document({ formatting: true, links: true, dividers: true }),\n      brand: relationship({ ref: 'Brand.content' }),\n      department: relationship({ ref: 'Department' }),\n      assets: relationship({ ref: 'Asset', many: true }),\n      createdBy: relationship({ ref: 'User' }),\n      reviewers: relationship({ ref: 'User', many: true }),\n      tags: relationship({ ref: 'Tag.content', many: true }),\n    },\n    ui: { listView: { initialColumns: ['title', 'status', 'brand', 'department'] } },\n  }),\n\n  AuditLog: list({\n    access: {\n      operation: {\n        query: ({ session }) =>\n          Boolean(session && (permissions.canManageUsers({ session }) || permissions.canViewAnalytics({ session }))),\n        create: permissions.canManageUsers,\n        update: permissions.canManageUsers,\n        delete: permissions.canManageUsers,\n      },\n    },\n    fields: {\n      action: text({ validation: { isRequired: true } }),\n      entityType: text({ validation: { isRequired: true } }),\n      entityId: text(),\n      timestamp: timestamp({ defaultValue: { kind: 'now' } }),\n      meta: json(),\n      user: relationship({ ref: 'User' }),\n      department: relationship({ ref: 'Department' }),\n    },\n  }),\n\n  AnalyticsEvent: list({\n    access: {\n      operation: {\n        query: permissions.canViewAnalytics,\n        create: allowAll,\n        update: permissions.canViewAnalytics,\n        delete: permissions.canViewAnalytics,\n      },\n    },\n    fields: {\n      eventType: select({\n        type: 'enum',\n        options: [\n          { label: 'View', value: 'view' },\n          { label: 'Download', value: 'download' },\n          { label: 'Share', value: 'share' },\n          { label: 'Search', value: 'search' },\n        ],\n        defaultValue: 'view',\n      }),\n      timestamp: timestamp({ defaultValue: { kind: 'now' } }),\n      user: relationship({ ref: 'User' }),\n      entityType: text(),\n      entityId: text(),\n      meta: json(),\n      department: relationship({ ref: 'Department' }),\n    },\n  }),\n\n  Question: list({\n    access: {\n      operation: {\n        query: isSignedIn,\n        create: isSignedIn,\n        update: permissions.canAnswerQuestions,\n        delete: permissions.canAnswerQuestions,\n      },\n      filter: { query: departmentFilter },\n    },\n    fields: {\n      subject: text({ validation: { isRequired: true } }),\n      body: document({ formatting: true, links: true }),\n      status: select({\n        type: 'enum',\n        options: [\n          { label: 'New', value: 'new' },\n          { label: 'Triage', value: 'triage' },\n          { label: 'Answered', value: 'answered' },\n          { label: 'Closed', value: 'closed' },\n        ],\n        defaultValue: 'new',\n      }),\n      department: relationship({ ref: 'Department' }),\n      askedBy: relationship({ ref: 'User' }),\n      tags: relationship({ ref: 'Tag.questions', many: true }),\n      answers: relationship({ ref: 'Answer.question', many: true }),\n    },\n  }),\n\n  Answer: list({\n    access: {\n      operation: {\n        query: isSignedIn,\n        create: permissions.canAnswerQuestions,\n        update: permissions.canAnswerQuestions,\n        delete: permissions.canAnswerQuestions,\n      },\n      filter: { query: departmentFilter },\n    },\n    fields: {\n      body: document({ formatting: true, links: true }),\n      question: relationship({ ref: 'Question.answers' }),\n      answeredBy: relationship({ ref: 'User' }),\n      approved: checkbox({ defaultValue: true }),\n      department: relationship({ ref: 'Department' }),\n    },\n  }),\n} satisfies Lists\n\n", "import { g } from '@keystone-6/core'\nimport {\n  type BaseFieldTypeInfo,\n  type BaseListTypeInfo,\n  type CommonFieldConfig,\n  type FieldData,\n  type FieldTypeFunc,\n  type JSONValue,\n  fieldType,\n} from '@keystone-6/core/types'\nimport { GraphQLError } from 'graphql'\nimport type { ComponentBlock } from './DocumentEditor/component-blocks/api-shared'\nimport { assertValidComponentSchema } from './DocumentEditor/component-blocks/field-assertions'\nimport type { Relationships } from './DocumentEditor/relationship-shared'\nimport { addRelationshipData } from './relationship-data'\nimport { validateAndNormalizeDocument } from './validation'\nimport type { DocumentFeatures, controller } from './views-shared'\n\ntype RelationshipsConfig = Record<\n  string,\n  {\n    listKey: string\n    label: string\n    labelField?: string\n    /** GraphQL fields to select when querying the field */\n    selection?: string\n  }\n>\n\ntype FormattingConfig = {\n  inlineMarks?:\n    | boolean\n    | {\n        bold?: boolean\n        italic?: boolean\n        underline?: boolean\n        strikethrough?: boolean\n        code?: boolean\n        superscript?: boolean\n        subscript?: boolean\n        keyboard?: boolean\n      }\n  listTypes?:\n    | boolean\n    | {\n        ordered?: boolean\n        unordered?: boolean\n      }\n  alignment?:\n    | boolean\n    | {\n        center?: boolean\n        end?: boolean\n      }\n  headingLevels?: boolean | readonly (1 | 2 | 3 | 4 | 5 | 6)[]\n  blockTypes?:\n    | boolean\n    | {\n        blockquote?: boolean\n        code?: boolean\n      }\n  softBreaks?: boolean\n}\n\nexport type DocumentFieldConfig<ListTypeInfo extends BaseListTypeInfo> = CommonFieldConfig<\n  ListTypeInfo,\n  BaseFieldTypeInfo\n> & {\n  relationships?: RelationshipsConfig\n  componentBlocks?: Record<string, ComponentBlock>\n  formatting?: boolean | FormattingConfig\n  links?: boolean\n  dividers?: boolean\n  layouts?: readonly (readonly [number, ...number[]])[]\n  db?: { map?: string; extendPrismaSchema?: (field: string) => string }\n}\n\nexport function document<ListTypeInfo extends BaseListTypeInfo>({\n  componentBlocks = {},\n  dividers,\n  formatting,\n  layouts,\n  relationships: configRelationships,\n  links,\n  ...config\n}: DocumentFieldConfig<ListTypeInfo> = {}): FieldTypeFunc<ListTypeInfo> {\n  return meta => {\n    const documentFeatures = normaliseDocumentFeatures({\n      dividers,\n      formatting,\n      layouts,\n      links,\n    })\n    const relationships = normaliseRelationships(configRelationships, meta)\n    const inputResolver = (data: JSONValue | null | undefined): any => {\n      if (data === null)\n        throw new GraphQLError('Input error: Document fields cannot be set to null')\n      if (data === undefined) return data\n\n      return validateAndNormalizeDocument(data, documentFeatures, componentBlocks, relationships)\n    }\n\n    if ((config as any).isIndexed === 'unique') {\n      throw Error(\"isIndexed: 'unique' is not a supported option for field type document\")\n    }\n\n    const lists = new Set(Object.keys(meta.lists))\n    for (const [name, block] of Object.entries(componentBlocks)) {\n      try {\n        assertValidComponentSchema({ kind: 'object', fields: block.schema }, lists, 'document')\n      } catch (err) {\n        throw new Error(\n          `Component block ${name} in ${meta.listKey}.${meta.fieldKey}: ${(err as any).message}`\n        )\n      }\n    }\n\n    const defaultValue = [{ type: 'paragraph', children: [{ text: '' }] }]\n    return fieldType({\n      kind: 'scalar',\n      scalar: 'Json',\n      mode: 'required',\n      default:\n        meta.provider === 'sqlite'\n          ? undefined\n          : {\n              kind: 'literal',\n              // TODO: waiting on https://github.com/prisma/prisma/issues/26571\n              //   input.create manages defaultValues anyway\n              value: JSON.stringify(defaultValue ?? null),\n            },\n      map: config.db?.map,\n      extendPrismaSchema: config.db?.extendPrismaSchema,\n    })({\n      ...config,\n      __ksTelemetryFieldTypeName: '@keystone-6/document',\n      input: {\n        create: {\n          arg: g.arg({ type: g.JSON }),\n          resolve(val) {\n            if (val === undefined) {\n              val = defaultValue\n            }\n            return inputResolver(val)\n          },\n        },\n        update: { arg: g.arg({ type: g.JSON }), resolve: inputResolver },\n      },\n      output: g.field({\n        type: g.object<{ document: JSONValue }>()({\n          name: `${meta.listKey}_${meta.fieldKey}_Document`,\n          fields: {\n            document: g.field({\n              args: {\n                hydrateRelationships: g.arg({\n                  type: g.nonNull(g.Boolean),\n                  defaultValue: false,\n                }),\n              },\n              type: g.nonNull(g.JSON),\n              resolve({ document }, { hydrateRelationships }, context) {\n                return hydrateRelationships\n                  ? addRelationshipData(document as any, context, relationships, componentBlocks)\n                  : (document as any)\n              },\n            }),\n          },\n        }),\n        resolve({ value }) {\n          if (value === null) return null\n          return { document: value }\n        },\n      }),\n      views: '@keystone-6/fields-document/views',\n      getAdminMeta(): Parameters<typeof controller>[0]['fieldMeta'] {\n        return {\n          relationships,\n          documentFeatures,\n          componentBlocksPassedOnServer: Object.keys(componentBlocks),\n        }\n      },\n    })\n  }\n}\n\nfunction normaliseRelationships(\n  configRelationships: DocumentFieldConfig<BaseListTypeInfo>['relationships'],\n  meta: FieldData\n) {\n  if (!configRelationships) return {}\n  const relationships: Relationships = {}\n  for (const [key, relationship] of Object.entries(configRelationships)) {\n    if (meta.lists[relationship.listKey] === undefined) {\n      throw new Error(\n        `An inline relationship ${relationship.label} (${key}) in the field at ${meta.listKey}.${meta.fieldKey} has listKey set to \"${relationship.listKey}\" but no list named \"${relationship.listKey}\" exists.`\n      )\n    }\n    relationships[key] = {\n      ...relationship,\n      labelField: relationship.labelField ?? null,\n      selection: relationship.selection ?? null,\n    }\n  }\n  return relationships\n}\n\nfunction normaliseDocumentFeatures(\n  config: Pick<\n    DocumentFieldConfig<BaseListTypeInfo>,\n    'formatting' | 'dividers' | 'layouts' | 'links'\n  >\n) {\n  const {\n    alignment,\n    blockTypes,\n    headingLevels,\n    inlineMarks,\n    listTypes,\n    softBreaks,\n  }: FormattingConfig =\n    typeof config.formatting === 'boolean'\n      ? {\n          alignment: config.formatting,\n          blockTypes: config.formatting,\n          headingLevels: config.formatting,\n          inlineMarks: config.formatting,\n          listTypes: config.formatting,\n          softBreaks: config.formatting,\n        }\n      : (config.formatting ?? {})\n\n  const documentFeatures: DocumentFeatures = {\n    formatting: {\n      alignment: {\n        center: typeof alignment === 'boolean' ? alignment : !!alignment?.center,\n        end: typeof alignment === 'boolean' ? alignment : !!alignment?.end,\n      },\n      blockTypes: {\n        blockquote: typeof blockTypes === 'boolean' ? blockTypes : !!blockTypes?.blockquote,\n        code: typeof blockTypes === 'boolean' ? blockTypes : !!blockTypes?.code,\n      },\n      headingLevels:\n        typeof headingLevels === 'boolean'\n          ? ([1, 2, 3, 4, 5, 6] as const).filter(_ => headingLevels)\n          : [...new Set(headingLevels)].sort(),\n      inlineMarks: {\n        bold: typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.bold,\n        code: typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.code,\n        italic: typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.italic,\n        strikethrough:\n          typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.strikethrough,\n        underline: typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.underline,\n        keyboard: typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.keyboard,\n        subscript: typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.subscript,\n        superscript: typeof inlineMarks === 'boolean' ? inlineMarks : !!inlineMarks?.superscript,\n      },\n      listTypes: {\n        ordered: typeof listTypes === 'boolean' ? listTypes : !!listTypes?.ordered,\n        unordered: typeof listTypes === 'boolean' ? listTypes : !!listTypes?.unordered,\n      },\n      softBreaks: typeof softBreaks === 'boolean' ? softBreaks : !!softBreaks,\n    },\n    links: !!config.links,\n    layouts: [...new Set((config.layouts || []).map(x => JSON.stringify(x)))].map(x =>\n      JSON.parse(x)\n    ),\n    dividers: !!config.dividers,\n  }\n  return documentFeatures\n}\n\nexport type { Node } from './structure-validation'\nexport { structure } from './structure'\n", "import {\n  type Location,\n  type NodeEntry,\n  type PathRef,\n  type Point,\n  Editor,\n  Element,\n  Node,\n  Path,\n  Text,\n  Transforms,\n} from 'slate'\nimport type { Node as StructureNode } from '../structure-validation'\n\nexport type Mark =\n  | 'bold'\n  | 'italic'\n  | 'underline'\n  | 'strikethrough'\n  | 'code'\n  | 'superscript'\n  | 'subscript'\n  | 'keyboard'\n\nexport const allMarks: Mark[] = [\n  'bold',\n  'italic',\n  'underline',\n  'strikethrough',\n  'code',\n  'superscript',\n  'subscript',\n  'keyboard',\n]\n\nconst IS_MAC =\n  typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform)\n\nexport const modifierKeyText = IS_MAC ? '\u2318' : 'Ctrl'\n\nexport function isElementActive(\n  editor: Editor,\n  format: Exclude<StructureNode, { text: string }>['type']\n) {\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === format,\n  })\n\n  return !!match\n}\n\nexport function clearFormatting(editor: Editor) {\n  Transforms.unwrapNodes(editor, {\n    match: node => node.type === 'heading' || node.type === 'blockquote' || node.type === 'code',\n  })\n  Transforms.unsetNodes(editor, allMarks, { match: Text.isText })\n}\n\nexport function moveChildren(\n  editor: Editor,\n  parent: NodeEntry | Path,\n  to: Path,\n  shouldMoveNode: (node: Node) => boolean = () => true\n) {\n  const parentPath = Path.isPath(parent) ? parent : parent[1]\n  const parentNode = Path.isPath(parent) ? Node.get(editor, parentPath) : parent[0]\n  if (!(Element.isElement(parentNode) && Editor.isBlock(editor, parentNode))) return\n\n  for (let i = parentNode.children.length - 1; i >= 0; i--) {\n    if (shouldMoveNode(parentNode.children[i])) {\n      const childPath = [...parentPath, i]\n      Transforms.moveNodes(editor, { at: childPath, to })\n    }\n  }\n}\n\nexport function insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(\n  editor: Editor,\n  nodes: Node | Node[],\n  slate?: {\n    ReactEditor: {\n      focus: (editor: Editor) => void\n    }\n  }\n) {\n  let pathRefForEmptyNodeAtCursor: PathRef | undefined\n  const entry = Editor.above(editor, {\n    match: node => node.type === 'heading' || node.type === 'paragraph',\n  })\n  if (entry && Node.string(entry[0]) === '') {\n    pathRefForEmptyNodeAtCursor = Editor.pathRef(editor, entry[1])\n  }\n  Transforms.insertNodes(editor, nodes)\n  const path = pathRefForEmptyNodeAtCursor?.unref()\n  if (path) {\n    Transforms.removeNodes(editor, { at: path })\n    // even though the selection is in the right place after the removeNodes\n    // for some reason the editor blurs so we need to focus it again\n    slate?.ReactEditor.focus(editor)\n  }\n}\n\n/**\n * This is equivalent to Editor.after except that it ignores points that have no content\n * like the point in a void text node, an empty text node and the last point in a text node\n */\n// TODO: this would probably break if you were trying to get the last point in the editor?\nexport function EditorAfterButIgnoringingPointsWithNoContent(\n  editor: Editor,\n  at: Location,\n  {\n    distance = 1,\n  }: {\n    distance?: number\n  } = {}\n): Point | undefined {\n  const anchor = Editor.point(editor, at, { edge: 'end' })\n  const focus = Editor.end(editor, [])\n  const range = { anchor, focus }\n  let d = 0\n  let target\n\n  for (const p of Editor.positions(editor, {\n    at: range,\n  })) {\n    if (d > distance) break\n\n    // this is the important change\n    const node = Node.get(editor, p.path) as Text\n    if (node.text.length === p.offset) continue\n\n    if (d !== 0) {\n      target = p\n    }\n\n    d++\n  }\n\n  return target\n}\n\nexport function nodeTypeMatcher<Type extends Element['type'][]>(\n  ...args: Type\n): (node: Node) => node is Element & { type: Type[number] } {\n  if (args.length === 1) {\n    const type = args[0]\n    return ((node: Node) => node.type === type) as any\n  }\n  const set = new Set(args)\n  return ((node: Node) => typeof node.type === 'string' && set.has(node.type)) as any\n}\n\nexport function assert(condition: boolean): asserts condition {\n  if (!condition) throw new Error('failed assert')\n}\n", "import { type ComponentSchema, type ComponentBlock } from './api-shared'\nimport { getKeysForArrayValue, getNewArrayElementKey, setKeysForArrayValue } from './preview-props'\nimport { assertNever, findChildPropPaths } from './utils'\n\nexport function getInitialValue(type: string, componentBlock: ComponentBlock) {\n  const props = getInitialPropsValue({ kind: 'object', fields: componentBlock.schema })\n  return {\n    type: 'component-block' as const,\n    component: type,\n    props,\n    children: findChildPropPaths(props, componentBlock.schema).map(x => ({\n      type: `component-${x.options.kind}-prop` as const,\n      propPath: x.path,\n      children: [\n        x.options.kind === 'block'\n          ? { type: 'paragraph' as const, children: [{ text: '' }] }\n          : { text: '' },\n      ],\n    })),\n  }\n}\n\nexport function getInitialPropsValue(schema: ComponentSchema): any {\n  switch (schema.kind) {\n    case 'form':\n      return schema.defaultValue\n    case 'child':\n      return null\n    case 'relationship':\n      return schema.many ? [] : null\n    case 'conditional': {\n      const defaultValue = schema.discriminant.defaultValue\n      return {\n        discriminant: defaultValue,\n        value: getInitialPropsValue(schema.values[defaultValue.toString()]),\n      }\n    }\n    case 'object': {\n      const obj: Record<string, any> = {}\n      for (const key of Object.keys(schema.fields)) {\n        obj[key] = getInitialPropsValue(schema.fields[key])\n      }\n      return obj\n    }\n    case 'array':\n      return []\n  }\n  assertNever(schema)\n}\n\nexport function getInitialPropsValueFromInitializer(\n  schema: ComponentSchema,\n  initializer: any\n): any {\n  switch (schema.kind) {\n    case 'form':\n      return initializer === undefined ? schema.defaultValue : initializer\n    case 'child':\n      return null\n    case 'relationship':\n      return initializer === undefined ? (schema.many ? [] : null) : initializer\n    case 'conditional': {\n      const defaultValue =\n        initializer === undefined ? schema.discriminant.defaultValue : initializer.discriminant\n      return {\n        discriminant: defaultValue,\n        value: getInitialPropsValueFromInitializer(\n          schema.values[defaultValue.toString()],\n          initializer === undefined ? undefined : initializer.value\n        ),\n      }\n    }\n    case 'object': {\n      const obj: Record<string, any> = {}\n      for (const key of Object.keys(schema.fields)) {\n        obj[key] = getInitialPropsValueFromInitializer(\n          schema.fields[key],\n          initializer === undefined ? undefined : initializer[key]\n        )\n      }\n      return obj\n    }\n    case 'array': {\n      return ((initializer ?? []) as { value?: unknown }[]).map(x =>\n        getInitialPropsValueFromInitializer(schema.element, x.value)\n      )\n    }\n  }\n  assertNever(schema)\n}\n\nexport function updateValue(schema: ComponentSchema, currentValue: any, updater: any): any {\n  if (updater === undefined) return currentValue\n\n  switch (schema.kind) {\n    case 'relationship':\n      return updater\n    case 'form':\n      return updater\n    case 'child':\n      return null\n    case 'conditional': {\n      return {\n        discriminant: updater.discriminant,\n        value:\n          updater.discriminant === currentValue.discriminant\n            ? updateValue(\n                schema.values[updater.discriminant.toString()],\n                currentValue.value,\n                updater.value\n              )\n            : getInitialPropsValueFromInitializer(\n                schema.values[updater.discriminant.toString()],\n                updater.value\n              ),\n      }\n    }\n    case 'object': {\n      const obj: Record<string, any> = {}\n      for (const key of Object.keys(schema.fields)) {\n        obj[key] = updateValue(schema.fields[key], currentValue[key], updater[key])\n      }\n      return obj\n    }\n    case 'array': {\n      const currentArrVal = currentValue as unknown[]\n      const newVal = updater as { key: string | undefined; value: unknown }[]\n      const uniqueKeys = new Set()\n      for (const x of newVal) {\n        if (x.key !== undefined) {\n          if (uniqueKeys.has(x.key)) {\n            throw new Error('Array elements must have unique keys')\n          }\n          uniqueKeys.add(x.key)\n        }\n      }\n      const keys = newVal.map(x => {\n        if (x.key !== undefined) return x.key\n        let elementKey = getNewArrayElementKey()\n        // just in case someone gives a key that is above our counter\n        while (uniqueKeys.has(elementKey)) {\n          elementKey = getNewArrayElementKey()\n        }\n        uniqueKeys.add(elementKey)\n        return elementKey\n      })\n      const prevKeys = getKeysForArrayValue(currentArrVal)\n      const prevValuesByKey = new Map(\n        currentArrVal.map((value, i) => {\n          return [prevKeys[i], value]\n        })\n      )\n      const val = newVal.map((x, i) => {\n        const id = keys[i]\n        if (prevValuesByKey.has(id)) {\n          return updateValue(schema.element, prevValuesByKey.get(id), x.value)\n        }\n        return getInitialPropsValueFromInitializer(schema.element, x.value)\n      })\n      setKeysForArrayValue(val, keys)\n      return val\n    }\n  }\n  assertNever(schema)\n}\n", "import type {\n  ArrayField,\n  ComponentSchema,\n  ConditionalField,\n  ValueForComponentSchema,\n  FormField,\n  FormFieldValue,\n  HydratedRelationshipData,\n  ObjectField,\n  RelationshipField,\n  GenericPreviewProps,\n} from './api-shared'\nimport { updateValue } from './initial-values'\n\nconst arrayValuesToElementKeys = new WeakMap<readonly unknown[], readonly string[]>()\n\nlet counter = 0\n\nexport function getKeysForArrayValue(value: readonly unknown[]) {\n  if (!arrayValuesToElementKeys.has(value)) {\n    arrayValuesToElementKeys.set(value, Array.from({ length: value.length }, getNewArrayElementKey))\n  }\n  return arrayValuesToElementKeys.get(value)!\n}\n\nexport function setKeysForArrayValue(value: readonly unknown[], elementIds: readonly string[]) {\n  arrayValuesToElementKeys.set(value, elementIds)\n}\n\nexport function getNewArrayElementKey() {\n  return (counter++).toString()\n}\n\nfunction castToMemoizedInfoForSchema<\n  T extends {\n    [Kind in ComponentSchema['kind']]: (\n      schema: Extract<ComponentSchema, { kind: Kind }>,\n      onChange: (\n        cb: (\n          prevVal: ValueForComponentSchema<Extract<ComponentSchema, { kind: Kind }>>\n        ) => ValueForComponentSchema<Extract<ComponentSchema, { kind: Kind }>>\n      ) => void\n    ) => unknown\n  },\n>(val: T): T {\n  return val\n}\n\ntype GeneralMap<K, V> = {\n  has(key: K): boolean\n  get(key: K): V | undefined\n  set(key: K, value: V): void\n}\n\nfunction getOrInsert<K, V>(map: GeneralMap<K, V>, key: K, val: (key: K) => V): V {\n  if (!map.has(key)) map.set(key, val(key))\n  return map.get(key)!\n}\n\nexport function createGetPreviewProps<Schema extends ComponentSchema, ChildFieldElement>(\n  rootSchema: Schema,\n  rootOnChange: (\n    cb: (val: ValueForComponentSchema<Schema>) => ValueForComponentSchema<Schema>\n  ) => void,\n  getChildFieldElement: (path: readonly string[]) => ChildFieldElement\n): (value: ValueForComponentSchema<Schema>) => GenericPreviewProps<Schema, ChildFieldElement> {\n  const memoizedInfoForSchema = castToMemoizedInfoForSchema({\n    form(schema, onChange) {\n      return (newVal: unknown) => onChange(() => newVal)\n    },\n    array(schema, onChange) {\n      return {\n        rawOnChange: onChange,\n        inner: new Map<\n          string,\n          {\n            onChange: (cb: (val: unknown) => unknown) => void\n            elementWithKey: { key: string } & GenericPreviewProps<\n              ComponentSchema,\n              ChildFieldElement\n            >\n            element: GenericPreviewProps<ComponentSchema, ChildFieldElement>\n          }\n        >(),\n        onChange(updater: readonly { key: string | undefined; value?: unknown }[]) {\n          onChange(value => updateValue(schema, value, updater))\n        },\n      }\n    },\n    child() {},\n    conditional(schema, onChange) {\n      return {\n        onChange: (discriminant: string | boolean, value?: unknown) =>\n          onChange(v => updateValue(schema, v, { discriminant, value })),\n        onChangeForValue: (cb: (prevVal: unknown) => unknown) =>\n          onChange(v => ({ discriminant: v.discriminant, value: cb(v.value) })),\n      }\n    },\n    object(schema, onChange) {\n      return {\n        onChange: (updater: Record<string, unknown>) => {\n          onChange(value => updateValue(schema, value, updater))\n        },\n        innerOnChanges: Object.fromEntries(\n          Object.keys(schema.fields).map(key => {\n            return [\n              key,\n              (newVal: (prevVal: unknown) => unknown) => {\n                onChange(v => ({ ...v, [key]: newVal(v[key]) }))\n              },\n            ]\n          })\n        ),\n      }\n    },\n    relationship(schema, onChange) {\n      return (newVal: HydratedRelationshipData | readonly HydratedRelationshipData[] | null) =>\n        onChange(() => newVal)\n    },\n  })\n\n  const previewPropsFactories: {\n    [Kind in ComponentSchema['kind']]: (\n      schema: Extract<ComponentSchema, { kind: Kind }>,\n      value: ValueForComponentSchema<Extract<ComponentSchema, { kind: Kind }>>,\n      memoized: ReturnType<(typeof memoizedInfoForSchema)[Kind]>,\n      path: readonly string[],\n      getInnerProp: <Field extends ComponentSchema>(\n        schema: Field,\n        value: ValueForComponentSchema<Field>,\n        onChange: (\n          cb: (prevVal: ValueForComponentSchema<Field>) => ValueForComponentSchema<Field>\n        ) => void,\n        key: string\n      ) => GenericPreviewProps<Field, ChildFieldElement>\n    ) => GenericPreviewProps<Extract<ComponentSchema, { kind: Kind }>, ChildFieldElement>\n  } = {\n    form(schema, value, onChange) {\n      return {\n        value: value as FormFieldValue,\n        onChange,\n        options: schema.options,\n        schema: schema,\n      }\n    },\n    child(schema, value, onChange, path) {\n      return { element: getChildFieldElement(path), schema: schema }\n    },\n    object(schema, value, memoized, path, getInnerProp) {\n      const fields: Record<string, GenericPreviewProps<ComponentSchema, ChildFieldElement>> = {}\n\n      for (const key of Object.keys(schema.fields)) {\n        fields[key] = getInnerProp(\n          schema.fields[key],\n          value[key],\n          memoized.innerOnChanges[key],\n          key\n        )\n      }\n\n      const previewProps: GenericPreviewProps<\n        ObjectField<Record<string, ComponentSchema>>,\n        ChildFieldElement\n      > = {\n        fields,\n        onChange: memoized.onChange,\n        schema: schema,\n      }\n      return previewProps\n    },\n    array(schema, value, memoized, path, getInnerProp) {\n      if (!Array.isArray(value)) throw new TypeError('Expected array')\n      const arrayValue = value as readonly unknown[]\n      const keys = getKeysForArrayValue(arrayValue)\n      const unusedKeys = new Set([...keys])\n\n      const props: GenericPreviewProps<ArrayField<ComponentSchema>, ChildFieldElement> = {\n        elements: arrayValue.map((val, i) => {\n          const key = keys[i]\n          unusedKeys.delete(key)\n          const element = getOrInsert(memoized.inner, key, () => {\n            const onChange = (val: (val: unknown) => unknown) => {\n              memoized.rawOnChange(prev => {\n                const keys = getKeysForArrayValue(prev as readonly unknown[])\n                const index = keys.indexOf(key)\n                const newValue = [...(prev as readonly unknown[])]\n                newValue[index] = val(newValue[index])\n                setKeysForArrayValue(newValue, keys)\n                return newValue\n              })\n            }\n            const element = getInnerProp(schema.element, val, onChange, key)\n            return {\n              element,\n              elementWithKey: {\n                ...element,\n                key,\n              },\n              onChange,\n            }\n          })\n          const currentInnerProp = getInnerProp(schema.element, val, element.onChange, key)\n          if (element.element !== currentInnerProp) {\n            element.element = currentInnerProp\n            element.elementWithKey = {\n              ...currentInnerProp,\n              key,\n            }\n          }\n          return element.elementWithKey\n        }),\n        schema: schema,\n        onChange: memoized.onChange,\n      }\n      for (const key of unusedKeys) {\n        memoized.inner.delete(key)\n      }\n      return props\n    },\n    relationship(schema, value, onChange) {\n      const props: GenericPreviewProps<RelationshipField<boolean>, ChildFieldElement> = {\n        value: value,\n        onChange,\n        schema: schema,\n      }\n      return props\n    },\n    conditional(schema, value, memoized, path, getInnerProp) {\n      const props: GenericPreviewProps<\n        ConditionalField<FormField<string | boolean, unknown>, { [key: string]: ComponentSchema }>,\n        ChildFieldElement\n      > = {\n        discriminant: value.discriminant as any,\n        onChange: memoized.onChange,\n        options: schema.discriminant.options,\n        value: getInnerProp(\n          schema.values[value.discriminant.toString()],\n          value.value,\n          memoized.onChangeForValue,\n          'value'\n        ),\n        schema: schema,\n      }\n      return props\n    },\n  }\n\n  function getPreviewPropsForProp<Schema extends ComponentSchema>(\n    schema: Schema,\n    value: unknown,\n    memoedThing: { __memoizedThing: true },\n    path: readonly string[],\n    getInnerProp: <Field extends ComponentSchema>(\n      schema: Field,\n      value: ValueForComponentSchema<Field>,\n      onChange: (\n        cb: (prevVal: ValueForComponentSchema<Field>) => ValueForComponentSchema<Field>\n      ) => void,\n      key: string\n    ) => GenericPreviewProps<Field, ChildFieldElement>\n  ): GenericPreviewProps<Schema, ChildFieldElement> {\n    return previewPropsFactories[schema.kind](\n      schema as any,\n      value,\n      memoedThing as any,\n      path,\n      getInnerProp\n    ) as any\n  }\n\n  function getInitialMemoState<Schema extends ComponentSchema>(\n    schema: Schema,\n    value: ValueForComponentSchema<Schema>,\n    onChange: (\n      cb: (val: ValueForComponentSchema<Schema>) => ValueForComponentSchema<Schema>\n    ) => void,\n    path: readonly string[]\n  ): MemoState<Schema> {\n    const innerState = new Map<string, MemoState<ComponentSchema>>()\n    const memoizedInfo = (\n      memoizedInfoForSchema[schema.kind] as (\n        schema: ComponentSchema,\n        onChange: (\n          cb: (val: ValueForComponentSchema<Schema>) => ValueForComponentSchema<Schema>\n        ) => void\n      ) => any\n    )(schema, onChange)\n    const state: MemoState<ComponentSchema> = {\n      value,\n      inner: innerState,\n      props: getPreviewPropsForProp(\n        schema,\n        value,\n        memoizedInfo,\n        path,\n        (schema, value, onChange, key) => {\n          const state = getInitialMemoState(schema, value, onChange, path.concat(key))\n          innerState.set(key, state)\n          return state.props\n        }\n      ),\n      schema: schema,\n      cached: memoizedInfo,\n    }\n    return state as MemoState<Schema>\n  }\n  function getUpToDateProps<Schema extends ComponentSchema>(\n    schema: Schema,\n    value: ValueForComponentSchema<Schema>,\n    onChange: (\n      cb: (val: ValueForComponentSchema<Schema>) => ValueForComponentSchema<Schema>\n    ) => void,\n    memoState: MemoState<Schema>,\n    path: readonly string[]\n  ): GenericPreviewProps<Schema, ChildFieldElement> {\n    if (memoState.schema !== schema) {\n      Object.assign(memoState, getInitialMemoState(schema, value, onChange, path))\n      return memoState.props\n    }\n    if (memoState.value === value) {\n      return memoState.props\n    }\n    memoState.value = value\n    const unusedKeys = new Set(memoState.inner.keys())\n    memoState.props = getPreviewPropsForProp(\n      schema,\n      value,\n      memoState.cached as any,\n      path,\n      (schema, value, onChange, innerMemoStateKey) => {\n        unusedKeys.delete(innerMemoStateKey)\n        if (!memoState.inner.has(innerMemoStateKey)) {\n          const innerState = getInitialMemoState(\n            schema,\n            value,\n            onChange,\n            path.concat(innerMemoStateKey)\n          )\n          memoState.inner.set(innerMemoStateKey, innerState)\n          return innerState.props\n        }\n        return getUpToDateProps<typeof schema>(\n          schema,\n          value,\n          onChange,\n          memoState.inner.get(innerMemoStateKey) as MemoState<typeof schema>,\n          path.concat(innerMemoStateKey)\n        )\n      }\n    )\n    for (const key of unusedKeys) {\n      memoState.inner.delete(key)\n    }\n    return memoState.props\n  }\n\n  type MemoState<Schema extends ComponentSchema> = {\n    props: GenericPreviewProps<Schema, ChildFieldElement>\n    value: unknown\n    schema: Schema\n    cached: ReturnType<(typeof memoizedInfoForSchema)[Schema['kind']]>\n    inner: Map<string, MemoState<ComponentSchema>>\n  }\n\n  let memoState: MemoState<Schema>\n\n  return (\n    value: ValueForComponentSchema<Schema>\n  ): GenericPreviewProps<Schema, ChildFieldElement> => {\n    if (memoState === undefined) {\n      memoState = getInitialMemoState(rootSchema, value, rootOnChange, [])\n      return memoState.props\n    }\n    return getUpToDateProps(rootSchema, value, rootOnChange, memoState, [])\n  }\n}\n", "import type { DocumentFeatures } from '../../views-shared'\nimport type { DocumentFeaturesForNormalization } from '../document-features-normalization'\nimport { type Mark, assert } from '../utils'\nimport type { ComponentSchema, ChildField } from './api-shared'\nimport { getKeysForArrayValue, setKeysForArrayValue } from './preview-props'\n\ntype PathToChildFieldWithOption = { path: ReadonlyPropPath; options: ChildField['options'] }\n\nexport function findChildPropPathsForProp(\n  value: any,\n  schema: ComponentSchema,\n  path: ReadonlyPropPath\n): PathToChildFieldWithOption[] {\n  switch (schema.kind) {\n    case 'form':\n    case 'relationship':\n      return []\n    case 'child':\n      return [{ path: path, options: schema.options }]\n    case 'conditional':\n      return findChildPropPathsForProp(\n        value.value,\n        schema.values[value.discriminant],\n        path.concat('value')\n      )\n    case 'object': {\n      const paths: PathToChildFieldWithOption[] = []\n      Object.keys(schema.fields).forEach(key => {\n        paths.push(...findChildPropPathsForProp(value[key], schema.fields[key], path.concat(key)))\n      })\n      return paths\n    }\n    case 'array': {\n      const paths: PathToChildFieldWithOption[] = []\n      ;(value as any[]).forEach((val, i) => {\n        paths.push(...findChildPropPathsForProp(val, schema.element, path.concat(i)))\n      })\n      return paths\n    }\n  }\n}\n\nexport function findChildPropPaths(\n  value: Record<string, any>,\n  props: Record<string, ComponentSchema>\n): { path: ReadonlyPropPath | undefined; options: ChildField['options'] }[] {\n  const propPaths = findChildPropPathsForProp(value, { kind: 'object', fields: props }, [])\n  if (propPaths.length) return propPaths\n\n  return [\n    {\n      path: undefined,\n      options: { kind: 'inline', placeholder: '' },\n    },\n  ]\n}\n\nexport function assertNever(arg: never): never {\n  throw new Error('expected to never be called but received: ' + JSON.stringify(arg))\n}\n\nexport type DocumentFeaturesForChildField =\n  | {\n      kind: 'inline'\n      inlineMarks: 'inherit' | DocumentFeatures['formatting']['inlineMarks']\n      documentFeatures: {\n        links: boolean\n        relationships: boolean\n      }\n      softBreaks: boolean\n    }\n  | {\n      kind: 'block'\n      inlineMarks: 'inherit' | DocumentFeatures['formatting']['inlineMarks']\n      softBreaks: boolean\n      componentBlocks: boolean\n      documentFeatures: DocumentFeaturesForNormalization\n    }\n\nexport function getDocumentFeaturesForChildField(\n  editorDocumentFeatures: DocumentFeatures,\n  options: ChildField['options']\n): DocumentFeaturesForChildField {\n  // an important note for this: normalization based on document features\n  // is done based on the document features returned here\n  // and the editor document features\n  // so the result for any given child prop will be the things that are\n  // allowed by both these document features\n  // AND the editor document features\n  const inlineMarksFromOptions = options.formatting?.inlineMarks\n\n  const inlineMarks =\n    inlineMarksFromOptions === 'inherit'\n      ? 'inherit'\n      : (Object.fromEntries(\n          Object.keys(editorDocumentFeatures.formatting.inlineMarks).map(mark => {\n            return [mark as Mark, !!(inlineMarksFromOptions || {})[mark as Mark]]\n          })\n        ) as Record<Mark, boolean>)\n  if (options.kind === 'inline') {\n    return {\n      kind: 'inline',\n      inlineMarks,\n      documentFeatures: {\n        links: options.links === 'inherit',\n        relationships: options.relationships === 'inherit',\n      },\n      softBreaks: options.formatting?.softBreaks === 'inherit',\n    }\n  }\n  return {\n    kind: 'block',\n    inlineMarks,\n    softBreaks: options.formatting?.softBreaks === 'inherit',\n    documentFeatures: {\n      layouts: [],\n      dividers: options.dividers === 'inherit' ? editorDocumentFeatures.dividers : false,\n      formatting: {\n        alignment:\n          options.formatting?.alignment === 'inherit'\n            ? editorDocumentFeatures.formatting.alignment\n            : {\n                center: false,\n                end: false,\n              },\n        blockTypes:\n          options.formatting?.blockTypes === 'inherit'\n            ? editorDocumentFeatures.formatting.blockTypes\n            : {\n                blockquote: false,\n                code: false,\n              },\n        headingLevels:\n          options.formatting?.headingLevels === 'inherit'\n            ? editorDocumentFeatures.formatting.headingLevels\n            : options.formatting?.headingLevels || [],\n        listTypes:\n          options.formatting?.listTypes === 'inherit'\n            ? editorDocumentFeatures.formatting.listTypes\n            : {\n                ordered: false,\n                unordered: false,\n              },\n      },\n      links: options.links === 'inherit',\n      relationships: options.relationships === 'inherit',\n    },\n    componentBlocks: options.componentBlocks === 'inherit',\n  }\n}\n\nfunction getSchemaAtPropPathInner(\n  path: (string | number)[],\n  value: unknown,\n  schema: ComponentSchema\n): undefined | ComponentSchema {\n  // because we're checking the length here\n  // the non-null asserts on shift below are fine\n  if (path.length === 0) return schema\n  if (schema.kind === 'child' || schema.kind === 'form' || schema.kind === 'relationship') return\n  if (schema.kind === 'conditional') {\n    const key = path.shift()\n    if (key === 'discriminant')\n      return getSchemaAtPropPathInner(path, (value as any).discriminant, schema.discriminant)\n    if (key === 'value') {\n      const propVal = schema.values[(value as any).discriminant]\n      return getSchemaAtPropPathInner(path, (value as any).value, propVal)\n    }\n    return\n  }\n  if (schema.kind === 'object') {\n    const key = path.shift()!\n    return getSchemaAtPropPathInner(path, (value as any)[key], schema.fields[key])\n  }\n  if (schema.kind === 'array') {\n    const index = path.shift()!\n    return getSchemaAtPropPathInner(path, (value as any)[index], schema.element)\n  }\n  assertNever(schema)\n}\n\nexport function getSchemaAtPropPath(\n  path: ReadonlyPropPath,\n  value: Record<string, unknown>,\n  props: Record<string, ComponentSchema>\n): undefined | ComponentSchema {\n  return getSchemaAtPropPathInner([...path], value, {\n    kind: 'object',\n    fields: props,\n  })\n}\n\nexport function clientSideValidateProp(schema: ComponentSchema, value: unknown): boolean {\n  if (schema.kind === 'child') return true\n  if (schema.kind === 'relationship') return true\n  if (schema.kind === 'form') return schema.validate(value)\n  if (typeof value !== 'object') return false\n  if (value === null) return false\n  switch (schema.kind) {\n    case 'conditional': {\n      if (!('discriminant' in value) || !('value' in value)) return false\n      if (!schema.discriminant.validate(value.discriminant)) return false\n      return clientSideValidateProp(\n        schema.values[\n          // not actually gonna always be a string but just let property access do the coercion\n          value.discriminant as string\n        ],\n        value.value\n      )\n    }\n    case 'object': {\n      for (const [key, childProp] of Object.entries(schema.fields)) {\n        if (!clientSideValidateProp(childProp, (value as any)[key])) return false\n      }\n      return true\n    }\n    case 'array': {\n      if (!Array.isArray(value)) return false\n      for (const innerVal of value) {\n        if (!clientSideValidateProp(schema.element, innerVal)) return false\n      }\n      return true\n    }\n  }\n}\n\nexport function getAncestorSchemas(\n  rootSchema: ComponentSchema,\n  path: ReadonlyPropPath,\n  value: unknown\n) {\n  const ancestors: ComponentSchema[] = []\n  const currentPath = [...path]\n  let currentProp = rootSchema\n  let currentValue = value\n  while (currentPath.length) {\n    ancestors.push(currentProp)\n    const key = currentPath.shift()! // this code only runs when path.length is truthy so this non-null assertion is fine\n    if (currentProp.kind === 'array') {\n      currentProp = currentProp.element\n      currentValue = (currentValue as any)[key]\n    } else if (currentProp.kind === 'conditional') {\n      currentProp = currentProp.values[(value as any).discriminant]\n      currentValue = (currentValue as any).value\n    } else if (currentProp.kind === 'object') {\n      currentValue = (currentValue as any)[key]\n      currentProp = currentProp.fields[key]\n    } else if (\n      currentProp.kind === 'child' ||\n      currentProp.kind === 'form' ||\n      currentProp.kind === 'relationship'\n    ) {\n      throw new Error(`unexpected prop \"${key}\"`)\n    } else {\n      assertNever(currentProp)\n    }\n  }\n  return ancestors\n}\n\nexport type ReadonlyPropPath = readonly (string | number)[]\n\nexport function getValueAtPropPath(value: unknown, inputPath: ReadonlyPropPath) {\n  const path = [...inputPath]\n  while (path.length) {\n    const key = path.shift()!\n    value = (value as any)[key]\n  }\n  return value\n}\n\nexport function traverseProps(\n  schema: ComponentSchema,\n  value: unknown,\n  visitor: (schema: ComponentSchema, value: unknown, path: ReadonlyPropPath) => void,\n  path: ReadonlyPropPath = []\n) {\n  if (schema.kind === 'form' || schema.kind === 'relationship' || schema.kind === 'child') {\n    visitor(schema, value, path)\n    return\n  }\n  if (schema.kind === 'object') {\n    for (const [key, childProp] of Object.entries(schema.fields)) {\n      traverseProps(childProp, (value as any)[key], visitor, [...path, key])\n    }\n    visitor(schema, value, path)\n    return\n  }\n  if (schema.kind === 'array') {\n    for (const [idx, val] of (value as unknown[]).entries()) {\n      traverseProps(schema.element, val, visitor, path.concat(idx))\n    }\n    return visitor(schema, value, path)\n  }\n  if (schema.kind === 'conditional') {\n    const discriminant: string | boolean = (value as any).discriminant\n    visitor(schema, discriminant, path.concat('discriminant'))\n    traverseProps(\n      schema.values[discriminant.toString()],\n      (value as any).value,\n      visitor,\n      path.concat('value')\n    )\n    visitor(schema, value, path)\n    return\n  }\n  assertNever(schema)\n}\n\nexport function replaceValueAtPropPath(\n  schema: ComponentSchema,\n  value: unknown,\n  newValue: unknown,\n  path: ReadonlyPropPath\n): unknown {\n  if (path.length === 0) return newValue\n\n  const [key, ...newPath] = path\n\n  if (schema.kind === 'object') {\n    return {\n      ...(value as any),\n      [key]: replaceValueAtPropPath(schema.fields[key], (value as any)[key], newValue, newPath),\n    }\n  }\n\n  if (schema.kind === 'conditional') {\n    const conditionalValue = value as { discriminant: string | boolean; value: unknown }\n    // replaceValueAtPropPath should not be used to only update the discriminant of a conditional field\n    // if you want to update the discriminant of a conditional field, replace the value of the whole conditional field\n    assert(key === 'value')\n    return {\n      discriminant: conditionalValue.discriminant,\n      value: replaceValueAtPropPath(schema.values[key], conditionalValue.value, newValue, newPath),\n    }\n  }\n\n  if (schema.kind === 'array') {\n    const prevVal = value as unknown[]\n    const newVal = [...prevVal]\n    setKeysForArrayValue(newVal, getKeysForArrayValue(prevVal))\n    newVal[key as number] = replaceValueAtPropPath(\n      schema.element,\n      newVal[key as number],\n      newValue,\n      newPath\n    )\n    return newVal\n  }\n\n  // we should never reach here since form, relationship or child fields don't contain other fields\n  // so the only thing that can happen to them is to be replaced which happens at the start of this function when path.length === 0\n  assert(schema.kind !== 'form' && schema.kind !== 'relationship' && schema.kind !== 'child')\n\n  assertNever(schema)\n}\n\nexport function getPlaceholderTextForPropPath(\n  propPath: ReadonlyPropPath,\n  fields: Record<string, ComponentSchema>,\n  formProps: Record<string, any>\n): string {\n  const field = getSchemaAtPropPath(propPath, formProps, fields)\n  if (field?.kind === 'child') return field.options.placeholder\n  return ''\n}\n", "import { type ComponentSchema } from './api-shared'\nimport { assertNever } from './utils'\n\nexport function assertValidComponentSchema(\n  schema: ComponentSchema,\n  lists: ReadonlySet<string>,\n  mode: 'structure' | 'document'\n) {\n  assertValidComponentSchemaInner(schema, [], [], new Set(), lists, mode)\n}\n\n// recursive things can exist but they have to either be:\n// - inside the non-default portion of a conditional field\n// - inside an array field\n// when we hit the non-default portion of a conditional field or an array field\n// checking inside of it essentially means pretend it's a new thing\nfunction assertValidComponentSchemaInner(\n  schema: ComponentSchema,\n  schemaAncestors: ComponentSchema[],\n  propPath: string[],\n  seenProps: Set<ComponentSchema>,\n  lists: ReadonlySet<string>,\n  mode: 'structure' | 'document'\n) {\n  if (schema.kind === 'form') {\n    if (mode === 'structure' && !schema.graphql) {\n      throw new Error(\n        `There is a form field without a configured GraphQL schema at \"${propPath.join('.')}\", fields used in the structure field must have a GraphQL schema.`\n      )\n    }\n    return\n  }\n  if (schema.kind === 'child') {\n    if (mode === 'structure') {\n      throw new Error(\n        `There is a child field at \"${propPath.join('.')}\" but child fields are not allowed in structure fields.`\n      )\n    }\n    return\n  }\n  if (schema.kind === 'relationship') {\n    if (lists.has(schema.listKey)) {\n      return\n    }\n    throw new Error(\n      `The relationship field at \"${propPath.join('.')}\" has the listKey \"${\n        schema.listKey\n      }\" but no list named \"${schema.listKey}\" exists.`\n    )\n  }\n  const ancestor = schemaAncestors.indexOf(schema)\n  if (ancestor !== -1) {\n    throw new Error(\n      `The field \"${propPath.join(\n        '.'\n      )}\" is the same as it's ancestor. Use an array or conditional field for recursive structures.`\n    )\n  }\n  if (seenProps.has(schema)) {\n    return\n  }\n  propPath.push(schema.kind)\n  try {\n    seenProps.add(schema)\n    if (schema.kind === 'array') {\n      assertValidComponentSchemaInner(schema.element, [], propPath, seenProps, lists, mode)\n      return\n    }\n    if (schema.kind === 'object') {\n      schemaAncestors.push(schema)\n      for (const [key, innerProp] of Object.entries(schema.fields)) {\n        propPath.push(key)\n        if (schema.fields[key] !== innerProp) {\n          throw new Error(\n            `Fields on an object field must not change over time but the field at \"${propPath.join(\n              '.'\n            )}\" changes between accesses`\n          )\n        }\n        assertValidComponentSchemaInner(\n          innerProp,\n          schemaAncestors,\n          propPath,\n          seenProps,\n          lists,\n          mode\n        )\n        propPath.pop()\n      }\n      schemaAncestors.pop()\n      return\n    }\n    if (schema.kind === 'conditional') {\n      schemaAncestors.push(schema)\n      const stringifiedDefaultDiscriminant = schema.discriminant.defaultValue.toString()\n      for (const [key, innerProp] of Object.entries(schema.values)) {\n        propPath.push(key)\n        if (schema.values[key] !== innerProp) {\n          throw new Error(\n            `Fields on a conditional field must not change over time but the field at \"${propPath.join(\n              '.'\n            )}\" changes between accesses`\n          )\n        }\n        assertValidComponentSchemaInner(\n          innerProp,\n          key === stringifiedDefaultDiscriminant ? schemaAncestors : [],\n          propPath,\n          seenProps,\n          lists,\n          mode\n        )\n        propPath.pop()\n      }\n      schemaAncestors.pop()\n      return\n    }\n  } finally {\n    propPath.pop()\n  }\n  assertNever(schema)\n}\n", "import type { KeystoneContext } from '@keystone-6/core/types'\nimport type { Descendant } from 'slate'\n\nimport type {\n  ComponentBlock,\n  ComponentSchema,\n  RelationshipField,\n} from './DocumentEditor/component-blocks/api-shared'\nimport { assertNever } from './DocumentEditor/component-blocks/utils'\nimport type { Relationships } from './DocumentEditor/relationship-shared'\n\nconst labelFieldAlias = '____document_field_relationship_item_label'\nconst idFieldAlias = '____document_field_relationship_item_id'\n\nexport function addRelationshipData(\n  nodes: Descendant[],\n  context: KeystoneContext,\n  relationships: Relationships,\n  componentBlocks: Record<string, ComponentBlock>\n): Promise<Descendant[]> {\n  return Promise.all(\n    nodes.map(async (node): Promise<Descendant> => {\n      if (node.type === 'relationship') {\n        const relationship = relationships[node.relationship]\n        if (!relationship) return node\n\n        return {\n          ...node,\n          data: await fetchDataForOne(\n            context,\n            {\n              ...relationship,\n              many: false,\n            },\n            node.data\n          ),\n        }\n      }\n      if (node.type === 'component-block') {\n        const componentBlock = componentBlocks[node.component as string]\n        if (componentBlock) {\n          const [props, children] = await Promise.all([\n            addRelationshipDataToComponentProps(\n              { kind: 'object', fields: componentBlock.schema },\n              node.props,\n              (relationship, data) => fetchRelationshipData(context, relationship, data)\n            ),\n            addRelationshipData(node.children, context, relationships, componentBlocks),\n          ])\n          return {\n            ...node,\n            props,\n            children,\n          }\n        }\n      }\n      if ('children' in node && Array.isArray(node.children)) {\n        return {\n          ...node,\n          children: await addRelationshipData(\n            node.children,\n            context,\n            relationships,\n            componentBlocks\n          ),\n        }\n      }\n      return node\n    })\n  )\n}\n\ntype Relationship_ = Omit<RelationshipField<boolean>, 'kind' | 'description'>\n\nexport async function fetchRelationshipData(\n  context: KeystoneContext,\n  relationship: Relationship_,\n  data: any\n) {\n  if (!relationship.many) return fetchDataForOne(context, relationship, data)\n\n  const ids = Array.isArray(data) ? data.filter(item => item.id != null).map(x => x.id) : []\n  if (!ids.length) return []\n\n  const list = context.__internal.lists[relationship.listKey]\n  const { listQueryName } = list.graphql.names\n  const labelField = relationship.labelField ?? list.ui.labelField\n\n  const value = (await context.graphql.run({\n    query: `query($ids: [ID!]!) {items:${listQueryName}(where: { id: { in: $ids } }) {${idFieldAlias}:id ${labelFieldAlias}:${labelField}\\n${\n      relationship.selection || ''\n    }}}`,\n    variables: { ids },\n  })) as { items: { [idFieldAlias]: string | number; [labelFieldAlias]: string }[] }\n\n  return Array.isArray(value.items)\n    ? value.items.map(({ [labelFieldAlias]: label, [idFieldAlias]: id, ...data }) => {\n        return { id, label, data }\n      })\n    : []\n}\n\nasync function fetchDataForOne(context: KeystoneContext, relationship: Relationship_, data: any) {\n  // Single related item\n  const id = data?.id\n  if (id == null) return null\n\n  // An exception here indicates something wrong with either the system or the\n  // configuration (e.g. a bad selection field). These will surface as system\n  // errors from the GraphQL field resolver.\n  const list = context.__internal.lists[relationship.listKey]\n  const { itemQueryName } = list.graphql.names\n  const labelField = relationship.labelField ?? list.ui.labelField\n  const value = (await context.graphql.run({\n    query: `query($id: ID!) {item:${itemQueryName}(where: { id: $id }) {${labelFieldAlias}:${labelField}\\n${relationship.selection || ''}}}`,\n    variables: { id },\n  })) as { item: Record<string, any> | null }\n\n  if (value.item === null) return { id, data: undefined, label: undefined }\n  return {\n    id,\n    label: value.item[labelFieldAlias],\n    data: (() => {\n      const { [labelFieldAlias]: _ignore, ...otherData } = value.item\n      return otherData\n    })(),\n  }\n}\n\nexport async function addRelationshipDataToComponentProps(\n  schema: ComponentSchema,\n  value: any,\n  fetchData: (relationship: RelationshipField<boolean>, data: any) => Promise<any>\n): Promise<any> {\n  switch (schema.kind) {\n    case 'child':\n      return value\n    case 'form':\n      return value\n    case 'relationship':\n      return fetchData(schema, value)\n    case 'object': {\n      return Object.fromEntries(\n        await Promise.all(\n          Object.keys(schema.fields).map(async key => [\n            key,\n            // if val[key] === undefined, we know a new field was added to the schema\n            // but there is old data in the database that doesn't have the new field\n            // we're intentionally not just magically adding it because we may want to\n            // have a more optimised strategy of hydrating relationships so we don't\n            // want to add something unrelated that requires the current \"traverse everything\" strategy\n            value[key] === undefined\n              ? undefined\n              : await addRelationshipDataToComponentProps(\n                  schema.fields[key],\n                  value[key],\n                  fetchData\n                ),\n          ])\n        )\n      )\n    }\n    case 'conditional': {\n      return {\n        discriminant: value.discriminant,\n        value: await addRelationshipDataToComponentProps(\n          schema.values[value.discriminant],\n          value.value,\n          fetchData\n        ),\n      }\n    }\n    case 'array': {\n      return await Promise.all(\n        (value as any[]).map(async innerVal =>\n          addRelationshipDataToComponentProps(schema.element, innerVal, fetchData)\n        )\n      )\n    }\n  }\n  assertNever(schema)\n}\n", "import { Editor, Text } from 'slate'\nimport type { ComponentBlock, ComponentSchema } from './DocumentEditor/component-blocks/api-shared'\nimport { type ReadonlyPropPath, assertNever } from './DocumentEditor/component-blocks/utils'\nimport { createDocumentEditor } from './DocumentEditor/editor-shared'\nimport type { Relationships } from './DocumentEditor/relationship-shared'\nimport {\n  type Node,\n  type TextWithMarks,\n  isRelationshipData,\n  validateDocumentStructure,\n} from './structure-validation'\nimport type { DocumentFeatures } from './views-shared'\n\nexport class PropValidationError extends Error {\n  path: ReadonlyPropPath\n  constructor(message: string, path: ReadonlyPropPath) {\n    super(`${message} at ${path.join('.')}`)\n    this.path = path\n  }\n}\n\nfunction validateComponentBlockProps(\n  schema: ComponentSchema,\n  value: unknown,\n  relationships: Relationships,\n  path: ReadonlyPropPath\n): any {\n  if (schema.kind === 'form') {\n    value = value === undefined ? schema.defaultValue : value\n    if (schema.validate(value)) {\n      return value\n    }\n    throw new PropValidationError(`Invalid form prop value: ${JSON.stringify(value)}`, path)\n  }\n  if (schema.kind === 'child') {\n    return null\n  }\n  if (schema.kind === 'relationship') {\n    if (schema.many) {\n      if (Array.isArray(value) && value.every(isRelationshipData)) {\n        // yes, ts understands this completely correctly, i'm as suprised as you are\n        return value.map(x => ({ id: x.id }))\n      } else {\n        throw new PropValidationError(`Invalid relationship value: ${JSON.stringify(value)}`, path)\n      }\n    }\n    if (value === null || isRelationshipData(value)) {\n      return value === null ? null : { id: value.id }\n    } else {\n      throw new PropValidationError(`Invalid relationship value: ${JSON.stringify(value)}`, path)\n    }\n  }\n\n  if (schema.kind === 'conditional') {\n    if (typeof value !== 'object' || value === null) {\n      throw new PropValidationError(\n        `Conditional value must be an object but is ${typeof value}`,\n        path\n      )\n    }\n    for (const key of Object.keys(value)) {\n      if (key !== 'discriminant' && key !== 'value') {\n        throw new PropValidationError(\n          `Conditional value only allows keys named \"discriminant\" and \"value\", not \"${key}\"`,\n          path\n        )\n      }\n    }\n    const discriminant = (value as any).discriminant\n    const val = (value as any).value\n    // for some reason mongo or mongoose or something is saving undefined as null\n    // so we're doing this so that we avoid setting undefined on objects\n    const obj: any = {}\n    const discriminantVal = validateComponentBlockProps(\n      schema.discriminant,\n      discriminant,\n      relationships,\n      path.concat('discriminant')\n    )\n    if (discriminantVal !== undefined) {\n      obj.discriminant = discriminantVal\n    }\n    const conditionalFieldValue = validateComponentBlockProps(\n      schema.values[discriminant],\n      val,\n      relationships,\n      path.concat('value')\n    )\n    if (conditionalFieldValue !== undefined) {\n      obj.value = conditionalFieldValue\n    }\n    return obj\n  }\n\n  if (schema.kind === 'object') {\n    if (typeof value !== 'object' || value === null) {\n      throw new PropValidationError(`Object value must be an object but is ${typeof value}`, path)\n    }\n    const val: Record<string, any> = {}\n    for (const key of Object.keys(schema.fields)) {\n      const propVal = validateComponentBlockProps(\n        schema.fields[key],\n        (value as any)[key],\n        relationships,\n        path.concat(key)\n      )\n      // for some reason mongo or mongoose or something is saving undefined as null\n      // so we're doing this so that we avoid setting undefined on objects\n      if (propVal !== undefined) {\n        val[key] = propVal\n      }\n    }\n    return val\n  }\n  if (schema.kind === 'array') {\n    if (!Array.isArray(value)) {\n      throw new PropValidationError(\n        `Array field value must be an array but is ${typeof value}`,\n        path\n      )\n    }\n    return value.map((innerVal, i) => {\n      return validateComponentBlockProps(schema.element, innerVal, relationships, path.concat(i))\n    })\n  }\n  assertNever(schema)\n}\n\nfunction isText(node: Node): node is TextWithMarks {\n  return Text.isText(node)\n}\n\n// note that the errors thrown from here will only be exposed\n// as internal server error from the graphql api in prod\n// this is fine because these cases are pretty much all about\n// malicious content being inserted, not valid content\nexport function getValidatedNodeWithNormalizedComponentFormProps(\n  node: Node,\n  componentBlocks: Record<string, ComponentBlock>,\n  relationships: Relationships\n): Node {\n  if (isText(node)) return node\n  if (node.type === 'component-block') {\n    if (Object.prototype.hasOwnProperty.call(componentBlocks, node.component)) {\n      const componentBlock = componentBlocks[node.component]\n      node = {\n        ...node,\n        props: validateComponentBlockProps(\n          { kind: 'object', fields: componentBlock.schema },\n          node.props,\n          relationships,\n          []\n        ),\n      }\n    }\n  }\n\n  if (node.type === 'relationship') {\n    node = {\n      type: 'relationship',\n      data:\n        node.data?.id !== undefined\n          ? { id: node.data.id, data: undefined, label: undefined }\n          : null,\n      relationship: node.relationship,\n      children: node.children,\n    }\n  }\n\n  return {\n    ...node,\n    children: node.children.map(x =>\n      getValidatedNodeWithNormalizedComponentFormProps(x, componentBlocks, relationships)\n    ),\n  }\n}\n\nexport function validateAndNormalizeDocument(\n  value: unknown,\n  documentFeatures: DocumentFeatures,\n  componentBlocks: Record<string, ComponentBlock>,\n  relationships: Relationships\n) {\n  validateDocumentStructure(value)\n  const children = value.map(x =>\n    getValidatedNodeWithNormalizedComponentFormProps(x, componentBlocks, relationships)\n  )\n  const editor = createDocumentEditor(documentFeatures, componentBlocks, relationships)\n  editor.children = children as any\n  Editor.normalize(editor, { force: true })\n  return editor.children\n}\n", "import {\n  type Descendant,\n  type NodeEntry,\n  Editor,\n  Element,\n  Node,\n  Path,\n  Text,\n  Transforms,\n  createEditor,\n} from 'slate'\nimport { withHistory } from 'slate-history'\n\nimport { type ComponentBlock } from './component-blocks/api-shared'\nimport { type DocumentFeatures } from '../views-shared'\n\nimport { withComponentBlocks } from './component-blocks/with-component-blocks'\nimport { withParagraphs } from './paragraphs'\nimport { withList } from './lists-shared'\nimport { withLink } from './link-shared'\nimport { withLayouts } from './layouts-shared'\nimport { withHeading } from './heading-shared'\nimport { withBlockquote } from './blockquote-shared'\nimport { type Relationships, withRelationship } from './relationship-shared'\nimport { withDivider } from './divider-shared'\nimport { withCodeBlock } from './code-block-shared'\nimport { withMarks } from './marks'\nimport { withSoftBreaks } from './soft-breaks'\nimport { withShortcuts } from './shortcuts'\nimport { withDocumentFeaturesNormalization } from './document-features-normalization'\nimport { withInsertMenu } from './insert-menu-shared'\nimport { withBlockMarkdownShortcuts } from './block-markdown-shortcuts'\nimport { withPasting } from './pasting'\n\nexport type Block = Exclude<Element, { type: 'relationship' | 'link' }>\n\nconst blockquoteChildren = [\n  'paragraph',\n  'code',\n  'heading',\n  'ordered-list',\n  'unordered-list',\n  'divider',\n] as const\nconst paragraphLike = [...blockquoteChildren, 'blockquote'] as const\nconst insideOfLayouts = [...paragraphLike, 'component-block'] as const\n\nexport const editorSchema = {\n  editor: blockContainer({\n    allowedChildren: [...insideOfLayouts, 'layout'],\n    invalidPositionHandleMode: 'move',\n  }),\n  layout: blockContainer({ allowedChildren: ['layout-area'], invalidPositionHandleMode: 'move' }),\n  'layout-area': blockContainer({\n    allowedChildren: insideOfLayouts,\n    invalidPositionHandleMode: 'unwrap',\n  }),\n  blockquote: blockContainer({\n    allowedChildren: blockquoteChildren,\n    invalidPositionHandleMode: 'move',\n  }),\n  paragraph: inlineContainer({ invalidPositionHandleMode: 'unwrap' }),\n  code: inlineContainer({ invalidPositionHandleMode: 'move' }),\n  divider: inlineContainer({ invalidPositionHandleMode: 'move' }),\n  heading: inlineContainer({ invalidPositionHandleMode: 'unwrap' }),\n  'component-block': blockContainer({\n    allowedChildren: ['component-block-prop', 'component-inline-prop'],\n    invalidPositionHandleMode: 'move',\n  }),\n  'component-inline-prop': inlineContainer({ invalidPositionHandleMode: 'unwrap' }),\n  'component-block-prop': blockContainer({\n    allowedChildren: insideOfLayouts,\n    invalidPositionHandleMode: 'unwrap',\n  }),\n  'ordered-list': blockContainer({\n    allowedChildren: ['list-item'],\n    invalidPositionHandleMode: 'move',\n  }),\n  'unordered-list': blockContainer({\n    allowedChildren: ['list-item'],\n    invalidPositionHandleMode: 'move',\n  }),\n  'list-item': blockContainer({\n    allowedChildren: ['list-item-content', 'ordered-list', 'unordered-list'],\n    invalidPositionHandleMode: 'unwrap',\n  }),\n  'list-item-content': inlineContainer({ invalidPositionHandleMode: 'unwrap' }),\n} satisfies Record<Block['type'] | 'editor', BlockContainerSchema | InlineContainerSchema>\n\ntype EditorSchema = typeof editorSchema\ntype InlineContainingType = {\n  [Key in keyof EditorSchema]: { inlines: Key; blocks: never }[EditorSchema[Key]['kind']]\n}[keyof EditorSchema]\n\nfunction inlineContainer(args: {\n  invalidPositionHandleMode: 'unwrap' | 'move'\n}): InlineContainerSchema {\n  return {\n    kind: 'inlines',\n    invalidPositionHandleMode: args.invalidPositionHandleMode,\n  }\n}\n\nconst inlineContainerTypes = new Set(\n  Object.entries(editorSchema)\n    .filter(([, value]) => value.kind === 'inlines')\n    .map(([type]) => type)\n)\n\ntype InlineContainerSchema = { kind: 'inlines'; invalidPositionHandleMode: 'unwrap' | 'move' }\n\ntype TypesWhichHaveNoExtraRequiredProps = {\n  [Type in Block['type']]: { type: Type; children: Descendant[] } extends Block & { type: Type }\n    ? Type\n    : never\n}[Block['type']]\n\ntype BlockContainerSchema = {\n  kind: 'blocks'\n  allowedChildren: ReadonlySet<Element['type']>\n  blockToWrapInlinesIn: TypesWhichHaveNoExtraRequiredProps\n  invalidPositionHandleMode: 'unwrap' | 'move'\n}\n\nexport function isInlineContainer(node: Node): node is Block & { type: InlineContainingType } {\n  return node.type !== undefined && inlineContainerTypes.has(node.type)\n}\n\nexport function createDocumentEditor(\n  documentFeatures: DocumentFeatures,\n  componentBlocks: Record<string, ComponentBlock>,\n  relationships: Relationships,\n  slate?: {\n    withReact: (editor: Editor) => any\n    ReactEditor: {\n      focus: (editor: Editor) => void\n    }\n  }\n) {\n  return withPasting(\n    withSoftBreaks(\n      withBlocksSchema(\n        withLink(\n          documentFeatures,\n          componentBlocks,\n          withList(\n            withHeading(\n              withRelationship(\n                withInsertMenu(\n                  withComponentBlocks(\n                    componentBlocks,\n                    documentFeatures,\n                    relationships,\n                    withParagraphs(\n                      withShortcuts(\n                        withDivider(\n                          withLayouts(\n                            withMarks(\n                              documentFeatures,\n                              componentBlocks,\n                              withCodeBlock(\n                                withBlockMarkdownShortcuts(\n                                  documentFeatures,\n                                  componentBlocks,\n                                  withBlockquote(\n                                    withDocumentFeaturesNormalization(\n                                      documentFeatures,\n                                      relationships,\n                                      withHistory(\n                                        slate?.withReact(createEditor()) ?? createEditor()\n                                      )\n                                    )\n                                  )\n                                )\n                              )\n                            )\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n}\n\nfunction blockContainer(args: {\n  allowedChildren: readonly [TypesWhichHaveNoExtraRequiredProps, ...Block['type'][]]\n  invalidPositionHandleMode: 'unwrap' | 'move'\n}): BlockContainerSchema {\n  return {\n    kind: 'blocks',\n    allowedChildren: new Set(args.allowedChildren),\n    blockToWrapInlinesIn: args.allowedChildren[0],\n    invalidPositionHandleMode: args.invalidPositionHandleMode,\n  }\n}\n\nconst blockTypes: Set<string | undefined> = new Set(\n  Object.keys(editorSchema).filter(x => x !== 'editor')\n)\n\nexport function isBlock(node: Descendant): node is Block {\n  return blockTypes.has(node.type)\n}\n\nfunction withBlocksSchema(editor: Editor): Editor {\n  const { normalizeNode } = editor\n  editor.normalizeNode = ([node, path]) => {\n    if (!Text.isText(node) && node.type !== 'link' && node.type !== 'relationship') {\n      const nodeType = Editor.isEditor(node) ? 'editor' : node.type\n      if (typeof nodeType !== 'string' || editorSchema[nodeType] === undefined) {\n        Transforms.unwrapNodes(editor, { at: path })\n        return\n      }\n      const info = editorSchema[nodeType]\n\n      if (\n        info.kind === 'blocks' &&\n        node.children.length !== 0 &&\n        node.children.every(child => !(Element.isElement(child) && Editor.isBlock(editor, child)))\n      ) {\n        Transforms.wrapNodes(\n          editor,\n          { type: info.blockToWrapInlinesIn, children: [] },\n          { at: path, match: node => !(Element.isElement(node) && Editor.isBlock(editor, node)) }\n        )\n        return\n      }\n\n      for (const [index, childNode] of node.children.entries()) {\n        const childPath = [...path, index]\n        if (info.kind === 'inlines') {\n          if (\n            !Text.isText(childNode) &&\n            !Editor.isInline(editor, childNode) &&\n            // these checks are implicit in Editor.isBlock\n            // but that isn't encoded in types so these will make TS happy\n            childNode.type !== 'link' &&\n            childNode.type !== 'relationship'\n          ) {\n            handleNodeInInvalidPosition(editor, [childNode, childPath], path)\n            return\n          }\n        } else {\n          if (\n            !(Element.isElement(childNode) && Editor.isBlock(editor, childNode)) ||\n            // these checks are implicit in Editor.isBlock\n            // but that isn't encoded in types so these will make TS happy\n            childNode.type === 'link' ||\n            childNode.type === 'relationship'\n          ) {\n            Transforms.wrapNodes(\n              editor,\n              { type: info.blockToWrapInlinesIn, children: [] },\n              { at: childPath }\n            )\n            return\n          }\n          if (\n            Element.isElement(childNode) &&\n            Editor.isBlock(editor, childNode) &&\n            !info.allowedChildren.has(childNode.type)\n          ) {\n            handleNodeInInvalidPosition(editor, [childNode, childPath], path)\n            return\n          }\n        }\n      }\n    }\n    normalizeNode([node, path])\n  }\n  return editor\n}\n\nfunction handleNodeInInvalidPosition(\n  editor: Editor,\n  [node, path]: NodeEntry<Block>,\n  parentPath: Path\n) {\n  const nodeType = node.type\n  const childNodeInfo = editorSchema[nodeType]\n  // the parent of a block will never be an inline so this casting is okay\n  const parentNode = Node.get(editor, parentPath) as Block | Editor\n  const parentNodeType = Editor.isEditor(parentNode) ? 'editor' : parentNode.type\n  const parentNodeInfo = editorSchema[parentNodeType]\n\n  if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === 'unwrap') {\n    if (parentNodeInfo.kind === 'blocks' && parentNodeInfo.blockToWrapInlinesIn) {\n      Transforms.setNodes(\n        editor,\n        {\n          type: parentNodeInfo.blockToWrapInlinesIn,\n          ...(Object.fromEntries(\n            Object.keys(node)\n              .filter(key => key !== 'type' && key !== 'children')\n              .map(key => [key, null])\n          ) as any), // the Slate types don't understand that null is allowed and it will unset properties with setNodes\n        },\n        { at: path }\n      )\n      return\n    }\n    Transforms.unwrapNodes(editor, { at: path })\n    return\n  }\n\n  const info = editorSchema[parentNode.type || 'editor']\n  if (info?.kind === 'blocks' && info.allowedChildren.has(nodeType)) {\n    if (parentPath.length === 0) {\n      Transforms.moveNodes(editor, { at: path, to: [path[0] + 1] })\n    } else {\n      Transforms.moveNodes(editor, { at: path, to: Path.next(parentPath) })\n    }\n    return\n  }\n  if (Editor.isEditor(parentNode)) {\n    Transforms.moveNodes(editor, { at: path, to: [path[0] + 1] })\n    Transforms.unwrapNodes(editor, { at: [path[0] + 1] })\n    return\n  }\n  handleNodeInInvalidPosition(editor, [node, path], parentPath.slice(0, -1))\n}\n\n// to print the editor schema in Graphviz if you want to visualize it\n// function printEditorSchema(editorSchema: EditorSchema) {\n//   return `digraph G {\n//   concentrate=true;\n//   ${Object.keys(editorSchema)\n//     .map(key => {\n//       let val = editorSchema[key];\n//       if (val.kind === 'inlines') {\n//         return `\"${key}\" -> inlines`;\n//       }\n//       if (val.kind === 'blocks') {\n//         return `\"${key}\" -> {${[...val.allowedChildren].map(x => JSON.stringify(x)).join(' ')}}`;\n//       }\n//     })\n//     .join('\\n  ')}\n// }`;\n// }\n", "import { type NodeEntry, Editor, Element, Transforms, Range, Path, Node, Text } from 'slate'\n\nimport weakMemoize from '@emotion/weak-memoize'\nimport type { ArrayField, ChildField, ComponentBlock, ComponentSchema } from './api-shared'\nimport { assert, moveChildren } from '../utils'\nimport type { DocumentFeatures } from '../../views-shared'\nimport {\n  areArraysEqual,\n  normalizeElementBasedOnDocumentFeatures,\n  normalizeInlineBasedOnLinksAndRelationships,\n  normalizeTextBasedOnInlineMarksAndSoftBreaks,\n} from '../document-features-normalization'\nimport type { Relationships } from '../relationship-shared'\nimport {\n  type DocumentFeaturesForChildField,\n  type ReadonlyPropPath,\n  assertNever,\n  findChildPropPaths,\n  getAncestorSchemas,\n  getDocumentFeaturesForChildField,\n  getValueAtPropPath,\n  replaceValueAtPropPath,\n  traverseProps,\n} from './utils'\nimport { getInitialPropsValue } from './initial-values'\nimport { getKeysForArrayValue, getNewArrayElementKey, setKeysForArrayValue } from './preview-props'\n\nfunction getAncestorComponentBlock(editor: Editor) {\n  if (editor.selection) {\n    const ancestorEntry = Editor.above(editor, {\n      match: node =>\n        Element.isElement(node) && Editor.isBlock(editor, node) && node.type !== 'paragraph',\n    })\n    if (\n      ancestorEntry &&\n      (ancestorEntry[0].type === 'component-block-prop' ||\n        ancestorEntry[0].type === 'component-inline-prop')\n    ) {\n      return {\n        isInside: true,\n        componentBlock: Editor.parent(editor, ancestorEntry[1]) as NodeEntry<\n          Element & { type: 'component-block' }\n        >,\n        prop: ancestorEntry as NodeEntry<\n          Element & { type: 'component-inline-prop' | 'component-block-prop' }\n        >,\n      } as const\n    }\n  }\n  return { isInside: false } as const\n}\n\nconst alreadyNormalizedThings: WeakMap<DocumentFeaturesForChildField, WeakSet<Node>> = new WeakMap()\n\nfunction normalizeNodeWithinComponentProp(\n  [node, path]: NodeEntry,\n  editor: Editor,\n  fieldOptions: DocumentFeaturesForChildField,\n  relationships: Relationships\n): boolean {\n  let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions)\n  if (!alreadyNormalizedNodes) {\n    alreadyNormalizedNodes = new WeakSet()\n    alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes)\n  }\n  if (alreadyNormalizedNodes.has(node)) return false\n\n  let didNormalization = false\n  if (fieldOptions.inlineMarks !== 'inherit' && Text.isText(node)) {\n    didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks(\n      [node, path],\n      editor,\n      fieldOptions.inlineMarks,\n      fieldOptions.softBreaks\n    )\n  }\n  if (Element.isElement(node)) {\n    for (const [i, child] of node.children.entries()) {\n      if (\n        normalizeNodeWithinComponentProp([child, [...path, i]], editor, fieldOptions, relationships)\n      ) {\n        return true\n      }\n    }\n\n    if (fieldOptions.kind === 'block') {\n      if (node.type === 'component-block') {\n        if (!fieldOptions.componentBlocks) {\n          Transforms.unwrapNodes(editor, { at: path })\n          didNormalization = true\n        }\n      } else {\n        didNormalization = normalizeElementBasedOnDocumentFeatures(\n          [node, path],\n          editor,\n          fieldOptions.documentFeatures,\n          relationships\n        )\n      }\n    } else {\n      didNormalization = normalizeInlineBasedOnLinksAndRelationships(\n        [node, path],\n        editor,\n        fieldOptions.documentFeatures.links,\n        fieldOptions.documentFeatures.relationships,\n        relationships\n      )\n    }\n  }\n\n  if (didNormalization === false) {\n    alreadyNormalizedNodes.add(node)\n  }\n  return didNormalization\n}\n\nfunction canSchemaContainChildField(rootSchema: ComponentSchema) {\n  const queue = new Set<ComponentSchema>([rootSchema])\n  for (const schema of queue) {\n    if (schema.kind === 'form' || schema.kind === 'relationship') continue\n    if (schema.kind === 'child') return true\n    if (schema.kind === 'array') {\n      queue.add(schema.element)\n      continue\n    }\n\n    if (schema.kind === 'object') {\n      for (const innerProp of Object.values(schema.fields)) {\n        queue.add(innerProp)\n      }\n      continue\n    }\n\n    if (schema.kind === 'conditional') {\n      for (const innerProp of Object.values(schema.values)) {\n        queue.add(innerProp)\n      }\n      continue\n    }\n\n    assertNever(schema)\n  }\n  return false\n}\n\nfunction doesSchemaOnlyEverContainASingleChildField(rootSchema: ComponentSchema): boolean {\n  const queue = new Set<ComponentSchema>([rootSchema])\n  let hasFoundChildField = false\n  for (const schema of queue) {\n    if (schema.kind === 'form' || schema.kind === 'relationship') continue\n    if (schema.kind === 'child') {\n      if (hasFoundChildField) return false\n      hasFoundChildField = true\n      continue\n    }\n\n    if (schema.kind === 'array') {\n      if (canSchemaContainChildField(schema.element)) return false\n      continue\n    }\n\n    if (schema.kind === 'object') {\n      for (const innerProp of Object.values(schema.fields)) {\n        queue.add(innerProp)\n      }\n      continue\n    }\n\n    if (schema.kind === 'conditional') {\n      for (const innerProp of Object.values(schema.values)) {\n        queue.add(innerProp)\n      }\n      continue\n    }\n\n    assertNever(schema)\n  }\n  return hasFoundChildField\n}\n\nfunction findArrayFieldsWithSingleChildField(schema: ComponentSchema, value: unknown) {\n  const propPaths: [ReadonlyPropPath, ArrayField<ComponentSchema>][] = []\n  traverseProps(schema, value, (schema, value, path) => {\n    if (schema.kind === 'array' && doesSchemaOnlyEverContainASingleChildField(schema.element)) {\n      propPaths.push([path, schema])\n    }\n  })\n  return propPaths\n}\n\nfunction isEmptyChildFieldNode(\n  element: Element & ({ type: 'component-block-prop' } | { type: 'component-inline-prop' })\n) {\n  const firstChild = element.children[0]\n  return (\n    element.children.length === 1 &&\n    ((element.type === 'component-inline-prop' &&\n      firstChild.type === undefined &&\n      firstChild.text === '') ||\n      (element.type === 'component-block-prop' &&\n        firstChild.type === 'paragraph' &&\n        firstChild.children.length === 1 &&\n        firstChild.children[0].type === undefined &&\n        firstChild.children[0].text === ''))\n  )\n}\n\nexport function withComponentBlocks(\n  blockComponents: Record<string, ComponentBlock | undefined>,\n  editorDocumentFeatures: DocumentFeatures,\n  relationships: Relationships,\n  editor: Editor\n): Editor {\n  // note that conflicts between the editor document features\n  // and the child field document features are dealt with elsewhere\n  const memoizedGetDocumentFeaturesForChildField = weakMemoize(\n    (options: ChildField['options']): DocumentFeaturesForChildField => {\n      return getDocumentFeaturesForChildField(editorDocumentFeatures, options)\n    }\n  )\n  const { normalizeNode, deleteBackward, insertBreak } = editor\n  editor.deleteBackward = unit => {\n    if (editor.selection) {\n      const ancestorComponentBlock = getAncestorComponentBlock(editor)\n      if (\n        ancestorComponentBlock.isInside &&\n        Range.isCollapsed(editor.selection) &&\n        Editor.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) &&\n        ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0\n      ) {\n        Transforms.unwrapNodes(editor, { at: ancestorComponentBlock.componentBlock[1] })\n        return\n      }\n    }\n    deleteBackward(unit)\n  }\n  editor.insertBreak = () => {\n    const ancestorComponentBlock = getAncestorComponentBlock(editor)\n    if (editor.selection && ancestorComponentBlock.isInside) {\n      const {\n        prop: [componentPropNode, componentPropPath],\n        componentBlock: [componentBlockNode, componentBlockPath],\n      } = ancestorComponentBlock\n      const isLastProp =\n        componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1\n\n      if (componentPropNode.type === 'component-block-prop') {\n        const [[paragraphNode, paragraphPath]] = Editor.nodes(editor, {\n          match: node => node.type === 'paragraph',\n        })\n        const isLastParagraph =\n          paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1\n        if (Node.string(paragraphNode) === '' && isLastParagraph) {\n          if (isLastProp) {\n            Transforms.moveNodes(editor, {\n              at: paragraphPath,\n              to: Path.next(ancestorComponentBlock.componentBlock[1]),\n            })\n          } else {\n            Transforms.move(editor, { distance: 1, unit: 'line' })\n            Transforms.removeNodes(editor, { at: paragraphPath })\n          }\n          return\n        }\n      }\n      if (componentPropNode.type === 'component-inline-prop') {\n        Editor.withoutNormalizing(editor, () => {\n          const componentBlock = blockComponents[componentBlockNode.component]\n          if (componentPropNode.propPath !== undefined && componentBlock !== undefined) {\n            const rootSchema = { kind: 'object' as const, fields: componentBlock.schema }\n            const ancestorFields = getAncestorSchemas(\n              rootSchema,\n              componentPropNode.propPath,\n              componentBlockNode.props\n            )\n            const idx = [...ancestorFields].reverse().findIndex(item => item.kind === 'array')\n            if (idx !== -1) {\n              const arrayFieldIdx = ancestorFields.length - 1 - idx\n              const arrayField = ancestorFields[arrayFieldIdx]\n              assert(arrayField.kind === 'array')\n              const val = getValueAtPropPath(\n                componentBlockNode.props,\n                componentPropNode.propPath.slice(0, arrayFieldIdx)\n              ) as unknown[]\n              if (doesSchemaOnlyEverContainASingleChildField(arrayField.element)) {\n                if (\n                  Node.string(componentPropNode) === '' &&\n                  val.length - 1 === componentPropNode.propPath[arrayFieldIdx]\n                ) {\n                  Transforms.removeNodes(editor, { at: componentPropPath })\n                  if (isLastProp) {\n                    Transforms.insertNodes(\n                      editor,\n                      { type: 'paragraph', children: [{ text: '' }] },\n                      { at: Path.next(componentBlockPath) }\n                    )\n                    Transforms.select(editor, Path.next(componentBlockPath))\n                  } else {\n                    Transforms.move(editor, { distance: 1, unit: 'line' })\n                  }\n                } else {\n                  insertBreak()\n                }\n                return\n              }\n            }\n          }\n\n          Transforms.splitNodes(editor, { always: true })\n          const splitNodePath = Path.next(componentPropPath)\n\n          if (isLastProp) {\n            Transforms.moveNodes(editor, {\n              at: splitNodePath,\n              to: Path.next(componentBlockPath),\n            })\n          } else {\n            moveChildren(editor, splitNodePath, [...Path.next(splitNodePath), 0])\n            Transforms.removeNodes(editor, { at: splitNodePath })\n          }\n        })\n        return\n      }\n    }\n    insertBreak()\n  }\n\n  editor.normalizeNode = entry => {\n    const [node, path] = entry\n    if (\n      node.type === 'component-inline-prop' &&\n      !node.propPath &&\n      (node.children.length !== 1 || !Text.isText(node.children[0]) || node.children[0].text !== '')\n    ) {\n      Transforms.removeNodes(editor, {\n        at: path,\n      })\n      return\n    }\n\n    if (node.type === 'component-block') {\n      const componentBlock = blockComponents[node.component]\n      if (componentBlock) {\n        const rootSchema = { kind: 'object' as const, fields: componentBlock.schema }\n\n        const updatedProps = addMissingFields(node.props, rootSchema) as Record<string, unknown>\n        if (updatedProps !== node.props) {\n          Transforms.setNodes(editor, { props: updatedProps }, { at: path })\n          return\n        }\n\n        for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(\n          rootSchema,\n          node.props\n        )) {\n          if (\n            node.children.length === 1 &&\n            node.children[0].type === 'component-inline-prop' &&\n            node.children[0].propPath === undefined\n          ) {\n            break\n          }\n          const nodesWithin: [\n            number,\n            Element & { type: 'component-block-prop' | 'component-inline-prop' },\n          ][] = []\n          for (const [idx, childNode] of node.children.entries()) {\n            if (\n              (childNode.type === 'component-block-prop' ||\n                childNode.type === 'component-inline-prop') &&\n              childNode.propPath !== undefined\n            ) {\n              const subPath = childNode.propPath.concat()\n              while (subPath.length) {\n                if (typeof subPath.pop() === 'number') break\n              }\n\n              if (areArraysEqual(propPath, subPath)) {\n                nodesWithin.push([idx, childNode])\n              }\n            }\n          }\n          const arrVal = getValueAtPropPath(node.props, propPath) as unknown[]\n          const prevKeys = getKeysForArrayValue(arrVal)\n          const prevKeysSet = new Set(prevKeys)\n          const alreadyUsedIndicies = new Set<number>()\n          const newVal: unknown[] = []\n          const newKeys: string[] = []\n          const getNewKey = () => {\n            let key = getNewArrayElementKey()\n            while (prevKeysSet.has(key)) {\n              key = getNewArrayElementKey()\n            }\n            return key\n          }\n          for (const [, node] of nodesWithin) {\n            const idxFromValue = node.propPath![propPath.length]\n            assert(typeof idxFromValue === 'number')\n            if (\n              arrVal.length <= idxFromValue ||\n              (alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node))\n            ) {\n              newVal.push(getInitialPropsValue(arrayField.element))\n              newKeys.push(getNewKey())\n            } else {\n              alreadyUsedIndicies.add(idxFromValue)\n              newVal.push(arrVal[idxFromValue])\n              newKeys.push(\n                alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]\n              )\n            }\n          }\n          setKeysForArrayValue(newVal, newKeys)\n          if (!areArraysEqual(arrVal, newVal)) {\n            const transformedProps = replaceValueAtPropPath(\n              rootSchema,\n              node.props,\n              newVal,\n              propPath\n            )\n            Transforms.setNodes(\n              editor,\n              { props: transformedProps as Record<string, unknown> },\n              { at: path }\n            )\n            for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {\n              const newPropPath = [...nodeWithin.propPath!]\n              newPropPath[propPath.length] = idx\n              Transforms.setNodes(\n                editor,\n                { propPath: newPropPath },\n                { at: [...path, idxInChildrenOfBlock] }\n              )\n            }\n            return\n          }\n        }\n\n        const missingKeys = new Map(\n          findChildPropPaths(node.props, componentBlock.schema).map(x => [\n            JSON.stringify(x.path) as string | undefined,\n            x.options.kind,\n          ])\n        )\n\n        node.children.forEach(node => {\n          assert(node.type === 'component-block-prop' || node.type === 'component-inline-prop')\n          missingKeys.delete(JSON.stringify(node.propPath))\n        })\n        if (missingKeys.size) {\n          Transforms.insertNodes(\n            editor,\n            [...missingKeys].map(([prop, kind]) => ({\n              type: `component-${kind}-prop` as const,\n              propPath: prop ? JSON.parse(prop) : prop,\n              children: [{ text: '' }],\n            })),\n            { at: [...path, node.children.length] }\n          )\n          return\n        }\n\n        const foundProps = new Set<string>()\n\n        const stringifiedInlinePropPaths: Record<\n          string,\n          { options: ChildField['options']; index: number } | undefined\n        > = {}\n        findChildPropPaths(node.props, blockComponents[node.component]!.schema).forEach(\n          (x, index) => {\n            stringifiedInlinePropPaths[JSON.stringify(x.path)] = { options: x.options, index }\n          }\n        )\n\n        for (const [index, childNode] of node.children.entries()) {\n          if (\n            // children that are not these will be handled by\n            // the generic allowedChildren normalization\n            childNode.type !== 'component-inline-prop' &&\n            childNode.type !== 'component-block-prop'\n          ) {\n            continue\n          }\n\n          const childPath = [...path, index]\n          const stringifiedPropPath = JSON.stringify(childNode.propPath)\n          if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {\n            Transforms.removeNodes(editor, { at: childPath })\n            return\n          }\n\n          if (foundProps.has(stringifiedPropPath)) {\n            Transforms.removeNodes(editor, { at: childPath })\n            return\n          }\n\n          foundProps.add(stringifiedPropPath)\n          const propInfo = stringifiedInlinePropPaths[stringifiedPropPath]!\n          const expectedIndex = propInfo.index\n          if (index !== expectedIndex) {\n            Transforms.moveNodes(editor, { at: childPath, to: [...path, expectedIndex] })\n            return\n          }\n\n          const expectedChildNodeType = `component-${propInfo.options.kind}-prop` as const\n          if (childNode.type !== expectedChildNodeType) {\n            Transforms.setNodes(editor, { type: expectedChildNodeType }, { at: childPath })\n            return\n          }\n\n          const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options)\n          if (\n            normalizeNodeWithinComponentProp(\n              [childNode, childPath],\n              editor,\n              documentFeatures,\n              relationships\n            )\n          ) {\n            return\n          }\n        }\n      }\n    }\n\n    normalizeNode(entry)\n  }\n\n  return editor\n}\n\n// the only thing that this will fix is a new field being added to an object field, nothing else.\nfunction addMissingFields(value: unknown, schema: ComponentSchema): unknown {\n  if (schema.kind === 'child' || schema.kind === 'form' || schema.kind === 'relationship') {\n    return value\n  }\n  if (schema.kind === 'conditional') {\n    const conditionalValue = value as { discriminant: string | boolean; value: unknown }\n    const updatedInnerValue = addMissingFields(\n      conditionalValue.value,\n      schema.values[conditionalValue.discriminant.toString()]\n    )\n    if (updatedInnerValue === conditionalValue.value) {\n      return value\n    }\n    return { discriminant: conditionalValue.discriminant, value: updatedInnerValue }\n  }\n  if (schema.kind === 'array') {\n    const arrValue = value as unknown[]\n    const newArrValue = arrValue.map(x => addMissingFields(x, schema.element))\n    if (areArraysEqual(arrValue, newArrValue)) {\n      return value\n    }\n    return newArrValue\n  }\n  if (schema.kind === 'object') {\n    const objectValue = value as Record<string, unknown>\n    let hasChanged = false\n    const newObjectValue: Record<string, unknown> = {}\n    for (const [key, innerSchema] of Object.entries(schema.fields)) {\n      const innerValue = objectValue[key]\n      if (innerValue === undefined) {\n        hasChanged = true\n        newObjectValue[key] = getInitialPropsValue(innerSchema)\n        continue\n      }\n      const newInnerValue = addMissingFields(innerValue as Record<string, unknown>, innerSchema)\n      if (newInnerValue !== innerValue) {\n        hasChanged = true\n      }\n      newObjectValue[key] = newInnerValue\n    }\n    if (hasChanged) {\n      return newObjectValue\n    }\n    return value\n  }\n  assertNever(schema)\n}\n", "import { Editor, Element, Node, Text, Transforms, type NodeEntry } from 'slate'\nimport type { DocumentFeatures } from '../views-shared'\nimport type { Relationships } from './relationship-shared'\n\nexport function areArraysEqual(a: readonly unknown[], b: readonly unknown[]) {\n  return a.length === b.length && a.every((x, i) => x === b[i])\n}\n\nexport function normalizeTextBasedOnInlineMarksAndSoftBreaks(\n  [node, path]: NodeEntry<Text>,\n  editor: Editor,\n  inlineMarks: DocumentFeatures['formatting']['inlineMarks'],\n  softBreaks: boolean\n): boolean {\n  const marksToRemove = Object.keys(node).filter(\n    x => x !== 'text' && x !== 'insertMenu' && (inlineMarks as any)[x] !== true\n  )\n  if (marksToRemove.length) {\n    Transforms.unsetNodes(editor, marksToRemove, { at: path })\n    return true\n  }\n  if (!softBreaks) {\n    const hasSoftBreaks = node.text.includes('\\n')\n    if (hasSoftBreaks) {\n      const [parentNode] = Editor.parent(editor, path)\n      if (parentNode.type !== 'code') {\n        for (const position of Editor.positions(editor, { at: path })) {\n          const character = (Node.get(editor, position.path) as Text).text[position.offset]\n          if (character === '\\n') {\n            Transforms.delete(editor, { at: position })\n            return true\n          }\n        }\n      }\n    }\n  }\n\n  return false\n}\n\nexport type DocumentFeaturesForNormalization = Omit<DocumentFeatures, 'formatting'> & {\n  formatting: Omit<DocumentFeatures['formatting'], 'inlineMarks' | 'softBreaks'>\n  relationships: boolean\n}\n\nexport function normalizeInlineBasedOnLinksAndRelationships(\n  [node, path]: NodeEntry<Element>,\n  editor: Editor,\n  links: boolean,\n  relationshipsEnabled: boolean,\n  relationships: Relationships\n) {\n  if (node.type === 'link' && !links) {\n    Transforms.insertText(editor, ` (${node.href})`, { at: Editor.end(editor, path) })\n    Transforms.unwrapNodes(editor, { at: path })\n    return true\n  }\n  if (\n    node.type === 'relationship' &&\n    (!relationshipsEnabled || relationships[node.relationship] === undefined)\n  ) {\n    const data: any = node.data\n    if (data) {\n      const relationship = relationships[node.relationship]\n      Transforms.insertText(\n        editor,\n        `${data.label || data.id || ''} (${relationship?.label || node.relationship}:${\n          data.id || ''\n        })`,\n        { at: Editor.before(editor, path) }\n      )\n    }\n    Transforms.removeNodes(editor, { at: path })\n    return true\n  }\n  return false\n}\n\nexport function normalizeElementBasedOnDocumentFeatures(\n  [node, path]: NodeEntry<Element>,\n  editor: Editor,\n  {\n    formatting,\n    dividers,\n    layouts,\n    links,\n    relationships: relationshipsEnabled,\n  }: DocumentFeaturesForNormalization,\n  relationships: Relationships\n): boolean {\n  if (\n    (node.type === 'heading' &&\n      (!formatting.headingLevels.length || !formatting.headingLevels.includes(node.level))) ||\n    (node.type === 'ordered-list' && !formatting.listTypes.ordered) ||\n    (node.type === 'unordered-list' && !formatting.listTypes.unordered) ||\n    (node.type === 'code' && !formatting.blockTypes.code) ||\n    (node.type === 'blockquote' && !formatting.blockTypes.blockquote) ||\n    (node.type === 'layout' &&\n      (layouts.length === 0 || !layouts.some(layout => areArraysEqual(layout, node.layout))))\n  ) {\n    Transforms.unwrapNodes(editor, { at: path })\n    return true\n  }\n  if (\n    (node.type === 'paragraph' || node.type === 'heading') &&\n    ((!formatting.alignment.center && node.textAlign === 'center') ||\n      (!formatting.alignment.end && node.textAlign === 'end') ||\n      ('textAlign' in node && node.textAlign !== 'center' && node.textAlign !== 'end'))\n  ) {\n    Transforms.unsetNodes(editor, 'textAlign', { at: path })\n    return true\n  }\n  if (node.type === 'divider' && !dividers) {\n    Transforms.removeNodes(editor, { at: path })\n    return true\n  }\n\n  return normalizeInlineBasedOnLinksAndRelationships(\n    [node, path],\n    editor,\n    links,\n    relationshipsEnabled,\n    relationships\n  )\n}\n\nexport function withDocumentFeaturesNormalization(\n  documentFeatures: DocumentFeatures,\n  relationships: Relationships,\n  editor: Editor\n): Editor {\n  const { normalizeNode } = editor\n  const documentFeaturesForNormalization = { ...documentFeatures, relationships: true }\n  editor.normalizeNode = ([node, path]) => {\n    if (Text.isText(node)) {\n      normalizeTextBasedOnInlineMarksAndSoftBreaks(\n        [node, path],\n        editor,\n        documentFeatures.formatting.inlineMarks,\n        documentFeatures.formatting.softBreaks\n      )\n    } else if (Element.isElement(node)) {\n      normalizeElementBasedOnDocumentFeatures(\n        [node, path],\n        editor,\n        documentFeaturesForNormalization,\n        relationships\n      )\n    }\n    normalizeNode([node, path])\n  }\n  return editor\n}\n", "import { Editor, Transforms } from 'slate'\n\nexport const paragraphElement = () => ({\n  type: 'paragraph' as const,\n  children: [{ text: '' }],\n})\n\nexport function withParagraphs(editor: Editor): Editor {\n  const { normalizeNode } = editor\n\n  editor.normalizeNode = entry => {\n    const [node, path] = entry\n\n    if (Editor.isEditor(node)) {\n      const lastNode = node.children[node.children.length - 1]\n      if (lastNode?.type !== 'paragraph') {\n        Transforms.insertNodes(editor, paragraphElement(), {\n          at: [...path, node.children.length],\n        })\n        return\n      }\n    }\n\n    normalizeNode(entry)\n  }\n\n  return editor\n}\n", "import { Editor, Element, Node, Path, Transforms, Range } from 'slate'\nimport { isElementActive, moveChildren, nodeTypeMatcher } from './utils'\nimport { getListTypeAbove } from './toolbar-state-shared'\n\nexport const isListType = (type: string | undefined) =>\n  type === 'ordered-list' || type === 'unordered-list'\n\nexport const isListNode = (\n  node: Node\n): node is Element & { type: 'ordered-list' | 'unordered-list' } => isListType(node.type)\n\nexport const toggleList = (editor: Editor, format: 'ordered-list' | 'unordered-list') => {\n  const listAbove = getListTypeAbove(editor)\n  const isActive = isElementActive(editor, format) && (listAbove === 'none' || listAbove === format)\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.unwrapNodes(editor, {\n      match: isListNode,\n      split: true,\n      mode: isActive ? 'all' : 'lowest',\n    })\n    if (!isActive) {\n      Transforms.wrapNodes(\n        editor,\n        { type: format, children: [] },\n        {\n          match: x =>\n            x.type !== 'list-item-content' && Element.isElement(x) && Editor.isBlock(editor, x),\n        }\n      )\n    }\n  })\n}\n\nfunction getAncestorList(editor: Editor) {\n  if (editor.selection) {\n    const listItem = Editor.above(editor, {\n      match: nodeTypeMatcher('list-item'),\n    })\n    const list = Editor.above(editor, {\n      match: isListNode,\n    })\n    if (listItem && list) {\n      return {\n        isInside: true,\n        listItem,\n        list,\n      } as const\n    }\n  }\n  return { isInside: false } as const\n}\n\nexport function withList(editor: Editor): Editor {\n  const { insertBreak, normalizeNode, deleteBackward } = editor\n  editor.deleteBackward = unit => {\n    if (editor.selection) {\n      const ancestorList = getAncestorList(editor)\n      if (\n        ancestorList.isInside &&\n        Range.isCollapsed(editor.selection) &&\n        Editor.isStart(editor, editor.selection.anchor, ancestorList.list[1])\n      ) {\n        Transforms.unwrapNodes(editor, {\n          match: isListNode,\n          split: true,\n        })\n        return\n      }\n    }\n    deleteBackward(unit)\n  }\n  editor.insertBreak = () => {\n    const [listItem] = Editor.nodes(editor, {\n      match: node => node.type === 'list-item',\n      mode: 'lowest',\n    })\n    if (listItem && Node.string(listItem[0]) === '') {\n      Transforms.unwrapNodes(editor, {\n        match: isListNode,\n        split: true,\n      })\n      return\n    }\n\n    insertBreak()\n  }\n\n  editor.normalizeNode = entry => {\n    const [node, path] = entry\n    if (Element.isElement(node) || Editor.isEditor(node)) {\n      const isElementBeingNormalizedAList = isListNode(node)\n      for (const [childNode, childPath] of Node.children(editor, path)) {\n        const index = childPath[childPath.length - 1]\n        // merge sibling lists\n        if (isListNode(childNode)) {\n          if (node.children[childPath[childPath.length - 1] + 1]?.type === childNode.type) {\n            const siblingNodePath = Path.next(childPath)\n            moveChildren(editor, siblingNodePath, [...childPath, childNode.children.length])\n            Transforms.removeNodes(editor, { at: siblingNodePath })\n            return\n          }\n          if (isElementBeingNormalizedAList) {\n            const previousChild = node.children[index - 1]\n            if (Element.isElement(previousChild)) {\n              Transforms.moveNodes(editor, {\n                at: childPath,\n                to: [...Path.previous(childPath), previousChild.children.length - 1],\n              })\n            } else {\n              Transforms.unwrapNodes(editor, { at: childPath })\n            }\n            return\n          }\n        }\n        if (\n          node.type === 'list-item' &&\n          childNode.type !== 'list-item-content' &&\n          index === 0 &&\n          Element.isElement(childNode) &&\n          Editor.isBlock(editor, childNode)\n        ) {\n          if (path[path.length - 1] !== 0) {\n            const previousChild = Node.get(editor, Path.previous(path))\n\n            if (Element.isElement(previousChild)) {\n              Transforms.moveNodes(editor, {\n                at: path,\n                to: [...Path.previous(path), previousChild.children.length],\n              })\n              return\n            }\n          }\n          Transforms.unwrapNodes(editor, { at: childPath })\n          return\n        }\n        if (node.type === 'list-item' && childNode.type === 'list-item-content' && index !== 0) {\n          Transforms.splitNodes(editor, { at: childPath })\n          return\n        }\n      }\n    }\n\n    normalizeNode(entry)\n  }\n  return editor\n}\n\nexport function nestList(editor: Editor) {\n  const block = Editor.above(editor, {\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n  })\n\n  if (!block || block[0].type !== 'list-item-content') {\n    return false\n  }\n  const listItemPath = Path.parent(block[1])\n  // we're the first item in the list therefore we can't nest\n  if (listItemPath[listItemPath.length - 1] === 0) {\n    return false\n  }\n  const previousListItemPath = Path.previous(listItemPath)\n  const previousListItemNode = Node.get(editor, previousListItemPath) as Element\n  if (previousListItemNode.children.length !== 1) {\n    // there's a list nested inside our previous sibling list item so move there\n    Transforms.moveNodes(editor, {\n      at: listItemPath,\n      to: [\n        ...previousListItemPath,\n        previousListItemNode.children.length - 1,\n        (previousListItemNode.children[previousListItemNode.children.length - 1] as any).children\n          .length,\n      ],\n    })\n    return true\n  }\n  const type = Editor.parent(editor, Path.parent(block[1]))[0].type as\n    | 'ordered-list'\n    | 'unordered-list'\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.wrapNodes(editor, { type, children: [] }, { at: listItemPath })\n    Transforms.moveNodes(editor, {\n      to: [...previousListItemPath, previousListItemNode.children.length],\n      at: listItemPath,\n    })\n  })\n  return true\n}\n\nexport function unnestList(editor: Editor) {\n  const block = Editor.above(editor, {\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n  })\n\n  if (block && block[0].type === 'list-item-content') {\n    Transforms.unwrapNodes(editor, {\n      match: isListNode,\n      split: true,\n    })\n    return true\n  }\n  return false\n}\n", "import { Element, Editor, Range, Text } from 'slate'\nimport { type DocumentFeatures } from '../views-shared'\nimport { type ComponentBlock } from './component-blocks/api-shared'\nimport {\n  type DocumentFeaturesForChildField,\n  getSchemaAtPropPath,\n  getDocumentFeaturesForChildField,\n} from './component-blocks/utils'\nimport { isListNode } from './lists-shared'\nimport { allMarks, isElementActive, type Mark, nodeTypeMatcher } from './utils'\n\ntype BasicToolbarItem = { isSelected: boolean; isDisabled: boolean }\n\n// component blocks are not in the ToolbarState because they're inserted in the closest available place and the selected state is not shown in the toolbar\n\n// note that isDisabled being false here does not mean the action should be allowed\n// it means that the action should be allowed if isDisabled is false AND the relevant document feature is enabled\n// (because things are hidden if they're not enabled in the editor document features)\nexport type ToolbarState = {\n  textStyles: {\n    selected: 'normal' | 1 | 2 | 3 | 4 | 5 | 6\n    allowedHeadingLevels: (1 | 2 | 3 | 4 | 5 | 6)[]\n  }\n  marks: {\n    [key in Mark]: BasicToolbarItem\n  }\n  clearFormatting: {\n    isDisabled: boolean\n  }\n  alignment: {\n    selected: 'start' | 'center' | 'end'\n    isDisabled: boolean\n  }\n  lists: { ordered: BasicToolbarItem; unordered: BasicToolbarItem }\n  links: BasicToolbarItem\n  blockquote: BasicToolbarItem\n  // note that layouts can't be disabled because they are inserted\n  // so they will be inserted to the closest valid location\n  // unlike the other things here which wrap elements\n  layouts: { isSelected: boolean }\n  dividers: { isDisabled: boolean }\n  code: BasicToolbarItem\n  relationships: { isDisabled: boolean }\n  editor: Editor\n  editorDocumentFeatures: DocumentFeatures\n}\n\nexport function getAncestorComponentChildFieldDocumentFeatures(\n  editor: Editor,\n  editorDocumentFeatures: DocumentFeatures,\n  componentBlocks: Record<string, ComponentBlock>\n): DocumentFeaturesForChildField | undefined {\n  const ancestorComponentProp = Editor.above(editor, {\n    match: nodeTypeMatcher('component-block-prop', 'component-inline-prop'),\n  })\n\n  if (ancestorComponentProp) {\n    const propPath = ancestorComponentProp[0].propPath\n    const ancestorComponent = Editor.parent(editor, ancestorComponentProp[1])\n    if (ancestorComponent[0].type === 'component-block') {\n      const component = ancestorComponent[0].component\n      const componentBlock = componentBlocks[component]\n      if (componentBlock && propPath) {\n        const childField = getSchemaAtPropPath(\n          propPath,\n          ancestorComponent[0].props,\n          componentBlock.schema\n        )\n        if (childField?.kind === 'child') {\n          return getDocumentFeaturesForChildField(editorDocumentFeatures, childField.options)\n        }\n      }\n    }\n  }\n}\n\nexport const createToolbarState = (\n  editor: Editor,\n  componentBlocks: Record<string, ComponentBlock>,\n  editorDocumentFeatures: DocumentFeatures\n): ToolbarState => {\n  const locationDocumentFeatures: DocumentFeaturesForChildField =\n    getAncestorComponentChildFieldDocumentFeatures(\n      editor,\n      editorDocumentFeatures,\n      componentBlocks\n    ) || {\n      kind: 'block',\n      inlineMarks: 'inherit',\n      documentFeatures: {\n        dividers: true,\n        formatting: {\n          alignment: { center: true, end: true },\n          blockTypes: { blockquote: true, code: true },\n          headingLevels: [1, 2, 3, 4, 5, 6],\n          listTypes: { ordered: true, unordered: true },\n        },\n        layouts: editorDocumentFeatures.layouts,\n        links: true,\n        relationships: true,\n      },\n      softBreaks: true,\n      componentBlocks: true,\n    }\n\n  const [maybeCodeBlockEntry] = Editor.nodes(editor, {\n    match: node => node.type !== 'code' && Element.isElement(node) && Editor.isBlock(editor, node),\n  })\n  const editorMarks = Editor.marks(editor) || {}\n  const marks = Object.fromEntries(\n    allMarks.map(mark => [\n      mark,\n      {\n        isDisabled:\n          (locationDocumentFeatures.inlineMarks !== 'inherit' &&\n            !locationDocumentFeatures.inlineMarks[mark]) ||\n          !maybeCodeBlockEntry,\n        isSelected: !!editorMarks[mark],\n      },\n    ])\n  ) as ToolbarState['marks']\n\n  // Editor.marks is \"what are the marks that would be applied if text was inserted now\"\n  // that's not really the UX we want, if we have some a document like this\n  // <paragraph>\n  //   <text>\n  //     <anchor />\n  //     content\n  //   </text>\n  //   <text bold>bold</text>\n  //   <text>\n  //     content\n  //     <focus />\n  //   </text>\n  // </paragraph>\n\n  // we want bold to be shown as selected even though if you inserted text from that selection, it wouldn't be bold\n  // so we look at all the text nodes in the selection to get their marks\n  // but only if the selection is expanded because if you're in the middle of some text\n  // with your selection collapsed with a mark but you've removed it(i.e. editor.removeMark)\n  // the text nodes you're in will have the mark but the ui should show the mark as not being selected\n  if (editor.selection && Range.isExpanded(editor.selection)) {\n    for (const node of Editor.nodes(editor, { match: Text.isText })) {\n      for (const key of Object.keys(node[0])) {\n        if (key === 'insertMenu' || key === 'text') {\n          continue\n        }\n        if (key in marks) {\n          marks[key as Mark].isSelected = true\n        }\n      }\n    }\n  }\n\n  const [headingEntry] = Editor.nodes(editor, {\n    match: nodeTypeMatcher('heading'),\n  })\n\n  const [listEntry] = Editor.nodes(editor, {\n    match: isListNode,\n  })\n\n  const [alignableEntry] = Editor.nodes(editor, {\n    match: nodeTypeMatcher('paragraph', 'heading'),\n  })\n\n  // (we're gonna use markdown here because the equivelant slate structure is quite large and doesn't add value here)\n  // let's imagine a document that looks like this:\n  // - thing\n  //   1. something<cursor />\n  // in the toolbar, you don't want to see that both ordered and unordered lists are selected\n  // you want to see only ordered list selected, because\n  // - you want to know what list you're actually in, you don't really care about the outer list\n  // - when you want to change the list to a unordered list, the unordered list button should be inactive to show you can change to it\n  const listTypeAbove = getListTypeAbove(editor)\n\n  return {\n    marks,\n    textStyles: {\n      selected: headingEntry ? headingEntry[0].level : 'normal',\n      allowedHeadingLevels:\n        locationDocumentFeatures.kind === 'block' && !listEntry\n          ? locationDocumentFeatures.documentFeatures.formatting.headingLevels\n          : [],\n    },\n    relationships: { isDisabled: !locationDocumentFeatures.documentFeatures.relationships },\n    code: {\n      isSelected: isElementActive(editor, 'code'),\n      isDisabled: !(\n        locationDocumentFeatures.kind === 'block' &&\n        locationDocumentFeatures.documentFeatures.formatting.blockTypes.code\n      ),\n    },\n    lists: {\n      ordered: {\n        isSelected:\n          isElementActive(editor, 'ordered-list') &&\n          (listTypeAbove === 'none' || listTypeAbove === 'ordered-list'),\n        isDisabled: !(\n          locationDocumentFeatures.kind === 'block' &&\n          locationDocumentFeatures.documentFeatures.formatting.listTypes.ordered &&\n          !headingEntry\n        ),\n      },\n      unordered: {\n        isSelected:\n          isElementActive(editor, 'unordered-list') &&\n          (listTypeAbove === 'none' || listTypeAbove === 'unordered-list'),\n        isDisabled: !(\n          locationDocumentFeatures.kind === 'block' &&\n          locationDocumentFeatures.documentFeatures.formatting.listTypes.unordered &&\n          !headingEntry\n        ),\n      },\n    },\n    alignment: {\n      isDisabled:\n        !alignableEntry &&\n        !(\n          locationDocumentFeatures.kind === 'block' &&\n          locationDocumentFeatures.documentFeatures.formatting.alignment\n        ),\n      selected: alignableEntry?.[0].textAlign || 'start',\n    },\n    blockquote: {\n      isDisabled: !(\n        locationDocumentFeatures.kind === 'block' &&\n        locationDocumentFeatures.documentFeatures.formatting.blockTypes.blockquote\n      ),\n      isSelected: isElementActive(editor, 'blockquote'),\n    },\n    layouts: { isSelected: isElementActive(editor, 'layout') },\n    links: {\n      isDisabled:\n        !editor.selection ||\n        Range.isCollapsed(editor.selection) ||\n        !locationDocumentFeatures.documentFeatures.links,\n      isSelected: isElementActive(editor, 'link'),\n    },\n    editor,\n    dividers: {\n      isDisabled:\n        locationDocumentFeatures.kind === 'inline' ||\n        !locationDocumentFeatures.documentFeatures.dividers,\n    },\n    clearFormatting: {\n      isDisabled: !(\n        Object.values(marks).some(x => x.isSelected) ||\n        !!hasBlockThatClearsOnClearFormatting(editor)\n      ),\n    },\n    editorDocumentFeatures,\n  }\n}\n\nfunction hasBlockThatClearsOnClearFormatting(editor: Editor) {\n  const [node] = Editor.nodes(editor, {\n    match: node => node.type === 'heading' || node.type === 'code' || node.type === 'blockquote',\n  })\n  return !!node\n}\n\nexport function getListTypeAbove(editor: Editor): 'none' | 'ordered-list' | 'unordered-list' {\n  const listAbove = Editor.above(editor, { match: isListNode })\n  if (!listAbove) {\n    return 'none'\n  }\n  return listAbove[0].type\n}\n", "import { Element, Editor, Node, Range, Transforms, Text } from 'slate'\n\nimport { type DocumentFeatures } from '../views'\nimport { EditorAfterButIgnoringingPointsWithNoContent, isElementActive } from './utils'\nimport { getAncestorComponentChildFieldDocumentFeatures } from './toolbar-state-shared'\nimport { type ComponentBlock } from './component-blocks/api'\nimport { isInlineContainer } from './editor-shared'\n\nconst isLinkActive = (editor: Editor) => {\n  return isElementActive(editor, 'link')\n}\n\nexport function wrapLink(editor: Editor, url: string) {\n  if (isLinkActive(editor)) {\n    Transforms.unwrapNodes(editor, { match: n => n.type === 'link' })\n    return\n  }\n\n  const { selection } = editor\n  const isCollapsed = selection && Range.isCollapsed(selection)\n\n  if (isCollapsed) {\n    Transforms.insertNodes(editor, {\n      type: 'link',\n      href: url,\n      children: [{ text: url }],\n    })\n  } else {\n    Transforms.wrapNodes(\n      editor,\n      {\n        type: 'link',\n        href: url,\n        children: [{ text: '' }],\n      },\n      { split: true }\n    )\n  }\n}\n\nconst markdownLinkPattern = /(^|\\s)\\[(.+?)\\]\\((\\S+)\\)$/\n\nexport function withLink(\n  editorDocumentFeatures: DocumentFeatures,\n  componentBlocks: Record<string, ComponentBlock>,\n  editor: Editor\n): Editor {\n  const { insertText, isInline, normalizeNode } = editor\n\n  editor.isInline = element => {\n    return element.type === 'link' ? true : isInline(element)\n  }\n\n  if (editorDocumentFeatures.links) {\n    editor.insertText = text => {\n      insertText(text)\n      if (text !== ')' || !editor.selection) return\n      const startOfBlock = Editor.start(\n        editor,\n        Editor.above(editor, {\n          match: node => Element.isElement(node) && Editor.isBlock(editor, node),\n        })![1]\n      )\n\n      const startOfBlockToEndOfShortcutString = Editor.string(editor, {\n        anchor: editor.selection.anchor,\n        focus: startOfBlock,\n      })\n      const match = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString)\n      if (!match) return\n      const ancestorComponentChildFieldDocumentFeatures =\n        getAncestorComponentChildFieldDocumentFeatures(\n          editor,\n          editorDocumentFeatures,\n          componentBlocks\n        )\n      if (ancestorComponentChildFieldDocumentFeatures?.documentFeatures.links === false) {\n        return\n      }\n      const [, maybeWhitespace, linkText, href] = match\n      // by doing this, the insertText(')') above will happen in a different undo than the link replacement\n      // so that means that when someone does an undo after this\n      // it will undo to the state of \"[content](link)\" rather than \"[content](link\" (note the missing closing bracket)\n      editor.writeHistory('undos', { operations: [], selectionBefore: null })\n      const startOfShortcut =\n        match.index === 0\n          ? startOfBlock\n          : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {\n              distance: match.index,\n            })!\n      const startOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(\n        editor,\n        startOfShortcut,\n        {\n          distance: maybeWhitespace === '' ? 1 : 2,\n        }\n      )!\n      const endOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfLinkText, {\n        distance: linkText.length,\n      })!\n\n      Transforms.delete(editor, {\n        at: { anchor: endOfLinkText, focus: editor.selection.anchor },\n      })\n      Transforms.delete(editor, {\n        at: { anchor: startOfShortcut, focus: startOfLinkText },\n      })\n\n      Transforms.wrapNodes(\n        editor,\n        { type: 'link', href, children: [] },\n        { at: { anchor: editor.selection.anchor, focus: startOfShortcut }, split: true }\n      )\n      const nextNode = Editor.next(editor)\n      if (nextNode) {\n        Transforms.select(editor, nextNode[1])\n      }\n    }\n  }\n\n  editor.normalizeNode = ([node, path]) => {\n    if (node.type === 'link') {\n      if (Node.string(node) === '') {\n        Transforms.unwrapNodes(editor, { at: path })\n        return\n      }\n      for (const [idx, child] of node.children.entries()) {\n        if (child.type === 'link') {\n          // links cannot contain links\n          Transforms.unwrapNodes(editor, { at: [...path, idx] })\n          return\n        }\n      }\n    }\n    if (isInlineContainer(node)) {\n      let lastMergableLink: { index: number; node: Node & { type: 'link' } } | null = null\n      for (const [idx, child] of node.children.entries()) {\n        if (child.type === 'link' && child.href === lastMergableLink?.node.href) {\n          const firstLinkPath = [...path, lastMergableLink.index]\n          const secondLinkPath = [...path, idx]\n          const to = [...firstLinkPath, lastMergableLink.node.children.length]\n          // note this is going in reverse, js doesn't have double-ended iterators so it's a for(;;)\n          for (let i = child.children.length - 1; i >= 0; i--) {\n            const childPath = [...secondLinkPath, i]\n            Transforms.moveNodes(editor, { at: childPath, to })\n          }\n          Transforms.removeNodes(editor, { at: secondLinkPath })\n          return\n        }\n        if (!Text.isText(child) || child.text !== '') {\n          lastMergableLink = null\n        }\n        if (child.type === 'link') {\n          lastMergableLink = { index: idx, node: child }\n        }\n      }\n    }\n    normalizeNode([node, path])\n  }\n\n  return editor\n}\n", "import { Editor, Element, Node, Transforms, Range, Point } from 'slate'\nimport { paragraphElement } from './paragraphs'\nimport { insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading, moveChildren } from './utils'\n\nexport function insertLayout(editor: Editor, layout: [number, ...number[]]) {\n  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, [\n    {\n      type: 'layout',\n      layout,\n      children: [\n        { type: 'layout-area', children: [{ type: 'paragraph', children: [{ text: '' }] }] },\n      ],\n    },\n  ])\n  const layoutEntry = Editor.above(editor, { match: x => x.type === 'layout' })\n  if (layoutEntry) {\n    Transforms.select(editor, [...layoutEntry[1], 0])\n  }\n}\n\n// Plugin\nexport function withLayouts(editor: Editor): Editor {\n  const { normalizeNode, deleteBackward } = editor\n  editor.deleteBackward = unit => {\n    if (\n      editor.selection &&\n      Range.isCollapsed(editor.selection) &&\n      // this is just an little optimisation\n      // we're only doing things if we're at the start of a layout area\n      // and the start of anything will always be offset 0\n      // so we'll bailout if we're not at offset 0\n      editor.selection.anchor.offset === 0\n    ) {\n      const [aboveNode, abovePath] = Editor.above(editor, {\n        match: node => node.type === 'layout-area',\n      }) || [editor, []]\n      if (\n        aboveNode.type === 'layout-area' &&\n        Point.equals(Editor.start(editor, abovePath), editor.selection.anchor)\n      ) {\n        return\n      }\n    }\n    deleteBackward(unit)\n  }\n  editor.normalizeNode = entry => {\n    const [node, path] = entry\n\n    if (Element.isElement(node) && node.type === 'layout') {\n      if (node.layout === undefined) {\n        Transforms.unwrapNodes(editor, { at: path })\n        return\n      }\n      if (node.children.length < node.layout.length) {\n        Transforms.insertNodes(\n          editor,\n          Array.from({\n            length: node.layout.length - node.children.length,\n          }).map(() => ({\n            type: 'layout-area',\n            children: [paragraphElement()],\n          })),\n          {\n            at: [...path, node.children.length],\n          }\n        )\n        return\n      }\n      if (node.children.length > node.layout.length) {\n        Array.from({\n          length: node.children.length - node.layout.length,\n        })\n          .map((_, i) => i)\n          .reverse()\n          .forEach(i => {\n            const layoutAreaToRemovePath = [...path, i + node.layout.length]\n            const child = node.children[i + node.layout.length] as Element\n            moveChildren(\n              editor,\n              layoutAreaToRemovePath,\n              [\n                ...path,\n                node.layout.length - 1,\n                (node.children[node.layout.length - 1] as Element).children.length,\n              ],\n              node => node.type !== 'paragraph' || Node.string(child) !== ''\n            )\n\n            Transforms.removeNodes(editor, {\n              at: layoutAreaToRemovePath,\n            })\n          })\n        return\n      }\n    }\n    normalizeNode(entry)\n  }\n  return editor\n}\n", "import { type Element, Editor, Transforms, Range, Point, Path, Node, Text } from 'slate'\n\nexport function withHeading(editor: Editor): Editor {\n  const { insertBreak } = editor\n  editor.insertBreak = () => {\n    insertBreak()\n\n    const entry = Editor.above(editor, {\n      match: n => n.type === 'heading',\n    })\n    if (!entry || !editor.selection || !Range.isCollapsed(editor.selection)) return\n    const path = entry[1]\n\n    if (\n      // we want to unwrap the heading when the user inserted a break at the end of the heading\n      // when the user inserts a break at the end of a heading, the new heading\n      // that we want to unwrap will be empty so the end will be equal to the selection\n      Point.equals(Editor.end(editor, path), editor.selection.anchor)\n    ) {\n      Transforms.unwrapNodes(editor, {\n        at: path,\n      })\n      return\n    }\n    // we also want to unwrap the _previous_ heading when the user inserted a break\n    // at the start of the heading, essentially just inserting an empty paragraph above the heading\n    if (!Path.hasPrevious(path)) return\n    const previousPath = Path.previous(path)\n    const previousNode = Node.get(editor, previousPath) as Element\n    if (\n      previousNode.type === 'heading' &&\n      previousNode.children.length === 1 &&\n      Text.isText(previousNode.children[0]) &&\n      previousNode.children[0].text === ''\n    ) {\n      Transforms.unwrapNodes(editor, {\n        at: previousPath,\n      })\n    }\n  }\n  return editor\n}\n", "import { Editor, Node, Path, Range, Transforms } from 'slate'\n\nimport { isElementActive } from './utils'\n\nexport function insertBlockquote(editor: Editor) {\n  const isActive = isElementActive(editor, 'blockquote')\n  if (isActive) {\n    Transforms.unwrapNodes(editor, {\n      match: node => node.type === 'blockquote',\n    })\n  } else {\n    Transforms.wrapNodes(editor, {\n      type: 'blockquote',\n      children: [],\n    })\n  }\n}\n\nfunction getDirectBlockquoteParentFromSelection(editor: Editor) {\n  if (!editor.selection) return { isInside: false } as const\n  const [, parentPath] = Editor.parent(editor, editor.selection)\n  if (!parentPath.length) {\n    return { isInside: false } as const\n  }\n  const [maybeBlockquoteParent, maybeBlockquoteParentPath] = Editor.parent(editor, parentPath)\n  const isBlockquote = maybeBlockquoteParent.type === 'blockquote'\n  return isBlockquote\n    ? ({ isInside: true, path: maybeBlockquoteParentPath } as const)\n    : ({ isInside: false } as const)\n}\n\nexport function withBlockquote(editor: Editor): Editor {\n  const { insertBreak, deleteBackward } = editor\n  editor.deleteBackward = unit => {\n    if (editor.selection) {\n      const parentBlockquote = getDirectBlockquoteParentFromSelection(editor)\n      if (\n        parentBlockquote.isInside &&\n        Range.isCollapsed(editor.selection) &&\n        // the selection is at the start of the paragraph\n        editor.selection.anchor.offset === 0 &&\n        // it's the first paragraph in the panel\n        editor.selection.anchor.path[editor.selection.anchor.path.length - 2] === 0\n      ) {\n        Transforms.unwrapNodes(editor, {\n          match: node => node.type === 'blockquote',\n          split: true,\n        })\n        return\n      }\n    }\n    deleteBackward(unit)\n  }\n  editor.insertBreak = () => {\n    const panel = getDirectBlockquoteParentFromSelection(editor)\n    if (editor.selection && panel.isInside) {\n      const [node, nodePath] = Editor.node(editor, editor.selection)\n      if (Path.isDescendant(nodePath, panel.path) && Node.string(node) === '') {\n        Transforms.unwrapNodes(editor, {\n          match: node => node.type === 'blockquote',\n          split: true,\n        })\n        return\n      }\n    }\n    insertBreak()\n  }\n\n  return editor\n}\n", "import type { Editor } from 'slate'\n\n// inline relationship type\nexport type Relationships = Record<\n  string,\n  {\n    listKey: string\n    label: string\n    /** The label field to use for this relationship when showing the select */\n    labelField: string | null\n    /** The GraphQL selection to use for this relationship when hydrating .data */\n    selection: string | null\n  }\n>\n\nexport function withRelationship(editor: Editor): Editor {\n  const { isVoid, isInline } = editor\n  editor.isVoid = element => element.type === 'relationship' || isVoid(element)\n  editor.isInline = element => element.type === 'relationship' || isInline(element)\n  return editor\n}\n", "import { Editor } from 'slate'\nimport { insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading } from './utils'\n\nexport function insertDivider(editor: Editor) {\n  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {\n    type: 'divider',\n    children: [{ text: '' }],\n  })\n  Editor.insertNode(editor, { type: 'paragraph', children: [{ text: '' }] })\n}\n\nexport function withDivider(editor: Editor): Editor {\n  const { isVoid } = editor\n  editor.isVoid = node => {\n    return node.type === 'divider' || isVoid(node)\n  }\n  return editor\n}\n", "import { Editor, Element, Point, Range, Text, Transforms } from 'slate'\n\nexport function withCodeBlock(editor: Editor): Editor {\n  const { insertBreak, normalizeNode } = editor\n\n  editor.insertBreak = () => {\n    const [node, path] = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    }) || [editor, []]\n    if (node.type === 'code' && Text.isText(node.children[0])) {\n      const text = node.children[0].text\n      if (\n        text[text.length - 1] === '\\n' &&\n        editor.selection &&\n        Range.isCollapsed(editor.selection) &&\n        Point.equals(Editor.end(editor, path), editor.selection.anchor)\n      ) {\n        insertBreak()\n        Transforms.setNodes(editor, { type: 'paragraph', children: [] })\n        Transforms.delete(editor, {\n          distance: 1,\n          at: { path: [...path, 0], offset: text.length - 1 },\n        })\n        return\n      }\n      editor.insertText('\\n')\n      return\n    }\n    insertBreak()\n  }\n  editor.normalizeNode = ([node, path]) => {\n    if (node.type === 'code' && Element.isElement(node)) {\n      for (const [index, childNode] of node.children.entries()) {\n        if (!Text.isText(childNode)) {\n          if (editor.isVoid(childNode)) {\n            Transforms.removeNodes(editor, { at: [...path, index] })\n          } else {\n            Transforms.unwrapNodes(editor, { at: [...path, index] })\n          }\n          return\n        }\n        const marks = Object.keys(childNode).filter(x => x !== 'text')\n        if (marks.length) {\n          Transforms.unsetNodes(editor, marks, { at: [...path, index] })\n          return\n        }\n      }\n    }\n    normalizeNode([node, path])\n  }\n\n  return editor\n}\n", "import { type Point, Editor, Element, Node, Path, Range, Text, Transforms } from 'slate'\nimport { type DocumentFeatures } from '../views-shared'\nimport { type ComponentBlock } from './component-blocks/api-shared'\nimport { getAncestorComponentChildFieldDocumentFeatures } from './toolbar-state-shared'\nimport { type Mark, EditorAfterButIgnoringingPointsWithNoContent } from './utils'\n\nexport const allMarkdownShortcuts = {\n  bold: ['**', '__'],\n  italic: ['*', '_'],\n  strikethrough: ['~~'],\n  code: ['`'],\n}\n\nfunction applyMark(editor: Editor, mark: string, shortcutText: string, startOfStartPoint: Point) {\n  // so that this starts a new undo group\n  editor.writeHistory('undos', { operations: [], selectionBefore: null })\n  const startPointRef = Editor.pointRef(editor, startOfStartPoint)\n\n  Transforms.delete(editor, {\n    at: editor.selection!.anchor,\n    distance: shortcutText.length,\n    reverse: true,\n  })\n  Transforms.delete(editor, { at: startOfStartPoint, distance: shortcutText.length })\n\n  Transforms.setNodes(\n    editor,\n    { [mark]: true },\n    {\n      match: Text.isText,\n      split: true,\n      at: { anchor: startPointRef.unref()!, focus: editor.selection!.anchor },\n    }\n  )\n  // once you've ended the shortcut, you're done with the mark\n  // so we need to remove it so the text you insert after doesn't have it\n  editor.removeMark(mark)\n}\n\nexport function withMarks(\n  editorDocumentFeatures: DocumentFeatures,\n  componentBlocks: Record<string, ComponentBlock>,\n  editor: Editor\n): Editor {\n  const { insertText, insertBreak } = editor\n\n  editor.insertBreak = () => {\n    insertBreak()\n    const marksAfterInsertBreak = Editor.marks(editor)\n    if (!marksAfterInsertBreak || !editor.selection) return\n    const parentBlock = Editor.above(editor, {\n      match: node => Element.isElement(node) && Editor.isBlock(editor, node),\n    })\n    if (!parentBlock) return\n    const point = EditorAfterButIgnoringingPointsWithNoContent(editor, editor.selection.anchor)\n    const marksAfterInsertBreakArr = Object.keys(\n      marksAfterInsertBreak\n    ) as (keyof typeof marksAfterInsertBreak)[]\n    if (!point || !Path.isDescendant(point.path, parentBlock[1])) {\n      for (const mark of marksAfterInsertBreakArr) {\n        editor.removeMark(mark)\n      }\n\n      return\n    }\n    const textNode = Node.get(editor, point.path) as Text\n\n    for (const mark of marksAfterInsertBreakArr) {\n      if (!textNode[mark]) {\n        editor.removeMark(mark)\n      }\n    }\n  }\n\n  const selectedMarkdownShortcuts: Partial<typeof allMarkdownShortcuts> = {}\n  const enabledMarks = editorDocumentFeatures.formatting.inlineMarks\n  ;(Object.keys(allMarkdownShortcuts) as (keyof typeof allMarkdownShortcuts)[]).forEach(mark => {\n    if (enabledMarks[mark]) {\n      selectedMarkdownShortcuts[mark] = allMarkdownShortcuts[mark]\n    }\n  })\n\n  if (Object.keys(selectedMarkdownShortcuts).length === 0) return editor\n\n  editor.insertText = text => {\n    insertText(text)\n    if (editor.selection && Range.isCollapsed(editor.selection)) {\n      for (const [mark, shortcuts] of Object.entries(selectedMarkdownShortcuts)) {\n        for (const shortcutText of shortcuts!) {\n          if (text === shortcutText[shortcutText.length - 1]) {\n            // this function is not inlined because\n            // https://github.com/swc-project/swc/issues/2622\n            const startOfBlock = getStartOfBlock(editor)\n\n            const startOfBlockToEndOfShortcutString = Editor.string(editor, {\n              anchor: editor.selection.anchor,\n              focus: startOfBlock,\n            })\n            const hasWhitespaceBeforeEndOfShortcut = /\\s/.test(\n              startOfBlockToEndOfShortcutString.slice(\n                -shortcutText.length - 1,\n                -shortcutText.length\n              )\n            )\n\n            const endOfShortcutContainsExpectedContent =\n              shortcutText === startOfBlockToEndOfShortcutString.slice(-shortcutText.length)\n\n            if (hasWhitespaceBeforeEndOfShortcut || !endOfShortcutContainsExpectedContent) {\n              continue\n            }\n\n            const strToMatchOn = startOfBlockToEndOfShortcutString.slice(\n              0,\n              -shortcutText.length - 1\n            )\n            // TODO: use regex probs\n            for (const [offsetFromStartOfBlock] of [...strToMatchOn].reverse().entries()) {\n              const expectedShortcutText = strToMatchOn.slice(\n                offsetFromStartOfBlock,\n                offsetFromStartOfBlock + shortcutText.length\n              )\n              if (expectedShortcutText !== shortcutText) {\n                continue\n              }\n\n              const startOfStartOfShortcut =\n                offsetFromStartOfBlock === 0\n                  ? startOfBlock\n                  : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {\n                      distance: offsetFromStartOfBlock,\n                    })!\n\n              const endOfStartOfShortcut = Editor.after(editor, startOfStartOfShortcut, {\n                distance: shortcutText.length,\n              })!\n\n              if (\n                offsetFromStartOfBlock !== 0 &&\n                !/\\s/.test(\n                  Editor.string(editor, {\n                    anchor: Editor.before(editor, startOfStartOfShortcut, { unit: 'character' })!,\n                    focus: startOfStartOfShortcut,\n                  })\n                )\n              ) {\n                continue\n              }\n\n              const contentBetweenShortcuts = Editor.string(editor, {\n                anchor: endOfStartOfShortcut,\n                focus: editor.selection.anchor,\n              }).slice(0, -shortcutText.length)\n\n              if (contentBetweenShortcuts === '' || /\\s/.test(contentBetweenShortcuts[0])) {\n                continue\n              }\n\n              // this is a bit of a weird one\n              // let's say you had <text>__thing _<cursor /></text> and you insert `_`.\n              // without the below, that would turn into <text italic>_thing _<cursor /></text>\n              // but it's probably meant to be bold but it's not because of the space before the ending _\n              // there's probably a better way to do this but meh, this works\n              if (\n                mark === 'italic' &&\n                (contentBetweenShortcuts[0] === '_' || contentBetweenShortcuts[0] === '*')\n              ) {\n                continue\n              }\n              const ancestorComponentChildFieldDocumentFeatures =\n                getAncestorComponentChildFieldDocumentFeatures(\n                  editor,\n                  editorDocumentFeatures,\n                  componentBlocks\n                )\n              if (\n                ancestorComponentChildFieldDocumentFeatures &&\n                ancestorComponentChildFieldDocumentFeatures.inlineMarks !== 'inherit' &&\n                ancestorComponentChildFieldDocumentFeatures.inlineMarks[mark as Mark] === false\n              ) {\n                continue\n              }\n              applyMark(editor, mark, shortcutText, startOfStartOfShortcut)\n              return\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return editor\n}\n\nfunction getStartOfBlock(editor: Editor) {\n  return Editor.start(\n    editor,\n    Editor.above(editor, {\n      match: node => Element.isElement(node) && Editor.isBlock(editor, node),\n    })![1]\n  )\n}\n", "import { Transforms, type Editor } from 'slate'\n\nexport function withSoftBreaks(editor: Editor): Editor {\n  // TODO: should soft breaks only work in particular places\n  editor.insertSoftBreak = () => {\n    Transforms.insertText(editor, '\\n')\n  }\n  return editor\n}\n", "import { Element, Range, Editor, Transforms, Path } from 'slate'\n\nexport const shortcuts: Record<string, string> = {\n  '...': '\u2026',\n  '-->': '\u2192',\n  '->': '\u2192',\n  '<-': '\u2190',\n  '<--': '\u2190',\n  '--': '\u2013',\n}\n\nexport function withShortcuts(editor: Editor): Editor {\n  const { insertText } = editor\n  editor.insertText = text => {\n    insertText(text)\n    if (text === ' ' && editor.selection && Range.isCollapsed(editor.selection)) {\n      const selectionPoint = editor.selection.anchor\n      const ancestorBlock = Editor.above(editor, {\n        match: node => Element.isElement(node) && Editor.isBlock(editor, node),\n      })\n      if (ancestorBlock) {\n        Object.keys(shortcuts).forEach(shortcut => {\n          const pointBefore = Editor.before(editor, selectionPoint, {\n            unit: 'character',\n            distance: shortcut.length + 1,\n          })\n          if (pointBefore && Path.isDescendant(pointBefore.path, ancestorBlock[1])) {\n            const range = { anchor: selectionPoint, focus: pointBefore }\n            const str = Editor.string(editor, range)\n            if (str.slice(0, shortcut.length) === shortcut) {\n              editor.writeHistory('undos', { operations: [], selectionBefore: null })\n              Transforms.select(editor, range)\n              editor.insertText(shortcuts[shortcut] + ' ')\n            }\n          }\n        })\n      }\n    }\n  }\n  return editor\n}\n", "import { Editor, Element, Node, Path, Point, Text, Transforms } from 'slate'\n\nconst nodeListsWithoutInsertMenu = new WeakSet<Node[]>()\n\nconst nodesWithoutInsertMenu = new WeakSet<Node>()\n\nfunction findPathWithInsertMenu(node: Node, path: Path): Path | undefined {\n  if (Text.isText(node)) return node.insertMenu ? path : undefined\n  if (nodeListsWithoutInsertMenu.has(node.children)) return\n\n  for (const [index, child] of node.children.entries()) {\n    if (nodesWithoutInsertMenu.has(child)) continue\n    const maybePath = findPathWithInsertMenu(child, [...path, index])\n    if (maybePath) {\n      return maybePath\n    }\n    nodesWithoutInsertMenu.add(child)\n  }\n  nodeListsWithoutInsertMenu.add(node.children)\n}\n\nfunction removeInsertMenuMarkWhenOutsideOfSelection(editor: Editor) {\n  const path = findPathWithInsertMenu(editor, [])\n  if (\n    path &&\n    !Editor.marks(editor)?.insertMenu &&\n    (!editor.selection ||\n      !Path.equals(editor.selection.anchor.path, path) ||\n      !Path.equals(editor.selection.focus.path, path))\n  ) {\n    Transforms.unsetNodes(editor, 'insertMenu', { at: path })\n    return true\n  }\n  return false\n}\n\nexport function withInsertMenu(editor: Editor): Editor {\n  const { normalizeNode, apply, insertText } = editor\n  editor.normalizeNode = ([node, path]) => {\n    if (Text.isText(node) && node.insertMenu) {\n      if (node.text[0] !== '/') {\n        Transforms.unsetNodes(editor, 'insertMenu', { at: path })\n        return\n      }\n      const whitespaceMatch = /\\s/.exec(node.text)\n      if (whitespaceMatch) {\n        Transforms.unsetNodes(editor, 'insertMenu', {\n          at: {\n            anchor: { path, offset: whitespaceMatch.index },\n            focus: Editor.end(editor, path),\n          },\n          match: Text.isText,\n          split: true,\n        })\n        return\n      }\n    }\n    if (Editor.isEditor(editor) && removeInsertMenuMarkWhenOutsideOfSelection(editor)) {\n      return\n    }\n    normalizeNode([node, path])\n  }\n\n  editor.apply = op => {\n    apply(op)\n    // we're calling this here AND in normalizeNode\n    // because normalizeNode won't be called on selection changes\n    // but apply will\n    // we're still calling this from normalizeNode though because we want it to happen\n    // when normalization happens\n    if (op.type === 'set_selection') {\n      removeInsertMenuMarkWhenOutsideOfSelection(editor)\n    }\n  }\n\n  editor.insertText = text => {\n    insertText(text)\n    if (editor.selection && text === '/') {\n      const startOfBlock = Editor.start(\n        editor,\n        Editor.above(editor, {\n          match: node => Element.isElement(node) && Editor.isBlock(editor, node),\n        })![1]\n      )\n      const before = Editor.before(editor, editor.selection.anchor, { unit: 'character' })\n      if (\n        before &&\n        (Point.equals(startOfBlock, before) ||\n          (before.offset !== 0 &&\n            /\\s/.test((Node.get(editor, before.path) as Text).text[before.offset - 1])))\n      ) {\n        Transforms.setNodes(\n          editor,\n          { insertMenu: true },\n          {\n            at: { anchor: before, focus: editor.selection.anchor },\n            match: Text.isText,\n            split: true,\n          }\n        )\n      }\n    }\n  }\n  return editor\n}\n", "import { Element, Editor, Transforms, Range } from 'slate'\nimport { type DocumentFeatures } from '../views-shared'\nimport { type ComponentBlock } from './component-blocks/api-shared'\nimport { insertDivider } from './divider-shared'\nimport { type DocumentFeaturesForNormalization } from './document-features-normalization'\nimport { getAncestorComponentChildFieldDocumentFeatures } from './toolbar-state-shared'\n\nexport function withBlockMarkdownShortcuts(\n  documentFeatures: DocumentFeatures,\n  componentBlocks: Record<string, ComponentBlock>,\n  editor: Editor\n): Editor {\n  const { insertText } = editor\n  const shortcuts: Record<\n    string,\n    Record<\n      string,\n      {\n        insert: () => void\n        type: 'paragraph' | 'heading-or-paragraph'\n        shouldBeEnabledInComponentBlock: (\n          locationDocumentFeatures: DocumentFeaturesForNormalization\n        ) => boolean\n      }\n    >\n  > = Object.create(null)\n  const editorDocumentFeaturesForNormalizationToCheck: DocumentFeaturesForNormalization = {\n    ...documentFeatures,\n    relationships: true,\n  }\n  const addShortcut = (\n    text: string,\n    insert: () => void,\n    shouldBeEnabledInComponentBlock: (\n      locationDocumentFeatures: DocumentFeaturesForNormalization\n    ) => boolean,\n    type: 'paragraph' | 'heading-or-paragraph' = 'paragraph'\n  ) => {\n    if (!shouldBeEnabledInComponentBlock(editorDocumentFeaturesForNormalizationToCheck)) return\n    const trigger = text[text.length - 1]\n    if (!shortcuts[trigger]) {\n      shortcuts[trigger] = Object.create(null)\n    }\n    shortcuts[trigger][text] = {\n      insert,\n      type,\n      shouldBeEnabledInComponentBlock,\n    }\n  }\n  addShortcut(\n    '1. ',\n    () => {\n      Transforms.wrapNodes(\n        editor,\n        { type: 'ordered-list', children: [] },\n        { match: n => Element.isElement(n) && Editor.isBlock(editor, n) }\n      )\n    },\n    features => features.formatting.listTypes.ordered\n  )\n\n  addShortcut(\n    '- ',\n    () => {\n      Transforms.wrapNodes(\n        editor,\n        { type: 'unordered-list', children: [] },\n        { match: n => Element.isElement(n) && Editor.isBlock(editor, n) }\n      )\n    },\n    features => features.formatting.listTypes.unordered\n  )\n  addShortcut(\n    '* ',\n    () => {\n      Transforms.wrapNodes(\n        editor,\n        { type: 'unordered-list', children: [] },\n        { match: n => Element.isElement(n) && Editor.isBlock(editor, n) }\n      )\n    },\n    features => features.formatting.listTypes.unordered\n  )\n\n  documentFeatures.formatting.headingLevels.forEach(level => {\n    addShortcut(\n      '#'.repeat(level) + ' ',\n      () => {\n        Transforms.setNodes(\n          editor,\n          { type: 'heading', level },\n          { match: node => node.type === 'paragraph' || node.type === 'heading' }\n        )\n      },\n      features => features.formatting.headingLevels.includes(level),\n      'heading-or-paragraph'\n    )\n  })\n\n  addShortcut(\n    '> ',\n    () => {\n      Transforms.wrapNodes(\n        editor,\n        { type: 'blockquote', children: [] },\n        { match: node => node.type === 'paragraph' }\n      )\n    },\n    features => features.formatting.blockTypes.blockquote\n  )\n\n  addShortcut(\n    '```',\n    () => {\n      Transforms.wrapNodes(\n        editor,\n        { type: 'code', children: [] },\n        { match: node => node.type === 'paragraph' }\n      )\n    },\n    features => features.formatting.blockTypes.code\n  )\n\n  addShortcut(\n    '---',\n    () => {\n      insertDivider(editor)\n    },\n    features => features.dividers\n  )\n\n  editor.insertText = text => {\n    insertText(text)\n    const shortcutsForTrigger = shortcuts[text]\n    if (shortcutsForTrigger && editor.selection && Range.isCollapsed(editor.selection)) {\n      const { anchor } = editor.selection\n      const block = Editor.above(editor, {\n        match: node => Element.isElement(node) && Editor.isBlock(editor, node),\n      })\n      if (!block || (block[0].type !== 'paragraph' && block[0].type !== 'heading')) return\n\n      const start = Editor.start(editor, block[1])\n      const range = { anchor, focus: start }\n      const shortcutText = Editor.string(editor, range)\n      const shortcut = shortcutsForTrigger[shortcutText]\n\n      if (!shortcut || (shortcut.type === 'paragraph' && block[0].type !== 'paragraph')) {\n        return\n      }\n      const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(\n        editor,\n        documentFeatures,\n        componentBlocks\n      )\n      if (\n        locationDocumentFeatures &&\n        (locationDocumentFeatures.kind === 'inline' ||\n          !shortcut.shouldBeEnabledInComponentBlock(locationDocumentFeatures.documentFeatures))\n      ) {\n        return\n      }\n      // so that this starts a new undo group\n      editor.writeHistory('undos', { operations: [], selectionBefore: null })\n      Transforms.select(editor, range)\n      Transforms.delete(editor)\n      shortcut.insert()\n    }\n  }\n  return editor\n}\n", "import { type Descendant, Element, Editor, Transforms, Range } from 'slate'\nimport { isValidURL } from '../isValidURL'\nimport { insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading } from '../utils'\nimport { deserializeHTML } from './html'\nimport { deserializeMarkdown } from './markdown'\n\nconst urlPattern = /https?:\\/\\//\n\nfunction insertFragmentButDifferent(editor: Editor, nodes: Descendant[]) {\n  const firstNode = nodes[0]\n  if (Element.isElement(firstNode) && Editor.isBlock(editor, firstNode)) {\n    insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes)\n  } else {\n    Transforms.insertFragment(editor, nodes)\n  }\n}\n\nexport function withPasting(editor: Editor): Editor {\n  const { insertData, setFragmentData } = editor\n\n  editor.setFragmentData = data => {\n    if (editor.selection) {\n      data.setData('application/x-keystone-document-editor', 'true')\n    }\n    setFragmentData(data)\n  }\n\n  editor.insertData = data => {\n    // this exists because behind the scenes, Slate sets the slate document\n    // on the data transfer, this is great because it means when you copy and paste\n    // something in the editor or between editors, it'll use the actual Slate data\n    // rather than the serialized html so component blocks and etc. will work fine\n    // we're setting application/x-keystone-document-editor\n    // though so that we only accept slate data from Keystone's editor\n    // because other editors will likely have a different structure\n    // so we'll rely on the html deserialization instead\n    // (note that yes, we do call insertData at the end of this function\n    // which is where Slate's logic will run, it'll never do anything there though\n    // since anything that will have slate data will also have text/html which we handle\n    // before we call insertData)\n    // TODO: handle the case of copying between editors with different components blocks\n    // (right now, things will blow up in most cases)\n    if (data.getData('application/x-keystone-document-editor') === 'true') {\n      insertData(data)\n      return\n    }\n    const blockAbove = Editor.above(editor, {\n      match: node => Element.isElement(node) && Editor.isBlock(editor, node),\n    })\n    if (blockAbove?.[0].type === 'code') {\n      const plain = data.getData('text/plain')\n      editor.insertText(plain)\n      return\n    }\n    const vsCodeEditorData = data.getData('vscode-editor-data')\n    if (vsCodeEditorData) {\n      try {\n        const vsCodeData = JSON.parse(vsCodeEditorData)\n        if (vsCodeData?.mode === 'markdown' || vsCodeData?.mode === 'mdx') {\n          const plain = data.getData('text/plain')\n          if (plain) {\n            const fragment = deserializeMarkdown(plain)\n            insertFragmentButDifferent(editor, fragment)\n            return\n          }\n        }\n      } catch (err) {\n        console.log(err)\n      }\n    }\n\n    const plain = data.getData('text/plain')\n\n    if (\n      // isValidURL is a bit more permissive than a user might expect\n      // so for pasting, we'll constrain it to starting with https:// or http://\n      urlPattern.test(plain) &&\n      isValidURL(plain) &&\n      editor.selection &&\n      !Range.isCollapsed(editor.selection) &&\n      // we only want to turn the selected text into a link if the selection is within the same block\n      Editor.above(editor, {\n        match: node =>\n          Element.isElement(node) &&\n          Editor.isBlock(editor, node) &&\n          !(Element.isElement(node.children[0]) && Editor.isBlock(editor, node.children[0])),\n      }) &&\n      // and there is only text(potentially with marks) in the selection\n      // no other links or inline relationships\n      Editor.nodes(editor, {\n        match: node => Element.isElement(node) && Editor.isInline(editor, node),\n      }).next().done\n    ) {\n      Transforms.wrapNodes(editor, { type: 'link', href: plain, children: [] }, { split: true })\n      return\n    }\n\n    const html = data.getData('text/html')\n    if (html) {\n      const fragment = deserializeHTML(html)\n      insertFragmentButDifferent(editor, fragment)\n      return\n    }\n\n    if (plain) {\n      const fragment = deserializeMarkdown(plain)\n      insertFragmentButDifferent(editor, fragment)\n      return\n    }\n\n    insertData(data)\n  }\n\n  return editor\n}\n", "import { sanitizeUrl } from '@braintree/sanitize-url'\n\nexport function isValidURL(url: string) {\n  return (\n    url === sanitizeUrl(url) ||\n    new URL(url, 'https://a').toString() === new URL(sanitizeUrl(url), 'https://a').toString()\n  )\n}\n", "// very loosely based on https://github.com/ianstormtaylor/slate/blob/d22c76ae1313fe82111317417912a2670e73f5c9/site/examples/paste-html.tsx\nimport { Node } from 'slate'\nimport { type Block, isBlock } from '../editor-shared'\nimport { type Mark } from '../utils'\nimport {\n  type InlineFromExternalPaste,\n  addMarksToChildren,\n  getInlineNodes,\n  forceDisableMarkForChildren,\n  setLinkForChildren,\n} from './utils'\n\nfunction getAlignmentFromElement(element: globalThis.Element): 'center' | 'end' | undefined {\n  const parent = element.parentElement\n  // confluence\n  const attribute = parent?.getAttribute('data-align')\n  // note: we don't show html that confluence would parse as alignment\n  // we could change that but meh\n  // (they match on div.fabric-editor-block-mark with data-align)\n  if (attribute === 'center' || attribute === 'end') {\n    return attribute\n  }\n  if (element instanceof HTMLElement) {\n    // Google docs\n    const textAlign = element.style.textAlign\n    if (textAlign === 'center') {\n      return 'center'\n    }\n    // TODO: RTL things?\n    if (textAlign === 'right' || textAlign === 'end') {\n      return 'end'\n    }\n  }\n}\n\nconst headings: Record<string, (Node & { type: 'heading' })['level'] | undefined> = {\n  H1: 1,\n  H2: 2,\n  H3: 3,\n  H4: 4,\n  H5: 5,\n  H6: 6,\n}\n\nconst TEXT_TAGS: Record<string, Mark | undefined> = {\n  CODE: 'code',\n  DEL: 'strikethrough',\n  S: 'strikethrough',\n  STRIKE: 'strikethrough',\n  EM: 'italic',\n  I: 'italic',\n  STRONG: 'bold',\n  U: 'underline',\n  SUP: 'superscript',\n  SUB: 'subscript',\n  KBD: 'keyboard',\n}\n\nfunction marksFromElementAttributes(element: globalThis.HTMLElement) {\n  const marks = new Set<Mark>()\n  const style = element.style\n  const { nodeName } = element\n  const markFromNodeName = TEXT_TAGS[nodeName]\n  if (markFromNodeName) {\n    marks.add(markFromNodeName)\n  }\n  const { fontWeight, textDecoration, verticalAlign } = style\n\n  if (textDecoration === 'underline') {\n    marks.add('underline')\n  } else if (textDecoration === 'line-through') {\n    marks.add('strikethrough')\n  }\n  // confluence\n  if (nodeName === 'SPAN' && element.classList.contains('code')) {\n    marks.add('code')\n  }\n  // Google Docs does weird things with <b>\n  if (nodeName === 'B' && fontWeight !== 'normal') {\n    marks.add('bold')\n  } else if (\n    typeof fontWeight === 'string' &&\n    (fontWeight === 'bold' ||\n      fontWeight === 'bolder' ||\n      fontWeight === '1000' ||\n      /^[5-9]\\d{2}$/.test(fontWeight))\n  ) {\n    marks.add('bold')\n  }\n  if (style.fontStyle === 'italic') {\n    marks.add('italic')\n  }\n  // Google Docs uses vertical align for subscript and superscript instead of <sup> and <sub>\n  if (verticalAlign === 'super') {\n    marks.add('superscript')\n  } else if (verticalAlign === 'sub') {\n    marks.add('subscript')\n  }\n  return marks\n}\n\nexport function deserializeHTML(html: string) {\n  const parsed = new DOMParser().parseFromString(html, 'text/html')\n  return fixNodesForBlockChildren(deserializeNodes(parsed.body.childNodes))\n}\n\ntype DeserializedNode = InlineFromExternalPaste | Block\n\ntype DeserializedNodes = [DeserializedNode, ...DeserializedNode[]]\n\nexport function deserializeHTMLNode(el: globalThis.Node): DeserializedNode[] {\n  if (!(el instanceof globalThis.HTMLElement)) {\n    const text = el.textContent\n    if (!text) {\n      return []\n    }\n    return getInlineNodes(text)\n  }\n  if (el.nodeName === 'BR') {\n    return getInlineNodes('\\n')\n  }\n\n  if (el.nodeName === 'IMG') {\n    const alt = el.getAttribute('alt')\n    return getInlineNodes(alt ?? '')\n  }\n\n  if (el.nodeName === 'HR') {\n    return [{ type: 'divider', children: [{ text: '' }] }]\n  }\n\n  const marks = marksFromElementAttributes(el)\n\n  // Dropbox Paper displays blockquotes as lists for some reason\n  if (el.classList.contains('listtype-quote')) {\n    marks.delete('italic')\n    return addMarksToChildren(marks, () => [\n      { type: 'blockquote', children: fixNodesForBlockChildren(deserializeNodes(el.childNodes)) },\n    ])\n  }\n\n  return addMarksToChildren(marks, (): DeserializedNode[] => {\n    const { nodeName } = el\n\n    if (nodeName === 'A') {\n      const href = el.getAttribute('href')\n      if (href) {\n        return setLinkForChildren(href, () =>\n          forceDisableMarkForChildren('underline', () => deserializeNodes(el.childNodes))\n        )\n      }\n    }\n\n    if (nodeName === 'PRE' && el.textContent) {\n      return [{ type: 'code', children: [{ text: el.textContent || '' }] }]\n    }\n\n    const deserialized = deserializeNodes(el.childNodes)\n    const children = fixNodesForBlockChildren(deserialized)\n\n    if (nodeName === 'LI') {\n      let nestedList: Block | undefined\n\n      const listItemContent = {\n        type: 'list-item-content' as const,\n        children: children.filter(node => {\n          if (\n            nestedList === undefined &&\n            (node.type === 'ordered-list' || node.type === 'unordered-list')\n          ) {\n            nestedList = node\n            return false\n          }\n          return true\n        }),\n      }\n      const listItemChildren = nestedList ? [listItemContent, nestedList] : [listItemContent]\n      return [{ type: 'list-item', children: listItemChildren }]\n    }\n\n    if (nodeName === 'P') {\n      return [{ type: 'paragraph', textAlign: getAlignmentFromElement(el), children }]\n    }\n\n    const headingLevel = headings[nodeName]\n\n    if (typeof headingLevel === 'number') {\n      return [\n        { type: 'heading', level: headingLevel, textAlign: getAlignmentFromElement(el), children },\n      ]\n    }\n\n    if (nodeName === 'BLOCKQUOTE') {\n      return [{ type: 'blockquote', children }]\n    }\n    if (nodeName === 'OL') {\n      return [{ type: 'ordered-list', children }]\n    }\n    if (nodeName === 'UL') {\n      return [{ type: 'unordered-list', children }]\n    }\n    if (nodeName === 'DIV' && !isBlock(children[0])) {\n      return [{ type: 'paragraph', children }]\n    }\n    return deserialized\n  })\n}\n\nfunction deserializeNodes(nodes: Iterable<globalThis.Node>): DeserializedNode[] {\n  const outputNodes: (InlineFromExternalPaste | Block)[] = []\n  for (const node of nodes) {\n    outputNodes.push(...deserializeHTMLNode(node))\n  }\n  return outputNodes\n}\n\nfunction fixNodesForBlockChildren(deserializedNodes: DeserializedNode[]): DeserializedNodes {\n  if (!deserializedNodes.length) {\n    // Slate also gets unhappy if an element has no children\n    // the empty text nodes will get normalized away if they're not needed\n    return [{ text: '' }]\n  }\n  if (deserializedNodes.some(isBlock)) {\n    const result: DeserializedNode[] = []\n    let queuedInlines: InlineFromExternalPaste[] = []\n    const flushInlines = () => {\n      if (queuedInlines.length) {\n        result.push({ type: 'paragraph', children: queuedInlines })\n        queuedInlines = []\n      }\n    }\n    for (const node of deserializedNodes) {\n      if (isBlock(node)) {\n        flushInlines()\n        result.push(node)\n        continue\n      }\n      // we want to ignore whitespace between block level elements\n      // useful info about whitespace in html:\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace\n      if (Node.string(node).trim() !== '') {\n        queuedInlines.push(node)\n      }\n    }\n    flushInlines()\n    return result as DeserializedNodes\n  }\n  return deserializedNodes as DeserializedNodes\n}\n", "import { type Text } from 'slate'\nimport { type Mark } from '../utils'\n\n// a v important note\n// marks in the markdown ast/html are represented quite differently to how they are in slate\n// if you had the markdown **something https://keystonejs.com something**\n// the bold node is the parent of the link node\n// but in slate, marks are only represented on text nodes\n\nconst currentlyActiveMarks = new Set<Mark>()\nconst currentlyDisabledMarks = new Set<Mark>()\nlet currentLink: string | null = null\n\nexport function addMarkToChildren<T>(mark: Mark, cb: () => T): T {\n  const wasPreviouslyActive = currentlyActiveMarks.has(mark)\n  currentlyActiveMarks.add(mark)\n  try {\n    return cb()\n  } finally {\n    if (!wasPreviouslyActive) {\n      currentlyActiveMarks.delete(mark)\n    }\n  }\n}\n\nexport function setLinkForChildren<T>(href: string, cb: () => T): T {\n  // we'll only use the outer link\n  if (currentLink !== null) {\n    return cb()\n  }\n  currentLink = href\n  try {\n    return cb()\n  } finally {\n    currentLink = null\n  }\n}\n\nexport function addMarksToChildren<T>(marks: Set<Mark>, cb: () => T): T {\n  const marksToRemove = new Set<Mark>()\n  for (const mark of marks) {\n    if (!currentlyActiveMarks.has(mark)) {\n      marksToRemove.add(mark)\n    }\n    currentlyActiveMarks.add(mark)\n  }\n  try {\n    return cb()\n  } finally {\n    for (const mark of marksToRemove) {\n      currentlyActiveMarks.delete(mark)\n    }\n  }\n}\n\nexport function forceDisableMarkForChildren<T>(mark: Mark, cb: () => T): T {\n  const wasPreviouslyDisabled = currentlyDisabledMarks.has(mark)\n  currentlyDisabledMarks.add(mark)\n  try {\n    return cb()\n  } finally {\n    if (!wasPreviouslyDisabled) {\n      currentlyDisabledMarks.delete(mark)\n    }\n  }\n}\n\n/**\n * This type is more strict than `Element & { type: 'link'; }` because `children`\n * is constrained to only contain Text nodes. This can't be assumed generally around the editor\n * (because of inline relationships or nested links(which are normalized away but the editor needs to not break if it happens))\n * but where this type is used, we're only going to allow links to contain Text and that's important\n * so that we know a block will never be inside an inline because Slate gets unhappy when that happens\n * (really the link inline should probably be a mark rather than an inline,\n * non-void inlines are probably always bad but that would imply changing the document\n * structure which would be such unnecessary breakage)\n */\ntype StrictLink = { type: 'link'; href: string; children: Text[] }\n// inline relationships are not here because we never create them from handling a paste from html or markdown\nexport type InlineFromExternalPaste = Text | StrictLink\n\nexport function getInlineNodes(\n  text: string\n): [InlineFromExternalPaste, ...InlineFromExternalPaste[]] {\n  const node: Text = { text }\n  for (const mark of currentlyActiveMarks) {\n    if (!currentlyDisabledMarks.has(mark)) {\n      node[mark] = true\n    }\n  }\n  if (currentLink !== null) {\n    return [\n      { text: '' },\n      { type: 'link' as const, href: currentLink, children: [node] },\n      { text: '' },\n    ]\n  }\n  return [node]\n}\n", "import mdASTUtilFromMarkdown from 'mdast-util-from-markdown'\n// @ts-expect-error\nimport autoLinkLiteralFromMarkdownExtension from 'mdast-util-gfm-autolink-literal/from-markdown'\n// @ts-expect-error\nimport autoLinkLiteralMarkdownSyntax from 'micromark-extension-gfm-autolink-literal'\n// @ts-expect-error\nimport gfmStrikethroughFromMarkdownExtension from 'mdast-util-gfm-strikethrough/from-markdown'\nimport gfmStrikethroughMarkdownSyntax from 'micromark-extension-gfm-strikethrough'\nimport { type Block } from '../editor-shared'\nimport {\n  type InlineFromExternalPaste,\n  addMarkToChildren,\n  getInlineNodes,\n  setLinkForChildren,\n} from './utils'\n\nconst markdownConfig = {\n  mdastExtensions: [autoLinkLiteralFromMarkdownExtension, gfmStrikethroughFromMarkdownExtension],\n  extensions: [autoLinkLiteralMarkdownSyntax, gfmStrikethroughMarkdownSyntax()],\n}\n\nexport function deserializeMarkdown(markdown: string) {\n  const root = mdASTUtilFromMarkdown(markdown, markdownConfig)\n  let nodes = root.children\n  if (nodes.length === 1 && nodes[0].type === 'paragraph') {\n    nodes = nodes[0].children\n  }\n  return deserializeChildren(nodes, markdown)\n}\n\ntype MDNode = ReturnType<typeof mdASTUtilFromMarkdown>['children'][number]\n\nfunction deserializeChildren(nodes: MDNode[], input: string) {\n  const outputNodes: (InlineFromExternalPaste | Block)[] = []\n  for (const node of nodes) {\n    const result = deserializeMarkdownNode(node, input)\n    if (result.length) {\n      outputNodes.push(...result)\n    }\n  }\n  if (!outputNodes.length) {\n    outputNodes.push({ text: '' })\n  }\n  return outputNodes\n}\n\nfunction deserializeMarkdownNode(node: MDNode, input: string): (InlineFromExternalPaste | Block)[] {\n  switch (node.type) {\n    case 'blockquote':\n      return [{ type: 'blockquote', children: deserializeChildren(node.children, input) }]\n    case 'link': {\n      // arguably this could just return a link node rather than use setLinkForChildren since the children _should_ only be inlines\n      // but rather than relying on the markdown parser we use being correct in this way since it isn't nicely codified in types\n      // let's be safe since we already have the code to do it the safer way because of html pasting\n      return setLinkForChildren(node.url, () => deserializeChildren(node.children, input))\n    }\n    case 'code':\n      return [{ type: 'code', children: [{ text: node.value }] }]\n    case 'paragraph':\n      return [{ type: 'paragraph', children: deserializeChildren(node.children, input) }]\n    case 'heading': {\n      return [\n        {\n          type: 'heading',\n          level: node.depth,\n          children: deserializeChildren(node.children, input),\n        },\n      ]\n    }\n    case 'list': {\n      return [\n        {\n          type: node.ordered ? 'ordered-list' : 'unordered-list',\n          children: deserializeChildren(node.children, input),\n        },\n      ]\n    }\n    case 'listItem':\n      return [{ type: 'list-item', children: deserializeChildren(node.children, input) }]\n    case 'thematicBreak':\n      return [{ type: 'divider', children: [{ text: '' }] }]\n    case 'break':\n      return getInlineNodes('\\n')\n    case 'delete':\n      return addMarkToChildren('strikethrough', () => deserializeChildren(node.children, input))\n    case 'strong':\n      return addMarkToChildren('bold', () => deserializeChildren(node.children, input))\n    case 'emphasis':\n      return addMarkToChildren('italic', () => deserializeChildren(node.children, input))\n    case 'inlineCode':\n      return addMarkToChildren('code', () => getInlineNodes(node.value))\n    case 'text':\n      return getInlineNodes(node.value)\n  }\n  return getInlineNodes(input.slice(node.position!.start.offset, node.position!.end.offset))\n}\n", "import { z } from 'zod'\nimport type { RelationshipData } from './DocumentEditor/component-blocks/api-shared'\nimport { isValidURL } from './DocumentEditor/isValidURL'\n\n// leaf types\nconst zMarkValue = z.union([z.literal(true), z.undefined()])\n\nconst zText = z\n  .object({\n    type: z.literal('text').optional(),\n    text: z.string(),\n    bold: zMarkValue,\n    italic: zMarkValue,\n    underline: zMarkValue,\n    strikethrough: zMarkValue,\n    code: zMarkValue,\n    superscript: zMarkValue,\n    subscript: zMarkValue,\n    keyboard: zMarkValue,\n    insertMenu: zMarkValue,\n  })\n  .strict()\n\nconst zTextAlign = z.union([z.undefined(), z.literal('center'), z.literal('end')])\n\n// recursive types\nconst zLink = z\n  .object({\n    type: z.literal('link'),\n    href: z.string().refine(val => isValidURL(val), {\n      error: `This type of URL is not accepted`,\n    }),\n  })\n  .strict()\n\nconst zHeading = z\n  .object({\n    type: z.literal('heading'),\n    textAlign: zTextAlign,\n    level: z.union([\n      z.literal(1),\n      z.literal(2),\n      z.literal(3),\n      z.literal(4),\n      z.literal(5),\n      z.literal(6),\n    ]),\n  })\n  .strict()\n\nconst zParagraph = z\n  .object({\n    type: z.literal('paragraph'),\n    textAlign: zTextAlign,\n  })\n  .strict()\n\nconst zBasicElement = <T extends string>(type: T) =>\n  z\n    .object({\n      type: z.literal(type),\n    })\n    .strict()\n\nconst zBasicElements = [\n  zBasicElement('blockquote'),\n  zBasicElement('layout-area'),\n  zBasicElement('code'),\n  zBasicElement('divider'),\n  zBasicElement('list-item'),\n  zBasicElement('list-item-content'),\n  zBasicElement('ordered-list'),\n  zBasicElement('unordered-list'),\n] as const\n\nconst zLayout = z\n  .object({\n    type: z.literal('layout'),\n    layout: z.array(z.number()),\n  })\n  .strict()\n\nconst zRelationshipData = z\n  .object({\n    id: z.string(),\n    label: z.string().optional(),\n    data: z.record(z.string(), z.any()).optional(),\n  })\n  .strict()\n\nconst zRelationship = z\n  .object({\n    type: z.literal('relationship'),\n    relationship: z.string(),\n    data: z.union([zRelationshipData, z.null()]),\n  })\n  .strict()\n\nconst zComponentBlock = z\n  .object({\n    type: z.literal('component-block'),\n    component: z.string(),\n    props: z.record(z.string(), z.any()),\n  })\n  .strict()\n\nconst zComponentProp = <T extends string>(type: T) =>\n  z\n    .object({\n      type: z.literal(type),\n      propPath: z.array(z.union([z.string(), z.number()])).optional(),\n    })\n    .strict()\n\nconst zComponentProps = [\n  zComponentProp('component-block-prop'),\n  zComponentProp('component-inline-prop'),\n] as const\n\nexport type Node =\n  // inline\n  | z.infer<typeof zText>\n  | (z.infer<typeof zLink> & { children: Node[] })\n  | (z.infer<typeof zRelationship> & { children: Node[] })\n  // block\n  | (z.infer<typeof zComponentBlock> & { children: Node[] })\n  | (z.infer<(typeof zComponentProps)[keyof typeof zComponentProps & number]> & {\n      children: Node[]\n    })\n  | (z.infer<(typeof zBasicElements)[keyof typeof zBasicElements & number]> & {\n      children: Node[]\n    })\n  | (z.infer<typeof zHeading> & { children: Node[] })\n  | (z.infer<typeof zLayout> & { children: Node[] })\n  | (z.infer<typeof zParagraph> & { children: Node[] })\n\nconst zBlock: z.ZodType<Node> = z.discriminatedUnion('type', [\n  zComponentBlock.extend({ children: z.lazy(() => zChildren) }),\n  ...zComponentProps.map(prop => prop.extend({ children: z.lazy(() => zChildren) })),\n  ...zBasicElements.map(prop => prop.extend({ children: z.lazy(() => zChildren) })),\n  zHeading.extend({ children: z.lazy(() => zChildren) }),\n  zLayout.extend({ children: z.lazy(() => zChildren) }),\n  zParagraph.extend({ children: z.lazy(() => zChildren) }),\n])\n\nconst zInline: z.ZodType<Node> = z.discriminatedUnion('type', [\n  zText,\n  zLink.extend({ children: z.lazy(() => zChildren) }),\n  zRelationship.extend({ children: z.lazy(() => zChildren) }),\n])\n\nconst zChildren: z.ZodType<Node[]> = z.array(z.union([zBlock, zInline]))\nconst zDocument = z.array(zBlock)\n\n// exports\nexport type TextWithMarks = z.infer<typeof zText>\n\nexport function isRelationshipData(value: unknown): value is RelationshipData {\n  return zRelationshipData.safeParse(value).success\n}\n\nexport function validateDocumentStructure(value: unknown): asserts value is Node[] {\n  const result = zDocument.safeParse(value)\n  if (!result.success) {\n    throw new Error(`Invalid document structure: ${result.error.message}`)\n  }\n}\n", "import { g } from '@keystone-6/core'\nimport type { BaseFieldTypeInfo } from '@keystone-6/core/types'\nimport {\n  type BaseListTypeInfo,\n  type CommonFieldConfig,\n  type FieldTypeFunc,\n  type JSONValue,\n  fieldType,\n} from '@keystone-6/core/types'\nimport type { ComponentSchema } from './DocumentEditor/component-blocks/api'\nimport { assertValidComponentSchema } from './DocumentEditor/component-blocks/field-assertions'\nimport { getInitialPropsValue } from './DocumentEditor/component-blocks/initial-values'\nimport { addRelationshipDataToComponentProps, fetchRelationshipData } from './relationship-data'\nimport {\n  getGraphQLInputType,\n  getValueForCreate,\n  getValueForUpdate,\n} from './structure-graphql-input'\nimport { getOutputGraphQLField } from './structure-graphql-output'\n\nexport type StructureFieldConfig<ListTypeInfo extends BaseListTypeInfo> = CommonFieldConfig<\n  ListTypeInfo,\n  BaseFieldTypeInfo\n> & {\n  db?: { map?: string }\n  schema: ComponentSchema\n}\n\nexport function structure<ListTypeInfo extends BaseListTypeInfo>({\n  schema,\n  ...config\n}: StructureFieldConfig<ListTypeInfo>): FieldTypeFunc<ListTypeInfo> {\n  return meta => {\n    if ((config as any).isIndexed === 'unique') {\n      throw Error(\"isIndexed: 'unique' is not a supported option for field type structure\")\n    }\n    const lists = new Set(Object.keys(meta.lists))\n    try {\n      assertValidComponentSchema(schema, lists, 'structure')\n    } catch (err) {\n      throw new Error(`${meta.listKey}.${meta.fieldKey}: ${(err as any).message}`)\n    }\n\n    const defaultValue = getInitialPropsValue(schema)\n    const unreferencedConcreteInterfaceImplementations: g<typeof g.object<any>>[] = []\n\n    const name = meta.listKey + meta.fieldKey[0].toUpperCase() + meta.fieldKey.slice(1)\n    const innerUpdate =\n      typeof config.hooks?.resolveInput === 'function'\n        ? config.hooks.resolveInput\n        : config.hooks?.resolveInput?.update\n    return fieldType({\n      kind: 'scalar',\n      scalar: 'Json',\n      default:\n        meta.provider === 'sqlite'\n          ? undefined\n          : {\n              kind: 'literal',\n              // TODO: waiting on https://github.com/prisma/prisma/issues/26571\n              //   input.create manages defaultValues anyway\n              value: JSON.stringify(defaultValue ?? null),\n            },\n      map: config.db?.map,\n      mode: 'required',\n    })({\n      ...config,\n      hooks: {\n        ...config.hooks,\n        resolveInput: {\n          create:\n            typeof config.hooks?.resolveInput === 'function'\n              ? config.hooks.resolveInput\n              : config.hooks?.resolveInput?.create,\n          update: async args => {\n            let val = args.resolvedData[meta.fieldKey]\n            let prevVal = args.item[meta.fieldKey]\n            val = await getValueForUpdate(schema, val, prevVal, args.context, [])\n            return innerUpdate\n              ? innerUpdate({\n                  ...args,\n                  resolvedData: { ...args.resolvedData, [meta.fieldKey]: val },\n                })\n              : val\n          },\n        },\n      },\n      input: {\n        create: {\n          arg: g.arg({\n            type: getGraphQLInputType(name, schema, 'create', new Map(), meta),\n          }),\n          async resolve(val, context) {\n            return await getValueForCreate(schema, val, context, [])\n          },\n        },\n        update: {\n          arg: g.arg({\n            type: getGraphQLInputType(name, schema, 'update', new Map(), meta),\n          }),\n          resolve(val) {\n            return val as any\n          },\n        },\n      },\n      output: g.field({\n        type: g.object<{ value: JSONValue }>()({\n          name: `${name}Output`,\n          fields: {\n            structure: getOutputGraphQLField(\n              name,\n              schema,\n              unreferencedConcreteInterfaceImplementations,\n              new Map(),\n              meta\n            ),\n            json: g.field({\n              type: g.JSON,\n              args: {\n                hydrateRelationships: g.arg({\n                  type: g.nonNull(g.Boolean),\n                  defaultValue: false,\n                }),\n              },\n              resolve({ value }, args, context) {\n                if (!args.hydrateRelationships) return value\n                return addRelationshipDataToComponentProps(schema, value, (schema, value) => {\n                  return fetchRelationshipData(context, schema, value)\n                })\n              },\n            }),\n          },\n        }),\n        resolve(source) {\n          return source\n        },\n      }),\n      __ksTelemetryFieldTypeName: '@keystone-6/structure',\n      views: '@keystone-6/fields-document/structure-views',\n      getAdminMeta: () => ({}),\n      unreferencedConcreteInterfaceImplementations,\n    })\n  }\n}\n", "import { g } from '@keystone-6/core'\nimport type { GArg, GInputType, GNonNull, InferValueFromArg } from '@keystone-6/core/graphql-ts'\nimport type {\n  BaseItem,\n  FieldData,\n  GraphQLTypesForList,\n  KeystoneContext,\n} from '@keystone-6/core/types'\nimport type { GraphQLResolveInfo } from 'graphql'\n\nimport type { ComponentSchema } from './DocumentEditor/component-blocks/api'\nimport { getInitialPropsValue } from './DocumentEditor/component-blocks/initial-values'\nimport { type ReadonlyPropPath, assertNever } from './DocumentEditor/component-blocks/utils'\n\nexport function getGraphQLInputType(\n  name: string,\n  schema: ComponentSchema,\n  operation: 'create' | 'update',\n  cache: Map<ComponentSchema, GInputType>,\n  meta: FieldData\n) {\n  if (!cache.has(schema)) {\n    const res = getGraphQLInputTypeInner(name, schema, operation, cache, meta)\n    cache.set(schema, res)\n  }\n  return cache.get(schema)!\n}\n\nfunction getGraphQLInputTypeInner(\n  name: string,\n  schema: ComponentSchema,\n  operation: 'create' | 'update',\n  cache: Map<ComponentSchema, GInputType>,\n  meta: FieldData\n): GInputType {\n  if (schema.kind === 'form') {\n    if (!schema.graphql) {\n      throw new Error(`Field at ${name} is missing a graphql field`)\n    }\n    return schema.graphql.input\n  }\n  if (schema.kind === 'object') {\n    const input = g.inputObject({\n      name: `${name}${operation[0].toUpperCase()}${operation.slice(1)}Input`,\n      fields: () =>\n        Object.fromEntries(\n          Object.entries(schema.fields).map(([key, val]): [string, GArg<GInputType>] => {\n            const type = getGraphQLInputType(\n              `${name}${key[0].toUpperCase()}${key.slice(1)}`,\n              val,\n              operation,\n              cache,\n              meta\n            )\n            return [key, g.arg({ type })]\n          })\n        ),\n    })\n    return input\n  }\n  if (schema.kind === 'array') {\n    const innerType = getGraphQLInputType(name, schema.element, operation, cache, meta)\n    return g.list(innerType)\n  }\n  if (schema.kind === 'conditional') {\n    const input = g.inputObject({\n      name: `${name}${operation[0].toUpperCase()}${operation.slice(1)}Input`,\n      fields: () =>\n        Object.fromEntries(\n          Object.entries(schema.values).map(([key, val]): [string, GArg<GInputType>] => {\n            const type = getGraphQLInputType(\n              `${name}${key[0].toUpperCase()}${key.slice(1)}`,\n              val,\n              operation,\n              cache,\n              meta\n            )\n            return [key, g.arg({ type })]\n          })\n        ),\n    })\n    return input\n  }\n\n  if (schema.kind === 'relationship') {\n    const inputType =\n      meta.lists[schema.listKey].types.relateTo[schema.many ? 'many' : 'one'][operation]\n    // there are cases where this won't exist\n    // for example if gql omit is enabled on the related field\n    if (inputType === undefined) {\n      throw new Error('')\n    }\n    return inputType\n  }\n  if (schema.kind === 'child') {\n    throw new Error(`Child fields are not supported in the structure field, found one at ${name}`)\n  }\n\n  assertNever(schema)\n}\n\nexport async function getValueForUpdate(\n  schema: ComponentSchema,\n  value: any,\n  prevValue: any,\n  context: KeystoneContext,\n  path: ReadonlyPropPath\n): Promise<any> {\n  if (value === undefined) return prevValue\n  if (prevValue === undefined) {\n    prevValue = getInitialPropsValue(schema)\n  }\n\n  if (schema.kind === 'form') {\n    if (schema.validate(value)) return value\n    throw new Error(`The value of the form field at '${path.join('.')}' is invalid`)\n  }\n  if (value === null) {\n    throw new Error(\n      `${schema.kind[0].toUpperCase() + schema.kind.slice(1)} fields cannot be set to null but the field at '${path.join('.')}' is null`\n    )\n  }\n  if (schema.kind === 'object') {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.fields).map(async ([key, val]) => {\n          return [\n            key,\n            await getValueForUpdate(val, value[key], prevValue[key], context, path.concat(key)),\n          ]\n        })\n      )\n    )\n  }\n  if (schema.kind === 'array') {\n    return Promise.all(\n      (value as any[]).map((val, i) =>\n        getValueForUpdate(schema.element, val, prevValue[i], context, path.concat(i))\n      )\n    )\n  }\n  if (schema.kind === 'relationship') {\n    if (schema.many) {\n      const val = (value as InferValueFromArg<\n        GArg<NonNullable<GraphQLTypesForList['relateTo']['many']['update']>>\n      >)!\n      return resolveRelateToManyForUpdateInput(val, context, schema.listKey, prevValue)\n    } else {\n      const val = (value as InferValueFromArg<\n        GArg<NonNullable<GraphQLTypesForList['relateTo']['one']['update']>>\n      >)!\n\n      return resolveRelateToOneForUpdateInput(val, context, schema.listKey)\n    }\n  }\n  if (schema.kind === 'conditional') {\n    const conditionalValueKeys = Object.keys(value)\n    if (conditionalValueKeys.length !== 1) {\n      throw new Error(\n        `Conditional field inputs must set exactly one of the fields but the field at ${path.join(\n          '.'\n        )} has ${conditionalValueKeys.length} fields set`\n      )\n    }\n    const key = conditionalValueKeys[0]\n    let discriminant: string | boolean = key\n    if ((key === 'true' || key === 'false') && !schema.discriminant.validate(key)) {\n      discriminant = key === 'true'\n    }\n    return {\n      discriminant,\n      value: await getValueForUpdate(\n        (schema.values as any)[key],\n        value[key],\n        prevValue.discriminant === discriminant ? prevValue.value : getInitialPropsValue(schema),\n        context,\n        path.concat('value')\n      ),\n    }\n  }\n\n  if (schema.kind === 'child') {\n    throw new Error(\n      `Child fields are not supported in the structure field, found one at ${path.join('.')}`\n    )\n  }\n\n  assertNever(schema)\n}\n\nexport async function getValueForCreate(\n  schema: ComponentSchema,\n  value: any,\n  context: KeystoneContext,\n  path: ReadonlyPropPath\n): Promise<any> {\n  // If value is undefined, get the specified defaultValue\n  if (value === undefined) return getInitialPropsValue(schema)\n  if (schema.kind === 'form') {\n    if (schema.validate(value)) return value\n    throw new Error(`The value of the form field at '${path.join('.')}' is invalid`)\n  }\n  if (value === null) {\n    throw new Error(\n      `${\n        schema.kind[0].toUpperCase() + schema.kind.slice(1)\n      } fields cannot be set to null but the field at '${path.join('.')}' is null`\n    )\n  }\n  if (schema.kind === 'array') {\n    return Promise.all(\n      (value as any[]).map((val, i) =>\n        getValueForCreate(schema.element, val, context, path.concat(i))\n      )\n    )\n  }\n  if (schema.kind === 'object') {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.fields).map(async ([key, val]) => {\n          return [key, await getValueForCreate(val, value[key], context, path.concat(key))]\n        })\n      )\n    )\n  }\n  if (schema.kind === 'relationship') {\n    if (schema.many) {\n      const val = (value as InferValueFromArg<\n        GArg<NonNullable<GraphQLTypesForList['relateTo']['many']['create']>>\n      >)!\n\n      return resolveRelateToManyForCreateInput(val, context, schema.listKey)\n    } else {\n      const val = (value as InferValueFromArg<\n        GArg<NonNullable<GraphQLTypesForList['relateTo']['one']['create']>>\n      >)!\n\n      return resolveRelateToOneForCreateInput(val, context, schema.listKey)\n    }\n  }\n  if (schema.kind === 'conditional') {\n    if (value === null) throw new Error()\n    const conditionalValueKeys = Object.keys(value)\n    if (conditionalValueKeys.length !== 1) throw new Error()\n    const key = conditionalValueKeys[0]\n    let discriminant: string | boolean = key\n    if ((key === 'true' || key === 'false') && !schema.discriminant.validate(key)) {\n      discriminant = key === 'true'\n    }\n\n    return {\n      discriminant,\n      value: await getValueForCreate(\n        (schema.values as any)[key],\n        value[key],\n        context,\n        path.concat('value')\n      ),\n    }\n  }\n\n  if (schema.kind === 'child') {\n    throw new Error(\n      `Child fields are not supported in the structure field, found one at ${path.join('.')}`\n    )\n  }\n\n  assertNever(schema)\n}\n/** MANY */\n\ntype _CreateValueManyType = Exclude<\n  InferValueFromArg<GArg<Exclude<GraphQLTypesForList['relateTo']['many']['create'], undefined>>>,\n  null | undefined\n>\n\ntype _UpdateValueManyType = Exclude<\n  InferValueFromArg<GArg<Exclude<GraphQLTypesForList['relateTo']['many']['update'], undefined>>>,\n  null | undefined\n>\n\nexport class RelationshipErrors extends Error {\n  errors: { error: Error; tag: string }[]\n  constructor(errors: { error: Error; tag: string }[]) {\n    super('Multiple relationship errors')\n    this.errors = errors\n  }\n}\n\nfunction getResolvedUniqueWheres(\n  uniqueInputs: Record<string, any>[],\n  context: KeystoneContext,\n  foreignListKey: string,\n  operation: string\n) {\n  return uniqueInputs.map(uniqueInput =>\n    checkUniqueItemExists(uniqueInput, foreignListKey, context, operation)\n  )\n}\n\n// these aren't here out of thinking this is better syntax(i do not think it is),\n// it's just because TS won't infer the arg is X bit\nexport const isFulfilled = <T>(arg: PromiseSettledResult<T>): arg is PromiseFulfilledResult<T> =>\n  arg.status === 'fulfilled'\nexport const isRejected = (arg: PromiseSettledResult<any>): arg is PromiseRejectedResult =>\n  arg.status === 'rejected'\n\nexport async function resolveRelateToManyForCreateInput(\n  value: _CreateValueManyType,\n  context: KeystoneContext,\n  foreignListKey: string,\n  tag?: string\n) {\n  if (!Array.isArray(value.connect) && !Array.isArray(value.create)) {\n    throw new Error(\n      `You must provide \"connect\" or \"create\" in to-many relationship inputs for \"create\" operations.`\n    )\n  }\n\n  // Perform queries for the connections\n  const connects = Promise.allSettled(\n    getResolvedUniqueWheres(value.connect || [], context, foreignListKey, 'connect')\n  )\n\n  // Perform nested mutations for the creations\n  const creates = Promise.allSettled(\n    (value.create || []).map(x => resolveCreateMutation(x, context, foreignListKey))\n  )\n\n  const [connectResult, createResult] = await Promise.all([connects, creates])\n\n  // Collect all the errors\n  const errors = [...connectResult, ...createResult].filter(isRejected)\n  if (errors.length) {\n    // readd tag\n    throw new RelationshipErrors(errors.map(x => ({ error: x.reason, tag: tag || '' })))\n  }\n\n  // Perform queries for the connections\n  return [...connectResult, ...createResult].filter(isFulfilled).map(x => x.value)\n}\n\nexport async function resolveRelateToManyForUpdateInput(\n  value: _UpdateValueManyType,\n  context: KeystoneContext,\n  foreignListKey: string,\n  prevVal: { id: string }[]\n) {\n  if (\n    !Array.isArray(value.connect) &&\n    !Array.isArray(value.create) &&\n    !Array.isArray(value.disconnect) &&\n    !Array.isArray(value.set)\n  ) {\n    throw new Error(\n      `You must provide at least one of \"set\", \"connect\", \"create\" or \"disconnect\" in to-many relationship inputs for \"update\" operations.`\n    )\n  }\n  if (value.set && value.disconnect) {\n    throw new Error(\n      `The \"set\" and \"disconnect\" fields cannot both be provided to to-many relationship inputs for \"update\" operations.`\n    )\n  }\n\n  // Perform queries for the connections\n  const connects = Promise.allSettled(\n    getResolvedUniqueWheres(value.connect || [], context, foreignListKey, 'connect')\n  )\n\n  const disconnects = Promise.allSettled(\n    getResolvedUniqueWheres(value.disconnect || [], context, foreignListKey, 'disconnect')\n  )\n\n  const sets = Promise.allSettled(\n    getResolvedUniqueWheres(value.set || [], context, foreignListKey, 'set')\n  )\n\n  // Perform nested mutations for the creations\n  const creates = Promise.allSettled(\n    (value.create || []).map(x => resolveCreateMutation(x, context, foreignListKey))\n  )\n\n  const [connectResult, createResult, disconnectResult, setResult] = await Promise.all([\n    connects,\n    creates,\n    disconnects,\n    sets,\n  ])\n\n  // Collect all the errors\n  const errors = [...connectResult, ...createResult, ...disconnectResult, ...setResult].filter(\n    isRejected\n  )\n  if (errors.length) throw new RelationshipErrors(errors.map(x => ({ error: x.reason, tag: '' })))\n\n  let values = prevVal\n  if (value.set) {\n    values = setResult.filter(isFulfilled).map(x => x.value)\n  }\n\n  const idsToDisconnect = new Set(disconnectResult.filter(isFulfilled).map(x => x.value.id))\n  values = values.filter(x => !idsToDisconnect.has(x.id))\n  values.push(...connectResult.filter(isFulfilled).map(x => x.value))\n  values.push(...createResult.filter(isFulfilled).map(x => x.value))\n\n  return values\n}\n\n/** ONE */\n\ntype _CreateValueType = Exclude<\n  InferValueFromArg<GArg<Exclude<GraphQLTypesForList['relateTo']['one']['create'], undefined>>>,\n  null | undefined\n>\ntype _UpdateValueType = Exclude<\n  InferValueFromArg<\n    GArg<GNonNull<Exclude<GraphQLTypesForList['relateTo']['one']['update'], undefined>>>\n  >,\n  null | undefined\n>\n\nfunction missingItem(operation: string, uniqueWhere: Record<string, any>) {\n  throw new Error(\n    `You cannot ${operation} the item '${JSON.stringify(uniqueWhere)}' - it may not exist`\n  )\n}\n\nexport async function checkUniqueItemExists(\n  uniqueInput: Record<string, unknown>,\n  listKey: string,\n  context: KeystoneContext,\n  operation: string\n) {\n  // Check whether the item exists (from this users POV).\n  const item = await context.db[listKey].findOne({ where: uniqueInput })\n  if (item === null) throw missingItem(operation, uniqueInput)\n\n  return { id: item.id.toString() }\n}\n\nasync function handleCreateAndUpdate(\n  value: _CreateValueType,\n  context: KeystoneContext,\n  foreignListKey: string\n) {\n  if (value.connect) return checkUniqueItemExists(value.connect, foreignListKey, context, 'connect')\n  return resolveCreateMutation(value, context, foreignListKey)\n}\n\nasync function resolveCreateMutation(value: any, context: KeystoneContext, foreignListKey: string) {\n  const mutationType = context.graphql.schema.getMutationType()!\n  const { id } = (await mutationType.getFields()[\n    context.__internal.lists[foreignListKey].graphql.names.createMutationName\n  ].resolve!(\n    {},\n    { data: value.create },\n    context,\n    // we happen to know this isn't used\n    // no one else should rely on that though\n    // it could change in the future\n    {} as GraphQLResolveInfo\n  )) as BaseItem\n  return { id: id.toString() }\n}\n\nexport function resolveRelateToOneForCreateInput(\n  value: _CreateValueType,\n  context: KeystoneContext,\n  foreignListKey: string\n) {\n  const numOfKeys = Object.keys(value).length\n  if (numOfKeys !== 1)\n    throw new Error(\n      `You must provide \"connect\" or \"create\" in to-one relationship inputs for \"create\" operations.`\n    )\n  return handleCreateAndUpdate(value, context, foreignListKey)\n}\n\nexport function resolveRelateToOneForUpdateInput(\n  value: _UpdateValueType,\n  context: KeystoneContext,\n  foreignListKey: string\n) {\n  if (Object.keys(value).length !== 1)\n    throw new Error(\n      `You must provide one of \"connect\", \"create\" or \"disconnect\" in to-one relationship inputs for \"update\" operations.`\n    )\n\n  if (value.connect || value.create) return handleCreateAndUpdate(value, context, foreignListKey)\n  if (value.disconnect) return null\n}\n", "import { g } from '@keystone-6/core'\nimport type { KeystoneContext } from '@keystone-6/core/types'\nimport { type FieldData } from '@keystone-6/core/types'\nimport { type ComponentSchema } from './DocumentEditor/component-blocks/api-shared'\nimport { assertNever } from './DocumentEditor/component-blocks/utils'\nimport type { GArg, GField, GInputType, GOutputType } from '@keystone-6/core/graphql-ts'\n\nfunction wrapGraphQLFieldInResolver<InputSource, OutputSource>(\n  inputField: GField<\n    { value: InputSource },\n    Record<string, GArg<GInputType, boolean>>,\n    GOutputType<KeystoneContext>,\n    InputSource,\n    KeystoneContext\n  >,\n  getVal: (outputSource: OutputSource) => InputSource\n): GField<\n  OutputSource,\n  Record<string, GArg<GInputType, boolean>>,\n  GOutputType<KeystoneContext>,\n  unknown,\n  KeystoneContext\n> {\n  return g.field({\n    type: inputField.type,\n    args: inputField.args,\n    deprecationReason: inputField.deprecationReason,\n    description: inputField.description,\n    extensions: inputField.extensions as any,\n    resolve(value, args, context, info) {\n      const val = getVal(value)\n      if (!inputField.resolve) {\n        return val\n      }\n      return inputField.resolve({ value: val }, args, context, info)\n    },\n  })\n}\n\ntype OutputField = GField<\n  { value: unknown },\n  Record<string, GArg<GInputType, boolean>>,\n  GOutputType<KeystoneContext>,\n  unknown,\n  KeystoneContext\n>\n\nexport function getOutputGraphQLField(\n  name: string,\n  schema: ComponentSchema,\n  interfaceImplementations: g<typeof g.object<any>>[],\n  cache: Map<ComponentSchema, OutputField>,\n  meta: FieldData\n) {\n  if (!cache.has(schema)) {\n    const res = getOutputGraphQLFieldInner(name, schema, interfaceImplementations, cache, meta)\n    cache.set(schema, res)\n  }\n  return cache.get(schema)!\n}\n\nfunction getOutputGraphQLFieldInner(\n  name: string,\n  schema: ComponentSchema,\n  interfaceImplementations: g<typeof g.object<any>>[],\n  cache: Map<ComponentSchema, OutputField>,\n  meta: FieldData\n): OutputField {\n  if (schema.kind === 'form') {\n    if (!schema.graphql) {\n      throw new Error(`Field at ${name} is missing a graphql field`)\n    }\n    return wrapGraphQLFieldInResolver(schema.graphql.output, x => x.value)\n  }\n  if (schema.kind === 'object') {\n    return g.field({\n      type: g.object<unknown>()({\n        name,\n        fields: () =>\n          Object.fromEntries(\n            Object.entries(schema.fields).map(\n              ([key, val]): [\n                string,\n                GField<\n                  unknown,\n                  Record<string, GArg<GInputType>>,\n                  GOutputType<KeystoneContext>,\n                  unknown,\n                  KeystoneContext\n                >,\n              ] => {\n                const field = getOutputGraphQLField(\n                  `${name}${key[0].toUpperCase()}${key.slice(1)}`,\n                  val,\n                  interfaceImplementations,\n                  cache,\n                  meta\n                )\n                return [key, wrapGraphQLFieldInResolver(field, source => (source as any)[key])]\n              }\n            )\n          ),\n      }),\n      resolve({ value }) {\n        return value\n      },\n    })\n  }\n  if (schema.kind === 'array') {\n    const innerField = getOutputGraphQLField(\n      name,\n      schema.element,\n      interfaceImplementations,\n      cache,\n      meta\n    )\n    const resolve = innerField.resolve\n\n    return g.field({\n      type: g.list(innerField.type),\n      args: innerField.args,\n      deprecationReason: innerField.deprecationReason,\n      description: innerField.description,\n      extensions: innerField.extensions,\n      resolve({ value }, args, context, info) {\n        if (!resolve) {\n          return value as unknown[]\n        }\n        return (value as unknown[]).map(val => resolve({ value: val }, args, context, info))\n      },\n    })\n  }\n  if (schema.kind === 'conditional') {\n    let discriminantField: OutputField\n\n    const getDiscriminantField = () => {\n      if (!discriminantField) {\n        discriminantField = getOutputGraphQLField(\n          name + 'Discriminant',\n          schema.discriminant,\n          interfaceImplementations,\n          cache,\n          meta\n        )\n      }\n      return discriminantField\n    }\n    type SourceType = { discriminant: string | boolean; value: unknown }\n\n    const interfaceType = g.interface<SourceType>()({\n      name,\n      resolveType: value => {\n        const stringifiedDiscriminant = value.discriminant.toString()\n        return name + stringifiedDiscriminant[0].toUpperCase() + stringifiedDiscriminant.slice(1)\n      },\n      fields: () => ({\n        discriminant: getDiscriminantField(),\n      }),\n    })\n\n    interfaceImplementations.push(\n      ...Object.entries(schema.values).map(([key, val]): g<typeof g.object<SourceType>> => {\n        const innerName = name + key[0].toUpperCase() + key.slice(1)\n        return g.object<SourceType>()({\n          name: innerName,\n          interfaces: [interfaceType],\n          fields: () => ({\n            discriminant: wrapGraphQLFieldInResolver(getDiscriminantField(), x => x.discriminant),\n            value: getOutputGraphQLField(\n              `${innerName}Value`,\n              val,\n              interfaceImplementations,\n              cache,\n              meta\n            ),\n          }),\n        })\n      })\n    )\n\n    return g.field({\n      type: interfaceType,\n      resolve({ value }) {\n        return value as SourceType\n      },\n    })\n  }\n\n  if (schema.kind === 'relationship') {\n    const listOutputType = meta.lists[schema.listKey].types.output\n    return g.field({\n      type: schema.many ? g.list(listOutputType) : listOutputType,\n      resolve({ value }, args, context) {\n        if (Array.isArray(value)) {\n          return context.db[schema.listKey].findMany({\n            where: {\n              id: { in: (value as { id: string }[]).map(x => x.id) },\n            },\n          })\n        }\n        if ((value as any)?.id == null) {\n          return null\n        }\n        return context.db[schema.listKey].findOne({\n          where: {\n            id: (value as { id: string }).id,\n          },\n        })\n      },\n    })\n  }\n\n  if (schema.kind === 'child') {\n    throw new Error('Child fields are not supported in the structure field')\n  }\n\n  assertNever(schema)\n}\n", "import type { BaseListTypeInfo } from '@keystone-6/core/types'\nimport type { Session } from '.keystone/types'\n\nexport type AccessArgs = {\n  session?: Session\n}\n\nexport const isSignedIn = ({ session }: AccessArgs) => Boolean(session)\n\nexport function hasPermission(\n  permission: keyof NonNullable<Session>['data']['role']\n): (args: AccessArgs) => boolean {\n  return ({ session }: AccessArgs) => Boolean(session?.data.role?.[permission])\n}\n\nexport const permissions = {\n  canUseAdminUI: hasPermission('canUseAdminUI'),\n  canManageUsers: hasPermission('canManageUsers'),\n  canManageAssets: hasPermission('canManageAssets'),\n  canApproveAssets: hasPermission('canApproveAssets'),\n  canManageBrands: hasPermission('canManageBrands'),\n  canManageContent: hasPermission('canManageContent'),\n  canPublishContent: hasPermission('canPublishContent'),\n  canViewAnalytics: hasPermission('canViewAnalytics'),\n  canManageDepartments: hasPermission('canManageDepartments'),\n  canAnswerQuestions: hasPermission('canAnswerQuestions'),\n  canManageAllDepartments: hasPermission('canManageAllDepartments'),\n}\n\nexport function departmentFilter<T extends BaseListTypeInfo['fields']>({\n  session,\n}: AccessArgs): Record<string, unknown> | boolean {\n  if (!session) return false\n  if (permissions.canManageAllDepartments({ session })) return true\n  if (!session.data.department?.id) return false\n  return { department: { id: { equals: session.data.department.id } } }\n}\n\n", "// Seeds rich demo data on first run. Safe to re-run (no duplicate users).\nasync function ensureSuperAdmin(context: any) {\n  const email = 'eliasisrael@adobe.com'\n  const existing = await context.db.User.findMany({\n    where: { email: { equals: email } },\n    take: 1,\n  })\n  if (existing.length > 0) return\n\n  let adminRole = (\n    await context.db.Role.findMany({ where: { name: { equals: 'Admin' } }, take: 1 })\n  )[0]\n\n  if (!adminRole) {\n    adminRole = await context.db.Role.createOne({\n      data: {\n        name: 'Admin',\n        canUseAdminUI: true,\n        canManageUsers: true,\n        canManageAssets: true,\n        canApproveAssets: true,\n        canManageBrands: true,\n        canManageContent: true,\n        canPublishContent: true,\n        canViewAnalytics: true,\n        canManageDepartments: true,\n        canAnswerQuestions: true,\n        canManageAllDepartments: true,\n      },\n    })\n  }\n\n  await context.db.User.createOne({\n    data: {\n      name: 'Elias Israel',\n      email,\n      password: '12345678',\n      role: { connect: { id: adminRole.id } },\n    },\n  })\n}\n\nexport async function seedDemoData(context: any) {\n  // If departments already exist, only ensure the super admin user exists\n  const existingDepartments = await context.db.Department.count()\n  if (existingDepartments > 0) {\n    await ensureSuperAdmin(context)\n    return\n  }\n\n  // Departments\n  const departments = await Promise.all(\n    [\n      { name: 'Marketing', slug: 'marketing', description: 'Marketing department' },\n      { name: 'Sales', slug: 'sales', description: 'Sales department' },\n      { name: 'Engineering', slug: 'engineering', description: 'Engineering department' },\n      { name: 'Legal', slug: 'legal', description: 'Legal & compliance' },\n    ].map((d: { name: string; slug: string; description: string }) =>\n      context.db.Department.createOne({ data: d })\n    )\n  )\n\n  const deptBySlug = Object.fromEntries(departments.map(d => [d.slug!, d]))\n\n  // Roles (7)\n  const roles = await Promise.all(\n    [\n      {\n        name: 'Admin',\n        canUseAdminUI: true,\n        canManageUsers: true,\n        canManageAssets: true,\n        canApproveAssets: true,\n        canManageBrands: true,\n        canManageContent: true,\n        canPublishContent: true,\n        canViewAnalytics: true,\n        canManageDepartments: true,\n        canAnswerQuestions: true,\n        canManageAllDepartments: true,\n      },\n      {\n        name: 'Content Manager',\n        canUseAdminUI: true,\n        canManageUsers: false,\n        canManageAssets: true,\n        canApproveAssets: true,\n        canManageBrands: true,\n        canManageContent: true,\n        canPublishContent: true,\n        canViewAnalytics: true,\n        canManageDepartments: false,\n        canAnswerQuestions: true,\n        canManageAllDepartments: false,\n      },\n      {\n        name: 'Creative',\n        canUseAdminUI: true,\n        canManageUsers: false,\n        canManageAssets: true,\n        canApproveAssets: false,\n        canManageBrands: false,\n        canManageContent: true,\n        canPublishContent: false,\n        canViewAnalytics: false,\n        canManageDepartments: false,\n        canAnswerQuestions: false,\n        canManageAllDepartments: false,\n      },\n      {\n        name: 'Viewer',\n        canUseAdminUI: true,\n        canManageUsers: false,\n        canManageAssets: false,\n        canApproveAssets: false,\n        canManageBrands: false,\n        canManageContent: false,\n        canPublishContent: false,\n        canViewAnalytics: false,\n        canManageDepartments: false,\n        canAnswerQuestions: false,\n        canManageAllDepartments: false,\n      },\n      {\n        name: 'Compliance',\n        canUseAdminUI: true,\n        canManageUsers: false,\n        canManageAssets: false,\n        canApproveAssets: true,\n        canManageBrands: false,\n        canManageContent: false,\n        canPublishContent: false,\n        canViewAnalytics: true,\n        canManageDepartments: false,\n        canAnswerQuestions: true,\n        canManageAllDepartments: false,\n      },\n      {\n        name: 'Brand Manager',\n        canUseAdminUI: true,\n        canManageUsers: false,\n        canManageAssets: true,\n        canApproveAssets: true,\n        canManageBrands: true,\n        canManageContent: true,\n        canPublishContent: true,\n        canViewAnalytics: true,\n        canManageDepartments: false,\n        canAnswerQuestions: true,\n        canManageAllDepartments: false,\n      },\n      {\n        name: 'Analyst',\n        canUseAdminUI: true,\n        canManageUsers: false,\n        canManageAssets: false,\n        canApproveAssets: false,\n        canManageBrands: false,\n        canManageContent: false,\n        canPublishContent: false,\n        canViewAnalytics: true,\n        canManageDepartments: false,\n        canAnswerQuestions: false,\n        canManageAllDepartments: false,\n      },\n    ].map((r: any) => context.db.Role.createOne({ data: r }))\n  )\n\n  const roleByName = Object.fromEntries(roles.map(r => [r.name!, r]))\n\n  // Users\n  const users = await Promise.all(\n    [\n      {\n        name: 'Alice Admin',\n        email: 'alice.admin@example.com',\n        password: 'password',\n        role: { connect: { id: roleByName['Admin'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n      {\n        name: 'Elias Israel',\n        email: 'eliasisrael@adobe.com',\n        password: '12345678',\n        role: { connect: { id: roleByName['Admin'].id } },\n        // optional department; Admin can access all departments regardless\n      },\n      {\n        name: 'Cameron Content',\n        email: 'cameron.content@example.com',\n        password: 'password',\n        role: { connect: { id: roleByName['Content Manager'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n      {\n        name: 'Chris Creative',\n        email: 'chris.creative@example.com',\n        password: 'password',\n        role: { connect: { id: roleByName['Creative'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n      {\n        name: 'Vera Viewer',\n        email: 'vera.viewer@example.com',\n        password: 'password',\n        role: { connect: { id: roleByName['Viewer'].id } },\n        department: { connect: { id: deptBySlug['sales'].id } },\n      },\n      {\n        name: 'Connie Compliance',\n        email: 'connie.compliance@example.com',\n        password: 'password',\n        role: { connect: { id: roleByName['Compliance'].id } },\n        department: { connect: { id: deptBySlug['legal'].id } },\n      },\n      {\n        name: 'Brenda Brand',\n        email: 'brenda.brand@example.com',\n        password: 'password',\n        role: { connect: { id: roleByName['Brand Manager'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n      {\n        name: 'Andy Analyst',\n        email: 'andy.analyst@example.com',\n        password: 'password',\n        role: { connect: { id: roleByName['Analyst'].id } },\n        department: { connect: { id: deptBySlug['engineering'].id } },\n      },\n    ].map((u: any) => context.db.User.createOne({ data: u }))\n  )\n\n  const userByEmail = Object.fromEntries(users.map(u => [u.email!, u]))\n\n  // Brands\n  const brands = await Promise.all(\n    [\n      {\n        name: 'Acme Global',\n        slug: 'acme',\n        description: 'Enterprise brand guidelines',\n        complianceStatus: 'needs_review',\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n      {\n        name: 'Contoso Health',\n        slug: 'contoso',\n        description: 'Healthcare brand',\n        complianceStatus: 'compliant',\n        department: { connect: { id: deptBySlug['legal'].id } },\n      },\n    ].map((b: any) => context.db.Brand.createOne({ data: b }))\n  )\n\n  const brandBySlug = Object.fromEntries(brands.map(b => [b.slug!, b]))\n\n  // Tags\n  const tags = await Promise.all(\n    ['Urgent', 'Brand', 'Campaign', 'Legal', 'Press'].map((name: string) =>\n      context.db.Tag.createOne({ data: { name } })\n    )\n  )\n\n  // Assets\n  const assets = await Promise.all(\n    [\n      {\n        title: 'Acme Logo',\n        description: 'Primary logo in SVG',\n        status: 'approved',\n        brand: { connect: { id: brandBySlug['acme'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n        uploadedBy: { connect: { id: userByEmail['chris.creative@example.com'].id } },\n        approvedBy: { connect: { id: userByEmail['connie.compliance@example.com'].id } },\n        tags: { connect: tags.slice(0, 2).map(t => ({ id: t.id })) },\n      },\n      {\n        title: 'Press Kit 2025',\n        description: 'Zip with brand press assets',\n        status: 'in_review',\n        brand: { connect: { id: brandBySlug['acme'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n        uploadedBy: { connect: { id: userByEmail['cameron.content@example.com'].id } },\n        tags: { connect: tags.slice(1, 4).map(t => ({ id: t.id })) },\n      },\n    ].map((a: any) => context.db.Asset.createOne({ data: a }))\n  )\n\n  // Content\n  await Promise.all(\n    [\n      {\n        title: 'Spring Campaign Brief',\n        status: 'review',\n        brand: { connect: { id: brandBySlug['acme'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n        createdBy: { connect: { id: userByEmail['cameron.content@example.com'].id } },\n        reviewers: {\n          connect: [\n            userByEmail['connie.compliance@example.com'],\n            userByEmail['brenda.brand@example.com'],\n          ].map((u: any) => ({ id: u.id })),\n        },\n        tags: { connect: tags.slice(0, 3).map((t: any) => ({ id: t.id })) },\n      },\n      {\n        title: 'Brand Compliance Checklist',\n        status: 'approved',\n        brand: { connect: { id: brandBySlug['contoso'].id } },\n        department: { connect: { id: deptBySlug['legal'].id } },\n        createdBy: { connect: { id: userByEmail['connie.compliance@example.com'].id } },\n        reviewers: {\n          connect: [userByEmail['andy.analyst@example.com']].map((u: any) => ({ id: u.id })),\n        },\n        tags: { connect: tags.slice(2, 5).map((t: any) => ({ id: t.id })) },\n      },\n    ].map((c: any) => context.db.Content.createOne({ data: c }))\n  )\n\n  // Questions & Answers\n  const questions = await Promise.all(\n    [\n      {\n        subject: 'Can we use the old logo on social? ',\n        status: 'new',\n        department: { connect: { id: deptBySlug['marketing'].id } },\n        askedBy: { connect: { id: userByEmail['vera.viewer@example.com'].id } },\n        tags: { connect: tags.slice(0, 2).map(t => ({ id: t.id })) },\n      },\n      {\n        subject: 'Press kit approval timeline',\n        status: 'triage',\n        department: { connect: { id: deptBySlug['marketing'].id } },\n        askedBy: { connect: { id: userByEmail['cameron.content@example.com'].id } },\n        tags: { connect: tags.slice(1, 4).map(t => ({ id: t.id })) },\n      },\n    ].map((q: any) => context.db.Question.createOne({ data: q }))\n  )\n\n  await context.db.Answer.createOne({\n    data: {\n      question: { connect: { id: questions[0].id } },\n      answeredBy: { connect: { id: userByEmail['connie.compliance@example.com'].id } },\n      approved: true,\n      department: { connect: { id: deptBySlug['legal'].id } },\n    },\n  })\n\n  // Analytics Events\n  await Promise.all(\n    [\n      {\n        eventType: 'view',\n        user: { connect: { id: userByEmail['vera.viewer@example.com'].id } },\n        entityType: 'Asset',\n        entityId: assets[0].id,\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n      {\n        eventType: 'download',\n        user: { connect: { id: userByEmail['cameron.content@example.com'].id } },\n        entityType: 'Asset',\n        entityId: assets[1].id,\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n    ].map((e: any) => context.db.AnalyticsEvent.createOne({ data: e }))\n  )\n\n  // Audit logs\n  await Promise.all(\n    [\n      {\n        action: 'ASSET_APPROVED',\n        entityType: 'Asset',\n        entityId: assets[0].id,\n        user: { connect: { id: userByEmail['connie.compliance@example.com'].id } },\n        department: { connect: { id: deptBySlug['legal'].id } },\n      },\n      {\n        action: 'CONTENT_SUBMITTED',\n        entityType: 'Content',\n        user: { connect: { id: userByEmail['cameron.content@example.com'].id } },\n        department: { connect: { id: deptBySlug['marketing'].id } },\n      },\n    ].map((l: any) => context.db.AuditLog.createOne({ data: l }))\n  )\n\n  // Ensure requested super admin user exists (in case user list was changed)\n  await ensureSuperAdmin(context)\n}\n\n"],
  "mappings": "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",
  "names": ["import_core", "import_graphql", "import_core", "session", "import_core", "AUTHENTICATION_FAILURE", "config", "list", "session", "withAuth", "import_core", "import_core", "import_types", "import_graphql", "lists", "relationship", "list", "data", "import_slate", "import_slate", "import_slate", "import_slate", "relationship", "schema", "value", "weakMemoize", "node", "import_slate", "import_slate", "import_slate", "list", "import_slate", "text", "import_slate", "node", "import_slate", "import_slate", "node", "import_slate", "import_slate", "text", "import_slate", "text", "shortcuts", "import_slate", "import_slate", "text", "import_slate", "text", "import_slate", "shortcuts", "text", "import_slate", "import_slate", "text", "text", "import_from_markdown", "autoLinkLiteralFromMarkdownExtension", "gfmStrikethroughFromMarkdownExtension", "autoLinkLiteralMarkdownSyntax", "gfmStrikethroughMarkdownSyntax", "mdASTUtilFromMarkdown", "plain", "node", "import_core", "import_core", "import_core", "config", "lists", "document", "relationship", "blockTypes", "session", "session", "fs", "bytes", "express", "session"]
}
