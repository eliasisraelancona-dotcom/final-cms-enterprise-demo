"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@wry+context@0.7.4";
exports.ids = ["vendor-chunks/@wry+context@0.7.4"];
exports.modules = {

/***/ "(pages-dir-node)/../../../../node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/bundle.cjs":
/*!**************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/bundle.cjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nvar MISSING_VALUE = {};\nvar idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nvar makeSlotClass = function () { return /** @class */ (function () {\n    function Slot() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\n            \"slot\",\n            idCounter++,\n            Date.now(),\n            Math.random().toString(36).slice(2),\n        ].join(\":\");\n    }\n    Slot.prototype.hasValue = function () {\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\n            // We use the Slot object iself as a key to its value, which means the\n            // value cannot be obtained without a reference to the Slot object.\n            if (this.id in context_1.slots) {\n                var value = context_1.slots[this.id];\n                if (value === MISSING_VALUE)\n                    break;\n                if (context_1 !== currentContext) {\n                    // Cache the value in currentContext.slots so the next lookup will\n                    // be faster. This caching is safe because the tree of contexts and\n                    // the values of the slots are logically immutable.\n                    currentContext.slots[this.id] = value;\n                }\n                return true;\n            }\n        }\n        if (currentContext) {\n            // If a value was not found for this Slot, it's never going to be found\n            // no matter how many times we look it up, so we might as well cache\n            // the absence of the value, too.\n            currentContext.slots[this.id] = MISSING_VALUE;\n        }\n        return false;\n    };\n    Slot.prototype.getValue = function () {\n        if (this.hasValue()) {\n            return currentContext.slots[this.id];\n        }\n    };\n    Slot.prototype.withValue = function (value, callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        var _a;\n        var slots = (_a = {\n                __proto__: null\n            },\n            _a[this.id] = value,\n            _a);\n        var parent = currentContext;\n        currentContext = { parent: parent, slots: slots };\n        try {\n            // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n            return callback.apply(thisArg, args);\n        }\n        finally {\n            currentContext = parent;\n        }\n    };\n    // Capture the current context and wrap a callback function so that it\n    // reestablishes the captured context when called.\n    Slot.bind = function (callback) {\n        var context = currentContext;\n        return function () {\n            var saved = currentContext;\n            try {\n                currentContext = context;\n                return callback.apply(this, arguments);\n            }\n            finally {\n                currentContext = saved;\n            }\n        };\n    };\n    // Immediately run a callback function without any captured context.\n    Slot.noContext = function (callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        if (currentContext) {\n            var saved = currentContext;\n            try {\n                currentContext = null;\n                // Function.prototype.apply allows the arguments array argument to be\n                // omitted or undefined, so args! is fine here.\n                return callback.apply(thisArg, args);\n            }\n            finally {\n                currentContext = saved;\n            }\n        }\n        else {\n            return callback.apply(thisArg, args);\n        }\n    };\n    return Slot;\n}()); };\nfunction maybe(fn) {\n    try {\n        return fn();\n    }\n    catch (ignored) { }\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nvar globalKey = \"@wry/context:Slot\";\nvar host = \n// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(function () { return globalThis; }) ||\n    // Fall back to global, which works in Node.js and may be converted by some\n    // bundlers to the appropriate identifier (window, self, ...) depending on the\n    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n    maybe(function () { return global; }) ||\n    // Otherwise, use a dummy host that's local to this module. We used to fall\n    // back to using the Array constructor as a namespace, but that was flagged in\n    // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n    Object.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nvar globalHost = host;\nvar Slot = globalHost[globalKey] ||\n    // Earlier versions of this package stored the globalKey property on the Array\n    // constructor, so we check there as well, to prevent Slot class duplication.\n    Array[globalKey] ||\n    (function (Slot) {\n        try {\n            Object.defineProperty(globalHost, globalKey, {\n                value: Slot,\n                enumerable: false,\n                writable: false,\n                // When it was possible for globalHost to be the Array constructor (a\n                // legacy Slot dedup strategy), it was important for the property to be\n                // configurable:true so it could be deleted. That does not seem to be as\n                // important when globalHost is the global object, but I don't want to\n                // cause similar problems again, and configurable:true seems safest.\n                // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n                configurable: true\n            });\n        }\n        finally {\n            return Slot;\n        }\n    })(makeSlotClass());\n\nvar bind = Slot.bind, noContext = Slot.noContext;\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nfunction asyncFromGen(genFn) {\n    return function () {\n        var gen = genFn.apply(this, arguments);\n        var boundNext = bind(gen.next);\n        var boundThrow = bind(gen.throw);\n        return new Promise(function (resolve, reject) {\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                }\n                catch (error) {\n                    return reject(error);\n                }\n                var next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                }\n                else {\n                    next(result.value);\n                }\n            }\n            var invokeNext = function (value) { return invoke(boundNext, value); };\n            var invokeThrow = function (error) { return invoke(boundThrow, error); };\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nvar wrappedFibers = [];\nfunction wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        var wrap = function (obj, method) {\n            var fn = obj[method];\n            obj[method] = function () {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n}\n\nexports.Slot = Slot;\nexports.asyncFromGen = asyncFromGen;\nexports.bind = bind;\nexports.noContext = noContext;\nexports.setTimeout = setTimeoutWithContext;\nexports.wrapYieldingFiberMethods = wrapYieldingFiberMethods;\n//# sourceMappingURL=bundle.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdyeStjb250ZXh0QDAuNy40L25vZGVfbW9kdWxlcy9Ad3J5L2NvbnRleHQvbGliL2J1bmRsZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsaURBQWlEO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWixvQkFBb0I7QUFDcEIsWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvamFpbWVpc3JhZWxjYW1wZWFzL2tleXN0b25lL25vZGVfbW9kdWxlcy8ucG5wbS9Ad3J5K2NvbnRleHRAMC43LjQvbm9kZV9tb2R1bGVzL0B3cnkvY29udGV4dC9saWIvYnVuZGxlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgY3VycmVudENvbnRleHQgdmFyaWFibGUgd2lsbCBvbmx5IGJlIHVzZWQgaWYgdGhlIG1ha2VTbG90Q2xhc3Ncbi8vIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2hpY2ggaGFwcGVucyBvbmx5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IGNvcHkgb2YgdGhlXG4vLyBAd3J5L2NvbnRleHQgcGFja2FnZSB0byBiZSBpbXBvcnRlZC5cbnZhciBjdXJyZW50Q29udGV4dCA9IG51bGw7XG4vLyBUaGlzIHVuaXF1ZSBpbnRlcm5hbCBvYmplY3QgaXMgdXNlZCB0byBkZW5vdGUgdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZVxuLy8gZm9yIGEgZ2l2ZW4gU2xvdCwgYW5kIGlzIG5ldmVyIGV4cG9zZWQgdG8gb3V0c2lkZSBjb2RlLlxudmFyIE1JU1NJTkdfVkFMVUUgPSB7fTtcbnZhciBpZENvdW50ZXIgPSAxO1xuLy8gQWx0aG91Z2ggd2UgY2FuJ3QgZG8gYW55dGhpbmcgYWJvdXQgdGhlIGNvc3Qgb2YgZHVwbGljYXRlZCBjb2RlIGZyb21cbi8vIGFjY2lkZW50YWxseSBidW5kbGluZyBtdWx0aXBsZSBjb3BpZXMgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlLCB3ZSBjYW5cbi8vIGF2b2lkIGNyZWF0aW5nIHRoZSBTbG90IGNsYXNzIG1vcmUgdGhhbiBvbmNlIHVzaW5nIG1ha2VTbG90Q2xhc3MuXG52YXIgbWFrZVNsb3RDbGFzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbG90KCkge1xuICAgICAgICAvLyBJZiB5b3UgaGF2ZSBhIFNsb3Qgb2JqZWN0LCB5b3UgY2FuIGZpbmQgb3V0IGl0cyBzbG90LmlkLCBidXQgeW91IGNhbm5vdFxuICAgICAgICAvLyBndWVzcyB0aGUgc2xvdC5pZCBvZiBhIFNsb3QgeW91IGRvbid0IGhhdmUgYWNjZXNzIHRvLCB0aGFua3MgdG8gdGhlXG4gICAgICAgIC8vIHJhbmRvbWl6ZWQgc3VmZml4LlxuICAgICAgICB0aGlzLmlkID0gW1xuICAgICAgICAgICAgXCJzbG90XCIsXG4gICAgICAgICAgICBpZENvdW50ZXIrKyxcbiAgICAgICAgICAgIERhdGUubm93KCksXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcbiAgICAgICAgXS5qb2luKFwiOlwiKTtcbiAgICB9XG4gICAgU2xvdC5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGNvbnRleHRfMSA9IGN1cnJlbnRDb250ZXh0OyBjb250ZXh0XzE7IGNvbnRleHRfMSA9IGNvbnRleHRfMS5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgU2xvdCBvYmplY3QgaXNlbGYgYXMgYSBrZXkgdG8gaXRzIHZhbHVlLCB3aGljaCBtZWFucyB0aGVcbiAgICAgICAgICAgIC8vIHZhbHVlIGNhbm5vdCBiZSBvYnRhaW5lZCB3aXRob3V0IGEgcmVmZXJlbmNlIHRvIHRoZSBTbG90IG9iamVjdC5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkIGluIGNvbnRleHRfMS5zbG90cykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRleHRfMS5zbG90c1t0aGlzLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IE1JU1NJTkdfVkFMVUUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0XzEgIT09IGN1cnJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSB2YWx1ZSBpbiBjdXJyZW50Q29udGV4dC5zbG90cyBzbyB0aGUgbmV4dCBsb29rdXAgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBmYXN0ZXIuIFRoaXMgY2FjaGluZyBpcyBzYWZlIGJlY2F1c2UgdGhlIHRyZWUgb2YgY29udGV4dHMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgb2YgdGhlIHNsb3RzIGFyZSBsb2dpY2FsbHkgaW1tdXRhYmxlLlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIElmIGEgdmFsdWUgd2FzIG5vdCBmb3VuZCBmb3IgdGhpcyBTbG90LCBpdCdzIG5ldmVyIGdvaW5nIHRvIGJlIGZvdW5kXG4gICAgICAgICAgICAvLyBubyBtYXR0ZXIgaG93IG1hbnkgdGltZXMgd2UgbG9vayBpdCB1cCwgc28gd2UgbWlnaHQgYXMgd2VsbCBjYWNoZVxuICAgICAgICAgICAgLy8gdGhlIGFic2VuY2Ugb2YgdGhlIHZhbHVlLCB0b28uXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IE1JU1NJTkdfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2xvdC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2xvdC5wcm90b3R5cGUud2l0aFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaywgXG4gICAgLy8gR2l2ZW4gdGhlIHByZXZhbGVuY2Ugb2YgYXJyb3cgZnVuY3Rpb25zLCBzcGVjaWZ5aW5nIGFyZ3VtZW50cyBpcyBsaWtlbHlcbiAgICAvLyB0byBiZSBtdWNoIG1vcmUgY29tbW9uIHRoYW4gc3BlY2lmeWluZyBgdGhpc2AsIGhlbmNlIHRoaXMgb3JkZXJpbmc6XG4gICAgYXJncywgdGhpc0FyZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBzbG90cyA9IChfYSA9IHtcbiAgICAgICAgICAgICAgICBfX3Byb3RvX186IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYVt0aGlzLmlkXSA9IHZhbHVlLFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICB2YXIgcGFyZW50ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgIGN1cnJlbnRDb250ZXh0ID0geyBwYXJlbnQ6IHBhcmVudCwgc2xvdHM6IHNsb3RzIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkgYWxsb3dzIHRoZSBhcmd1bWVudHMgYXJyYXkgYXJndW1lbnQgdG8gYmVcbiAgICAgICAgICAgIC8vIG9taXR0ZWQgb3IgdW5kZWZpbmVkLCBzbyBhcmdzISBpcyBmaW5lIGhlcmUuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQ2FwdHVyZSB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB3cmFwIGEgY2FsbGJhY2sgZnVuY3Rpb24gc28gdGhhdCBpdFxuICAgIC8vIHJlZXN0YWJsaXNoZXMgdGhlIGNhcHR1cmVkIGNvbnRleHQgd2hlbiBjYWxsZWQuXG4gICAgU2xvdC5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2F2ZWQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBzYXZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIEltbWVkaWF0ZWx5IHJ1biBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhvdXQgYW55IGNhcHR1cmVkIGNvbnRleHQuXG4gICAgU2xvdC5ub0NvbnRleHQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIFxuICAgIC8vIEdpdmVuIHRoZSBwcmV2YWxlbmNlIG9mIGFycm93IGZ1bmN0aW9ucywgc3BlY2lmeWluZyBhcmd1bWVudHMgaXMgbGlrZWx5XG4gICAgLy8gdG8gYmUgbXVjaCBtb3JlIGNvbW1vbiB0aGFuIHNwZWNpZnlpbmcgYHRoaXNgLCBoZW5jZSB0aGlzIG9yZGVyaW5nOlxuICAgIGFyZ3MsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgc2F2ZWQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSBhbGxvd3MgdGhlIGFyZ3VtZW50cyBhcnJheSBhcmd1bWVudCB0byBiZVxuICAgICAgICAgICAgICAgIC8vIG9taXR0ZWQgb3IgdW5kZWZpbmVkLCBzbyBhcmdzISBpcyBmaW5lIGhlcmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBzYXZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNsb3Q7XG59KCkpOyB9O1xuZnVuY3Rpb24gbWF5YmUoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGlnbm9yZWQpIHsgfVxufVxuLy8gV2Ugc3RvcmUgYSBzaW5nbGUgZ2xvYmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBTbG90IGNsYXNzIGFzIGEgcGVybWFuZW50XG4vLyBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsVGhpcyBvYmplY3QuIFRoaXMgb2JmdXNjYXRpb24gZG9lc1xuLy8gbm90aGluZyB0byBwcmV2ZW50IGFjY2VzcyB0byB0aGUgU2xvdCBjbGFzcywgYnV0IGF0IGxlYXN0IGl0IGVuc3VyZXMgdGhlXG4vLyBpbXBsZW1lbnRhdGlvbiAoaS5lLiBjdXJyZW50Q29udGV4dCkgY2Fubm90IGJlIHRhbXBlcmVkIHdpdGgsIGFuZCBhbGwgY29waWVzXG4vLyBvZiB0aGUgQHdyeS9jb250ZXh0IHBhY2thZ2UgKGhvcGVmdWxseSBqdXN0IG9uZSkgd2lsbCBzaGFyZSB0aGUgc2FtZSBTbG90XG4vLyBpbXBsZW1lbnRhdGlvbi4gU2luY2UgdGhlIGZpcnN0IGNvcHkgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlIHRvIGJlXG4vLyBpbXBvcnRlZCB3aW5zLCB0aGlzIHRlY2huaXF1ZSBpbXBvc2VzIGEgc3RlZXAgY29zdCBmb3IgYW55IGZ1dHVyZSBicmVha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgU2xvdCBjbGFzcy5cbnZhciBnbG9iYWxLZXkgPSBcIkB3cnkvY29udGV4dDpTbG90XCI7XG52YXIgaG9zdCA9IFxuLy8gUHJlZmVyIGdsb2JhbFRoaXMgd2hlbiBhdmFpbGFibGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtbi93cnl3YXJlL2lzc3Vlcy8zNDdcbm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbFRoaXM7IH0pIHx8XG4gICAgLy8gRmFsbCBiYWNrIHRvIGdsb2JhbCwgd2hpY2ggd29ya3MgaW4gTm9kZS5qcyBhbmQgbWF5IGJlIGNvbnZlcnRlZCBieSBzb21lXG4gICAgLy8gYnVuZGxlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGlkZW50aWZpZXIgKHdpbmRvdywgc2VsZiwgLi4uKSBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gYnVuZGxpbmcgdGFyZ2V0LiBodHRwczovL2dpdGh1Yi5jb20vZW5kb2pzL2VuZG8vaXNzdWVzLzU3NiNpc3N1ZWNvbW1lbnQtMTE3ODUxNTIyNFxuICAgIG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbDsgfSkgfHxcbiAgICAvLyBPdGhlcndpc2UsIHVzZSBhIGR1bW15IGhvc3QgdGhhdCdzIGxvY2FsIHRvIHRoaXMgbW9kdWxlLiBXZSB1c2VkIHRvIGZhbGxcbiAgICAvLyBiYWNrIHRvIHVzaW5nIHRoZSBBcnJheSBjb25zdHJ1Y3RvciBhcyBhIG5hbWVzcGFjZSwgYnV0IHRoYXQgd2FzIGZsYWdnZWQgaW5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtbi93cnl3YXJlL2lzc3Vlcy8zNDcsIGFuZCBjYW4gYmUgYXZvaWRlZC5cbiAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gV2hpY2hldmVyIGdsb2JhbEhvc3Qgd2UncmUgdXNpbmcsIG1ha2UgVHlwZVNjcmlwdCBoYXBweSBhYm91dCB0aGUgYWRkaXRpb25hbFxuLy8gZ2xvYmFsS2V5IHByb3BlcnR5LlxudmFyIGdsb2JhbEhvc3QgPSBob3N0O1xudmFyIFNsb3QgPSBnbG9iYWxIb3N0W2dsb2JhbEtleV0gfHxcbiAgICAvLyBFYXJsaWVyIHZlcnNpb25zIG9mIHRoaXMgcGFja2FnZSBzdG9yZWQgdGhlIGdsb2JhbEtleSBwcm9wZXJ0eSBvbiB0aGUgQXJyYXlcbiAgICAvLyBjb25zdHJ1Y3Rvciwgc28gd2UgY2hlY2sgdGhlcmUgYXMgd2VsbCwgdG8gcHJldmVudCBTbG90IGNsYXNzIGR1cGxpY2F0aW9uLlxuICAgIEFycmF5W2dsb2JhbEtleV0gfHxcbiAgICAoZnVuY3Rpb24gKFNsb3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxIb3N0LCBnbG9iYWxLZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogU2xvdCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpdCB3YXMgcG9zc2libGUgZm9yIGdsb2JhbEhvc3QgdG8gYmUgdGhlIEFycmF5IGNvbnN0cnVjdG9yIChhXG4gICAgICAgICAgICAgICAgLy8gbGVnYWN5IFNsb3QgZGVkdXAgc3RyYXRlZ3kpLCBpdCB3YXMgaW1wb3J0YW50IGZvciB0aGUgcHJvcGVydHkgdG8gYmVcbiAgICAgICAgICAgICAgICAvLyBjb25maWd1cmFibGU6dHJ1ZSBzbyBpdCBjb3VsZCBiZSBkZWxldGVkLiBUaGF0IGRvZXMgbm90IHNlZW0gdG8gYmUgYXNcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnRhbnQgd2hlbiBnbG9iYWxIb3N0IGlzIHRoZSBnbG9iYWwgb2JqZWN0LCBidXQgSSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAgICAgLy8gY2F1c2Ugc2ltaWxhciBwcm9ibGVtcyBhZ2FpbiwgYW5kIGNvbmZpZ3VyYWJsZTp0cnVlIHNlZW1zIHNhZmVzdC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW5kb2pzL2VuZG8vaXNzdWVzLzU3NiNpc3N1ZWNvbW1lbnQtMTE3ODI3NDAwOFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZXR1cm4gU2xvdDtcbiAgICAgICAgfVxuICAgIH0pKG1ha2VTbG90Q2xhc3MoKSk7XG5cbnZhciBiaW5kID0gU2xvdC5iaW5kLCBub0NvbnRleHQgPSBTbG90Lm5vQ29udGV4dDtcbmZ1bmN0aW9uIHNldFRpbWVvdXRXaXRoQ29udGV4dChjYWxsYmFjaywgZGVsYXkpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kKGNhbGxiYWNrKSwgZGVsYXkpO1xufVxuLy8gVHVybiBhbnkgZ2VuZXJhdG9yIGZ1bmN0aW9uIGludG8gYW4gYXN5bmMgZnVuY3Rpb24gKHVzaW5nIHlpZWxkIGluc3RlYWRcbi8vIG9mIGF3YWl0KSwgd2l0aCBjb250ZXh0IGF1dG9tYXRpY2FsbHkgcHJlc2VydmVkIGFjcm9zcyB5aWVsZHMuXG5mdW5jdGlvbiBhc3luY0Zyb21HZW4oZ2VuRm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2VuID0gZ2VuRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGJvdW5kTmV4dCA9IGJpbmQoZ2VuLm5leHQpO1xuICAgICAgICB2YXIgYm91bmRUaHJvdyA9IGJpbmQoZ2VuLnRocm93KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5jYWxsKGdlbiwgYXJndW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gcmVzdWx0LmRvbmUgPyByZXNvbHZlIDogaW52b2tlTmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShyZXN1bHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKG5leHQsIHJlc3VsdC5kb25lID8gcmVqZWN0IDogaW52b2tlVGhyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnZva2VOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpbnZva2UoYm91bmROZXh0LCB2YWx1ZSk7IH07XG4gICAgICAgICAgICB2YXIgaW52b2tlVGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShib3VuZFRocm93LCBlcnJvcik7IH07XG4gICAgICAgICAgICBpbnZva2VOZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG4vLyBJZiB5b3UgdXNlIHRoZSBmaWJlcnMgbnBtIHBhY2thZ2UgdG8gaW1wbGVtZW50IGNvcm91dGluZXMgaW4gTm9kZS5qcyxcbi8vIHlvdSBzaG91bGQgY2FsbCB0aGlzIGZ1bmN0aW9uIGF0IGxlYXN0IG9uY2UgdG8gZW5zdXJlIGNvbnRleHQgbWFuYWdlbWVudFxuLy8gcmVtYWlucyBjb2hlcmVudCBhY3Jvc3MgYW55IHlpZWxkcy5cbnZhciB3cmFwcGVkRmliZXJzID0gW107XG5mdW5jdGlvbiB3cmFwWWllbGRpbmdGaWJlck1ldGhvZHMoRmliZXIpIHtcbiAgICAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgaW1wbGVtZW50YXRpb24gb2YgRmliZXIgcGVyIHByb2Nlc3MsIHNvIHRoaXMgYXJyYXlcbiAgICAvLyBzaG91bGQgbmV2ZXIgZ3JvdyBsb25nZXIgdGhhbiBvbmUgZWxlbWVudC5cbiAgICBpZiAod3JhcHBlZEZpYmVycy5pbmRleE9mKEZpYmVyKSA8IDApIHtcbiAgICAgICAgdmFyIHdyYXAgPSBmdW5jdGlvbiAob2JqLCBtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IG9ialttZXRob2RdO1xuICAgICAgICAgICAgb2JqW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vQ29udGV4dChmbiwgYXJndW1lbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZXNlIG1ldGhvZHMgY2FuIHlpZWxkLCBhY2NvcmRpbmcgdG9cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xhdmVyZGV0L25vZGUtZmliZXJzL2Jsb2IvZGRlYmVkOWI4YWUzODgzZTU3ZjgyMmUyMTA4ZTY5NDNlNWM4ZDJhOC9maWJlcnMuanMjTDk3LUwxMDBcbiAgICAgICAgd3JhcChGaWJlciwgXCJ5aWVsZFwiKTtcbiAgICAgICAgd3JhcChGaWJlci5wcm90b3R5cGUsIFwicnVuXCIpO1xuICAgICAgICB3cmFwKEZpYmVyLnByb3RvdHlwZSwgXCJ0aHJvd0ludG9cIik7XG4gICAgICAgIHdyYXBwZWRGaWJlcnMucHVzaChGaWJlcik7XG4gICAgfVxuICAgIHJldHVybiBGaWJlcjtcbn1cblxuZXhwb3J0cy5TbG90ID0gU2xvdDtcbmV4cG9ydHMuYXN5bmNGcm9tR2VuID0gYXN5bmNGcm9tR2VuO1xuZXhwb3J0cy5iaW5kID0gYmluZDtcbmV4cG9ydHMubm9Db250ZXh0ID0gbm9Db250ZXh0O1xuZXhwb3J0cy5zZXRUaW1lb3V0ID0gc2V0VGltZW91dFdpdGhDb250ZXh0O1xuZXhwb3J0cy53cmFwWWllbGRpbmdGaWJlck1ldGhvZHMgPSB3cmFwWWllbGRpbmdGaWJlck1ldGhvZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../../../node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/bundle.cjs\n");

/***/ }),

/***/ "../../../../node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/bundle.cjs":
/*!**************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/bundle.cjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nvar MISSING_VALUE = {};\nvar idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nvar makeSlotClass = function () { return /** @class */ (function () {\n    function Slot() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\n            \"slot\",\n            idCounter++,\n            Date.now(),\n            Math.random().toString(36).slice(2),\n        ].join(\":\");\n    }\n    Slot.prototype.hasValue = function () {\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\n            // We use the Slot object iself as a key to its value, which means the\n            // value cannot be obtained without a reference to the Slot object.\n            if (this.id in context_1.slots) {\n                var value = context_1.slots[this.id];\n                if (value === MISSING_VALUE)\n                    break;\n                if (context_1 !== currentContext) {\n                    // Cache the value in currentContext.slots so the next lookup will\n                    // be faster. This caching is safe because the tree of contexts and\n                    // the values of the slots are logically immutable.\n                    currentContext.slots[this.id] = value;\n                }\n                return true;\n            }\n        }\n        if (currentContext) {\n            // If a value was not found for this Slot, it's never going to be found\n            // no matter how many times we look it up, so we might as well cache\n            // the absence of the value, too.\n            currentContext.slots[this.id] = MISSING_VALUE;\n        }\n        return false;\n    };\n    Slot.prototype.getValue = function () {\n        if (this.hasValue()) {\n            return currentContext.slots[this.id];\n        }\n    };\n    Slot.prototype.withValue = function (value, callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        var _a;\n        var slots = (_a = {\n                __proto__: null\n            },\n            _a[this.id] = value,\n            _a);\n        var parent = currentContext;\n        currentContext = { parent: parent, slots: slots };\n        try {\n            // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n            return callback.apply(thisArg, args);\n        }\n        finally {\n            currentContext = parent;\n        }\n    };\n    // Capture the current context and wrap a callback function so that it\n    // reestablishes the captured context when called.\n    Slot.bind = function (callback) {\n        var context = currentContext;\n        return function () {\n            var saved = currentContext;\n            try {\n                currentContext = context;\n                return callback.apply(this, arguments);\n            }\n            finally {\n                currentContext = saved;\n            }\n        };\n    };\n    // Immediately run a callback function without any captured context.\n    Slot.noContext = function (callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        if (currentContext) {\n            var saved = currentContext;\n            try {\n                currentContext = null;\n                // Function.prototype.apply allows the arguments array argument to be\n                // omitted or undefined, so args! is fine here.\n                return callback.apply(thisArg, args);\n            }\n            finally {\n                currentContext = saved;\n            }\n        }\n        else {\n            return callback.apply(thisArg, args);\n        }\n    };\n    return Slot;\n}()); };\nfunction maybe(fn) {\n    try {\n        return fn();\n    }\n    catch (ignored) { }\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nvar globalKey = \"@wry/context:Slot\";\nvar host = \n// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(function () { return globalThis; }) ||\n    // Fall back to global, which works in Node.js and may be converted by some\n    // bundlers to the appropriate identifier (window, self, ...) depending on the\n    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n    maybe(function () { return global; }) ||\n    // Otherwise, use a dummy host that's local to this module. We used to fall\n    // back to using the Array constructor as a namespace, but that was flagged in\n    // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n    Object.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nvar globalHost = host;\nvar Slot = globalHost[globalKey] ||\n    // Earlier versions of this package stored the globalKey property on the Array\n    // constructor, so we check there as well, to prevent Slot class duplication.\n    Array[globalKey] ||\n    (function (Slot) {\n        try {\n            Object.defineProperty(globalHost, globalKey, {\n                value: Slot,\n                enumerable: false,\n                writable: false,\n                // When it was possible for globalHost to be the Array constructor (a\n                // legacy Slot dedup strategy), it was important for the property to be\n                // configurable:true so it could be deleted. That does not seem to be as\n                // important when globalHost is the global object, but I don't want to\n                // cause similar problems again, and configurable:true seems safest.\n                // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n                configurable: true\n            });\n        }\n        finally {\n            return Slot;\n        }\n    })(makeSlotClass());\n\nvar bind = Slot.bind, noContext = Slot.noContext;\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nfunction asyncFromGen(genFn) {\n    return function () {\n        var gen = genFn.apply(this, arguments);\n        var boundNext = bind(gen.next);\n        var boundThrow = bind(gen.throw);\n        return new Promise(function (resolve, reject) {\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                }\n                catch (error) {\n                    return reject(error);\n                }\n                var next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                }\n                else {\n                    next(result.value);\n                }\n            }\n            var invokeNext = function (value) { return invoke(boundNext, value); };\n            var invokeThrow = function (error) { return invoke(boundThrow, error); };\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nvar wrappedFibers = [];\nfunction wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        var wrap = function (obj, method) {\n            var fn = obj[method];\n            obj[method] = function () {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n}\n\nexports.Slot = Slot;\nexports.asyncFromGen = asyncFromGen;\nexports.bind = bind;\nexports.noContext = noContext;\nexports.setTimeout = setTimeoutWithContext;\nexports.wrapYieldingFiberMethods = wrapYieldingFiberMethods;\n//# sourceMappingURL=bundle.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3cnkrY29udGV4dEAwLjcuNC9ub2RlX21vZHVsZXMvQHdyeS9jb250ZXh0L2xpYi9idW5kbGUuY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELGlEQUFpRDtBQUNqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1osb0JBQW9CO0FBQ3BCLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL2phaW1laXNyYWVsY2FtcGVhcy9rZXlzdG9uZS9ub2RlX21vZHVsZXMvLnBucG0vQHdyeStjb250ZXh0QDAuNy40L25vZGVfbW9kdWxlcy9Ad3J5L2NvbnRleHQvbGliL2J1bmRsZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGN1cnJlbnRDb250ZXh0IHZhcmlhYmxlIHdpbGwgb25seSBiZSB1c2VkIGlmIHRoZSBtYWtlU2xvdENsYXNzXG4vLyBmdW5jdGlvbiBpcyBjYWxsZWQsIHdoaWNoIGhhcHBlbnMgb25seSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBjb3B5IG9mIHRoZVxuLy8gQHdyeS9jb250ZXh0IHBhY2thZ2UgdG8gYmUgaW1wb3J0ZWQuXG52YXIgY3VycmVudENvbnRleHQgPSBudWxsO1xuLy8gVGhpcyB1bmlxdWUgaW50ZXJuYWwgb2JqZWN0IGlzIHVzZWQgdG8gZGVub3RlIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWVcbi8vIGZvciBhIGdpdmVuIFNsb3QsIGFuZCBpcyBuZXZlciBleHBvc2VkIHRvIG91dHNpZGUgY29kZS5cbnZhciBNSVNTSU5HX1ZBTFVFID0ge307XG52YXIgaWRDb3VudGVyID0gMTtcbi8vIEFsdGhvdWdoIHdlIGNhbid0IGRvIGFueXRoaW5nIGFib3V0IHRoZSBjb3N0IG9mIGR1cGxpY2F0ZWQgY29kZSBmcm9tXG4vLyBhY2NpZGVudGFsbHkgYnVuZGxpbmcgbXVsdGlwbGUgY29waWVzIG9mIHRoZSBAd3J5L2NvbnRleHQgcGFja2FnZSwgd2UgY2FuXG4vLyBhdm9pZCBjcmVhdGluZyB0aGUgU2xvdCBjbGFzcyBtb3JlIHRoYW4gb25jZSB1c2luZyBtYWtlU2xvdENsYXNzLlxudmFyIG1ha2VTbG90Q2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xvdCgpIHtcbiAgICAgICAgLy8gSWYgeW91IGhhdmUgYSBTbG90IG9iamVjdCwgeW91IGNhbiBmaW5kIG91dCBpdHMgc2xvdC5pZCwgYnV0IHlvdSBjYW5ub3RcbiAgICAgICAgLy8gZ3Vlc3MgdGhlIHNsb3QuaWQgb2YgYSBTbG90IHlvdSBkb24ndCBoYXZlIGFjY2VzcyB0bywgdGhhbmtzIHRvIHRoZVxuICAgICAgICAvLyByYW5kb21pemVkIHN1ZmZpeC5cbiAgICAgICAgdGhpcy5pZCA9IFtcbiAgICAgICAgICAgIFwic2xvdFwiLFxuICAgICAgICAgICAgaWRDb3VudGVyKyssXG4gICAgICAgICAgICBEYXRlLm5vdygpLFxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXG4gICAgICAgIF0uam9pbihcIjpcIik7XG4gICAgfVxuICAgIFNsb3QucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBjb250ZXh0XzEgPSBjdXJyZW50Q29udGV4dDsgY29udGV4dF8xOyBjb250ZXh0XzEgPSBjb250ZXh0XzEucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIFNsb3Qgb2JqZWN0IGlzZWxmIGFzIGEga2V5IHRvIGl0cyB2YWx1ZSwgd2hpY2ggbWVhbnMgdGhlXG4gICAgICAgICAgICAvLyB2YWx1ZSBjYW5ub3QgYmUgb2J0YWluZWQgd2l0aG91dCBhIHJlZmVyZW5jZSB0byB0aGUgU2xvdCBvYmplY3QuXG4gICAgICAgICAgICBpZiAodGhpcy5pZCBpbiBjb250ZXh0XzEuc2xvdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0XzEuc2xvdHNbdGhpcy5pZF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBNSVNTSU5HX1ZBTFVFKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dF8xICE9PSBjdXJyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdmFsdWUgaW4gY3VycmVudENvbnRleHQuc2xvdHMgc28gdGhlIG5leHQgbG9va3VwIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgZmFzdGVyLiBUaGlzIGNhY2hpbmcgaXMgc2FmZSBiZWNhdXNlIHRoZSB0cmVlIG9mIGNvbnRleHRzIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWVzIG9mIHRoZSBzbG90cyBhcmUgbG9naWNhbGx5IGltbXV0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQuc2xvdHNbdGhpcy5pZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJZiBhIHZhbHVlIHdhcyBub3QgZm91bmQgZm9yIHRoaXMgU2xvdCwgaXQncyBuZXZlciBnb2luZyB0byBiZSBmb3VuZFxuICAgICAgICAgICAgLy8gbm8gbWF0dGVyIGhvdyBtYW55IHRpbWVzIHdlIGxvb2sgaXQgdXAsIHNvIHdlIG1pZ2h0IGFzIHdlbGwgY2FjaGVcbiAgICAgICAgICAgIC8vIHRoZSBhYnNlbmNlIG9mIHRoZSB2YWx1ZSwgdG9vLlxuICAgICAgICAgICAgY3VycmVudENvbnRleHQuc2xvdHNbdGhpcy5pZF0gPSBNSVNTSU5HX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNsb3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQuc2xvdHNbdGhpcy5pZF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNsb3QucHJvdG90eXBlLndpdGhWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY2FsbGJhY2ssIFxuICAgIC8vIEdpdmVuIHRoZSBwcmV2YWxlbmNlIG9mIGFycm93IGZ1bmN0aW9ucywgc3BlY2lmeWluZyBhcmd1bWVudHMgaXMgbGlrZWx5XG4gICAgLy8gdG8gYmUgbXVjaCBtb3JlIGNvbW1vbiB0aGFuIHNwZWNpZnlpbmcgYHRoaXNgLCBoZW5jZSB0aGlzIG9yZGVyaW5nOlxuICAgIGFyZ3MsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgc2xvdHMgPSAoX2EgPSB7XG4gICAgICAgICAgICAgICAgX19wcm90b19fOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2FbdGhpcy5pZF0gPSB2YWx1ZSxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHsgcGFyZW50OiBwYXJlbnQsIHNsb3RzOiBzbG90cyB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5IGFsbG93cyB0aGUgYXJndW1lbnRzIGFycmF5IGFyZ3VtZW50IHRvIGJlXG4gICAgICAgICAgICAvLyBvbWl0dGVkIG9yIHVuZGVmaW5lZCwgc28gYXJncyEgaXMgZmluZSBoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIENhcHR1cmUgdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgd3JhcCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHNvIHRoYXQgaXRcbiAgICAvLyByZWVzdGFibGlzaGVzIHRoZSBjYXB0dXJlZCBjb250ZXh0IHdoZW4gY2FsbGVkLlxuICAgIFNsb3QuYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgY29udGV4dCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNhdmVkID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBJbW1lZGlhdGVseSBydW4gYSBjYWxsYmFjayBmdW5jdGlvbiB3aXRob3V0IGFueSBjYXB0dXJlZCBjb250ZXh0LlxuICAgIFNsb3Qubm9Db250ZXh0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBcbiAgICAvLyBHaXZlbiB0aGUgcHJldmFsZW5jZSBvZiBhcnJvdyBmdW5jdGlvbnMsIHNwZWNpZnlpbmcgYXJndW1lbnRzIGlzIGxpa2VseVxuICAgIC8vIHRvIGJlIG11Y2ggbW9yZSBjb21tb24gdGhhbiBzcGVjaWZ5aW5nIGB0aGlzYCwgaGVuY2UgdGhpcyBvcmRlcmluZzpcbiAgICBhcmdzLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHNhdmVkID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkgYWxsb3dzIHRoZSBhcmd1bWVudHMgYXJyYXkgYXJndW1lbnQgdG8gYmVcbiAgICAgICAgICAgICAgICAvLyBvbWl0dGVkIG9yIHVuZGVmaW5lZCwgc28gYXJncyEgaXMgZmluZSBoZXJlLlxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTbG90O1xufSgpKTsgfTtcbmZ1bmN0aW9uIG1heWJlKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChpZ25vcmVkKSB7IH1cbn1cbi8vIFdlIHN0b3JlIGEgc2luZ2xlIGdsb2JhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2xvdCBjbGFzcyBhcyBhIHBlcm1hbmVudFxuLy8gbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb2YgdGhlIGdsb2JhbFRoaXMgb2JqZWN0LiBUaGlzIG9iZnVzY2F0aW9uIGRvZXNcbi8vIG5vdGhpbmcgdG8gcHJldmVudCBhY2Nlc3MgdG8gdGhlIFNsb3QgY2xhc3MsIGJ1dCBhdCBsZWFzdCBpdCBlbnN1cmVzIHRoZVxuLy8gaW1wbGVtZW50YXRpb24gKGkuZS4gY3VycmVudENvbnRleHQpIGNhbm5vdCBiZSB0YW1wZXJlZCB3aXRoLCBhbmQgYWxsIGNvcGllc1xuLy8gb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlIChob3BlZnVsbHkganVzdCBvbmUpIHdpbGwgc2hhcmUgdGhlIHNhbWUgU2xvdFxuLy8gaW1wbGVtZW50YXRpb24uIFNpbmNlIHRoZSBmaXJzdCBjb3B5IG9mIHRoZSBAd3J5L2NvbnRleHQgcGFja2FnZSB0byBiZVxuLy8gaW1wb3J0ZWQgd2lucywgdGhpcyB0ZWNobmlxdWUgaW1wb3NlcyBhIHN0ZWVwIGNvc3QgZm9yIGFueSBmdXR1cmUgYnJlYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIFNsb3QgY2xhc3MuXG52YXIgZ2xvYmFsS2V5ID0gXCJAd3J5L2NvbnRleHQ6U2xvdFwiO1xudmFyIGhvc3QgPSBcbi8vIFByZWZlciBnbG9iYWxUaGlzIHdoZW4gYXZhaWxhYmxlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbW4vd3J5d2FyZS9pc3N1ZXMvMzQ3XG5tYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiBnbG9iYWxUaGlzOyB9KSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byBnbG9iYWwsIHdoaWNoIHdvcmtzIGluIE5vZGUuanMgYW5kIG1heSBiZSBjb252ZXJ0ZWQgYnkgc29tZVxuICAgIC8vIGJ1bmRsZXJzIHRvIHRoZSBhcHByb3ByaWF0ZSBpZGVudGlmaWVyICh3aW5kb3csIHNlbGYsIC4uLikgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIGJ1bmRsaW5nIHRhcmdldC4gaHR0cHM6Ly9naXRodWIuY29tL2VuZG9qcy9lbmRvL2lzc3Vlcy81NzYjaXNzdWVjb21tZW50LTExNzg1MTUyMjRcbiAgICBtYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiBnbG9iYWw7IH0pIHx8XG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgYSBkdW1teSBob3N0IHRoYXQncyBsb2NhbCB0byB0aGlzIG1vZHVsZS4gV2UgdXNlZCB0byBmYWxsXG4gICAgLy8gYmFjayB0byB1c2luZyB0aGUgQXJyYXkgY29uc3RydWN0b3IgYXMgYSBuYW1lc3BhY2UsIGJ1dCB0aGF0IHdhcyBmbGFnZ2VkIGluXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbW4vd3J5d2FyZS9pc3N1ZXMvMzQ3LCBhbmQgY2FuIGJlIGF2b2lkZWQuXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFdoaWNoZXZlciBnbG9iYWxIb3N0IHdlJ3JlIHVzaW5nLCBtYWtlIFR5cGVTY3JpcHQgaGFwcHkgYWJvdXQgdGhlIGFkZGl0aW9uYWxcbi8vIGdsb2JhbEtleSBwcm9wZXJ0eS5cbnZhciBnbG9iYWxIb3N0ID0gaG9zdDtcbnZhciBTbG90ID0gZ2xvYmFsSG9zdFtnbG9iYWxLZXldIHx8XG4gICAgLy8gRWFybGllciB2ZXJzaW9ucyBvZiB0aGlzIHBhY2thZ2Ugc3RvcmVkIHRoZSBnbG9iYWxLZXkgcHJvcGVydHkgb24gdGhlIEFycmF5XG4gICAgLy8gY29uc3RydWN0b3IsIHNvIHdlIGNoZWNrIHRoZXJlIGFzIHdlbGwsIHRvIHByZXZlbnQgU2xvdCBjbGFzcyBkdXBsaWNhdGlvbi5cbiAgICBBcnJheVtnbG9iYWxLZXldIHx8XG4gICAgKGZ1bmN0aW9uIChTbG90KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsSG9zdCwgZ2xvYmFsS2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFNsb3QsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIFdoZW4gaXQgd2FzIHBvc3NpYmxlIGZvciBnbG9iYWxIb3N0IHRvIGJlIHRoZSBBcnJheSBjb25zdHJ1Y3RvciAoYVxuICAgICAgICAgICAgICAgIC8vIGxlZ2FjeSBTbG90IGRlZHVwIHN0cmF0ZWd5KSwgaXQgd2FzIGltcG9ydGFudCBmb3IgdGhlIHByb3BlcnR5IHRvIGJlXG4gICAgICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlOnRydWUgc28gaXQgY291bGQgYmUgZGVsZXRlZC4gVGhhdCBkb2VzIG5vdCBzZWVtIHRvIGJlIGFzXG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0YW50IHdoZW4gZ2xvYmFsSG9zdCBpcyB0aGUgZ2xvYmFsIG9iamVjdCwgYnV0IEkgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgIC8vIGNhdXNlIHNpbWlsYXIgcHJvYmxlbXMgYWdhaW4sIGFuZCBjb25maWd1cmFibGU6dHJ1ZSBzZWVtcyBzYWZlc3QuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VuZG9qcy9lbmRvL2lzc3Vlcy81NzYjaXNzdWVjb21tZW50LTExNzgyNzQwMDhcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcmV0dXJuIFNsb3Q7XG4gICAgICAgIH1cbiAgICB9KShtYWtlU2xvdENsYXNzKCkpO1xuXG52YXIgYmluZCA9IFNsb3QuYmluZCwgbm9Db250ZXh0ID0gU2xvdC5ub0NvbnRleHQ7XG5mdW5jdGlvbiBzZXRUaW1lb3V0V2l0aENvbnRleHQoY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZChjYWxsYmFjayksIGRlbGF5KTtcbn1cbi8vIFR1cm4gYW55IGdlbmVyYXRvciBmdW5jdGlvbiBpbnRvIGFuIGFzeW5jIGZ1bmN0aW9uICh1c2luZyB5aWVsZCBpbnN0ZWFkXG4vLyBvZiBhd2FpdCksIHdpdGggY29udGV4dCBhdXRvbWF0aWNhbGx5IHByZXNlcnZlZCBhY3Jvc3MgeWllbGRzLlxuZnVuY3Rpb24gYXN5bmNGcm9tR2VuKGdlbkZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdlbiA9IGdlbkZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBib3VuZE5leHQgPSBiaW5kKGdlbi5uZXh0KTtcbiAgICAgICAgdmFyIGJvdW5kVGhyb3cgPSBiaW5kKGdlbi50aHJvdyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuY2FsbChnZW4sIGFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHJlc3VsdC5kb25lID8gcmVzb2x2ZSA6IGludm9rZU5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UocmVzdWx0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudGhlbihuZXh0LCByZXN1bHQuZG9uZSA/IHJlamVjdCA6IGludm9rZVRocm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW52b2tlTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaW52b2tlKGJvdW5kTmV4dCwgdmFsdWUpOyB9O1xuICAgICAgICAgICAgdmFyIGludm9rZVRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoYm91bmRUaHJvdywgZXJyb3IpOyB9O1xuICAgICAgICAgICAgaW52b2tlTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuLy8gSWYgeW91IHVzZSB0aGUgZmliZXJzIG5wbSBwYWNrYWdlIHRvIGltcGxlbWVudCBjb3JvdXRpbmVzIGluIE5vZGUuanMsXG4vLyB5b3Ugc2hvdWxkIGNhbGwgdGhpcyBmdW5jdGlvbiBhdCBsZWFzdCBvbmNlIHRvIGVuc3VyZSBjb250ZXh0IG1hbmFnZW1lbnRcbi8vIHJlbWFpbnMgY29oZXJlbnQgYWNyb3NzIGFueSB5aWVsZHMuXG52YXIgd3JhcHBlZEZpYmVycyA9IFtdO1xuZnVuY3Rpb24gd3JhcFlpZWxkaW5nRmliZXJNZXRob2RzKEZpYmVyKSB7XG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGltcGxlbWVudGF0aW9uIG9mIEZpYmVyIHBlciBwcm9jZXNzLCBzbyB0aGlzIGFycmF5XG4gICAgLy8gc2hvdWxkIG5ldmVyIGdyb3cgbG9uZ2VyIHRoYW4gb25lIGVsZW1lbnQuXG4gICAgaWYgKHdyYXBwZWRGaWJlcnMuaW5kZXhPZihGaWJlcikgPCAwKSB7XG4gICAgICAgIHZhciB3cmFwID0gZnVuY3Rpb24gKG9iaiwgbWV0aG9kKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBvYmpbbWV0aG9kXTtcbiAgICAgICAgICAgIG9ialttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub0NvbnRleHQoZm4sIGFyZ3VtZW50cywgdGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBUaGVzZSBtZXRob2RzIGNhbiB5aWVsZCwgYWNjb3JkaW5nIHRvXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sYXZlcmRldC9ub2RlLWZpYmVycy9ibG9iL2RkZWJlZDliOGFlMzg4M2U1N2Y4MjJlMjEwOGU2OTQzZTVjOGQyYTgvZmliZXJzLmpzI0w5Ny1MMTAwXG4gICAgICAgIHdyYXAoRmliZXIsIFwieWllbGRcIik7XG4gICAgICAgIHdyYXAoRmliZXIucHJvdG90eXBlLCBcInJ1blwiKTtcbiAgICAgICAgd3JhcChGaWJlci5wcm90b3R5cGUsIFwidGhyb3dJbnRvXCIpO1xuICAgICAgICB3cmFwcGVkRmliZXJzLnB1c2goRmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gRmliZXI7XG59XG5cbmV4cG9ydHMuU2xvdCA9IFNsb3Q7XG5leHBvcnRzLmFzeW5jRnJvbUdlbiA9IGFzeW5jRnJvbUdlbjtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLm5vQ29udGV4dCA9IG5vQ29udGV4dDtcbmV4cG9ydHMuc2V0VGltZW91dCA9IHNldFRpbWVvdXRXaXRoQ29udGV4dDtcbmV4cG9ydHMud3JhcFlpZWxkaW5nRmliZXJNZXRob2RzID0gd3JhcFlpZWxkaW5nRmliZXJNZXRob2RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../../node_modules/.pnpm/@wry+context@0.7.4/node_modules/@wry/context/lib/bundle.cjs\n");

/***/ })

};
;